const btnAdicionarManutencao = document.getElementById("btnAdicionarManutencao");
const btnCancelarEdicaoManutencao = document.getElementById("btnCancelarEdicaoManutencao");
const manutencaoEditBanner = document.getElementById("manutencaoEditBanner");
const manutencaoEditInfo = document.getElementById("manutencaoEditInfo");
const novaManutencaoCard = document.getElementById("nova-manutencao");
const tipoManutencao = document.getElementById("tipoManutencao");
const customTipoField = document.getElementById("customTipoField");
const tituloManutencao = document.getElementById("tituloManutencao");
const subestacaoManutencao = document.getElementById("subestacaoManutencao");
const manutencaoProjeto = document.getElementById("manutencaoProjeto");
const equipamentoManutencao = document.getElementById("equipamentoManutencao");
const dataManutencao = document.getElementById("dataManutencao");
const futuraManutencao = document.getElementById("futuraManutencao");
const obsManutencao = document.getElementById("obsManutencao");
const obsManutencaoEditor = document.getElementById("obsManutencaoEditor");
const obsManutencaoHtml = document.getElementById("obsManutencaoHtml");
const obsManutencaoToolbar = document.querySelector(
  "[data-rich-toolbar='obsManutencao']"
);
const categoriaManutencao = document.getElementById("categoriaManutencao");
const prioridadeManutencao = document.getElementById("prioridadeManutencao");
const osReferenciaManutencao = document.getElementById("osReferenciaManutencao");
const participantesManutencao = document.getElementById("participantesManutencao");
const participantesManutencaoErro = document.getElementById("participantesManutencaoErro");
const manutencaoEquipeResponsavel = document.getElementById("manutencaoEquipeResponsavel");
const participantesManutencaoList = document.getElementById("participantesManutencaoList");
const participantesManutencaoSelected = document.getElementById("participantesManutencaoSelected");
const participanteExternoManutencao = document.getElementById("participanteExternoManutencao");
const btnAddParticipanteExterno = document.getElementById("btnAddParticipanteExterno");
const criticoManutencao = document.getElementById("criticoManutencao");
const novaDocPt = document.getElementById("novaDocPt");
const novaPtLabel = document.getElementById("novaPtLabel");
const novaDocInputs = Array.from(document.querySelectorAll("[data-nova-doc-input]"));
const novaDocButtons = Array.from(document.querySelectorAll("[data-nova-doc-btn]"));
const novaDocViews = Array.from(document.querySelectorAll("[data-nova-doc-view]"));
const novaDocNames = Array.from(document.querySelectorAll("[data-nova-doc-name]"));
let novaDocExisting = {};
const mensagemManutencao = document.getElementById("mensagemManutencao");
const listaLembretes = document.getElementById("listaLembretes");
const lembretesVazio = document.getElementById("lembretesVazio");
const listaAgendadas = document.getElementById("listaAgendadas");
const listaAgendadasVazia = document.getElementById("listaAgendadasVazia");
const alertaProgramacao = document.getElementById("alertaProgramacao");
const filtroProgramacaoSubestacao = document.getElementById("filtroProgramacaoSubestacao");
const filtroProgramacaoStatus = document.getElementById("filtroProgramacaoStatus");
const filtroProgramacaoPeriodo = document.getElementById("filtroProgramacaoPeriodo");
const listaBacklog = document.getElementById("listaBacklog");
const listaBacklogVazia = document.getElementById("listaBacklogVazia");
const listaConcluidas = document.getElementById("listaConcluidas");
const listaConcluidasVazia = document.getElementById("listaConcluidasVazia");
const listaAuditoria = document.getElementById("listaAuditoria");
const auditVazio = document.getElementById("auditVazio");
const listaExecucaoHoje = document.getElementById("listaExecucaoHoje");
const listaExecucaoHojeVazia = document.getElementById("listaExecucaoHojeVazia");
const listaExecucaoVencidas = document.getElementById("listaExecucaoVencidas");
const listaExecucaoVencidasVazia = document.getElementById("listaExecucaoVencidasVazia");
const listaExecucaoCriticas = document.getElementById("listaExecucaoCriticas");
const listaExecucaoCriticasVazia = document.getElementById("listaExecucaoCriticasVazia");
const listaRelatorios = document.getElementById("listaRelatorios");
const listaRelatoriosVazia = document.getElementById("listaRelatoriosVazia");
const relatorioPeriodoFiltro = document.getElementById("relatorioPeriodo");
const relatorioStatusFiltro = document.getElementById("relatorioStatus");
const relatorioResponsavelFiltro = document.getElementById("relatorioResponsavel");
const relatorioTipoFiltro = document.getElementById("relatorioTipoFiltro");
const btnRelatoriosExportar = document.getElementById("btnRelatoriosExportar");
const btnRelatoriosResumo = document.getElementById("btnRelatoriosResumo");
const relatorioResumoTotal = document.getElementById("relatorioResumoTotal");
const relatorioResumoConcluidas = document.getElementById("relatorioResumoConcluidas");
const relatorioResumoCriticos = document.getElementById("relatorioResumoCriticos");
const relatorioResumoAlertas = document.getElementById("relatorioResumoAlertas");
const relatorioResumoEvidencias = document.getElementById("relatorioResumoEvidencias");
const relatorioResumoEvidenciasLabel = document.getElementById("relatorioResumoEvidenciasLabel");
const relatorioResumoSla = document.getElementById("relatorioResumoSla");
const relatorioResumoSlaLabel = document.getElementById("relatorioResumoSlaLabel");
const relatorioMes = document.getElementById("relatorioMes");
const relatorioInicioMensal = document.getElementById("relatorioInicioMensal");
const relatorioFimMensal = document.getElementById("relatorioFimMensal");
const relatorioCliente = document.getElementById("relatorioCliente");
const btnRelatorioMensalPreview = document.getElementById("btnRelatorioMensalPreview");
const btnRelatorioMensalExportar = document.getElementById("btnRelatorioMensalExportar");
const btnRelatorioMensalRdo = document.getElementById("btnRelatorioMensalRdo");
const rdoMensalPreviewModal = document.getElementById("modalRdoMensalPreview");
const rdoMensalPreviewBody = document.getElementById("rdoMensalPreviewBody");
const rdoMensalPreviewClose = document.querySelector("[data-rdo-mensal-close]");
const perfProjetoPeriodo = document.getElementById("perfProjetoPeriodo");
const perfProjetoFiltro = document.getElementById("perfProjetoFiltro");
const perfProjetoCards = document.getElementById("perfProjetoCards");
const perfProjetoInsights = document.getElementById("perfProjetoInsights");
const perfProjetoTabela = document.getElementById("perfProjetoTabela");
const perfProjetoTotalConcluidas = document.getElementById("perfProjetoTotalConcluidas");
const perfProjetoTotalPrazo = document.getElementById("perfProjetoTotalPrazo");
const perfProjetoTotalSla = document.getElementById("perfProjetoTotalSla");
const perfProjetoTotalBacklog = document.getElementById("perfProjetoTotalBacklog");
const perfProjetoTotalCriticas = document.getElementById("perfProjetoTotalCriticas");
const perfProjetoTotalApr = document.getElementById("perfProjetoTotalApr");
const perfProjetoTotalOs = document.getElementById("perfProjetoTotalOs");
const perfProjetoTotalPte = document.getElementById("perfProjetoTotalPte");
const perfProjetoTotalPt = document.getElementById("perfProjetoTotalPt");
const perfPessoaPeriodo = document.getElementById("perfPessoaPeriodo");
const perfPessoaFiltro = document.getElementById("perfPessoaFiltro");
const perfPessoaCards = document.getElementById("perfPessoaCards");
const perfPessoaInsights = document.getElementById("perfPessoaInsights");
const perfPessoaTabela = document.getElementById("perfPessoaTabela");
const perfPessoaTotalAbertas = document.getElementById("perfPessoaTotalAbertas");
const perfPessoaTotalConcluidas = document.getElementById("perfPessoaTotalConcluidas");
const perfPessoaTotalPrazo = document.getElementById("perfPessoaTotalPrazo");
const perfPessoaTotalSla = document.getElementById("perfPessoaTotalSla");
const perfPessoaTotalBacklog = document.getElementById("perfPessoaTotalBacklog");
const perfPessoaTotalCriticas = document.getElementById("perfPessoaTotalCriticas");
const perfPessoaTotalApr = document.getElementById("perfPessoaTotalApr");
const perfPessoaTotalOs = document.getElementById("perfPessoaTotalOs");
const perfPessoaTotalPte = document.getElementById("perfPessoaTotalPte");
const perfPessoaTotalPt = document.getElementById("perfPessoaTotalPt");
const feedbackTo = document.getElementById("feedbackTo");
const feedbackScore = document.getElementById("feedbackScore");
const feedbackMessage = document.getElementById("feedbackMessage");
const btnEnviarFeedback = document.getElementById("btnEnviarFeedback");
const feedbackSendMsg = document.getElementById("feedbackSendMsg");
const feedbackList = document.getElementById("feedbackList");
const feedbackEmpty = document.getElementById("feedbackEmpty");
const feedbackStatReceived = document.getElementById("feedbackStatReceived");
const feedbackStatSent = document.getElementById("feedbackStatSent");
const feedbackStatAvg = document.getElementById("feedbackStatAvg");
const feedbackStatUnread = document.getElementById("feedbackStatUnread");
const feedbackSearch = document.getElementById("feedbackSearch");
const feedbackSort = document.getElementById("feedbackSort");
const feedbackTemplateButtons = Array.from(
  document.querySelectorAll("[data-feedback-template]")
);
const feedbackBadge = document.getElementById("feedbackBadge");
const feedbackTabButtons = Array.from(document.querySelectorAll("[data-feedback-tab]"));
const btnFeedbackInbox = document.getElementById("btnFeedbackInbox");
const feedbackInboxDot = document.getElementById("feedbackInboxDot");
const feedbackInboxPanel = document.getElementById("feedbackInboxPanel");
const feedbackInboxList = document.getElementById("feedbackInboxList");
const feedbackInboxEmpty = document.getElementById("feedbackInboxEmpty");
const feedbackInboxLink = document.getElementById("feedbackInboxLink");
const listaAnuncios = document.getElementById("listaAnuncios");
const anunciosVazio = document.getElementById("anunciosVazio");
const btnAnunciosLidos = document.getElementById("btnAnunciosLidos");
const btnNovoAnuncio = document.getElementById("btnNovoAnuncio");
const modalAnuncio = document.getElementById("modalAnuncio");
const formAnuncio = document.getElementById("formAnuncio");
const anuncioTitulo = document.getElementById("anuncioTitulo");
const anuncioTipo = document.getElementById("anuncioTipo");
const anuncioCriticidade = document.getElementById("anuncioCriticidade");
const anuncioEscopo = document.getElementById("anuncioEscopo");
const anuncioProjeto = document.getElementById("anuncioProjeto");
const anuncioProjetoField = document.getElementById("anuncioProjetoField");
const anuncioImagens = document.getElementById("anuncioImagens");
const anuncioImagensPreview = document.getElementById("anuncioImagensPreview");
const anuncioMensagem = document.getElementById("anuncioMensagem");
const btnCancelarAnuncio = document.getElementById("btnCancelarAnuncio");
const btnFecharAnuncio = document.getElementById("btnFecharAnuncio");
const mensagemAnuncio = document.getElementById("mensagemAnuncio");
const modalAnuncioView = document.getElementById("modalAnuncioView");
const anuncioViewTitulo = document.getElementById("anuncioViewTitulo");
const anuncioViewMeta = document.getElementById("anuncioViewMeta");
const anuncioViewMensagem = document.getElementById("anuncioViewMensagem");
const anuncioViewTipo = document.getElementById("anuncioViewTipo");
const anuncioViewSeveridade = document.getElementById("anuncioViewSeveridade");
const anuncioViewImagens = document.getElementById("anuncioViewImagens");
const anuncioViewReadsWrap = document.getElementById("anuncioViewReadsWrap");
const anuncioViewReads = document.getElementById("anuncioViewReads");
const btnAnuncioViewClose = document.getElementById("btnAnuncioViewClose");
const btnAnuncioViewCloseFooter = document.getElementById("btnAnuncioViewCloseFooter");
const btnAnuncioViewMarkRead = document.getElementById("btnAnuncioViewMarkRead");
const modalAnunciosLidos = document.getElementById("modalAnunciosLidos");
const listaAnunciosLidos = document.getElementById("listaAnunciosLidos");
const anunciosLidosVazio = document.getElementById("anunciosLidosVazio");
const btnAnunciosLidosClose = document.getElementById("btnAnunciosLidosClose");
const btnAnunciosLidosCloseFooter = document.getElementById("btnAnunciosLidosCloseFooter");
const countAgendadas = document.getElementById("countAgendadas");
const countLiberadas = document.getElementById("countLiberadas");
const countBacklog = document.getElementById("countBacklog");
const badgeBacklog = document.getElementById("badgeBacklog");
const countEmExecucao = document.getElementById("countEmExecucao");
const countEncerramento = document.getElementById("countEncerramento");
const countConcluidas = document.getElementById("countConcluidas");
const diasLembrete = document.getElementById("diasLembrete");
const graficoKpi = document.getElementById("graficoKpi");
const kpiTotal = document.getElementById("kpiTotal");
const kpiConclusao = document.getElementById("kpiConclusao");
const kpiConcluidas = document.getElementById("kpiConcluidas");
const kpiBacklog = document.getElementById("kpiBacklog");
const kpiPontual = document.getElementById("kpiPontual");
const kpiAtraso = document.getElementById("kpiAtraso");
const kpiPeriodo = document.getElementById("kpiPeriodo");
const kpiSubestacao = document.getElementById("kpiSubestacao");
const kpiCategoria = document.getElementById("kpiCategoria");
const kpiPrioridade = document.getElementById("kpiPrioridade");
const kpiUsuarioFiltro = document.getElementById("kpiUsuarioFiltro");
const kpiCards = document.getElementById("kpiCards");
const kpiTrendChart = document.getElementById("kpiTrendChart");
const kpiAgingChart = document.getElementById("kpiAgingChart");
const kpiSlaChart = document.getElementById("kpiSlaChart");
const kpiRanking = document.getElementById("kpiRanking");
const kpiRankingVazio = document.getElementById("kpiRankingVazio");
const kpiDrilldownTitulo = document.getElementById("kpiDrilldownTitulo");
const kpiDrilldownTabela = document.getElementById("kpiDrilldownTabela");
const kpiDrilldownVazio = document.getElementById("kpiDrilldownVazio");
const kpiDrilldownLimite = document.getElementById("kpiDrilldownLimite");
const perfExecBadge = document.getElementById("perfExecBadge");
const perfExecProgress = document.getElementById("perfExecProgress");
const perfExecProgressValue = document.getElementById("perfExecProgressValue");
const perfExecTempoMedio = document.getElementById("perfExecTempoMedio");
const perfExecSemana = document.getElementById("perfExecSemana");
const perfSlaBadge = document.getElementById("perfSlaBadge");
const perfSlaProgress = document.getElementById("perfSlaProgress");
const perfSlaProgressValue = document.getElementById("perfSlaProgressValue");
const perfSlaNoPrazo = document.getElementById("perfSlaNoPrazo");
const perfSlaForaPrazo = document.getElementById("perfSlaForaPrazo");
const perfReopenBadge = document.getElementById("perfReopenBadge");
const perfReopenProgress = document.getElementById("perfReopenProgress");
const perfReopenProgressValue = document.getElementById("perfReopenProgressValue");
const perfReopenUltimos = document.getElementById("perfReopenUltimos");
const perfReopenImpacto = document.getElementById("perfReopenImpacto");
const homeHoje = document.getElementById("homeHoje");
const homeAtrasadas = document.getElementById("homeAtrasadas");
const homeCriticas = document.getElementById("homeCriticas");
const homeRisco = document.getElementById("homeRisco");
const homeAlertas = document.getElementById("homeAlertas");
const homeAlertasVazio = document.getElementById("homeAlertasVazio");
const homePontual = document.getElementById("homePontual");
const homeBacklog = document.getElementById("homeBacklog");
const homeConcluidas = document.getElementById("homeConcluidas");
const homeAtrasoMedio = document.getElementById("homeAtrasoMedio");
const projectSelect = document.getElementById("projectSelect");
const projectSelectLabel = document.getElementById("projectSelectLabel");
const projectManageBtn = document.getElementById("projectManageBtn");
const crumbs = document.getElementById("crumbs");
const btnDashboard = document.getElementById("btnDashboard");
const btnHelp = document.getElementById("btnHelp");
const btnSyncSite = document.getElementById("btnSyncSite");
const syncStatusLabel = document.getElementById("syncStatusLabel");
const compatStatusLabel = document.getElementById("compatStatusLabel");
const modalHelp = document.getElementById("modalHelp");
const helpTitle = document.getElementById("helpTitle");
const helpMeta = document.getElementById("helpMeta");
const helpContent = document.getElementById("helpContent");
const btnHelpClose = document.getElementById("btnHelpClose");
const projectTabs = Array.from(document.querySelectorAll("[data-project-tab]"));
const projectPanels = Array.from(document.querySelectorAll("[data-project-panel]"));
const projectForm = document.getElementById("projectForm");
const projectFormSelect = document.getElementById("projectFormSelect");
const projectFormId = document.getElementById("projectFormId");
const projectFormCodigo = document.getElementById("projectFormCodigo");
const projectFormNome = document.getElementById("projectFormNome");
const projectFormCliente = document.getElementById("projectFormCliente");
const projectFormTime = document.getElementById("projectFormTime");
const projectFormDescricao = document.getElementById("projectFormDescricao");
const projectFormLocais = document.getElementById("projectFormLocais");
const projectFormCancel = document.getElementById("projectFormCancel");
const projectTable = document.getElementById("projectTable");
const projectTableBody = document.querySelector("#projectTable tbody");
const equipamentoForm = document.getElementById("equipamentoForm");
const equipamentoFormId = document.getElementById("equipamentoFormId");
const equipamentoFormProject = document.getElementById("equipamentoFormProject");
const equipamentoFormTag = document.getElementById("equipamentoFormTag");
const equipamentoFormNome = document.getElementById("equipamentoFormNome");
const equipamentoFormCategoria = document.getElementById("equipamentoFormCategoria");
const equipamentoFormDescricao = document.getElementById("equipamentoFormDescricao");
const equipamentoFormCancel = document.getElementById("equipamentoFormCancel");
const equipamentoTable = document.getElementById("equipamentoTable");
const equipamentoTableBody = document.querySelector("#equipamentoTable tbody");
const equipeForm = document.getElementById("equipeForm");
const equipeFormUser = document.getElementById("equipeFormUser");
const equipeSearch = document.getElementById("equipeSearch");
const equipeTable = document.getElementById("equipeTable");
const equipeTableBody = document.querySelector("#equipeTable tbody");
const pmpAno = document.getElementById("pmpAno");
const pmpView = document.getElementById("pmpView");
const pmpMes = document.getElementById("pmpMes");
const pmpMesField = document.getElementById("pmpMesField");
const pmpFiltroProjeto = document.getElementById("pmpFiltroProjeto");
const pmpFiltroFrequencia = document.getElementById("pmpFiltroFrequencia");
const pmpFiltroEquipamento = document.getElementById("pmpFiltroEquipamento");
const pmpFiltroResponsavel = document.getElementById("pmpFiltroResponsavel");
const pmpFiltroOrigem = document.getElementById("pmpFiltroOrigem");
const pmpFiltroStatus = document.getElementById("pmpFiltroStatus");
const pmpHorasDisponiveis = document.getElementById("pmpHorasDisponiveis");
const pmpBusca = document.getElementById("pmpBusca");
const pmpTotalPrevistas = document.getElementById("pmpTotalPrevistas");
const pmpTotalConforme = document.getElementById("pmpTotalConforme");
const pmpTotalAtraso = document.getElementById("pmpTotalAtraso");
const pmpTotalNaoExecutadas = document.getElementById("pmpTotalNaoExecutadas");
const pmpHorasPlanejadas = document.getElementById("pmpHorasPlanejadas");
const pmpHorasExecutadas = document.getElementById("pmpHorasExecutadas");
const pmpCargaSemanal = document.getElementById("pmpCargaSemanal");
const pmpCargaBar = document.getElementById("pmpCargaBar");
const pmpCargaBarHint = document.getElementById("pmpCargaBarHint");
const pmpForm = document.getElementById("pmpForm");
const pmpFormId = document.getElementById("pmpFormId");
const pmpFormTitle = document.getElementById("pmpFormTitle");
const pmpFormMensagem = document.getElementById("pmpFormMensagem");
const pmpFormCancel = document.getElementById("pmpFormCancel");
const pmpNome = document.getElementById("pmpNome");
const pmpCodigo = document.getElementById("pmpCodigo");
const pmpTipo = document.getElementById("pmpTipo");
const pmpProjeto = document.getElementById("pmpProjeto");
const pmpEquipamento = document.getElementById("pmpEquipamento");
const pmpFrequencia = document.getElementById("pmpFrequencia");
const pmpInicio = document.getElementById("pmpInicio");
const pmpOnlyWeekdays = document.getElementById("pmpOnlyWeekdays");
const pmpMesesWrap = document.getElementById("pmpMeses");
const pmpTecnicos = document.getElementById("pmpTecnicos");
const pmpDuracao = document.getElementById("pmpDuracao");
const pmpResponsavel = document.getElementById("pmpResponsavel");
const pmpDescricao = document.getElementById("pmpDescricao");
const pmpObservacoes = document.getElementById("pmpObservacoes");
const pmpProcedimentos = document.getElementById("pmpProcedimentos");
const pmpProcedimentoFile = document.getElementById("pmpProcedimentoFile");
const pmpProcedimentoUpload = document.getElementById("pmpProcedimentoUpload");
const pmpProcedimentoView = document.getElementById("pmpProcedimentoView");
const pmpProcedimentoRemove = document.getElementById("pmpProcedimentoRemove");
const pmpProcedimentoName = document.getElementById("pmpProcedimentoName");
const pmpChecklistList = document.getElementById("pmpChecklistList");
const pmpChecklistItem = document.getElementById("pmpChecklistItem");
const pmpChecklistLink = document.getElementById("pmpChecklistLink");
const pmpChecklistAdd = document.getElementById("pmpChecklistAdd");
const pmpGrid = document.getElementById("pmpGrid");
const pmpGridHead = document.getElementById("pmpGridHead");
const pmpGridBody = document.getElementById("pmpGridBody");
const pmpGridVazio = document.getElementById("pmpGridVazio");
const pmpImportBtn = document.getElementById("pmpImportBtn");
const pmpDuplicarPlano = document.getElementById("pmpDuplicarPlano");
const pmpExportPdf = document.getElementById("pmpExportPdf");
const pmpExportExcel = document.getElementById("pmpExportExcel");
const modalPmpImport = document.getElementById("modalPmpImport");
const pmpImportSearch = document.getElementById("pmpImportSearch");
const pmpImportList = document.getElementById("pmpImportList");
const pmpImportEmpty = document.getElementById("pmpImportEmpty");
const pmpImportCancel = document.getElementById("pmpImportCancel");
const pmpImportConfirm = document.getElementById("pmpImportConfirm");
const pmpImportClose = document.querySelector("[data-pmp-import-close]");
const modalPmpCell = document.getElementById("modalPmpCell");
const pmpCellTitle = document.getElementById("pmpCellTitle");
const pmpCellMeta = document.getElementById("pmpCellMeta");
const pmpCellExecList = document.getElementById("pmpCellExecList");
const pmpCellEvidencias = document.getElementById("pmpCellEvidencias");
const pmpCellChecklist = document.getElementById("pmpCellChecklist");
const pmpCellObservacoes = document.getElementById("pmpCellObservacoes");
const pmpCellProcedimentos = document.getElementById("pmpCellProcedimentos");
const pmpCellScheduledInput = document.getElementById("pmpCellScheduled");
const pmpCellExecutedInput = document.getElementById("pmpCellExecuted");
const pmpCellExecutorInput = document.getElementById("pmpCellExecutor");
const pmpCellObsInput = document.getElementById("pmpCellObsInput");
const pmpCellEvidenciasInput = document.getElementById("pmpCellEvidenciasInput");
const pmpCellChecklistInput = document.getElementById("pmpCellChecklistInput");
const pmpCellSave = document.getElementById("pmpCellSave");
const pmpCellRemove = document.getElementById("pmpCellRemove");
const pmpCellUnset = document.getElementById("pmpCellUnset");
const pmpCellMarkCancel = document.getElementById("pmpCellMarkCancel");
const pmpCellClose = document.getElementById("pmpCellClose");
const pmpCellCloseBtn = document.querySelector("[data-pmp-cell-close]");
const almoxDashCards = document.getElementById("almoxDashCards");
const almoxAlertas = document.getElementById("almoxAlertas");
const almoxAlertasVazio = document.getElementById("almoxAlertasVazio");
const almoxMovRecent = document.getElementById("almoxMovRecent");
const almoxMovRecentVazio = document.getElementById("almoxMovRecentVazio");
const almoxItemForm = document.getElementById("almoxItemForm");
const almoxItemType = document.getElementById("almoxItemType");
const almoxItemUnit = document.getElementById("almoxItemUnit");
const almoxItemName = document.getElementById("almoxItemName");
const almoxItemCode = document.getElementById("almoxItemCode");
const almoxItemBarcode = document.getElementById("almoxItemBarcode");
const almoxItemCA = document.getElementById("almoxItemCA");
const almoxItemCaValid = document.getElementById("almoxItemCaValid");
const almoxItemValid = document.getElementById("almoxItemValid");
const almoxItemDesc = document.getElementById("almoxItemDesc");
const almoxItemSubmit = document.getElementById("almoxItemSubmit");
const almoxItemMsg = document.getElementById("almoxItemMsg");
const almoxItemTableBody = document.getElementById("almoxItemTableBody");
const almoxItemEmpty = document.getElementById("almoxItemEmpty");
const almoxStockTableBody = document.getElementById("almoxStockTableBody");
const almoxStockEmpty = document.getElementById("almoxStockEmpty");
const almoxMovForm = document.getElementById("almoxMovForm");
const almoxMovType = document.getElementById("almoxMovType");
const almoxMovItem = document.getElementById("almoxMovItem");
const almoxMovQty = document.getElementById("almoxMovQty");
const almoxMovProject = document.getElementById("almoxMovProject");
const almoxMovProjectDest = document.getElementById("almoxMovProjectDest");
const almoxMovWorksite = document.getElementById("almoxMovWorksite");
const almoxMovWorksiteDest = document.getElementById("almoxMovWorksiteDest");
const almoxMovColab = document.getElementById("almoxMovColab");
const almoxMovReason = document.getElementById("almoxMovReason");
const almoxMovSubmit = document.getElementById("almoxMovSubmit");
const almoxMovMsg = document.getElementById("almoxMovMsg");
const almoxMovTableBody = document.getElementById("almoxMovTableBody");
const almoxMovEmpty = document.getElementById("almoxMovEmpty");
const almoxEpiTableBody = document.getElementById("almoxEpiTableBody");
const almoxEpiEmpty = document.getElementById("almoxEpiEmpty");
const almoxTransferFields = Array.from(document.querySelectorAll("[data-transfer-only]"));
const sstDashCards = document.getElementById("sstDashCards");
const sstAlertas = document.getElementById("sstAlertas");
const sstAlertasVazio = document.getElementById("sstAlertasVazio");
const sstTrainingForm = document.getElementById("sstTrainingForm");
const sstTrainingName = document.getElementById("sstTrainingName");
const sstTrainingNr = document.getElementById("sstTrainingNr");
const sstTrainingHours = document.getElementById("sstTrainingHours");
const sstTrainingValidity = document.getElementById("sstTrainingValidity");
const sstTrainingSubmit = document.getElementById("sstTrainingSubmit");
const sstTrainingMsg = document.getElementById("sstTrainingMsg");
const sstTrainingTableBody = document.getElementById("sstTrainingTableBody");
const sstTrainingEmpty = document.getElementById("sstTrainingEmpty");
const sstInspectionForm = document.getElementById("sstInspectionForm");
const sstInspectionProject = document.getElementById("sstInspectionProject");
const sstInspectionLocal = document.getElementById("sstInspectionLocal");
const sstInspectionTemplate = document.getElementById("sstInspectionTemplate");
const sstInspectionSafety = document.getElementById("sstInspectionSafety");
const sstInspectionExecutor = document.getElementById("sstInspectionExecutor");
const sstInspectionVehicle = document.getElementById("sstInspectionVehicle");
const sstInspectionVehicleField = document.getElementById("sstInspectionVehicleField");
const sstInspectionVehicleEmpty = document.getElementById("sstInspectionVehicleEmpty");
const sstInspectionVehicleCta = document.getElementById("sstInspectionVehicleCta");
const sstInspectionVehicleStatusField = document.getElementById("sstInspectionVehicleStatusField");
const sstInspectionVehicleStatusFilter = document.getElementById("sstInspectionVehicleStatusFilter");
const sstInspectionVehicleInfo = document.getElementById("sstInspectionVehicleInfo");
const sstInspectionVehiclePlate = document.getElementById("sstInspectionVehiclePlate");
const sstInspectionVehicleModel = document.getElementById("sstInspectionVehicleModel");
const sstInspectionVehicleType = document.getElementById("sstInspectionVehicleType");
const sstInspectionVehicleStatus = document.getElementById("sstInspectionVehicleStatus");
const sstInspectionStartBtn = document.getElementById("sstInspectionStartBtn");
const sstInspectionMsg = document.getElementById("sstInspectionMsg");
const sstVehicleForm = document.getElementById("sstVehicleForm");
const sstVehicleId = document.getElementById("sstVehicleId");
const sstVehicleProject = document.getElementById("sstVehicleProject");
const sstVehiclePlate = document.getElementById("sstVehiclePlate");
const sstVehicleModel = document.getElementById("sstVehicleModel");
const sstVehicleType = document.getElementById("sstVehicleType");
const sstVehicleStatus = document.getElementById("sstVehicleStatus");
const sstVehicleSubmit = document.getElementById("sstVehicleSubmit");
const sstVehicleCancel = document.getElementById("sstVehicleCancel");
const sstVehicleMsg = document.getElementById("sstVehicleMsg");
const sstVehicleFilterProject = document.getElementById("sstVehicleFilterProject");
const sstVehicleFilterStatus = document.getElementById("sstVehicleFilterStatus");
const sstVehicleFilterSearch = document.getElementById("sstVehicleFilterSearch");
const sstVehicleTableBody = document.getElementById("sstVehicleTableBody");
const sstVehicleEmpty = document.getElementById("sstVehicleEmpty");
const sstTemplateSeedBtn = document.getElementById("sstTemplateSeedBtn");
const sstTemplateNewBtn = document.getElementById("sstTemplateNewBtn");
const sstTemplateTableBody = document.getElementById("sstTemplateTableBody");
const sstTemplateEmpty = document.getElementById("sstTemplateEmpty");
const sstInspectionFilterProject = document.getElementById("sstInspectionFilterProject");
const sstInspectionFilterTemplate = document.getElementById("sstInspectionFilterTemplate");
const sstInspectionFilterStatus = document.getElementById("sstInspectionFilterStatus");
const sstInspectionFilterFrom = document.getElementById("sstInspectionFilterFrom");
const sstInspectionFilterTo = document.getElementById("sstInspectionFilterTo");
const sstInspectionFilterSearch = document.getElementById("sstInspectionFilterSearch");
const sstInspectionTableBody = document.getElementById("sstInspectionTableBody");
const sstInspectionEmpty = document.getElementById("sstInspectionEmpty");
const sstNcForm = document.getElementById("sstNcForm");
const sstNcProject = document.getElementById("sstNcProject");
const sstNcSeverity = document.getElementById("sstNcSeverity");
const sstNcStatus = document.getElementById("sstNcStatus");
const sstNcDue = document.getElementById("sstNcDue");
const sstNcCategory = document.getElementById("sstNcCategory");
const sstNcResponsible = document.getElementById("sstNcResponsible");
const sstNcTitle = document.getElementById("sstNcTitle");
const sstNcDesc = document.getElementById("sstNcDesc");
const sstNcSourceInspection = document.getElementById("sstNcSourceInspection");
const sstNcAttachments = document.getElementById("sstNcAttachments");
const sstNcAttachmentsList = document.getElementById("sstNcAttachmentsList");
const sstNcSubmit = document.getElementById("sstNcSubmit");
const sstNcMsg = document.getElementById("sstNcMsg");
const sstNcFilterProject = document.getElementById("sstNcFilterProject");
const sstNcFilterStatus = document.getElementById("sstNcFilterStatus");
const sstNcFilterSeverity = document.getElementById("sstNcFilterSeverity");
const sstNcFilterResponsible = document.getElementById("sstNcFilterResponsible");
const sstNcFilterFrom = document.getElementById("sstNcFilterFrom");
const sstNcFilterTo = document.getElementById("sstNcFilterTo");
const sstNcFilterSearch = document.getElementById("sstNcFilterSearch");
const sstNcTableBody = document.getElementById("sstNcTableBody");
const sstNcEmpty = document.getElementById("sstNcEmpty");
const modalSstNcDetails = document.getElementById("modalSstNcDetails");
const sstNcDetailsId = document.getElementById("sstNcDetailsId");
const sstNcDetailsHeader = document.getElementById("sstNcDetailsTitle");
const sstNcDetailsMeta = document.getElementById("sstNcDetailsMeta");
const sstNcDetailsTitleInput = document.getElementById("sstNcDetailsTitleInput");
const sstNcDetailsStatus = document.getElementById("sstNcDetailsStatus");
const sstNcDetailsSeverity = document.getElementById("sstNcDetailsSeverity");
const sstNcDetailsDue = document.getElementById("sstNcDetailsDue");
const sstNcDetailsResponsible = document.getElementById("sstNcDetailsResponsible");
const sstNcDetailsCategory = document.getElementById("sstNcDetailsCategory");
const sstNcDetailsDescription = document.getElementById("sstNcDetailsDescription");
const sstNcDetailsRootCause = document.getElementById("sstNcDetailsRootCause");
const sstNcDetailsCorrection = document.getElementById("sstNcDetailsCorrection");
const sstNcDetailsSource = document.getElementById("sstNcDetailsSource");
const sstNcDetailsCreated = document.getElementById("sstNcDetailsCreated");
const sstNcDetailsUpdated = document.getElementById("sstNcDetailsUpdated");
const sstNcDetailsAttachments = document.getElementById("sstNcDetailsAttachments");
const sstNcDetailsFiles = document.getElementById("sstNcDetailsFiles");
const sstNcDetailsEvidenceList = document.getElementById("sstNcDetailsEvidenceList");
const sstNcActionTitle = document.getElementById("sstNcActionTitle");
const sstNcActionResponsible = document.getElementById("sstNcActionResponsible");
const sstNcActionDue = document.getElementById("sstNcActionDue");
const sstNcActionAdd = document.getElementById("sstNcActionAdd");
const sstNcActionsList = document.getElementById("sstNcActionsList");
const sstNcHistory = document.getElementById("sstNcHistory");
const sstNcDetailsSave = document.getElementById("sstNcDetailsSave");
const sstNcDetailsClose = document.getElementById("sstNcDetailsClose");
const sstNcDetailsMsg = document.getElementById("sstNcDetailsMsg");
const sstNcNotifyBtn = document.getElementById("sstNcNotifyBtn");
const btnFecharSstNcDetails = document.getElementById("btnFecharSstNcDetails");
const sstIncidentForm = document.getElementById("sstIncidentForm");
const sstIncidentProject = document.getElementById("sstIncidentProject");
const sstIncidentSeverity = document.getElementById("sstIncidentSeverity");
const sstIncidentDate = document.getElementById("sstIncidentDate");
const sstIncidentCategory = document.getElementById("sstIncidentCategory");
const sstIncidentDesc = document.getElementById("sstIncidentDesc");
const sstIncidentSubmit = document.getElementById("sstIncidentSubmit");
const sstIncidentMsg = document.getElementById("sstIncidentMsg");
const sstIncidentTableBody = document.getElementById("sstIncidentTableBody");
const sstIncidentEmpty = document.getElementById("sstIncidentEmpty");
const sstAprForm = document.getElementById("sstAprForm");
const sstAprProject = document.getElementById("sstAprProject");
const sstAprActivity = document.getElementById("sstAprActivity");
const sstAprHazards = document.getElementById("sstAprHazards");
const sstAprRisks = document.getElementById("sstAprRisks");
const sstAprControls = document.getElementById("sstAprControls");
const sstAprSubmit = document.getElementById("sstAprSubmit");
const sstAprMsg = document.getElementById("sstAprMsg");
const sstPermitForm = document.getElementById("sstPermitForm");
const sstPermitApr = document.getElementById("sstPermitApr");
const sstPermitType = document.getElementById("sstPermitType");
const sstPermitFrom = document.getElementById("sstPermitFrom");
const sstPermitTo = document.getElementById("sstPermitTo");
const sstPermitReqs = document.getElementById("sstPermitReqs");
const sstPermitSubmit = document.getElementById("sstPermitSubmit");
const sstPermitMsg = document.getElementById("sstPermitMsg");
const sstAprTableBody = document.getElementById("sstAprTableBody");
const sstAprEmpty = document.getElementById("sstAprEmpty");
const sstPermitTableBody = document.getElementById("sstPermitTableBody");
const sstPermitEmpty = document.getElementById("sstPermitEmpty");
const sstDocNewBtn = document.getElementById("sstDocNewBtn");
const sstDocProjectFilter = document.getElementById("sstDocProjectFilter");
const sstDocStatusFilter = document.getElementById("sstDocStatusFilter");
const sstDocSearch = document.getElementById("sstDocSearch");
const sstDocStats = document.getElementById("sstDocStats");
const sstDocTableBody = document.getElementById("sstDocTableBody");
const sstDocEmpty = document.getElementById("sstDocEmpty");
const sstDocQueue = document.getElementById("sstDocQueue");
const sstDocQueueEmpty = document.getElementById("sstDocQueueEmpty");
const sstDocArchive = document.getElementById("sstDocArchive");
const sstDocArchiveEmpty = document.getElementById("sstDocArchiveEmpty");
const modalSstDocForm = document.getElementById("modalSstDocForm");
const formSstDoc = document.getElementById("formSstDoc");
const sstDocProject = document.getElementById("sstDocProject");
const sstDocResponsible = document.getElementById("sstDocResponsible");
const sstDocActivity = document.getElementById("sstDocActivity");
const sstDocAprCode = document.getElementById("sstDocAprCode");
const sstDocAprView = document.getElementById("sstDocAprView");
const sstDocAprBtn = document.getElementById("sstDocAprBtn");
const sstDocAprInput = document.getElementById("sstDocAprInput");
const sstDocAprName = document.getElementById("sstDocAprName");
const sstDocAttachments = document.getElementById("sstDocAttachments");
const sstDocNotes = document.getElementById("sstDocNotes");
const sstDocFormMsg = document.getElementById("sstDocFormMsg");
const btnFecharSstDocForm = document.getElementById("btnFecharSstDocForm");
const btnCancelarSstDocForm = document.getElementById("btnCancelarSstDocForm");
const modalSstDocReview = document.getElementById("modalSstDocReview");
const sstDocReviewId = document.getElementById("sstDocReviewId");
const sstDocReviewTitle = document.getElementById("sstDocReviewTitle");
const sstDocReviewMeta = document.getElementById("sstDocReviewMeta");
const sstDocReviewStatus = document.getElementById("sstDocReviewStatus");
const sstDocReviewAttachments = document.getElementById("sstDocReviewAttachments");
const sstDocReviewNotes = document.getElementById("sstDocReviewNotes");
const sstDocReviewInstructions = document.getElementById("sstDocReviewInstructions");
const sstDocReviewMsg = document.getElementById("sstDocReviewMsg");
const sstDocApproveBtn = document.getElementById("sstDocApproveBtn");
const sstDocRejectBtn = document.getElementById("sstDocRejectBtn");
const btnFecharSstDocReview = document.getElementById("btnFecharSstDocReview");
const btnCancelarSstDocReview = document.getElementById("btnCancelarSstDocReview");
const modalSstTemplate = document.getElementById("modalSstTemplate");
const sstTemplateModalTitle = document.getElementById("sstTemplateModalTitle");
const formSstTemplate = document.getElementById("formSstTemplate");
const sstTemplateId = document.getElementById("sstTemplateId");
const sstTemplateName = document.getElementById("sstTemplateName");
const sstTemplateType = document.getElementById("sstTemplateType");
const sstTemplatePeriodicity = document.getElementById("sstTemplatePeriodicity");
const sstTemplateProject = document.getElementById("sstTemplateProject");
const sstTemplateActive = document.getElementById("sstTemplateActive");
const sstTemplateQuestions = document.getElementById("sstTemplateQuestions");
const sstTemplateAddQuestion = document.getElementById("sstTemplateAddQuestion");
const sstTemplateMsg = document.getElementById("sstTemplateMsg");
const btnFecharSstTemplate = document.getElementById("btnFecharSstTemplate");
const btnCancelarSstTemplate = document.getElementById("btnCancelarSstTemplate");
const modalSstInspectionWizard = document.getElementById("modalSstInspectionWizard");
const sstWizardTitle = document.getElementById("sstWizardTitle");
const sstWizardMeta = document.getElementById("sstWizardMeta");
const sstWizardProgress = document.getElementById("sstWizardProgress");
const sstWizardBody = document.getElementById("sstWizardBody");
const sstWizardSummary = document.getElementById("sstWizardSummary");
const sstWizardPrev = document.getElementById("sstWizardPrev");
const sstWizardNext = document.getElementById("sstWizardNext");
const sstWizardMsg = document.getElementById("sstWizardMsg");
const btnFecharSstWizard = document.getElementById("btnFecharSstWizard");
const modalSstInspectionDetails = document.getElementById("modalSstInspectionDetails");
const sstInspectionDetailsTitle = document.getElementById("sstInspectionDetailsTitle");
const sstInspectionDetailsMeta = document.getElementById("sstInspectionDetailsMeta");
const sstInspectionDetailsBody = document.getElementById("sstInspectionDetailsBody");
const sstInspectionGenerateNc = document.getElementById("sstInspectionGenerateNc");
const sstInspectionDetailsMsg = document.getElementById("sstInspectionDetailsMsg");
const btnFecharSstDetails = document.getElementById("btnFecharSstDetails");
const btnCancelarSstDetails = document.getElementById("btnCancelarSstDetails");
const btnLembretes = document.getElementById("btnBell") || document.getElementById("btnLembretes");
const lembretesCount = document.getElementById("bellDot") || document.getElementById("lembretesCount");
const painelLembretes = document.getElementById("painelLembretes");
const loadingOverlay = document.getElementById("loadingOverlay");
const sidebar = document.getElementById("sidebar");
const btnToggleSidebar = document.querySelectorAll(
  "#btnSidebar, #btnSidebarToggle, #btnToggleSidebar, #btnMenu, #topbarMenuToggle, .header-toggle"
);
const appShell = document.querySelector(".app") || document.querySelector(".app-shell");
const btnLogoHome = document.getElementById("btnLogoHome");
const sidebarBackdrop = document.getElementById("sidebarBackdrop");
const dashboardHome = document.getElementById("dashboardHome");
const perfilNome = document.getElementById("perfilNome");
const perfilMatricula = document.getElementById("perfilMatricula");
const perfilCargo = document.getElementById("perfilCargo");
const perfilProjeto = document.getElementById("perfilProjeto");
const perfilUen = document.getElementById("perfilUen");
const perfilRole = document.getElementById("perfilRole");
const perfilAtribuicoes = document.getElementById("perfilAtribuicoes");
const perfilPermissoes = document.getElementById("perfilPermissoes");
const perfilSecoes = document.getElementById("perfilSecoes");
const perfilCard = document.getElementById("perfilCard");
const perfilTitle = document.getElementById("perfilTitle");
const perfilModeBadge = document.getElementById("perfilModeBadge");
const perfilView = document.getElementById("perfilView");
const perfilViewActions = document.getElementById("perfilViewActions");
const perfilEditActions = document.getElementById("perfilEditActions");
const perfilEditMount = document.getElementById("perfilEditMount");
const perfilAvatarActionsMount = document.getElementById("perfilAvatarActionsMount");
const perfilAvatarTemplate = document.getElementById("perfilAvatarTemplate");
const perfilEditTemplate = document.getElementById("perfilEditTemplate");
const perfilStatus = document.getElementById("perfilStatus");
const perfilStatusUpdated = document.getElementById("perfilStatusUpdated");
const perfilKpiAbertas = document.getElementById("perfilKpiAbertas");
const perfilKpiAtrasadas = document.getElementById("perfilKpiAtrasadas");
const perfilKpiPendencias = document.getElementById("perfilKpiPendencias");
const perfilKpiSla = document.getElementById("perfilKpiSla");
const perfilKpiChecklists = document.getElementById("perfilKpiChecklists");
const perfilPendenciasList = document.getElementById("perfilPendenciasList");
const perfilPendenciasEmpty = document.getElementById("perfilPendenciasEmpty");
const perfilAtribuicoesTags = document.getElementById("perfilAtribuicoesTags");
const perfilAtribuicoesEmpty = document.getElementById("perfilAtribuicoesEmpty");
const btnPerfilDefinirAtribuicoes = document.getElementById("btnPerfilDefinirAtribuicoes");
const perfilPermissoesResumo = document.getElementById("perfilPermissoesResumo");
const btnPerfilPermissoesDetalhes = document.getElementById("btnPerfilPermissoesDetalhes");
const perfilSecoesBadges = document.getElementById("perfilSecoesBadges");
const perfilAuditoriaList = document.getElementById("perfilAuditoriaList");
const perfilAuditoriaEmpty = document.getElementById("perfilAuditoriaEmpty");
const btnPerfilMinhasOs = document.getElementById("btnPerfilMinhasOs");
const btnPerfilCriarSolicitacao = document.getElementById("btnPerfilCriarSolicitacao");
const btnPerfilEscala = document.getElementById("btnPerfilEscala");
const btnPerfilExportar = document.getElementById("btnPerfilExportar");
const btnPerfilTrocarContexto = document.getElementById("btnPerfilTrocarContexto");
const btnPerfilVerPendencias = document.getElementById("btnPerfilVerPendencias");
const modalProfilePermissions = document.getElementById("modalProfilePermissions");
const btnCloseProfilePermissions = document.getElementById("btnCloseProfilePermissions");
const btnCloseProfilePermissionsFooter = document.getElementById(
  "btnCloseProfilePermissionsFooter"
);
const perfilPermissoesDetalhesList = document.getElementById("perfilPermissoesDetalhesList");
const perfilSecoesDetalhesList = document.getElementById("perfilSecoesDetalhesList");
const profileTabs = Array.from(document.querySelectorAll("[data-profile-tab]"));
const profilePanels = Array.from(document.querySelectorAll("[data-profile-panel]"));
const profileThemeSelect = document.getElementById("profileThemeSelect");
const profileDensitySelect = document.getElementById("profileDensitySelect");
const profileLanguageSelect = document.getElementById("profileLanguageSelect");
const profileTimezoneSelect = document.getElementById("profileTimezoneSelect");
const profileDashboardSelect = document.getElementById("profileDashboardSelect");
const profileNotifyAssigned = document.getElementById("profileNotifyAssigned");
const profileNotifyDue = document.getElementById("profileNotifyDue");
const profileNotifyCritical = document.getElementById("profileNotifyCritical");
const profileNotifyWeekly = document.getElementById("profileNotifyWeekly");
const profile2faToggle = document.getElementById("profile2faToggle");
const profileBlockUnknown = document.getElementById("profileBlockUnknown");
const btnPerfilEditar = document.getElementById("btnPerfilEditar");
const btnPerfilCancelar = document.getElementById("btnPerfilCancelar");

const usuarioAtual = document.getElementById("userChip") || document.getElementById("usuarioAtual");
const userAvatar = document.getElementById("userAvatar");
const userMenu = document.getElementById("userMenu");
const btnUserMenu = document.getElementById("btnUserMenu");
const userMenuPanel = document.getElementById("userMenuPanel");
const userMenuAvatar = document.getElementById("userMenuAvatar");
const userMenuName = document.getElementById("userMenuName");
const userMenuRole = document.getElementById("userMenuRole");
const btnTabLogin = document.getElementById("btnTabLogin");
const btnTabRegistro = document.getElementById("btnTabRegistro");
const btnSair = document.getElementById("btnLogout") || document.getElementById("btnSair");
const authPanels = document.getElementById("authPanels");
const authPanelLogin = document.querySelector("[data-auth-panel='login']");
const authPanelRegistro = document.querySelector("[data-auth-panel='registro']");
const loginForm = document.getElementById("loginForm");
const loginUsuario = document.getElementById("loginUsuario");
const loginSenha = document.getElementById("loginSenha");
const btnLoginSubmit = document.getElementById("btnLoginSubmit");
const btnAuthHelp = document.getElementById("btnAuthHelp");
const btnForgotPassword = document.getElementById("btnForgotPassword");
const modalAccessHelp = document.getElementById("modalAccessHelp");
const modalPasswordReset = document.getElementById("modalPasswordReset");
const btnAccessHelpClose = document.getElementById("btnAccessHelpClose");
const btnAccessHelpRequest = document.getElementById("btnAccessHelpRequest");
const btnAccessHelpReset = document.getElementById("btnAccessHelpReset");
const btnAccessHelpImport = document.getElementById("btnAccessHelpImport");
const passwordResetForm = document.getElementById("passwordResetForm");
const passwordResetEmail = document.getElementById("passwordResetEmail");
const passwordResetCode = document.getElementById("passwordResetCode");
const passwordResetNew = document.getElementById("passwordResetNew");
const passwordResetConfirm = document.getElementById("passwordResetConfirm");
const passwordResetMsg = document.getElementById("passwordResetMsg");
const btnPasswordResetSendCode = document.getElementById("btnPasswordResetSendCode");
const btnPasswordResetValidate = document.getElementById("btnPasswordResetValidate");
const btnPasswordResetSubmit = document.getElementById("btnPasswordResetSubmit");
const btnPasswordResetCancel = document.getElementById("btnPasswordResetCancel");
const btnPasswordResetClose = document.getElementById("btnPasswordResetClose");
const authToast = document.getElementById("authToast");
const btnToggleLoginSenha = document.getElementById("btnToggleLoginSenha");
const capsLockLogin = document.getElementById("capsLockLogin");
const reqForm = document.getElementById("reqForm");
const reqMatricula = document.getElementById("reqMatricula");
const reqNome = document.getElementById("reqNome");
const reqSenha = document.getElementById("reqSenha");
const reqSenhaConfirm = document.getElementById("reqSenhaConfirm");
const reqCodigoConvite = document.getElementById("reqCodigoConvite");
const verifyForm = document.getElementById("verifyForm");
const verifyEmail = document.getElementById("verifyEmail");
const verifyCode = document.getElementById("verifyCode");
const verifyHintEmail = document.getElementById("verifyHintEmail");
const verifyCodeError = document.getElementById("verifyCodeError");
const btnVerifySubmit = document.getElementById("btnVerifySubmit");
const btnVerifyResend = document.getElementById("btnVerifyResend");
const btnVerifyBack = document.getElementById("btnVerifyBack");
const btnRegistroSubmit = document.getElementById("btnRegistroSubmit");
const btnToggleReqSenha = document.getElementById("btnToggleReqSenha");
const btnToggleReqSenhaConfirm = document.getElementById("btnToggleReqSenhaConfirm");
const capsLockRegistro = document.getElementById("capsLockRegistro");
const reqSenhaRules = document.getElementById("reqSenhaRules");
const reqSenhaErro = document.getElementById("reqSenhaErro");
const reqSenhaConfirmErro = document.getElementById("reqSenhaConfirmErro");
const reqCodigoErro = document.getElementById("reqCodigoErro");
const mensagemConta = document.getElementById("mensagemConta");
const perfilAvatarPreview = document.getElementById("perfilAvatarPreview");
const perfilAvatarInput = document.getElementById("perfilAvatarInput");
const btnAvatarChange = document.getElementById("btnAvatarChange");
const btnAvatarSave = document.getElementById("btnAvatarSave");
const perfilAvatarErro = document.getElementById("perfilAvatarErro");
const perfilAvatarActions = document.getElementById("perfilAvatarActions");
const btnFecharPerfil = document.getElementById("btnFecharPerfil");
const perfilUenInput = document.getElementById("perfilUenInput");
const perfilProjetoInput = document.getElementById("perfilProjetoInput");
const btnPerfilSalvar = document.getElementById("btnPerfilSalvar");
const perfilSaveMsg = document.getElementById("perfilSaveMsg");
const perfilEdit = document.getElementById("perfilEdit");
const configDiasLembrete = document.getElementById("configDiasLembrete");
const btnSalvarConfig = document.getElementById("btnSalvarConfig");
const btnExportarDados = document.getElementById("btnExportarDados");
const inputImportarDados = document.getElementById("inputImportarDados");
const btnImportarDados = document.getElementById("btnImportarDados");
const inputDiasLimpeza = document.getElementById("inputDiasLimpeza");
const btnLimparConcluidas = document.getElementById("btnLimparConcluidas");
const btnLimparAuditoria = document.getElementById("btnLimparAuditoria");
const btnRecalcularBacklog = document.getElementById("btnRecalcularBacklog");
const btnGerarRelatorio = document.getElementById("btnGerarRelatorio");
const relatorioGerencial = document.getElementById("relatorioGerencial");
const mensagemGerencial = document.getElementById("mensagemGerencial");
const healthSummary = document.getElementById("healthSummary");
const healthTasks = document.getElementById("healthTasks");
const healthIntegrity = document.getElementById("healthIntegrity");
const healthMessage = document.getElementById("healthMessage");
const btnRefreshHealth = document.getElementById("btnRefreshHealth");
const apiLogsTable = document.getElementById("apiLogsTable");
const apiLogsEmpty = document.getElementById("apiLogsEmpty");
const apiLogsCount = document.getElementById("apiLogsCount");
const apiLogsMessage = document.getElementById("apiLogsMessage");
const btnLogsRefresh = document.getElementById("btnLogsRefresh");
const btnLogsLoadMore = document.getElementById("btnLogsLoadMore");
const automationList = document.getElementById("automationList");
const automationMessage = document.getElementById("automationMessage");
const btnAutomationRefresh = document.getElementById("btnAutomationRefresh");
const gerencialHealth = document.getElementById("gerencialHealth");
const gerencialLogs = document.getElementById("gerencialLogs");
const gerencialAutomations = document.getElementById("gerencialAutomations");
const gerencialFiles = document.getElementById("gerencialFiles");
const gerencialTabs = Array.from(document.querySelectorAll(".gerencial-tab"));
const gerencialPanels = Array.from(document.querySelectorAll("[data-tab-panel]"));
const gerencialIndicators = Array.from(
  document.querySelectorAll(".indicator-card[data-tab-target]")
);
const gerencialIndicatorsWrap = document.querySelector(".gerencial-indicators");
const indicatorHealthCard = document.querySelector("[data-indicator='diagnostico']");
const indicatorHealthCount = document.getElementById("indicatorHealthCount");
const indicatorHealthBadge = document.getElementById("indicatorHealthBadge");
const indicatorHealthMeta = document.getElementById("indicatorHealthMeta");
const indicatorLogsCard = document.querySelector("[data-indicator='logs']");
const indicatorLogsCount = document.getElementById("indicatorLogsCount");
const indicatorLogsBadge = document.getElementById("indicatorLogsBadge");
const indicatorLogsMeta = document.getElementById("indicatorLogsMeta");
const indicatorFilesCard = document.querySelector("[data-indicator='arquivos']");
const indicatorFilesCount = document.getElementById("indicatorFilesCount");
const indicatorFilesBadge = document.getElementById("indicatorFilesBadge");
const indicatorFilesMeta = document.getElementById("indicatorFilesMeta");
const indicatorAutomationsCard = document.querySelector("[data-indicator='automacoes']");
const indicatorAutomationsCount = document.getElementById("indicatorAutomationsCount");
const indicatorAutomationsBadge = document.getElementById("indicatorAutomationsBadge");
const indicatorAutomationsMeta = document.getElementById("indicatorAutomationsMeta");
const permissoesSearch = document.getElementById("permissoesSearch");
const permissoesSummary = document.getElementById("permissoesSummary");
const gerencialUpdateMessage = document.getElementById("gerencialUpdateMessage");
const gerencialLastUpdate = document.getElementById("gerencialLastUpdate");
const gerencialPalette = document.getElementById("gerencialPalette");
const gerencialPaletteInput = document.getElementById("gerencialPaletteInput");
const gerencialPaletteList = document.getElementById("gerencialPaletteList");
const gerencialPaletteTrigger = document.getElementById("gerencialPaletteTrigger");
const btnGerencialPalette = document.getElementById("btnGerencialPalette");
const btnGerencialRefreshAll = document.getElementById("btnGerencialRefreshAll");
const btnGerencialGoLogs = document.getElementById("btnGerencialGoLogs");
const btnGerencialGoPermissoes = document.getElementById("btnGerencialGoPermissoes");
const btnHealthRunAll = document.getElementById("btnHealthRunAll");
const btnLogsExport = document.getElementById("btnLogsExport");
const filesFilterType = document.getElementById("filesFilterType");
const filesSearch = document.getElementById("filesSearch");
const filesUploadType = document.getElementById("filesUploadType");
const filesUploadInput = document.getElementById("filesUploadInput");
const btnFilesUpload = document.getElementById("btnFilesUpload");
const btnFilesRefresh = document.getElementById("btnFilesRefresh");
const filesList = document.getElementById("filesList");
const filesEmpty = document.getElementById("filesEmpty");
const filesMessage = document.getElementById("filesMessage");
const gerencialPermissoes = document.getElementById("gerencialPermissoes");
const permissoesList = document.getElementById("permissoesList");
const btnPermissoesSalvar = document.getElementById("btnPermissoesSalvar");
const permissoesMessage = document.getElementById("permissoesMessage");
const btnLogsApply = document.getElementById("btnLogsApply");
const btnLogsClear = document.getElementById("btnLogsClear");
const logsFilterEndpoint = document.getElementById("logsFilterEndpoint");
const logsFilterUser = document.getElementById("logsFilterUser");
const logsFilterStatus = document.getElementById("logsFilterStatus");
const logsFilterFrom = document.getElementById("logsFilterFrom");
const logsFilterTo = document.getElementById("logsFilterTo");
const templateForm = document.getElementById("templateForm");
const templateNome = document.getElementById("templateNome");
const templateProjeto = document.getElementById("templateProjeto");
const templateSubestacao = document.getElementById("templateSubestacao");
const templateEquipamento = document.getElementById("templateEquipamento");
const templateEquipeResponsavel = document.getElementById("templateEquipeResponsavel");
const templateParticipantes = document.getElementById("templateParticipantes");
const templateParticipantesList = document.getElementById("templateParticipantesList");
const templateParticipantesSelected = document.getElementById("templateParticipantesSelected");
const templateParticipantesErro = document.getElementById("templateParticipantesErro");
const templateParticipanteExterno = document.getElementById("templateParticipanteExterno");
const btnAddTemplateParticipanteExterno = document.getElementById(
  "btnAddTemplateParticipanteExterno"
);
const templateFrequencia = document.getElementById("templateFrequencia");
const templateNomeErro = document.getElementById("templateNomeErro");
const templateInicioErro = document.getElementById("templateInicioErro");
const templateDailyErro = document.getElementById("templateDailyErro");
const templateWeeklyIntervalErro = document.getElementById("templateWeeklyIntervalErro");
const templateMonthlyDayErro = document.getElementById("templateMonthlyDayErro");
const templateMonthlyDaysErro = document.getElementById("templateMonthlyDaysErro");
const templateDailyField = document.getElementById("templateDailyField");
const templateDailyDays = document.querySelectorAll("[data-template-daily-day]");
const btnPresetDiasUteis = document.getElementById("btnPresetDiasUteis");
const templateWeeklyDayField = document.getElementById("templateWeeklyDayField");
const templateWeeklyDay = document.getElementById("templateWeeklyDay");
const templateWeeklyIntervalField = document.getElementById("templateWeeklyIntervalField");
const templateWeeklyInterval = document.getElementById("templateWeeklyInterval");
const templateMonthlyModeField = document.getElementById("templateMonthlyModeField");
const templateMonthlyFixed = document.getElementById("templateMonthlyFixed");
const templateMonthlyMulti = document.getElementById("templateMonthlyMulti");
const templateMonthlyDayField = document.getElementById("templateMonthlyDayField");
const templateMonthlyDay = document.getElementById("templateMonthlyDay");
const templateMonthlyDaysField = document.getElementById("templateMonthlyDaysField");
const templateMonthlyDaysInput = document.getElementById("templateMonthlyDaysInput");
const templateMonthlyDaysChips = document.getElementById("templateMonthlyDaysChips");
const templateResumo = document.getElementById("templateResumo");
const templateResumoLinhas = document.getElementById("templateResumoLinhas");
const templateInicioField = document.getElementById("templateInicioField");
const templateInicio = document.getElementById("templateInicio");
const templateObs = document.getElementById("templateObs");
const templateAtivo = document.getElementById("templateAtivo");
const templateMensagem = document.getElementById("templateMensagem");
const templatePresets = document.getElementById("templatePresets");
const btnCancelarModelo = document.getElementById("btnCancelarModelo");
const listaModelos = document.getElementById("listaModelos");
const modelosVazio = document.getElementById("modelosVazio");
const templateSearch = document.getElementById("templateSearch");
const templateFilterSubestacao = document.getElementById("templateFilterSubestacao");
const templateSort = document.getElementById("templateSort");
const listaSolicitacoes = document.getElementById("listaSolicitacoes");
const solicitacoesVazio = document.getElementById("solicitacoesVazio");
const listaUsuarios = document.getElementById("listaUsuarios");
const usuariosVazio = document.getElementById("usuariosVazio");
const inviteRole = document.getElementById("inviteRole");
const userFiltroNome = document.getElementById("userFiltroNome");
const userFiltroCargo = document.getElementById("userFiltroCargo");
const userFiltroProjeto = document.getElementById("userFiltroProjeto");
const userFiltroStatus = document.getElementById("userFiltroStatus");
const btnLimparFiltroUsuarios = document.getElementById("btnLimparFiltroUsuarios");
const userDrawer = document.getElementById("userDrawer");
const userDrawerForm = document.getElementById("userDrawerForm");
const drawerUserId = document.getElementById("drawerUserId");
const drawerNome = document.getElementById("drawerNome");
const drawerCargo = document.getElementById("drawerCargo");
const drawerRole = document.getElementById("drawerRole");
const drawerProjeto = document.getElementById("drawerProjeto");
const drawerActive = document.getElementById("drawerActive");
const drawerPermissions = document.getElementById("drawerPermissions");
const drawerMessage = document.getElementById("drawerMessage");
const drawerSubtitle = document.getElementById("drawerSubtitle");
const btnFecharUserDrawer = document.getElementById("btnFecharUserDrawer");
const btnCancelarUserDrawer = document.getElementById("btnCancelarUserDrawer");
const btnSalvarUserDrawer = document.getElementById("btnSalvarUserDrawer");
const btnGerarConvite = document.getElementById("btnGerarConvite");
const inviteResultado = document.getElementById("inviteResultado");
const btnIrAcessos = document.getElementById("btnIrAcessos");
const accessTabs = Array.from(document.querySelectorAll("[data-access-tab]"));
const accessPanels = Array.from(document.querySelectorAll("[data-access-panel]"));
const accessMsg = document.getElementById("accessMsg");
const accessStorageWarning = document.getElementById("accessStorageWarning");
const btnAccessNewUser = document.getElementById("btnAccessNewUser");
const btnAccessNewRole = document.getElementById("btnAccessNewRole");
const btnAccessExport = document.getElementById("btnAccessExport");
const btnAccessImport = document.getElementById("btnAccessImport");
const accessImportInput = document.getElementById("accessImportInput");
const btnAccessClearFilters = document.getElementById("btnAccessClearFilters");
const accessUserSearch = document.getElementById("accessUserSearch");
const accessUserStatusFilter = document.getElementById("accessUserStatusFilter");
const accessUserRoleFilter = document.getElementById("accessUserRoleFilter");
const accessUserProjectFilter = document.getElementById("accessUserProjectFilter");
const accessUsersTableBody = document.getElementById("accessUsersTableBody");
const accessUsersEmpty = document.getElementById("accessUsersEmpty");
const accessRoleSearch = document.getElementById("accessRoleSearch");
const accessRolesTableBody = document.getElementById("accessRolesTableBody");
const accessRolesEmpty = document.getElementById("accessRolesEmpty");
const modalAccessUser = document.getElementById("modalAccessUser");
const accessUserForm = document.getElementById("accessUserForm");
const accessUserId = document.getElementById("accessUserId");
const accessUserName = document.getElementById("accessUserName");
const accessUserMatricula = document.getElementById("accessUserMatricula");
const accessUserEmail = document.getElementById("accessUserEmail");
const accessUserRole = document.getElementById("accessUserRole");
const accessUserProject = document.getElementById("accessUserProject");
const accessUserStatus = document.getElementById("accessUserStatus");
const accessUserPasswordBlock = document.getElementById("accessUserPasswordBlock");
const accessUserPassword = document.getElementById("accessUserPassword");
const accessUserPasswordHint = document.getElementById("accessUserPasswordHint");
const accessUserModalTitle = document.getElementById("accessUserModalTitle");
const accessUserModalSubtitle = document.getElementById("accessUserModalSubtitle");
const accessUserFormMsg = document.getElementById("accessUserFormMsg");
const btnCloseAccessUserModal = document.getElementById("btnCloseAccessUserModal");
const btnAccessUserSave = document.getElementById("btnAccessUserSave");
const btnAccessUserCancel = document.getElementById("btnAccessUserCancel");
const btnAccessGeneratePassword = document.getElementById("btnAccessGeneratePassword");
const modalResetPassword = document.getElementById("modalResetPassword");
const resetPasswordForm = document.getElementById("resetPasswordForm");
const resetPasswordUserId = document.getElementById("resetPasswordUserId");
const resetPasswordUserLabel = document.getElementById("resetPasswordUserLabel");
const resetPasswordManualField = document.getElementById("resetPasswordManualField");
const resetPasswordValue = document.getElementById("resetPasswordValue");
const resetPasswordMsg = document.getElementById("resetPasswordMsg");
const btnCloseResetPassword = document.getElementById("btnCloseResetPassword");
const btnResetPasswordCancel = document.getElementById("btnResetPasswordCancel");
const btnResetPasswordConfirm = document.getElementById("btnResetPasswordConfirm");
const btnResetGeneratePassword = document.getElementById("btnResetGeneratePassword");
const modalGeneratedPassword = document.getElementById("modalGeneratedPassword");
const generatedPasswordValue = document.getElementById("generatedPasswordValue");
const btnCopyGeneratedPassword = document.getElementById("btnCopyGeneratedPassword");
const btnCloseGeneratedPassword = document.getElementById("btnCloseGeneratedPassword");
const btnGeneratedPasswordDone = document.getElementById("btnGeneratedPasswordDone");
const modalAccessRole = document.getElementById("modalAccessRole");
const accessRoleForm = document.getElementById("accessRoleForm");
const accessRoleId = document.getElementById("accessRoleId");
const accessRoleSelect = document.getElementById("accessRoleSelect");
const btnAccessRoleRename = document.getElementById("btnAccessRoleRename");
const accessRoleNameField = document.getElementById("accessRoleNameField");
const accessRoleName = document.getElementById("accessRoleName");
const accessRoleItemsList = document.getElementById("accessRoleItemsList");
const accessRoleEditor = document.getElementById("accessRoleEditor");
const accessRoleConfiguredCount = document.getElementById("accessRoleConfiguredCount");
const accessRoleAdminToggle = document.getElementById("accessRoleAdminToggle");
const accessRolePermissionSearch = document.getElementById("accessRolePermissionSearch");
const accessRoleFilterConfigured = document.getElementById("accessRoleFilterConfigured");
const accessRoleFilterCritical = document.getElementById("accessRoleFilterCritical");
const accessRoleAllNone = document.getElementById("accessRoleAllNone");
const accessRoleAllView = document.getElementById("accessRoleAllView");
const accessRoleAllEdit = document.getElementById("accessRoleAllEdit");
const accessRoleAdminNotice = document.getElementById("accessRoleAdminNotice");
const accessRoleModulesList = document.getElementById("accessRoleModulesList");
const accessRoleModuleTitle = document.getElementById("accessRoleModuleTitle");
const accessRoleModuleStats = document.getElementById("accessRoleModuleStats");
const accessRoleModuleLevel = document.getElementById("accessRoleModuleLevel");
const accessRoleUnknownBlock = document.getElementById("accessRoleUnknownBlock");
const accessRoleUnknownList = document.getElementById("accessRoleUnknownList");
const accessRoleChangesCount = document.getElementById("accessRoleChangesCount");
const accessRoleChangesDetails = document.getElementById("accessRoleChangesDetails");
const accessRoleChangesList = document.getElementById("accessRoleChangesList");
const accessRoleModalTitle = document.getElementById("accessRoleModalTitle");
const accessRoleModalSubtitle = document.getElementById("accessRoleModalSubtitle");
const accessRoleFormMsg = document.getElementById("accessRoleFormMsg");
const btnCloseAccessRoleModal = document.getElementById("btnCloseAccessRoleModal");
const btnAccessRoleSave = document.getElementById("btnAccessRoleSave");
const btnAccessRoleCancel = document.getElementById("btnAccessRoleCancel");
const modalConfirm = document.getElementById("modalConfirm");
const modalConfirmTitle = document.getElementById("modalConfirmTitle");
const modalConfirmMessage = document.getElementById("modalConfirmMessage");
const btnConfirmOk = document.getElementById("btnConfirmOk");
const btnConfirmCancel = document.getElementById("btnConfirmCancel");
const btnConfirmClose = document.getElementById("btnConfirmClose");
const modalInicioExecucao = document.getElementById("modalInicioExecucao");
const inicioExecucaoId = document.getElementById("inicioExecucaoId");
const btnConfirmarInicioExecucao = document.getElementById("btnConfirmarInicioExecucao");
const btnCancelarInicioExecucao = document.getElementById("btnCancelarInicioExecucao");
const btnFecharInicioExecucao = document.getElementById("btnFecharInicioExecucao");
const mensagemInicioExecucao = document.getElementById("mensagemInicioExecucao");
const modalCancelarInicio = document.getElementById("modalCancelarInicio");
const formCancelarInicio = document.getElementById("formCancelarInicio");
const cancelarInicioId = document.getElementById("cancelarInicioId");
const cancelarInicioMotivo = document.getElementById("cancelarInicioMotivo");
const cancelarInicioObs = document.getElementById("cancelarInicioObs");
const btnFecharCancelarInicio = document.getElementById("btnFecharCancelarInicio");
const btnCancelarCancelarInicio = document.getElementById("btnCancelarCancelarInicio");
const mensagemCancelarInicio = document.getElementById("mensagemCancelarInicio");
const modalRegistroExecucao = document.getElementById("modalRegistroExecucao");
const formRegistroExecucao = document.getElementById("formRegistroExecucao");
const registroId = document.getElementById("registroId");
const registroResumo = document.getElementById("registroResumo");
const registroTipo = document.getElementById("registroTipo");
const registroSubestacao = document.getElementById("registroSubestacao");
const registroCodigo = document.getElementById("registroCodigo");
const registroAbertaPor = document.getElementById("registroAbertaPor");
const registroAbertaEm = document.getElementById("registroAbertaEm");
const registroExecutadaPor = document.getElementById("registroExecutadaPor");
const registroInicio = document.getElementById("registroInicio");
const registroOsNumero = document.getElementById("registroOsNumero");
const registroParticipantes = document.getElementById("registroParticipantes");
const registroDocs = document.getElementById("registroDocs");
const registroResultado = document.getElementById("registroResultado");
const registroComentario = document.getElementById("registroComentario");
const registroObsExecucao = document.getElementById("registroObsExecucao");
const btnFecharRegistroExecucao = document.getElementById("btnFecharRegistroExecucao");
const btnCancelarRegistroExecucao = document.getElementById("btnCancelarRegistroExecucao");
const btnCancelarExecucao = document.getElementById("btnCancelarExecucao");
const formCancelarExecucao = document.getElementById("formCancelarExecucao");
const cancelarExecucaoMotivo = document.getElementById("cancelarExecucaoMotivo");
const btnVoltarCancelarExecucao = document.getElementById("btnVoltarCancelarExecucao");
const mensagemCancelarExecucao = document.getElementById("mensagemCancelarExecucao");
const mensagemRegistroExecucao = document.getElementById("mensagemRegistroExecucao");
const modalConclusao = document.getElementById("modalConclusao");
const conclusaoResumo = document.getElementById("conclusaoResumo");
const modalReagendar = document.getElementById("modalReagendar");
const formReagendar = document.getElementById("formReagendar");
const reagendarId = document.getElementById("reagendarId");
const reagendarData = document.getElementById("reagendarData");
const reagendarMotivo = document.getElementById("reagendarMotivo");
const reagendarObs = document.getElementById("reagendarObs");
const mensagemReagendar = document.getElementById("mensagemReagendar");
const btnFecharReagendar = document.getElementById("btnFecharReagendar");
const btnCancelarReagendar = document.getElementById("btnCancelarReagendar");
const modalBacklogMotivo = document.getElementById("modalBacklogMotivo");
const formBacklogMotivo = document.getElementById("formBacklogMotivo");
const backlogMotivoId = document.getElementById("backlogMotivoId");
const backlogMotivoSelect = document.getElementById("backlogMotivoSelect");
const backlogMotivoObs = document.getElementById("backlogMotivoObs");
const mensagemBacklogMotivo = document.getElementById("mensagemBacklogMotivo");
const btnFecharBacklogMotivo = document.getElementById("btnFecharBacklogMotivo");
const btnCancelarBacklogMotivo = document.getElementById("btnCancelarBacklogMotivo");
const modalLiberacao = document.getElementById("modalLiberacao");
const formLiberacao = document.getElementById("formLiberacao");
const liberacaoId = document.getElementById("liberacaoId");
const liberacaoOs = document.getElementById("liberacaoOs");
const liberacaoEquipamento = document.getElementById("liberacaoEquipamento");
const liberacaoCritico = document.getElementById("liberacaoCritico");
const liberacaoParticipantes = document.getElementById("liberacaoParticipantes");
const liberacaoEquipeResponsavel = document.getElementById("liberacaoEquipeResponsavel");
const liberacaoParticipantesList = document.getElementById("liberacaoParticipantesList");
const liberacaoParticipantesSelected = document.getElementById("liberacaoParticipantesSelected");
const liberacaoParticipanteExterno = document.getElementById("liberacaoParticipanteExterno");
const btnAddParticipanteExternoLiberacao = document.getElementById(
  "btnAddParticipanteExternoLiberacao"
);
const liberacaoParticipantesErro = document.getElementById("liberacaoParticipantesErro");
const liberacaoChecklist = document.getElementById("liberacaoChecklist");
const mensagemLiberacao = document.getElementById("mensagemLiberacao");
const liberacaoDocPt = document.getElementById("liberacaoDocPt");
const liberacaoDocInputs = Array.from(document.querySelectorAll("[data-doc-input]"));
const liberacaoDocButtons = Array.from(document.querySelectorAll("[data-doc-btn]"));
const liberacaoDocViews = Array.from(document.querySelectorAll("[data-doc-view]"));
const liberacaoDocNames = Array.from(document.querySelectorAll("[data-doc-name]"));
const btnFecharLiberacao = document.getElementById("btnFecharLiberacao");
const btnCancelarLiberacao = document.getElementById("btnCancelarLiberacao");
const modalOverride = document.getElementById("modalOverride");
const formOverride = document.getElementById("formOverride");
const overrideInfo = document.getElementById("overrideInfo");
const overrideMotivo = document.getElementById("overrideMotivo");
const overrideMensagem = document.getElementById("overrideMensagem");
const btnFecharOverride = document.getElementById("btnFecharOverride");
const btnCancelarOverride = document.getElementById("btnCancelarOverride");
const modalHistorico = document.getElementById("modalHistorico");
const listaHistorico = document.getElementById("listaHistorico");
const historicoVazio = document.getElementById("historicoVazio");
const historicoResumo = document.getElementById("historicoResumo");
const btnFecharHistorico = document.getElementById("btnFecharHistorico");
const btnHistoricoMais = document.getElementById("btnHistoricoMais");
const btnHistoricoExportar = document.getElementById("btnHistoricoExportar");
const btnHistoricoExportarPdf = document.getElementById("btnHistoricoExportarPdf");
const modalPreview = document.getElementById("modalPreview");
const previewFrame = document.getElementById("previewFrame");
const btnAbrirPreview = document.getElementById("btnAbrirPreview");
const btnFecharPreview = document.getElementById("btnFecharPreview");
const formConclusao = document.getElementById("formConclusao");
const mensagemConclusao = document.getElementById("mensagemConclusao");
const conclusaoId = document.getElementById("conclusaoId");
const conclusaoTipo = document.getElementById("conclusaoTipo");
const conclusaoSubestacao = document.getElementById("conclusaoSubestacao");
const conclusaoCodigo = document.getElementById("conclusaoCodigo");
const conclusaoAbertaPor = document.getElementById("conclusaoAbertaPor");
const conclusaoAbertaEm = document.getElementById("conclusaoAbertaEm");
const conclusaoExecutadaPor = document.getElementById("conclusaoExecutadaPor");
const conclusaoEncerradaPor = document.getElementById("conclusaoEncerradaPor");
const conclusaoInicio = document.getElementById("conclusaoInicio");
const conclusaoFim = document.getElementById("conclusaoFim");
const conclusaoDuracao = document.getElementById("conclusaoDuracao");
const conclusaoResultado = document.getElementById("conclusaoResultado");
const conclusaoComentario = document.getElementById("conclusaoComentario");
const conclusaoObsExecucao = document.getElementById("conclusaoObsExecucao");
const conclusaoModeloBreve = document.getElementById("conclusaoModeloBreve");
const btnAplicarModeloBreve = document.getElementById("btnAplicarModeloBreve");
const conclusaoDescricaoBreve = document.getElementById("conclusaoDescricaoBreve");
const conclusaoParticipantes = document.getElementById("conclusaoParticipantes");
const conclusaoDocs = document.getElementById("conclusaoDocs");
const conclusaoReferencia = document.getElementById("conclusaoReferencia");
const conclusaoFotosToggle = document.getElementById("conclusaoFotosToggle");
const conclusaoEvidenciasField = document.getElementById("conclusaoEvidenciasField");
const conclusaoEvidenciasLista = document.getElementById("conclusaoEvidenciasLista");
const evidenciaInputs = Array.from(document.querySelectorAll("[data-evidencia-input]"));
const evidenciaButtons = Array.from(document.querySelectorAll("[data-evidencia-btn]"));
const fotoSlots = Array.from(document.querySelectorAll("[data-photo-slot]"));
const btnFecharConclusao = document.getElementById("btnFecharConclusao");
const btnCancelarConclusao = document.getElementById("btnCancelarConclusao");
const modalRelatorio = document.getElementById("modalRelatorio");
const relatorioLogo = document.getElementById("relatorioLogo");
const relatorioTipo = document.getElementById("relatorioTipo");
const relatorioSubestacao = document.getElementById("relatorioSubestacao");
const relatorioCodigo = document.getElementById("relatorioCodigo");
const relatorioAbertaEm = document.getElementById("relatorioAbertaEm");
const relatorioInicio = document.getElementById("relatorioInicio");
const relatorioFim = document.getElementById("relatorioFim");
const relatorioDuracao = document.getElementById("relatorioDuracao");
const relatorioAbertaPor = document.getElementById("relatorioAbertaPor");
const relatorioExecutadaPor = document.getElementById("relatorioExecutadaPor");
const relatorioEncerradaPor = document.getElementById("relatorioEncerradaPor");
const relatorioResultado = document.getElementById("relatorioResultado");
const relatorioReferencia = document.getElementById("relatorioReferencia");
const relatorioEmitidoEm = document.getElementById("relatorioEmitidoEm");
const relatorioDescricao = document.getElementById("relatorioDescricao");
const relatorioObsExecucao = document.getElementById("relatorioObsExecucao");
const relatorioEvidencias = document.getElementById("relatorioEvidencias");
const btnImprimirRelatorio = document.getElementById("btnImprimirRelatorio");
const btnExportarPDF = document.getElementById("btnExportarPDF");
const btnFecharRelatorio = document.getElementById("btnFecharRelatorio");
const tabButtons = document.querySelectorAll("[data-tab]");
const panels = document.querySelectorAll("[data-panel]");
const adminElements = document.querySelectorAll("[data-admin-only]");

const DEFAULT_REMINDER_DAYS = 7;
const LOADING_DELAY_MS = 450;
const BASE_DOCUMENT_TITLE = "OPSCOPE - Sistema de Gest\u00e3o Operacional e Manuten\u00e7\u00e3o";
const HISTORY_PAGE_SIZE = 12;
const REMINDER_KEY = "denemanu.reminderDays";
const SIDEBAR_KEY = "opscope.sidebarCollapsed";
const SIDEBAR_STATE_KEY = "sb_state";
const NOTIFICATION_READ_KEY = "opscope.notifications.read";
const EXECUCAO_REG_ALERT_KEY = "opscope.execucaoRegistrada.alerts";
const SYNC_LAST_AT_KEY = "opscope.sync.lastAt";
const ANNOUNCEMENTS_KEY = "opscope.announcements";
const ANNOUNCEMENTS_READ_KEY = "opscope.announcements.read";
const ANNOUNCEMENTS_READERS_KEY = "opscope.announcements.readers";
const FEEDBACK_TTL_MS = 20 * 1000;
const TEAM_NOTIFICATION_WINDOW_DAYS = 14;
const STORAGE_KEY = "denemanu.manutencoes";
const MAINT_DIRTY_KEY = "opscope.maintenance.dirty";
const MAINT_TOMBSTONE_KEY = "opscope.maintenance.tombstones";
const MAINT_CACHE_USER_KEY = "opscope.maintenance.cache.user";
const TEMPLATE_KEY = "denemanu.templates";
const USER_KEY = "denemanu.users";
const ACCESS_USERS_KEY = "opscope.access.users";
const ACCESS_ROLES_KEY = "opscope.access.roles";
const ACCESS_ROLE_LEVELS_KEY = "opscope.access.roles.levels";
const ACCESS_SYNC_KEY = "opscope.access.sync";
const ACCESS_PACKAGE_VERSION = 1;
const ACCESS_USERS_BACKUP_KEY = "opscope.access.users.backup";
const ACCESS_ROLES_BACKUP_KEY = "opscope.access.roles.backup";
const TEMPLATE_SEED_DISABLED_KEY = "opscope.templates.seed.disabled";
const RECURRENCE_SUPPRESS_KEY = "opscope.maintenance.recurring.suppressed";
const GERENCIAL_PERMISSOES_KEY = "opscope.gerencial.permissoes";
const GERENCIAL_AUTOMATIONS_KEY = "opscope.gerencial.automations";
const GERENCIAL_FILES_KEY = "opscope.gerencial.files";
const REQUEST_KEY = "denemanu.requests";
const AUDIT_KEY = "denemanu.audit";
const RDO_KEY = "denemanu.rdo";
const FEEDBACK_KEY = "opscope.feedbacks";
const SST_DOCS_KEY = "opscope.sst.docs";
const SST_TEMPLATES_KEY = "opscope.sst.templates";
const SST_INSPECTIONS_KEY = "opscope.sst.inspections";
const SST_NCS_KEY = "opscope.sst.ncs.local";
const SST_EVIDENCES_KEY = "opscope.sst.evidences";
const SST_VEHICLES_KEY = "opscope.sst.vehicles";
const PROJECTS_KEY = "opscope.projects";
const PROJECTS_BACKUP_KEY = "opscope.projects.backup";
const PROJECTS_SYNC_KEY = "opscope.projects.sync";
const OPSCOPE_DB_VERSION = 4;
const SESSION_KEY = "denemanu.session";
const ACTIVE_PROJECT_KEY = "opscope.activeProjectId";
const DAY_MS = 24 * 60 * 60 * 1000;
const ACCESS_BOOTSTRAP_USER = {
  matricula: "35269",
  name: "Denisson Silva Alves",
  password: "20082000",
  roleName: "Administrador",
};
const ACCESS_HELP_MESSAGES = {
  request:
    "Olá, preciso de acesso ao OPSCOPE.\nNome: \nMatrícula: \nProjeto: \nObrigado!",
  reset:
    "Olá, preciso de reset de senha no OPSCOPE.\nNome: \nMatrícula: \nObrigado!",
};
const PASSWORD_RESET_RESEND_SECONDS = 60;
const ACCESS_STORAGE_READONLY_MESSAGE =
  "Armazenamento indisponivel. O sistema esta em modo somente leitura para evitar perda de dados.";
const MAX_REAGENDAMENTOS = 3;
const OUTROS_ALERT_THRESHOLD = 3;
const MIN_EVIDENCIAS = 2;
const MIN_DESCRICAO_BREVE = 60;
const MIN_RESUMO_RDO_CHARS = 12;
const ALMOCO_MIN = 60;
const MAX_EXECUCAO_HORAS = 12;
const DOC_KEYS = ["apr", "os", "pte", "pt"];
const DOC_LABELS = {
  apr: "APR",
  os: "OS",
  pte: "PTE",
  pt: "PT",
};
const RDO_CLIENTE = "SOLARIG";
const RDO_SETOR = "O&M - ENGELMIG";
const RDO_PROJETO = "834 - PARACATU/SOLARIG (Boa Sorte II)";
const SYSTEM_USER_ID = "system";
const CUSTOM_TIPO_OPTION = "__custom";
const DEFAULT_PROJECT_CODE = "834";
const DEFAULT_PROJECT_LABEL = "834 - PARACATU/SOLARIG (Boa Sorte II)";
const DEFAULT_TEAM_NAME = "O&M BSO2";
const SUBESTACOES = [];
const DEFAULT_TEMPLATE_NAMES = new Set([
  "Inspeção diária da subestação",
  "Inspeção mensal da subestação",
  "Inspeção semanal do GMG BSO2",
  "Inspeção semanal dos GMG PCT4",
  "Inspeção mensal do GMG BSO2",
  "Inspeção mensal dos GMG PCT4",
]);
const SST_SEVERITY_LABELS = {
  LOW: "Baixa",
  MED: "Media",
  HIGH: "Alta",
  CRITICAL: "Critica",
};
const SST_STATUS_LABELS = {
  OK: "OK",
  ATTENTION: "Atenção",
  NON_CONFORMING: "Não conforme",
};
const SST_CHECKLIST_TYPE_LABELS = {
  WORK_AT_HEIGHT: "NR-35 - Trabalho em Altura",
  SCAFFOLDING: "Andaimes",
  LADDERS: "Escadas portateis",
  PPE_COMPLIANCE: "EPI - Uso e Conformidade",
  EPC_ISOLATION: "EPC - Isolamento de area",
  FIRE_EXTINGUISHERS: "Extintores",
  FIRE_PREVENTION: "Prevencao de incendio",
  NR10_ELECTRICAL: "NR-10 - Eletricidade",
  POWER_TOOLS: "Ferramentas eletricas",
  MACHINERY_GUARDS: "Maquinas - Protecoes",
  LIFTING_OPERATIONS: "Icamento",
  HOISTS_CHAINS: "Talhas/Guinchos/Correntes",
  VEHICLES_DAILY: "Veiculos - Checklist diario",
  FORKLIFT: "Empilhadeira",
  CONFINED_SPACE: "Espaco confinado",
  HOT_WORK: "Trabalho a quente",
  CHEMICALS: "Quimicos",
  ERGONOMICS: "Ergonomia",
  HOUSEKEEPING: "Ordem e limpeza (5S)",
  FIRST_AID: "Primeiros socorros",
};
const WEEKDAYS = ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"];
const WEEKDAYS_SHORT = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"];
const DEFAULT_DAILY_DAYS = [1, 2, 3, 4, 5];
const PMP_TOLERANCE_DAYS = 3;
const PMP_MONTH_LABELS = [
  "Jan",
  "Fev",
  "Mar",
  "Abr",
  "Mai",
  "Jun",
  "Jul",
  "Ago",
  "Set",
  "Out",
  "Nov",
  "Dez",
];
const PMP_FREQUENCIES = [
  { value: "diaria", label: "Diária", unit: "day", interval: 1 },
  { value: "semanal", label: "Semanal", unit: "week", interval: 1 },
  { value: "mensal", label: "Mensal", unit: "month", interval: 1 },
  { value: "bimestral", label: "Bimestral", unit: "month", interval: 2 },
  { value: "trimestral", label: "Trimestral", unit: "month", interval: 3 },
  { value: "semestral", label: "Semestral", unit: "month", interval: 6 },
  { value: "anual", label: "Anual", unit: "year", interval: 1 },
  { value: "bienal", label: "Bienal", unit: "year", interval: 2 },
  { value: "trienal", label: "Trienal", unit: "year", interval: 3 },
];
const PMP_STATUS_LABELS = {
  on_time: "Conforme",
  late: "Fora da janela",
  missed: "Atrasada",
  scheduled: "Planejada",
  cancelled: "Cancelada",
  empty: "Não prevista",
};
const PMP_STATUS_FILTER_MAP = {
  conforme: "on_time",
  planejada: "scheduled",
  atrasada: "missed",
  fora_janela: "late",
  cancelada: "cancelled",
};
const PMP_TIPOS = [
  { value: "preventiva", label: "Preventiva", short: "PREV" },
  { value: "corretiva", label: "Corretiva", short: "COR" },
  { value: "preditiva", label: "Preditiva", short: "PRED" },
  { value: "inspecao", label: "Inspeção", short: "INSP" },
  { value: "outra", label: "Outra", short: "OUT" },
];
const SECTION_LABELS = {
  inicio: "Início",
  programacao: "Programação",
  nova: "Nova manutenção",
  modelos: "Modelos e recorrências",
  pmp: "PMP / Cronograma",
  execucao: "Execução do dia",
  backlog: "Backlog",
  projetos: "Gerenciar projeto",
  desempenho: "Desempenho",
  "performance-projects": "Desempenho por projeto",
  "performance-people": "Desempenho por colaborador",
  tendencias: "KPIs e tendências",
  relatorios: "Relatórios",
  feedbacks: "Feedbacks",
  perfil: "Meu perfil",
  acessos: "Gestão de Acessos",
  almoxarifado: "Almoxarifado",
  "almoxarifado-itens": "Itens",
  "almoxarifado-estoque": "Estoque por projeto",
  "almoxarifado-movimentacoes": "Movimentações",
  "almoxarifado-epis": "EPIs por colaborador",
  sst: "Segurança do Trabalho (SST)",
  "sst-treinamentos": "Treinamentos",
  "sst-inspecoes": "Inspeções",
  "sst-ncs": "Não conformidades",
  "sst-incidentes": "Incidentes",
  "sst-apr-pt": "Documentações",
};
const ADMIN_SECTIONS = ["rastreabilidade", "gerencial", "contas", "acessos"];
const DEFAULT_SECTIONS = Object.keys(SECTION_LABELS).reduce((acc, key) => {
  acc[key] = true;
  return acc;
}, {});
const DASHBOARD_CLIENT_TTL_MS = 30 * 1000;
const ANNOUNCEMENTS_TTL_MS = 20 * 1000;

const STATUS_LABELS = {
  agendada: "Agendada",
  liberada: "Liberada",
  backlog: "Backlog",
  em_execucao: "Em execução",
  encerramento: "Encerramento",
  concluida: "Concluída",
};

const PERMISSIONS = {
  create: "Criar",
  edit: "Editar",
  remove: "Remover",
  reschedule: "Reagendar",
  complete: "Executar",
};

const ACCESS_SECTION_PERMISSIONS = [
  "inicio",
  "programacao",
  "nova",
  "modelos",
  "execucao",
  "backlog",
  "feedbacks",
  "perfil",
];

const ACCESS_PERMISSION_ALIASES = {
  "programação": "programacao",
  "execução": "execucao",
};

const MAINTENANCE_ACCESS_PERMISSIONS = [
  "MAINT_CREATE",
  "MAINT_EDIT",
  "MAINT_REMOVE",
  "MAINT_RESCHEDULE",
  "MAINT_COMPLETE",
];

const ACCESS_PERMISSIONS = [
  "USER_READ",
  "USER_WRITE",
  "ROLE_READ",
  "ROLE_WRITE",
  "SST_READ",
  "SST_WRITE",
  "ALMOX_READ",
  "ALMOX_WRITE",
  "PROJECT_READ",
  "PROJECT_WRITE",
  "REPORTS_READ",
  "KPIS_READ",
  "ADMIN",
  ...MAINTENANCE_ACCESS_PERMISSIONS,
  ...ACCESS_SECTION_PERMISSIONS,
  "editarPerfil",
  "editarPerfilOutros",
  "verUsuarios",
  "convidarUsuarios",
  "desativarUsuarios",
  "verArquivos",
  "uploadArquivos",
  "excluirArquivos",
  "vincularArquivo",
  "verRDOs",
  "gerarRDOs",
  "excluirRDOs",
  "verRelatorios",
  "exportarRelatorios",
  "reexecutarTarefas",
  "verLogsAPI",
  "limparLogsAPI",
  "verAnuncios",
  "criarAnuncios",
  "receberEmailNovaManutencao",
  "gerenciarAutomacoes",
  "verAutomacoes",
  "verDiagnostico",
  "verPainelGerencial",
  "gerenciarAcessos",
  "verProjetos",
  "gerenciarProjetos",
  "gerenciarEquipamentos",
  "gerenciarEquipeProjeto",
  "gerenciarPMP",
  "verAlmoxarifado",
  "gerenciarAlmoxarifado",
  "verSST",
  "gerenciarSST",
];

const ACCESS_PERMISSION_LABELS = {
  USER_READ: "Visualizar usuarios",
  USER_WRITE: "Gerenciar usuarios",
  ROLE_READ: "Visualizar cargos",
  ROLE_WRITE: "Gerenciar cargos",
  SST_READ: "SST - leitura",
  SST_WRITE: "SST - escrita",
  ALMOX_READ: "Almoxarifado - leitura",
  ALMOX_WRITE: "Almoxarifado - escrita",
  PROJECT_READ: "Projetos - leitura",
  PROJECT_WRITE: "Projetos - escrita",
  REPORTS_READ: "Relatorios - leitura",
  KPIS_READ: "KPIs - leitura",
  ADMIN: "Administrador total",
  MAINT_CREATE: "Manutenção - criar",
  MAINT_EDIT: "Manutenção - editar",
  MAINT_REMOVE: "Manutenção - excluir",
  MAINT_RESCHEDULE: "Manutenção - reagendar",
  MAINT_COMPLETE: "Manutenção - executar",
  verAnuncios: "Ver anúncios",
  criarAnuncios: "Criar anúncios",
  receberEmailNovaManutencao: "Receber e-mail de nova manutenção",
};

const ACCESS_PERMISSION_GROUPS = [
  {
    key: "admin",
    label: "Administração",
    items: ["ADMIN", "gerenciarAcessos", "editarPerfil", "editarPerfilOutros"],
  },
  {
    key: "visibilidade",
    label: "Visibilidade (navegação)",
    items: ACCESS_SECTION_PERMISSIONS.slice(),
  },
  {
    key: "manutencao",
    label: "Manutenção (ações)",
    items: MAINTENANCE_ACCESS_PERMISSIONS.slice(),
  },
  {
    key: "usuarios",
    label: "Contas e equipe",
    items: ["verUsuarios", "convidarUsuarios", "desativarUsuarios"],
  },
  {
    key: "projetos",
    label: "Projetos",
    items: ["verProjetos", "gerenciarProjetos", "gerenciarEquipamentos", "gerenciarEquipeProjeto"],
  },
  {
    key: "pmp",
    label: "PMP / Cronograma",
    items: ["gerenciarPMP"],
  },
  {
    key: "sst",
    label: "Segurança do Trabalho (SST)",
    items: ["verSST", "gerenciarSST"],
  },
  {
    key: "almox",
    label: "Almoxarifado",
    items: ["verAlmoxarifado", "gerenciarAlmoxarifado"],
  },
  {
    key: "arquivos",
    label: "Arquivos",
    items: ["verArquivos", "uploadArquivos", "excluirArquivos", "vincularArquivo"],
  },
  {
    key: "rdo",
    label: "RDOs",
    items: ["verRDOs", "gerarRDOs", "excluirRDOs"],
  },
  {
    key: "relatorios",
    label: "Relatórios & KPIs",
    items: ["verRelatorios", "exportarRelatorios"],
  },
  {
    key: "comunicacao",
    label: "Comunicação",
    items: ["verAnuncios", "criarAnuncios", "receberEmailNovaManutencao"],
  },
  {
    key: "automacoes",
    label: "Automações",
    items: ["verAutomacoes", "gerenciarAutomacoes"],
  },
  {
    key: "diagnostico",
    label: "Diagnóstico",
    items: ["verDiagnostico", "reexecutarTarefas"],
  },
  {
    key: "logs",
    label: "Logs & Rastreabilidade",
    items: ["verLogsAPI", "limparLogsAPI"],
  },
  {
    key: "gerencial",
    label: "Painel gerencial",
    items: ["verPainelGerencial"],
  },
];

const GRANULAR_PERMISSION_LABELS = {
  editarPerfil: "Editar perfil (UEN/Projeto)",
  editarPerfilOutros: "Editar perfil de outros",
  verUsuarios: "Ver usuários",
  convidarUsuarios: "Convidar usuários",
  desativarUsuarios: "Desativar usuários",
  verArquivos: "Ver arquivos",
  uploadArquivos: "Enviar arquivos",
  excluirArquivos: "Excluir arquivos",
  vincularArquivo: "Vincular arquivo",
  verRDOs: "Ver RDOs",
  gerarRDOs: "Gerar RDOs",
  excluirRDOs: "Excluir RDOs",
  verRelatorios: "Ver relatórios",
  exportarRelatorios: "Exportar relatórios",
  reexecutarTarefas: "Reexecutar tarefas",
  verLogsAPI: "Ver logs de API",
  limparLogsAPI: "Limpar logs de API",
  gerenciarAutomacoes: "Gerenciar automações",
  verAutomacoes: "Ver automações",
  verDiagnostico: "Ver diagnóstico",
  verPainelGerencial: "Ver painel gerencial",
  gerenciarAcessos: "Gerenciar acessos",
  verProjetos: "Ver projetos",
  gerenciarProjetos: "Gerenciar projetos",
  gerenciarEquipamentos: "Gerenciar equipamentos",
  gerenciarEquipeProjeto: "Gerenciar equipe do projeto",
  gerenciarPMP: "Gerenciar PMP/Cronograma",
  verAlmoxarifado: "Ver Almoxarifado",
  gerenciarAlmoxarifado: "Gerenciar Almoxarifado",
  verSST: "Ver SST",
  gerenciarSST: "Gerenciar SST",
  verAnuncios: "Ver anúncios",
  criarAnuncios: "Criar anúncios",
};

const ACCESS_PERMISSION_CATALOG = [
  {
    key: "ADMIN",
    module: "Administracao",
    group: "Admin total",
    label: "Admin total",
    description: "Acesso total ao sistema.",
    level: "ADMIN",
    dangerous: true,
    hidden: true,
  },
  {
    key: "gerenciarAcessos",
    module: "Administracao",
    group: "Acesso",
    label: "Gerenciar acessos",
    description: "Criar e editar cargos e permissoes.",
    level: "ADMIN",
    dangerous: true,
  },
  {
    key: "editarPerfil",
    module: "Administracao",
    group: "Perfis",
    label: "Editar perfil (UEN/Projeto)",
    description: "Editar UEN e projeto do proprio perfil.",
    level: "WRITE",
  },
  {
    key: "editarPerfilOutros",
    module: "Administracao",
    group: "Perfis",
    label: "Editar perfil de outros",
    description: "Alterar dados de outros colaboradores.",
    level: "ADMIN",
    dangerous: true,
  },
  {
    key: "verUsuarios",
    module: "Contas e equipe",
    group: "Acesso",
    label: "Ver usuarios",
    description: "Visualizar lista de usuarios.",
    level: "READ",
  },
  {
    key: "convidarUsuarios",
    module: "Contas e equipe",
    group: "Acoes",
    label: "Criar contas",
    description: "Criar ou convidar usuarios.",
    level: "WRITE",
  },
  {
    key: "desativarUsuarios",
    module: "Contas e equipe",
    group: "Acoes",
    label: "Desativar usuarios",
    description: "Ativar ou inativar contas.",
    level: "ADMIN",
    dangerous: true,
  },
  {
    key: "ROLE_READ",
    module: "Cargos",
    group: "Acesso",
    label: "Visualizar cargos",
    description: "Acesso de leitura aos cargos.",
    level: "READ",
  },
  {
    key: "ROLE_WRITE",
    module: "Cargos",
    group: "Acoes",
    label: "Gerenciar cargos",
    description: "Criar, editar e remover cargos.",
    level: "ADMIN",
    dangerous: true,
  },
  {
    key: "inicio",
    module: "Navegacao",
    group: "Secoes",
    label: "Inicio",
    description: "Acesso ao painel inicial.",
    level: "READ",
  },
  {
    key: "programacao",
    module: "Navegacao",
    group: "Secoes",
    label: "Programacao",
    description: "Acesso a programacao.",
    level: "READ",
  },
  {
    key: "nova",
    module: "Navegacao",
    group: "Secoes",
    label: "Nova manutenção",
    description: "Acesso ao formulário de manutenção.",
    level: "READ",
  },
  {
    key: "modelos",
    module: "Navegacao",
    group: "Secoes",
    label: "Modelos e recorrências",
    description: "Acesso a modelos e recorrências.",
    level: "READ",
  },
  {
    key: "execucao",
    module: "Navegacao",
    group: "Secoes",
    label: "Execução do dia",
    description: "Acesso ao painel de execução.",
    level: "READ",
  },
  {
    key: "backlog",
    module: "Navegacao",
    group: "Secoes",
    label: "Backlog",
    description: "Acesso a manutenções em backlog.",
    level: "READ",
  },
  {
    key: "feedbacks",
    module: "Navegacao",
    group: "Secoes",
    label: "Feedbacks",
    description: "Acesso a feedbacks e comunicados.",
    level: "READ",
  },
  {
    key: "verAnuncios",
    module: "Comunicação",
    group: "Anúncios",
    label: "Ver anúncios",
    description: "Visualizar anúncios enviados para a equipe.",
    level: "READ",
  },
  {
    key: "criarAnuncios",
    module: "Comunicação",
    group: "Anúncios",
    label: "Criar anúncios",
    description: "Criar e enviar anúncios para equipes e projetos.",
    level: "WRITE",
  },
  {
    key: "receberEmailNovaManutencao",
    module: "Comunicação",
    group: "Notificações",
    label: "Receber e-mail de nova manutenção",
    description: "Receber avisos por e-mail quando novas manutenções forem criadas.",
    level: "READ",
  },
  {
    key: "perfil",
    module: "Navegacao",
    group: "Secoes",
    label: "Meu perfil",
    description: "Acesso a tela de perfil.",
    level: "READ",
  },
  {
    key: "MAINT_CREATE",
    module: "Manutencao",
    group: "Acoes",
    label: "Manutenção - criar",
    description: "Criar novas manutenções.",
    level: "WRITE",
  },
  {
    key: "MAINT_EDIT",
    module: "Manutencao",
    group: "Acoes",
    label: "Manutencao - editar",
    description: "Editar manutencoes existentes.",
    level: "WRITE",
  },
  {
    key: "MAINT_REMOVE",
    module: "Manutencao",
    group: "Acoes",
    label: "Manutencao - excluir",
    description: "Excluir manutencoes do sistema.",
    level: "ADMIN",
    dangerous: true,
  },
  {
    key: "MAINT_RESCHEDULE",
    module: "Manutencao",
    group: "Acoes",
    label: "Manutencao - reagendar",
    description: "Reagendar manutencoes.",
    level: "WRITE",
  },
  {
    key: "MAINT_COMPLETE",
    module: "Manutencao",
    group: "Acoes",
    label: "Manutencao - executar",
    description: "Registrar execucao e conclusao.",
    level: "WRITE",
  },
  {
    key: "verProjetos",
    module: "Projetos",
    group: "Acesso",
    label: "Ver projetos",
    description: "Visualizar projetos e dados associados.",
    level: "READ",
  },
  {
    key: "gerenciarProjetos",
    module: "Projetos",
    group: "Acoes",
    label: "Gerenciar projetos",
    description: "Criar e editar projetos.",
    level: "WRITE",
  },
  {
    key: "gerenciarEquipamentos",
    module: "Projetos",
    group: "Acoes",
    label: "Gerenciar equipamentos",
    description: "Cadastrar e ajustar equipamentos.",
    level: "WRITE",
  },
  {
    key: "gerenciarEquipeProjeto",
    module: "Projetos",
    group: "Acoes",
    label: "Gerenciar equipe do projeto",
    description: "Adicionar ou remover membros do projeto.",
    level: "WRITE",
  },
  {
    key: "gerenciarPMP",
    module: "PMP / Cronograma",
    group: "Acoes",
    label: "Gerenciar PMP/Cronograma",
    description: "Editar planos e cronogramas de manutencao.",
    level: "WRITE",
  },
  {
    key: "verSST",
    module: "SST",
    group: "Acesso",
    label: "Ver SST",
    description: "Visualizar modulo de SST.",
    level: "READ",
  },
  {
    key: "gerenciarSST",
    module: "SST",
    group: "Acoes",
    label: "Gerenciar SST",
    description: "Criar e editar dados de SST.",
    level: "WRITE",
  },
  {
    key: "verAlmoxarifado",
    module: "Almoxarifado",
    group: "Acesso",
    label: "Ver almoxarifado",
    description: "Visualizar itens e estoque.",
    level: "READ",
  },
  {
    key: "gerenciarAlmoxarifado",
    module: "Almoxarifado",
    group: "Acoes",
    label: "Gerenciar almoxarifado",
    description: "Criar e editar registros do almoxarifado.",
    level: "WRITE",
  },
  {
    key: "verArquivos",
    module: "Arquivos",
    group: "Acesso",
    label: "Ver arquivos",
    description: "Visualizar arquivos enviados.",
    level: "READ",
  },
  {
    key: "uploadArquivos",
    module: "Arquivos",
    group: "Acoes",
    label: "Enviar arquivos",
    description: "Enviar arquivos para o sistema.",
    level: "WRITE",
  },
  {
    key: "excluirArquivos",
    module: "Arquivos",
    group: "Acoes",
    label: "Excluir arquivos",
    description: "Remover arquivos do sistema.",
    level: "ADMIN",
    dangerous: true,
  },
  {
    key: "vincularArquivo",
    module: "Arquivos",
    group: "Acoes",
    label: "Vincular arquivo",
    description: "Relacionar arquivos a registros.",
    level: "WRITE",
  },
  {
    key: "verRDOs",
    module: "RDOs",
    group: "Acesso",
    label: "Ver RDOs",
    description: "Visualizar RDOs existentes.",
    level: "READ",
  },
  {
    key: "gerarRDOs",
    module: "RDOs",
    group: "Acoes",
    label: "Gerar RDOs",
    description: "Gerar novos RDOs.",
    level: "WRITE",
  },
  {
    key: "excluirRDOs",
    module: "RDOs",
    group: "Acoes",
    label: "Excluir RDOs",
    description: "Remover RDOs do sistema.",
    level: "ADMIN",
    dangerous: true,
  },
  {
    key: "verRelatorios",
    module: "Relatorios & KPIs",
    group: "Acesso",
    label: "Ver relatorios",
    description: "Visualizar relatorios e indicadores.",
    level: "READ",
  },
  {
    key: "exportarRelatorios",
    module: "Relatorios & KPIs",
    group: "Acoes",
    label: "Exportar relatorios",
    description: "Exportar relatorios e indicadores.",
    level: "WRITE",
  },
  {
    key: "verAutomacoes",
    module: "Automacoes",
    group: "Acesso",
    label: "Ver automacoes",
    description: "Visualizar automacoes configuradas.",
    level: "READ",
  },
  {
    key: "gerenciarAutomacoes",
    module: "Automacoes",
    group: "Acoes",
    label: "Gerenciar automacoes",
    description: "Criar e ajustar automacoes.",
    level: "ADMIN",
  },
  {
    key: "verDiagnostico",
    module: "Diagnostico",
    group: "Acesso",
    label: "Ver diagnostico",
    description: "Visualizar status do sistema.",
    level: "READ",
  },
  {
    key: "reexecutarTarefas",
    module: "Diagnostico",
    group: "Acoes",
    label: "Reexecutar tarefas",
    description: "Executar tarefas de diagnostico.",
    level: "ADMIN",
    dangerous: true,
  },
  {
    key: "verLogsAPI",
    module: "Logs & Rastreabilidade",
    group: "Acesso",
    label: "Ver logs de API",
    description: "Visualizar registros de integracao.",
    level: "READ",
  },
  {
    key: "limparLogsAPI",
    module: "Logs & Rastreabilidade",
    group: "Acoes",
    label: "Limpar logs de API",
    description: "Remover registros de log.",
    level: "ADMIN",
    dangerous: true,
  },
  {
    key: "verPainelGerencial",
    module: "Painel gerencial",
    group: "Acesso",
    label: "Ver painel gerencial",
    description: "Acesso ao painel gerencial.",
    level: "READ",
  },
  {
    key: "USER_READ",
    module: "Contas e equipe",
    group: "Compatibilidade (legado)",
    label: "Visualizar usuarios (legado)",
    description: "Permissao antiga de leitura de usuarios.",
    level: "READ",
    legacy: true,
  },
  {
    key: "USER_WRITE",
    module: "Contas e equipe",
    group: "Compatibilidade (legado)",
    label: "Gerenciar usuarios (legado)",
    description: "Permissao antiga de escrita de usuarios.",
    level: "ADMIN",
    dangerous: true,
    legacy: true,
  },
  {
    key: "PROJECT_READ",
    module: "Projetos",
    group: "Compatibilidade (legado)",
    label: "Projetos - leitura (legado)",
    description: "Permissao antiga de leitura de projetos.",
    level: "READ",
    legacy: true,
  },
  {
    key: "PROJECT_WRITE",
    module: "Projetos",
    group: "Compatibilidade (legado)",
    label: "Projetos - escrita (legado)",
    description: "Permissao antiga de escrita de projetos.",
    level: "WRITE",
    legacy: true,
  },
  {
    key: "SST_READ",
    module: "SST",
    group: "Compatibilidade (legado)",
    label: "SST - leitura (legado)",
    description: "Permissao antiga de leitura de SST.",
    level: "READ",
    legacy: true,
  },
  {
    key: "SST_WRITE",
    module: "SST",
    group: "Compatibilidade (legado)",
    label: "SST - escrita (legado)",
    description: "Permissao antiga de escrita de SST.",
    level: "WRITE",
    legacy: true,
  },
  {
    key: "ALMOX_READ",
    module: "Almoxarifado",
    group: "Compatibilidade (legado)",
    label: "Almoxarifado - leitura (legado)",
    description: "Permissao antiga de leitura de almoxarifado.",
    level: "READ",
    legacy: true,
  },
  {
    key: "ALMOX_WRITE",
    module: "Almoxarifado",
    group: "Compatibilidade (legado)",
    label: "Almoxarifado - escrita (legado)",
    description: "Permissao antiga de escrita de almoxarifado.",
    level: "WRITE",
    legacy: true,
  },
  {
    key: "REPORTS_READ",
    module: "Relatorios & KPIs",
    group: "Compatibilidade (legado)",
    label: "Relatorios - leitura (legado)",
    description: "Permissao antiga de leitura de relatorios.",
    level: "READ",
    legacy: true,
  },
  {
    key: "KPIS_READ",
    module: "Relatorios & KPIs",
    group: "Compatibilidade (legado)",
    label: "KPIs - leitura (legado)",
    description: "Permissao antiga de leitura de KPIs.",
    level: "READ",
    legacy: true,
  },
];

const ACCESS_PERMISSION_MODULE_ORDER = [
  "Administracao",
  "Navegacao",
  "Manutencao",
  "Contas e equipe",
  "Cargos",
  "Projetos",
  "PMP / Cronograma",
  "SST",
  "Almoxarifado",
  "Arquivos",
  "RDOs",
  "Relatorios & KPIs",
  "Comunicação",
  "Automacoes",
  "Diagnostico",
  "Logs & Rastreabilidade",
  "Painel gerencial",
];

const ACCESS_PERMISSION_INDEX = new Map(
  ACCESS_PERMISSION_CATALOG.map((permission) => [permission.key, permission])
);

const ACCESS_PERMISSION_VISIBLE = ACCESS_PERMISSION_CATALOG.filter((permission) => !permission.hidden);

const ACCESS_PERMISSION_MODULES = buildAccessPermissionModules(ACCESS_PERMISSION_VISIBLE);

const ACCESS_PERMISSION_KEYS_ALL = getAccessPermissionKeys(ACCESS_PERMISSION_CATALOG, {
  includeHidden: true,
  includeAdmin: true,
});

const ACCESS_PERMISSION_KEYS_VISIBLE = getAccessPermissionKeys(ACCESS_PERMISSION_CATALOG, {
  includeHidden: false,
  includeAdmin: false,
});

const ACCESS_PERMISSION_DANGEROUS = new Set(
  ACCESS_PERMISSION_CATALOG.filter((permission) => permission.dangerous).map(
    (permission) => permission.key
  )
);

const ACCESS_ROLE_ADMIN_KEYS = ["ADMIN", "ADMIN_TOTAL"];
const ACCESS_ROLE_LEVEL_PREFIX = "LEVEL:";

function buildAccessRoleLevelKey(itemKey) {
  return `${ACCESS_ROLE_LEVEL_PREFIX}${itemKey}`;
}

function isAccessRoleLevelKey(key) {
  return typeof key === "string" && key.startsWith(ACCESS_ROLE_LEVEL_PREFIX);
}

function getAccessRoleLevelItemKey(key) {
  return isAccessRoleLevelKey(key) ? key.slice(ACCESS_ROLE_LEVEL_PREFIX.length) : "";
}

const ACCESS_ROLE_ITEMS = [
  {
    key: "admin_acessos",
    module: "Administracao",
    label: "Gerenciar acessos",
    description: "Criar e editar cargos e permissoes.",
    dangerous: true,
    viewKeys: ["verPainelGerencial"],
    editKeys: ["gerenciarAcessos"],
  },
  {
    key: "admin_perfil",
    module: "Administracao",
    label: "Editar perfil (UEN/Projeto)",
    description: "Editar UEN e projeto do proprio perfil.",
    viewKeys: ["perfil"],
    editKeys: ["editarPerfil"],
  },
  {
    key: "admin_perfil_outros",
    module: "Administracao",
    label: "Editar perfil de outros",
    description: "Alterar dados de outros colaboradores.",
    dangerous: true,
    viewKeys: ["verUsuarios"],
    editKeys: ["editarPerfilOutros"],
  },
  {
    key: "cargos",
    module: "Cargos",
    label: "Cargos",
    description: "Visualizar e gerenciar cargos.",
    dangerous: true,
    viewKeys: ["ROLE_READ"],
    editKeys: ["ROLE_WRITE"],
  },
  {
    key: "usuarios",
    module: "Contas e equipe",
    label: "Usuarios",
    description: "Visualizar e gerenciar contas de colaboradores.",
    dangerous: true,
    viewKeys: ["verUsuarios", "USER_READ"],
    editKeys: ["convidarUsuarios", "desativarUsuarios", "USER_WRITE"],
  },
  {
    key: "nav_inicio",
    module: "Navegacao",
    label: "Inicio",
    description: "Acesso ao painel inicial.",
    viewKeys: ["inicio"],
    editKeys: [],
  },
  {
    key: "nav_programacao",
    module: "Navegacao",
    label: "Programacao",
    description: "Acesso a programacao.",
    viewKeys: ["programacao"],
    editKeys: [],
  },
  {
    key: "nav_nova",
    module: "Navegacao",
    label: "Nova manutencao",
    description: "Acesso ao formulario de manutencao.",
    viewKeys: ["nova"],
    editKeys: [],
  },
  {
    key: "nav_modelos",
    module: "Navegacao",
    label: "Modelos e recorrencias",
    description: "Acesso a modelos e recorrencias.",
    viewKeys: ["modelos"],
    editKeys: [],
  },
  {
    key: "nav_execucao",
    module: "Navegacao",
    label: "Execucao do dia",
    description: "Acesso ao painel de execucao.",
    viewKeys: ["execucao"],
    editKeys: [],
  },
  {
    key: "nav_backlog",
    module: "Navegacao",
    label: "Backlog",
    description: "Acesso a manutencoes em backlog.",
    viewKeys: ["backlog"],
    editKeys: [],
  },
  {
    key: "nav_feedbacks",
    module: "Navegacao",
    label: "Feedbacks",
    description: "Acesso a feedbacks e comunicados.",
    viewKeys: ["feedbacks"],
    editKeys: [],
  },
  {
    key: "nav_perfil",
    module: "Navegacao",
    label: "Meu perfil",
    description: "Acesso a tela de perfil.",
    viewKeys: ["perfil"],
    editKeys: [],
  },
  {
    key: "comunicacao_anuncios",
    module: "Comunicação",
    label: "Anúncios",
    description: "Visualizar e enviar anúncios.",
    viewKeys: ["verAnuncios"],
    editKeys: ["criarAnuncios"],
  },
  {
    key: "comunicacao_email_manutencao",
    module: "Comunicação",
    label: "E-mail de nova manutenção",
    description: "Receber e-mail quando uma nova manutenção for criada no projeto.",
    viewKeys: ["receberEmailNovaManutencao"],
    editKeys: [],
  },
  {
    key: "manut_criar",
    module: "Manutencao",
    label: "Criar manutencoes",
    description: "Criar novas manutencoes.",
    viewKeys: ["nova"],
    editKeys: ["MAINT_CREATE"],
  },
  {
    key: "manut_editar",
    module: "Manutencao",
    label: "Editar manutencoes",
    description: "Editar manutencoes existentes.",
    viewKeys: ["programacao"],
    editKeys: ["MAINT_EDIT"],
  },
  {
    key: "manut_reagendar",
    module: "Manutencao",
    label: "Reagendar manutencoes",
    description: "Reagendar manutencoes.",
    viewKeys: ["programacao"],
    editKeys: ["MAINT_RESCHEDULE"],
  },
  {
    key: "manut_executar",
    module: "Manutencao",
    label: "Executar manutencoes",
    description: "Registrar execucao e conclusao.",
    viewKeys: ["execucao"],
    editKeys: ["MAINT_COMPLETE"],
  },
  {
    key: "manut_excluir",
    module: "Manutencao",
    label: "Excluir manutencoes",
    description: "Excluir manutencoes do sistema.",
    dangerous: true,
    viewKeys: ["backlog"],
    editKeys: ["MAINT_REMOVE"],
  },
  {
    key: "projetos",
    module: "Projetos",
    label: "Projetos",
    description: "Visualizar e gerenciar projetos, equipes e equipamentos.",
    viewKeys: ["verProjetos", "PROJECT_READ"],
    editKeys: [
      "gerenciarProjetos",
      "gerenciarEquipamentos",
      "gerenciarEquipeProjeto",
      "PROJECT_WRITE",
    ],
  },
  {
    key: "pmp",
    module: "PMP / Cronograma",
    label: "PMP / Cronograma",
    description: "Editar planos e cronogramas de manutencao.",
    viewKeys: ["gerenciarPMP"],
    editKeys: [],
  },
  {
    key: "sst",
    module: "SST",
    label: "SST",
    description: "Visualizar e gerenciar dados de SST.",
    viewKeys: ["verSST", "SST_READ"],
    editKeys: ["gerenciarSST", "SST_WRITE"],
  },
  {
    key: "almox",
    module: "Almoxarifado",
    label: "Almoxarifado",
    description: "Visualizar e gerenciar itens e estoque.",
    viewKeys: ["verAlmoxarifado", "ALMOX_READ"],
    editKeys: ["gerenciarAlmoxarifado", "ALMOX_WRITE"],
  },
  {
    key: "arquivos",
    module: "Arquivos",
    label: "Arquivos",
    description: "Visualizar e gerenciar arquivos.",
    dangerous: true,
    viewKeys: ["verArquivos"],
    editKeys: ["uploadArquivos", "vincularArquivo", "excluirArquivos"],
  },
  {
    key: "rdos",
    module: "RDOs",
    label: "RDOs",
    description: "Visualizar e gerenciar RDOs.",
    dangerous: true,
    viewKeys: ["verRDOs"],
    editKeys: ["gerarRDOs", "excluirRDOs"],
  },
  {
    key: "relatorios",
    module: "Relatorios & KPIs",
    label: "Relatorios & KPIs",
    description: "Visualizar e exportar relatorios e indicadores.",
    viewKeys: ["verRelatorios", "REPORTS_READ", "KPIS_READ"],
    editKeys: ["exportarRelatorios"],
  },
  {
    key: "automacoes",
    module: "Automacoes",
    label: "Automacoes",
    description: "Visualizar e gerenciar automacoes.",
    viewKeys: ["verAutomacoes"],
    editKeys: ["gerenciarAutomacoes"],
  },
  {
    key: "diagnostico",
    module: "Diagnostico",
    label: "Diagnostico",
    description: "Visualizar diagnostico e reexecutar tarefas.",
    dangerous: true,
    viewKeys: ["verDiagnostico"],
    editKeys: ["reexecutarTarefas"],
  },
  {
    key: "logs",
    module: "Logs & Rastreabilidade",
    label: "Logs & Rastreabilidade",
    description: "Visualizar e limpar logs de API.",
    dangerous: true,
    viewKeys: ["verLogsAPI"],
    editKeys: ["limparLogsAPI"],
  },
  {
    key: "gerencial",
    module: "Painel gerencial",
    label: "Painel gerencial",
    description: "Acesso ao painel gerencial.",
    viewKeys: ["verPainelGerencial"],
    editKeys: [],
  },
];

ACCESS_ROLE_ITEMS.forEach((item) => {
  item.viewKeys = Array.from(new Set(item.viewKeys || []));
  item.editKeys = Array.from(new Set(item.editKeys || []));
  item.dangerous = Boolean(item.dangerous);
});

const ACCESS_ROLE_ITEM_INDEX = new Map(ACCESS_ROLE_ITEMS.map((item) => [item.key, item]));

const ACCESS_ROLE_VIEWONLY_KEYS = new Set(
  ACCESS_ROLE_ITEMS.filter((item) => !item.editKeys || item.editKeys.length === 0).map(
    (item) => item.key
  )
);

const ACCESS_ROLE_MODULES = buildAccessRoleModules(ACCESS_ROLE_ITEMS);

const ACCESS_ROLE_KNOWN_KEYS = new Set(
  ACCESS_ROLE_ITEMS.flatMap((item) => [...item.viewKeys, ...item.editKeys])
);
ACCESS_ROLE_ADMIN_KEYS.forEach((key) => ACCESS_ROLE_KNOWN_KEYS.add(key));

const ACCESS_MODULE_LABELS = {
  Administracao: "Administra\u00e7\u00e3o",
  Navegacao: "Navega\u00e7\u00e3o",
  Manutencao: "Manuten\u00e7\u00e3o",
  "Contas e equipe": "Contas e equipe",
  Cargos: "Cargos",
  Projetos: "Projetos",
  "PMP / Cronograma": "PMP / Cronograma",
  SST: "SST",
  Almoxarifado: "Almoxarifado",
  Arquivos: "Arquivos",
  RDOs: "RDOs",
  "Relatorios & KPIs": "Relat\u00f3rios & KPIs",
  Automacoes: "Automa\u00e7\u00f5es",
  Diagnostico: "Diagn\u00f3stico",
  "Logs & Rastreabilidade": "Logs & Rastreabilidade",
  "Painel gerencial": "Painel gerencial",
};

const ACCESS_GROUP_LABELS = {
  Acesso: "Acesso",
  Perfis: "Perfis",
  Secoes: "Se\u00e7\u00f5es",
  Acoes: "A\u00e7\u00f5es",
  "Compatibilidade (legado)": "Compatibilidade (legado)",
  "Admin total": "Admin total",
};

const ACCESS_LEVEL_LABELS = {
  READ: "Leitura",
  WRITE: "Edi\u00e7\u00e3o",
  ADMIN: "Admin",
};

const ACCESS_TEXT_REPLACEMENTS = [
  ["Administracao", "Administra\u00e7\u00e3o"],
  ["administracao", "administra\u00e7\u00e3o"],
  ["Navegacao", "Navega\u00e7\u00e3o"],
  ["navegacao", "navega\u00e7\u00e3o"],
  ["Manutencao", "Manuten\u00e7\u00e3o"],
  ["manutencao", "manuten\u00e7\u00e3o"],
  ["manutencoes", "manuten\u00e7\u00f5es"],
  ["Programacao", "Programa\u00e7\u00e3o"],
  ["programacao", "programa\u00e7\u00e3o"],
  ["Execucao", "Execu\u00e7\u00e3o"],
  ["execucao", "execu\u00e7\u00e3o"],
  ["Permissoes", "Permiss\u00f5es"],
  ["permissoes", "permiss\u00f5es"],
  ["Secoes", "Se\u00e7\u00f5es"],
  ["secoes", "se\u00e7\u00f5es"],
  ["Acoes", "A\u00e7\u00f5es"],
  ["acoes", "a\u00e7\u00f5es"],
  ["Relatorios", "Relat\u00f3rios"],
  ["relatorios", "relat\u00f3rios"],
  ["Usuarios", "Usu\u00e1rios"],
  ["usuarios", "usu\u00e1rios"],
  ["Tecnico", "T\u00e9cnico"],
  ["tecnico", "t\u00e9cnico"],
  ["Automacoes", "Automa\u00e7\u00f5es"],
  ["automacoes", "automa\u00e7\u00f5es"],
  ["Diagnostico", "Diagn\u00f3stico"],
  ["diagnostico", "diagn\u00f3stico"],
  ["Recorrencias", "Recorr\u00eancias"],
  ["recorrencias", "recorr\u00eancias"],
  ["Formulario", "Formul\u00e1rio"],
  ["formulario", "formul\u00e1rio"],
  ["Conclusao", "Conclus\u00e3o"],
  ["conclusao", "conclus\u00e3o"],
  ["Integracao", "Integra\u00e7\u00e3o"],
  ["integracao", "integra\u00e7\u00e3o"],
  ["Proprio", "Pr\u00f3prio"],
  ["proprio", "pr\u00f3prio"],
  ["Nao", "N\u00e3o"],
  ["nao", "n\u00e3o"],
  ["Modulo", "M\u00f3dulo"],
  ["modulo", "m\u00f3dulo"],
  ["Critico", "Cr\u00edtico"],
  ["critico", "cr\u00edtico"],
];

function formatAccessText(text) {
  if (!text) {
    return "";
  }
  let result = text;
  ACCESS_TEXT_REPLACEMENTS.forEach(([from, to]) => {
    result = result.replaceAll(from, to);
  });
  return result;
}

function getAccessModuleLabel(name) {
  return ACCESS_MODULE_LABELS[name] || formatAccessText(name);
}

function getAccessGroupLabel(name) {
  return ACCESS_GROUP_LABELS[name] || formatAccessText(name);
}

function buildAccessPermissionModules(catalog = []) {
  const byModule = new Map();
  catalog.forEach((permission) => {
    const moduleName = permission.module || "Outros";
    if (!byModule.has(moduleName)) {
      byModule.set(moduleName, { name: moduleName, groups: {}, permissions: [] });
    }
    const entry = byModule.get(moduleName);
    entry.permissions.push(permission);
    const groupName = permission.group || "Geral";
    if (!entry.groups[groupName]) {
      entry.groups[groupName] = [];
    }
    entry.groups[groupName].push(permission);
  });
  const ordered = ACCESS_PERMISSION_MODULE_ORDER.filter((name) => byModule.has(name)).map((name) =>
    byModule.get(name)
  );
  const extras = Array.from(byModule.values()).filter(
    (module) => !ACCESS_PERMISSION_MODULE_ORDER.includes(module.name)
  );
  return [...ordered, ...extras];
}

function buildAccessRoleModules(items = []) {
  const byModule = new Map();
  items.forEach((item) => {
    const moduleName = item.module || "Outros";
    if (!byModule.has(moduleName)) {
      byModule.set(moduleName, { name: moduleName, items: [] });
    }
    byModule.get(moduleName).items.push(item);
  });
  const ordered = ACCESS_PERMISSION_MODULE_ORDER.filter((name) => byModule.has(name)).map((name) =>
    byModule.get(name)
  );
  const extras = Array.from(byModule.values()).filter(
    (module) => !ACCESS_PERMISSION_MODULE_ORDER.includes(module.name)
  );
  return [...ordered, ...extras];
}

function getAccessPermissionKeys(catalog = ACCESS_PERMISSION_CATALOG, options = {}) {
  const includeHidden = options.includeHidden ?? false;
  const includeAdmin = options.includeAdmin ?? true;
  return catalog
    .filter((permission) => {
      if (!includeHidden && permission.hidden && permission.key !== "ADMIN") {
        return false;
      }
      if (!includeAdmin && permission.key === "ADMIN") {
        return false;
      }
      return true;
    })
    .map((permission) => permission.key);
}

function getAccessReadPermissionKeys(catalog = ACCESS_PERMISSION_CATALOG, moduleName) {
  return catalog
    .filter((permission) => {
      if (permission.hidden) {
        return false;
      }
      if (permission.level !== "READ") {
        return false;
      }
      if (moduleName && permission.module !== moduleName) {
        return false;
      }
      return true;
    })
    .map((permission) => permission.key);
}

function getAccessWritePermissionKeys(catalog = ACCESS_PERMISSION_CATALOG, moduleName) {
  return catalog
    .filter((permission) => {
      if (permission.hidden) {
        return false;
      }
      if (permission.level !== "WRITE") {
        return false;
      }
      if (moduleName && permission.module !== moduleName) {
        return false;
      }
      return true;
    })
    .map((permission) => permission.key);
}

function getAccessReadWritePermissionKeys(catalog = ACCESS_PERMISSION_CATALOG, moduleName) {
  return catalog
    .filter((permission) => {
      if (permission.hidden) {
        return false;
      }
      if (permission.level !== "READ" && permission.level !== "WRITE") {
        return false;
      }
      if (moduleName && permission.module !== moduleName) {
        return false;
      }
      return true;
    })
    .map((permission) => permission.key);
}

function getAccessPermissionSearchText(permission) {
  return [
    permission.key,
    permission.label,
    permission.description,
    permission.group,
    permission.module,
  ]
    .filter(Boolean)
    .join(" ")
    .toLowerCase();
}

function getAccessRoleItemSearchText(item) {
  return [
    item.key,
    item.label,
    item.description,
    item.module,
    ...(item.viewKeys || []),
    ...(item.editKeys || []),
  ]
    .filter(Boolean)
    .join(" ")
    .toLowerCase();
}

const PERMISSION_GROUPS = [
  {
    key: "perfil",
    label: "Perfis e usuários",
    items: [
      "editarPerfil",
      "editarPerfilOutros",
      "verUsuarios",
      "convidarUsuarios",
      "desativarUsuarios",
      "gerenciarAcessos",
    ],
  },
  {
    key: "projetos",
    label: "Projetos corporativos",
    items: ["verProjetos", "gerenciarProjetos", "gerenciarEquipamentos", "gerenciarEquipeProjeto"],
  },
  {
    key: "pmp",
    label: "PMP / Cronograma",
    items: ["gerenciarPMP"],
  },
  {
    key: "almoxarifado",
    label: "Almoxarifado",
    items: ["verAlmoxarifado", "gerenciarAlmoxarifado"],
  },
  {
    key: "sst",
    label: "Segurança do Trabalho (SST)",
    items: ["verSST", "gerenciarSST"],
  },
  {
    key: "arquivos",
    label: "Arquivos",
    items: ["verArquivos", "uploadArquivos", "excluirArquivos", "vincularArquivo"],
  },
  {
    key: "rdo",
    label: "RDOs",
    items: ["verRDOs", "gerarRDOs", "excluirRDOs"],
  },
  {
    key: "relatorios",
    label: "Relatórios",
    items: ["verRelatorios", "exportarRelatorios"],
  },
  {
    key: "comunicacao",
    label: "Comunicação",
    items: ["verAnuncios", "criarAnuncios"],
  },
  {
    key: "diagnostico",
    label: "Diagnóstico",
    items: ["verDiagnostico", "reexecutarTarefas"],
  },
  {
    key: "logs",
    label: "Logs de API",
    items: ["verLogsAPI", "limparLogsAPI"],
  },
  {
    key: "automacoes",
    label: "Automações",
    items: ["verAutomacoes", "gerenciarAutomacoes"],
  },
  {
    key: "gerencial",
    label: "Painel gerencial",
    items: ["verPainelGerencial"],
  },
];
const GRANULAR_PROFILE_ORDER = [
  "admin",
  "gestor",
  "almoxarife",
  "tecnico_sst",
  "supervisor",
  "colaborador",
  "pcm",
  "diretor_om",
  "gerente_contrato",
  "supervisor_om",
  "tecnico_senior",
  "tecnico_pleno",
  "tecnico_junior",
  "leitura",
];

const ADMIN_USERS_READ = "admin:users:read";
const ADMIN_USERS_WRITE = "admin:users:write";

const RBAC_ROLE_LABELS = {
  admin: "ADMIN",
  gestor: "GESTOR",
  almoxarife: "ALMOXARIFE",
  tecnico_sst: "TÉCNICO SST",
  supervisor: "SUPERVISOR",
  colaborador: "COLABORADOR",
  pcm: "PCM",
  diretor_om: "DIRETOR O&M",
  gerente_contrato: "GERENTE DE CONTRATO",
  supervisor_om: "SUPERVISOR O&M",
  tecnico_senior: "T\u00c9CNICO S\u00caNIOR",
  tecnico_pleno: "T\u00c9CNICO PLENO",
  tecnico_junior: "T\u00c9CNICO J\u00daNIOR",
  leitura: "LEITURA",
};

const LEGACY_ROLE_LABELS = {
  admin: "ADMIN",
  supervisor: "SUPERVISOR",
  executor: "EXECUTOR",
  leitura: "LEITURA",
};

const FULL_ACCESS_RBAC = new Set(["admin", "gestor", "diretor_om", "gerente_contrato"]);
const RELEASE_OVERRIDE_RBAC = new Set([
  "admin",
  "gestor",
  "pcm",
  "diretor_om",
  "gerente_contrato",
  "supervisor_om",
]);
const MASTER_MATRICULA = "35269";
const MASTER_USERNAME = "denisson.alves";
const DEFAULT_PROJECT_LOCAIS = ["LZC-BOS2", "LZC-PCT4", "LZC-LT", "LZC-BSO2/LZC-PCT4"];
const DEFAULT_PROJECTS_SEED = [
  {
    id: "b2f1f2a6-7c1a-4a0d-9e0c-0f2e2c1c1a50",
    codigo: DEFAULT_PROJECT_CODE,
    nome: "PARACATU/SOLARIG (Boa Sorte II)",
    cliente: "",
    descricao: "",
    locais: DEFAULT_PROJECT_LOCAIS.slice(),
    createdAt: "2026-01-21T18:10:00.000Z",
    updatedAt: "2026-01-21T18:10:00.000Z",
  },
];
const PERFORMANCE_TABS = new Set(["performance-projects", "performance-people"]);
const TAB_PERMISSION_MAP = {
  desempenho: "verRelatorios",
  "performance-projects": "verRelatorios",
  "performance-people": "verRelatorios",
  tendencias: "verRelatorios",
  relatorios: ["verRelatorios", "verRDOs"],
  projetos: ["verProjetos", "gerenciarProjetos", "gerenciarEquipamentos", "gerenciarEquipeProjeto"],
  pmp: "gerenciarPMP",
  solicitacoes: "verUsuarios",
  contas: "verUsuarios",
  acessos: "gerenciarAcessos",
  gerencial: "verPainelGerencial",
  rastreabilidade: "verLogsAPI",
  almoxarifado: "verAlmoxarifado",
  "almoxarifado-itens": "verAlmoxarifado",
  "almoxarifado-estoque": "verAlmoxarifado",
  "almoxarifado-movimentacoes": "verAlmoxarifado",
  "almoxarifado-epis": "verAlmoxarifado",
  sst: "verSST",
  "sst-treinamentos": "verSST",
  "sst-inspecoes": "verSST",
  "sst-ncs": "verSST",
  "sst-incidentes": "verSST",
  "sst-apr-pt": "verSST",
};
const LOCK_ICON_SVG =
  '<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M7 10V7a5 5 0 0 1 10 0v3h1a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h1Zm2 0h6V7a3 3 0 0 0-6 0v3Z" fill="currentColor"/></svg>';

function getRoleLabel(user) {
  if (!user) {
    return "EXECUTOR";
  }
  if (user.roleName) {
    return String(user.roleName).trim() || "EXECUTOR";
  }
  const rbacRole = String(user.rbacRole || "").trim().toLowerCase();
  if (rbacRole && RBAC_ROLE_LABELS[rbacRole]) {
    return RBAC_ROLE_LABELS[rbacRole];
  }
  const legacyRole = String(user.role || "").trim().toLowerCase();
  if (legacyRole && LEGACY_ROLE_LABELS[legacyRole]) {
    return LEGACY_ROLE_LABELS[legacyRole];
  }
  return (user.role || user.rbacRole || "EXECUTOR").toString().toUpperCase();
}

function normalizeSearchValue(value) {
  return String(value || "")
    .trim()
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "");
}

function normalizeMatricula(value) {
  return normalizeSearchValue(value).replace(/\s+/g, "");
}

function normalizeEmail(value) {
  return String(value || "").trim().toLowerCase();
}

function normalizeRoleName(value) {
  return normalizeSearchValue(value).replace(/\s+/g, " ").trim();
}

function normalizeAccessPermissionKey(value) {
  const raw = String(value || "").trim();
  if (!raw) {
    return "";
  }
  const alias = ACCESS_PERMISSION_ALIASES[raw.toLowerCase()];
  return alias || raw;
}

function normalizeAccessPermissionList(list) {
  const source = Array.isArray(list)
    ? list
    : list && typeof list[Symbol.iterator] === "function"
      ? Array.from(list)
      : [];
  const allowed = new Map();
  const allowedLower = new Map();
  ACCESS_PERMISSIONS.forEach((perm) => {
    const key = String(perm || "").trim();
    if (!key) {
      return;
    }
    allowed.set(key, key);
    allowedLower.set(key.toLowerCase(), key);
  });
  const result = new Set();
  source.forEach((perm) => {
    const raw = normalizeAccessPermissionKey(perm);
    if (!raw) {
      return;
    }
    if (allowed.has(raw)) {
      result.add(allowed.get(raw));
      return;
    }
    const lower = raw.toLowerCase();
    if (allowedLower.has(lower)) {
      result.add(allowedLower.get(lower));
    }
  });
  return Array.from(result);
}

function applyMaintenancePermissionDependencies(list) {
  const normalized = normalizeAccessPermissionList(list);
  if (normalized.includes("MAINT_CREATE") && !normalized.includes("MAINT_COMPLETE")) {
    normalized.push("MAINT_COMPLETE");
  }
  return normalized;
}

function ensureSectionPermissions(list) {
  const normalized = Array.isArray(list) ? list.slice() : [];
  if (!normalized.length) {
    return normalized;
  }
  const hasSectionControl = ACCESS_SECTION_PERMISSIONS.some((key) => normalized.includes(key));
  if (!hasSectionControl) {
    return normalized.concat(ACCESS_SECTION_PERMISSIONS);
  }
  return normalized;
}

function normalizeAccessRoleKeys(list) {
  const source = Array.isArray(list)
    ? list
    : list && typeof list[Symbol.iterator] === "function"
      ? Array.from(list)
      : [];
  const allowed = new Map();
  const allowedLower = new Map();
  ACCESS_PERMISSIONS.forEach((perm) => {
    const key = String(perm || "").trim();
    if (!key) {
      return;
    }
    allowed.set(key, key);
    allowedLower.set(key.toLowerCase(), key);
  });
  ACCESS_ROLE_ADMIN_KEYS.forEach((perm) => {
    const key = String(perm || "").trim();
    if (!key) {
      return;
    }
    allowed.set(key, key);
    allowedLower.set(key.toLowerCase(), key);
  });
  const result = [];
  const seen = new Set();
  source.forEach((perm) => {
    const raw = String(perm || "").trim();
    if (!raw) {
      return;
    }
    if (isAccessRoleLevelKey(raw)) {
      if (!seen.has(raw)) {
        seen.add(raw);
        result.push(raw);
      }
      return;
    }
    let key = raw;
    if (allowed.has(raw)) {
      key = allowed.get(raw);
    } else {
      const lower = raw.toLowerCase();
      if (allowedLower.has(lower)) {
        key = allowedLower.get(lower);
      }
    }
    if (!seen.has(key)) {
      seen.add(key);
      result.push(key);
    }
  });
  return result;
}

function mapAccessPermissionsToGranular(permissionList = []) {
  const normalized = normalizeAccessPermissionList(permissionList);
  const result = {};
  if (normalized.includes("ADMIN")) {
    Object.keys(GRANULAR_PERMISSION_LABELS).forEach((key) => {
      result[key] = true;
    });
    return result;
  }
  const allow = new Set(normalized);
  Object.keys(GRANULAR_PERMISSION_LABELS).forEach((key) => {
    if (allow.has(key)) {
      result[key] = true;
    }
  });
  if (allow.has("USER_READ") || allow.has("USER_WRITE")) {
    result.verUsuarios = true;
  }
  if (allow.has("USER_WRITE")) {
    result.convidarUsuarios = true;
    result.desativarUsuarios = true;
    result.editarPerfilOutros = true;
  }
  if (allow.has("PROJECT_READ") || allow.has("PROJECT_WRITE")) {
    result.verProjetos = true;
  }
  if (allow.has("PROJECT_WRITE")) {
    result.gerenciarProjetos = true;
    result.gerenciarEquipamentos = true;
    result.gerenciarEquipeProjeto = true;
  }
  if (allow.has("SST_READ") || allow.has("SST_WRITE")) {
    result.verSST = true;
  }
  if (allow.has("SST_WRITE")) {
    result.gerenciarSST = true;
  }
  if (allow.has("ALMOX_READ") || allow.has("ALMOX_WRITE")) {
    result.verAlmoxarifado = true;
  }
  if (allow.has("ALMOX_WRITE")) {
    result.gerenciarAlmoxarifado = true;
  }
  if (allow.has("REPORTS_READ") || allow.has("KPIS_READ")) {
    result.verRelatorios = true;
  }
  if (result.gerenciarSST) {
    result.verSST = true;
  }
  if (result.gerenciarAlmoxarifado) {
    result.verAlmoxarifado = true;
  }
  if (result.gerenciarProjetos || result.gerenciarEquipamentos || result.gerenciarEquipeProjeto) {
    result.verProjetos = true;
  }
  if (result.gerenciarAutomacoes) {
    result.verAutomacoes = true;
  }
  if (result.exportarRelatorios) {
    result.verRelatorios = true;
  }
  if (result.gerarRDOs || result.excluirRDOs) {
    result.verRDOs = true;
  }
  if (result.uploadArquivos || result.excluirArquivos || result.vincularArquivo) {
    result.verArquivos = true;
  }
  if (result.reexecutarTarefas) {
    result.verDiagnostico = true;
  }
  if (result.limparLogsAPI) {
    result.verLogsAPI = true;
  }
  return result;
}

function deriveMaintenancePermissions(rolePermissions, accountPermissions, accessRoleActive) {
  const normalized = applyMaintenancePermissionDependencies(rolePermissions);
  if (normalized.includes("ADMIN")) {
    return getDefaultPermissions();
  }
  const hasMaintenanceKeys = MAINTENANCE_ACCESS_PERMISSIONS.some((key) =>
    normalized.includes(key)
  );
  if (hasMaintenanceKeys) {
    return {
      create: normalized.includes("MAINT_CREATE"),
      edit: normalized.includes("MAINT_EDIT"),
      remove: normalized.includes("MAINT_REMOVE"),
      reschedule: normalized.includes("MAINT_RESCHEDULE"),
      complete: normalized.includes("MAINT_COMPLETE"),
    };
  }
  if (accessRoleActive) {
    return getEmptyPermissions();
  }
  if (
    accountPermissions &&
    typeof accountPermissions === "object" &&
    !Array.isArray(accountPermissions)
  ) {
    return accountPermissions;
  }
  return getDefaultPermissions();
}

function deriveSectionsFromAccessPermissions(rolePermissions) {
  const normalized = normalizeAccessPermissionList(rolePermissions);
  if (normalized.includes("ADMIN")) {
    return null;
  }
  const hasSectionControl = ACCESS_SECTION_PERMISSIONS.some((key) =>
    normalized.includes(key)
  );
  if (!hasSectionControl) {
    return null;
  }
  const sections = {};
  ACCESS_SECTION_PERMISSIONS.forEach((key) => {
    sections[key] = normalized.includes(key);
  });
  return sections;
}

function hasAccessPermission(user, permission) {
  if (!user || !permission) {
    return false;
  }
  const list = Array.isArray(user.rolePermissions)
    ? user.rolePermissions
    : Array.isArray(user.accessPermissions)
      ? user.accessPermissions
      : [];
  if (!list.length) {
    return false;
  }
  if (list.includes("ADMIN")) {
    return true;
  }
  if (list.includes(permission)) {
    return true;
  }
  const normalizedPermission = normalizeAccessPermissionKey(permission);
  const normalizedList = normalizeAccessPermissionList(list);
  return normalizedList.includes(normalizedPermission);
}

function buildRbacRoleKey(roleName) {
  const normalized = normalizeSearchValue(roleName);
  if (!normalized) {
    return "";
  }
  if (normalized === "pcm") {
    return "pcm";
  }
  if (normalized.includes("administrador") || normalized === "admin") {
    return "admin";
  }
  if (normalized.includes("supervisor o m")) {
    return "supervisor_om";
  }
  if (normalized.includes("diretor o m")) {
    return "diretor_om";
  }
  if (normalized.includes("gerente de contrato")) {
    return "gerente_contrato";
  }
  if (normalized.includes("tecnico senior")) {
    return "tecnico_senior";
  }
  if (normalized.includes("tecnico pleno")) {
    return "tecnico_pleno";
  }
  if (normalized.includes("tecnico junior")) {
    return "tecnico_junior";
  }
  return normalized.replace(/[^a-z0-9]+/g, "_");
}

function buildSessionUser(account, role) {
  if (!account) {
    return null;
  }
  let rolePermissions = normalizeAccessPermissionList(
    (role && role.permissions) || account.rolePermissions || account.accessPermissions || []
  );
  rolePermissions = ensureSectionPermissions(rolePermissions);
  const roleName = role ? role.name : account.roleName || "";
  const status = normalizeAccessUserStatus(account.status, account.active);
  const accessRoleActive =
    Boolean(role || account.roleId) ||
    Array.isArray(account.rolePermissions) ||
    Array.isArray(account.accessPermissions);
  let granularPermissions = mapAccessPermissionsToGranular(rolePermissions);
  const permissions = deriveMaintenancePermissions(
    rolePermissions,
    account.permissions,
    accessRoleActive
  );
  let sections = { ...DEFAULT_SECTIONS };
  if (account.sections && typeof account.sections === "object") {
    Object.keys(DEFAULT_SECTIONS).forEach((key) => {
      if (key in account.sections) {
        sections[key] = Boolean(account.sections[key]);
      }
    });
  }
  const derivedSections = deriveSectionsFromAccessPermissions(rolePermissions);
  if (derivedSections) {
    sections = { ...sections, ...derivedSections };
  }
  if (rolePermissions.includes("ADMIN")) {
    ADMIN_SECTIONS.forEach((key) => {
      sections[key] = true;
    });
  }
  const derivedRbacRole =
    account.rbacRole || (rolePermissions.includes("ADMIN") ? "admin" : roleName ? buildRbacRoleKey(roleName) : "");
  const derivedRole = account.role || derivedRbacRole || "";
  const fullAccessRole =
    rolePermissions.includes("ADMIN") ||
    derivedRole === "admin" ||
    FULL_ACCESS_RBAC.has(String(derivedRbacRole || "").trim().toLowerCase());
  if (fullAccessRole) {
    granularPermissions = mapAccessPermissionsToGranular(["ADMIN"]);
  }
  return {
    ...account,
    roleId: account.roleId || (role ? role.id : ""),
    roleName,
    rolePermissions,
    granularPermissions,
    rbacRole: derivedRbacRole,
    role: derivedRole,
    cargo: account.cargo || roleName,
    active: status !== "INATIVO",
    status,
    permissions,
    sections,
  };
}

function normalizeCargo(value) {
  return String(value || "")
    .trim()
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]+/g, " ")
    .trim();
}

async function resolveRoleFromDb(account) {
  if (!account) {
    return null;
  }
  const byId = account.roleId ? await getRoleFromDb(account.roleId) : null;
  if (byId) {
    return byId;
  }
  const fallbackName = String(account.roleName || account.cargo || account.role || "").trim();
  if (!fallbackName) {
    return null;
  }
  return getRoleByNameNormalized(normalizeRoleName(fallbackName));
}

function resolveRoleFromAccessMap(account) {
  if (!account) {
    return null;
  }
  if (account.roleId && accessRoleMap && accessRoleMap.has(account.roleId)) {
    return accessRoleMap.get(account.roleId);
  }
  const fallbackName = String(account.roleName || account.cargo || account.role || "").trim();
  if (!fallbackName || !Array.isArray(accessRoles)) {
    return null;
  }
  const normalized = normalizeRoleName(fallbackName);
  return accessRoles.find((role) => role && role.nameNormalized === normalized) || null;
}

function getCryptoProvider() {
  if (typeof crypto !== "undefined") {
    return crypto;
  }
  if (typeof window !== "undefined" && window.crypto) {
    return window.crypto;
  }
  return null;
}

function bufferToHex(buffer) {
  return Array.from(buffer || [])
    .map((item) => item.toString(16).padStart(2, "0"))
    .join("");
}

function getRandomInt(max) {
  const safeMax = Number.isFinite(max) && max > 0 ? Math.floor(max) : 1;
  const provider = getCryptoProvider();
  if (provider && provider.getRandomValues) {
    const array = new Uint32Array(1);
    provider.getRandomValues(array);
    return array[0] % safeMax;
  }
  return Math.floor(Math.random() * safeMax);
}

function generatePassword(length = 12) {
  const safeLength = Math.max(12, Number.isFinite(length) ? Math.floor(length) : 12);
  const lower = "abcdefghijkmnpqrstuvwxyz";
  const upper = "ABCDEFGHJKLMNPQRSTUVWXYZ";
  const digits = "23456789";
  const symbols = "!@#$%*?-_";
  const all = `${lower}${upper}${digits}${symbols}`;
  const pick = (chars) => chars[getRandomInt(chars.length)];
  const result = [pick(lower), pick(upper), pick(digits), pick(symbols)];
  while (result.length < safeLength) {
    result.push(pick(all));
  }
  for (let i = result.length - 1; i > 0; i -= 1) {
    const j = getRandomInt(i + 1);
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result.join("");
}

async function hashPasswordWithSalt(password, saltHex = "") {
  const plain = String(password || "");
  if (!plain) {
    throw new Error("Senha obrigatoria.");
  }
  const provider = getCryptoProvider();
  if (!provider || !provider.subtle || typeof TextEncoder === "undefined") {
    throw new Error("Criptografia indisponivel neste navegador.");
  }
  const saltBytes = saltHex
    ? null
    : (() => {
        const bytes = new Uint8Array(16);
        provider.getRandomValues(bytes);
        return bytes;
      })();
  const salt = saltHex || bufferToHex(saltBytes);
  const payload = new TextEncoder().encode(`${salt}:${plain}`);
  const digest = await provider.subtle.digest("SHA-256", payload);
  const hash = bufferToHex(new Uint8Array(digest));
  return `sha256:${salt}:${hash}`;
}

async function verifyPasswordHash(password, storedHash) {
  const raw = String(storedHash || "");
  if (!raw) {
    return false;
  }
  const parts = raw.split(":");
  if (parts.length !== 3 || parts[0] !== "sha256") {
    return false;
  }
  const recomputed = await hashPasswordWithSalt(password, parts[1]);
  return recomputed === raw;
}

function getCargoLevel(cargo) {
  const normalized = normalizeCargo(cargo);
  if (!normalized) {
    return 0;
  }
  if (normalized.includes("diretor o m")) {
    return 6;
  }
  if (normalized.includes("gerente de contrato")) {
    return 5;
  }
  if (normalized.includes("supervisor o m")) {
    return 4;
  }
  if (normalized.includes("tecnico senior")) {
    return 3;
  }
  if (normalized.includes("tecnico pleno")) {
    return 2;
  }
  if (normalized.includes("tecnico junior")) {
    return 1;
  }
  return 0;
}

function getProfileKeyForUser(user) {
  if (!user) {
    return "leitura";
  }
  const rbacRole = String(user.rbacRole || "").trim().toLowerCase();
  if (rbacRole && GRANULAR_PROFILE_ORDER.includes(rbacRole)) {
    return rbacRole;
  }
  const cargo = normalizeCargo(user.cargo);
  if (cargo.includes("supervisor o m")) {
    return "supervisor_om";
  }
  if (cargo.includes("tecnico senior")) {
    return "tecnico_senior";
  }
  if (cargo.includes("tecnico pleno")) {
    return "tecnico_pleno";
  }
  if (cargo.includes("tecnico junior")) {
    return "tecnico_junior";
  }
  return "leitura";
}

function hasGranularPermission(user, permissionKey) {
  if (!user || !permissionKey) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  if (user.granularPermissions && user.granularPermissions[permissionKey]) {
    return true;
  }
  if (
    user.permissions &&
    typeof user.permissions === "object" &&
    !Array.isArray(user.permissions) &&
    user.permissions[permissionKey]
  ) {
    return true;
  }
  if (Array.isArray(user.rolePermissions)) {
    const derived = mapAccessPermissionsToGranular(user.rolePermissions);
    return Boolean(derived[permissionKey]);
  }
  return false;
}

function canEditProfile(actor, target) {
  if (!actor || !target) {
    return false;
  }
  if (isFullAccessUser(actor)) {
    return true;
  }
  if (actor.id === target.id) {
    return hasGranularPermission(actor, "editarPerfil");
  }
  if (!hasGranularPermission(actor, "editarPerfilOutros")) {
    return false;
  }
  const actorLevel = getCargoLevel(actor.cargo);
  const targetLevel = getCargoLevel(target.cargo);
  return actorLevel > targetLevel;
}

function isMasterUser(user) {
  if (!user) {
    return false;
  }
  const matricula = String(user.matricula || "").trim();
  const username = String(user.username || "").trim().toLowerCase();
  return (
    (MASTER_MATRICULA && matricula === MASTER_MATRICULA) ||
    (MASTER_USERNAME && username === MASTER_USERNAME.toLowerCase())
  );
}

function isFullAccessUser(user) {
  if (!user) {
    return false;
  }
  if (isMasterUser(user)) {
    return true;
  }
  if (
    ACCESS_BOOTSTRAP_USER &&
    normalizeMatricula(user.matricula) === normalizeMatricula(ACCESS_BOOTSTRAP_USER.matricula)
  ) {
    return true;
  }
  if (hasAccessPermission(user, "ADMIN")) {
    return true;
  }
  const rbacRole = String(user.rbacRole || "").trim().toLowerCase();
  if (user.role === "admin" || FULL_ACCESS_RBAC.has(rbacRole)) {
    return true;
  }
  const cargo = normalizeCargo(user.cargo || user.roleName || user.role || "");
  if (
    cargo.includes("administrador") ||
    cargo === "admin" ||
    cargo.includes("diretor o m") ||
    cargo.includes("gerente de contrato")
  ) {
    return true;
  }
  return false;
}

function canOverrideRelease(user) {
  if (!user) {
    return false;
  }
  if (user.role === "admin" || user.role === "supervisor") {
    return true;
  }
  const rbacRole = String(user.rbacRole || "").trim().toLowerCase();
  return RELEASE_OVERRIDE_RBAC.has(rbacRole);
}

function canDeleteMaintenance(user) {
  if (!user) {
    return false;
  }
  if (isMasterUser(user) || isFullAccessUser(user)) {
    return true;
  }
  if (user.permissions && user.permissions.remove) {
    return true;
  }
  if (hasAccessPermission(user, "MAINT_REMOVE")) {
    return true;
  }
  const rbacRole = String(user.rbacRole || "").trim().toLowerCase();
  return rbacRole === "pcm";
}

function canEditConcludedMaintenance(user) {
  if (!user) {
    return false;
  }
  if (isMasterUser(user) || isFullAccessUser(user)) {
    return true;
  }
  if (user.permissions && user.permissions.edit) {
    return true;
  }
  if (hasAccessPermission(user, "MAINT_EDIT")) {
    return true;
  }
  const rbacRole = String(user.rbacRole || "").trim().toLowerCase();
  return rbacRole === "pcm";
}

function canReopenMaintenance(user) {
  return canEditConcludedMaintenance(user);
}

function canUploadPmpProcedimento(user) {
  if (!user) {
    return false;
  }
  if (isMasterUser(user)) {
    return true;
  }
  if (user.role === "admin") {
    return true;
  }
  const rbacRole = String(user.rbacRole || "").trim().toLowerCase();
  return rbacRole === "pcm";
}

function canManagePmpActivities(user) {
  return canUploadPmpProcedimento(user);
}

function canExecutePmp(user) {
  return Boolean(user);
}

function canAdminUsersRead() {
  if (!currentUser) {
    return false;
  }
  if (isFullAccessUser(currentUser)) {
    return true;
  }
  return canViewUsuarios(currentUser);
}

function canAdminUsersWrite() {
  if (!currentUser) {
    return false;
  }
  if (isFullAccessUser(currentUser)) {
    return true;
  }
  return (
    hasGranularPermission(currentUser, "gerenciarAcessos") ||
    hasGranularPermission(currentUser, "editarPerfilOutros") ||
    hasGranularPermission(currentUser, "desativarUsuarios") ||
    hasGranularPermission(currentUser, "convidarUsuarios")
  );
}

function canManageFilesClient(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return hasGranularPermission(user, "verArquivos");
}

function canUploadFilesClient(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return hasGranularPermission(user, "uploadArquivos");
}

function canDeleteFilesClient(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return hasGranularPermission(user, "excluirArquivos");
}

function canViewRdo(user) {
  return hasGranularPermission(user, "verRDOs");
}

function canGerarRelatorio(user) {
  return hasGranularPermission(user, "gerarRDOs");
}

function canExcluirRdo(user) {
  return hasGranularPermission(user, "excluirRDOs");
}

function canViewRelatorios(user) {
  return hasGranularPermission(user, "verRelatorios");
}

function canExportRelatorios(user) {
  return hasGranularPermission(user, "exportarRelatorios");
}

function canCreateAnnouncements(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return hasGranularPermission(user, "criarAnuncios");
}

function canViewAnnouncements(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return (
    hasGranularPermission(user, "verAnuncios") || hasGranularPermission(user, "criarAnuncios")
  );
}

function canViewGerencial(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return hasGranularPermission(user, "verPainelGerencial");
}

function canManageProjetos(user) {
  return hasGranularPermission(user, "gerenciarProjetos");
}

function canViewProjetos(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return (
    hasGranularPermission(user, "verProjetos") ||
    canManageProjetos(user) ||
    canManageEquipamentos(user) ||
    canManageEquipeProjeto(user)
  );
}

function canManageEquipamentos(user) {
  return hasGranularPermission(user, "gerenciarEquipamentos");
}

function canManageEquipeProjeto(user) {
  return hasGranularPermission(user, "gerenciarEquipeProjeto");
}

function canViewAlmoxarifado(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return hasGranularPermission(user, "verAlmoxarifado");
}

function canManageAlmoxarifado(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return hasGranularPermission(user, "gerenciarAlmoxarifado");
}

function canViewSst(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return hasGranularPermission(user, "verSST");
}

function canManageSst(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return hasGranularPermission(user, "gerenciarSST");
}

function canAccessGerencialTab(tabId, user) {
  if (!user || !canViewGerencial(user)) {
    return false;
  }
  switch (tabId) {
    case "geral":
      return true;
    case "diagnostico":
      return hasGranularPermission(user, "verDiagnostico");
    case "logs":
      return hasGranularPermission(user, "verLogsAPI");
    case "permissoes":
      return !USE_AUTH_API;
    case "arquivos":
      return canManageFilesClient(user);
    case "automacoes":
      return hasGranularPermission(user, "verAutomacoes");
    case "operacoes":
      return isAdmin();
    default:
      return false;
  }
}

const gerencialLoadedTabs = new Set();

function getIndicatorStatusLabel(status, count) {
  if (status === "error") {
    return `${count} críticos`;
  }
  if (status === "warn") {
    return `${count} alertas`;
  }
  return "OK";
}

function applyIndicatorStatus(card, badge, status) {
  if (card) {
    card.classList.remove("indicator-card--ok", "indicator-card--warn", "indicator-card--error");
    card.classList.add(`indicator-card--${status}`);
  }
  if (badge) {
    badge.classList.remove(
      "indicator-card__badge--warn",
      "indicator-card__badge--danger",
      "indicator-card__badge--neutral"
    );
    if (status === "error") {
      badge.classList.add("indicator-card__badge--danger");
    } else if (status === "warn") {
      badge.classList.add("indicator-card__badge--warn");
    } else {
      badge.classList.add("indicator-card__badge--neutral");
    }
  }
}

function summarizeHealthIndicators(snapshot) {
  if (!snapshot || !snapshot.modules) {
    return {
      status: "warn",
      alerts: 0,
      meta: "Diagnóstico indisponível",
    };
  }
  const modules = snapshot.modules;
  const moduleStatuses = [
    modules.database && modules.database.status,
    modules.backups && modules.backups.status,
    modules.queue && modules.queue.status,
    modules.integrity && modules.integrity.status,
  ].filter(Boolean);
  const moduleAlerts = moduleStatuses.filter((status) => status !== "ok").length;
  const tasks = modules.queue && modules.queue.tasks ? modules.queue.tasks : [];
  const taskAlerts = tasks.filter((task) => task.status && task.status !== "ok").length;
  const issues = modules.integrity && modules.integrity.issues ? modules.integrity.issues : [];
  const issueAlerts = issues.length;
  const alerts = moduleAlerts + taskAlerts + issueAlerts;
  const hasError = moduleStatuses.includes("error") || issues.some((item) => item.level === "error");
  const status = hasError ? "error" : alerts > 0 ? "warn" : "ok";
  const meta = snapshot.generatedAt ? `Atualizado em ${formatHealthDate(snapshot.generatedAt)}` : "Diagnóstico ativo";
  return { status, alerts, meta };
}

function updateGerencialIndicators() {
  if (!indicatorHealthCount && !indicatorLogsCount && !indicatorFilesCount && !indicatorAutomationsCount) {
    return;
  }
  const health = summarizeHealthIndicators(healthSnapshot);
  if (indicatorHealthCount) {
    indicatorHealthCount.textContent = String(health.alerts);
  }
  if (indicatorHealthBadge) {
    indicatorHealthBadge.textContent = getIndicatorStatusLabel(health.status, health.alerts);
  }
  if (indicatorHealthMeta) {
    indicatorHealthMeta.textContent = health.meta;
  }
  applyIndicatorStatus(indicatorHealthCard, indicatorHealthBadge, health.status);

  const logErrors = apiLogsState.items.filter((item) => Number(item.status) >= 400).length;
  const logStatus = logErrors > 0 ? "error" : "ok";
  if (indicatorLogsCount) {
    indicatorLogsCount.textContent = String(logErrors);
  }
  if (indicatorLogsBadge) {
    indicatorLogsBadge.textContent = getIndicatorStatusLabel(logStatus, logErrors);
  }
  if (indicatorLogsMeta) {
    indicatorLogsMeta.textContent = apiLogsState.items.length ? "Últimas requisições" : "Sem logs carregados";
  }
  applyIndicatorStatus(indicatorLogsCard, indicatorLogsBadge, logStatus);

  const filesCount = filesState.items.length;
  const filesStatus = filesCount ? "ok" : "warn";
  if (indicatorFilesCount) {
    indicatorFilesCount.textContent = String(filesCount);
  }
  if (indicatorFilesBadge) {
    indicatorFilesBadge.textContent = filesCount ? `${filesCount} itens` : "Sem arquivos";
  }
  if (indicatorFilesMeta) {
    indicatorFilesMeta.textContent = filesCount ? "Arquivos monitorados" : "Nenhum arquivo carregado";
  }
  applyIndicatorStatus(indicatorFilesCard, indicatorFilesBadge, filesStatus);

  const automationCount = automationsState.items.length;
  const activeCount = automationsState.items.filter((item) => item.enabled).length;
  const automationStatus = activeCount ? "ok" : automationCount ? "warn" : "warn";
  if (indicatorAutomationsCount) {
    indicatorAutomationsCount.textContent = String(activeCount);
  }
  if (indicatorAutomationsBadge) {
    indicatorAutomationsBadge.textContent = activeCount ? `${activeCount} ativas` : "Sem rotinas";
  }
  if (indicatorAutomationsMeta) {
    indicatorAutomationsMeta.textContent = automationCount
      ? `${automationCount} regras`
      : "Nenhuma automação carregada";
  }
  applyIndicatorStatus(indicatorAutomationsCard, indicatorAutomationsBadge, automationStatus);
}

function setGerencialUpdateMessage(text, isError = false) {
  if (!gerencialUpdateMessage) {
    return;
  }
  gerencialUpdateMessage.textContent = text || "";
  gerencialUpdateMessage.classList.toggle("mensagem--erro", isError);
}

function setGerencialLastUpdate() {
  if (!gerencialLastUpdate) {
    return;
  }
  const now = new Date();
  const name = currentUser ? getDisplayName(currentUser) : "Sistema";
  gerencialLastUpdate.textContent = `Atualizado em ${formatDateTime(now)} por ${name}`;
}

async function refreshGerencialAll() {
  if (!currentUser || !canViewGerencial(currentUser)) {
    return;
  }
  setGerencialUpdateMessage("Atualizando painel...");
  const results = await Promise.allSettled([
    carregarHealth(true),
    carregarApiLogs(true),
    carregarAutomacoes(true),
    carregarArquivos(true),
    carregarPermissoes(true),
  ]);
  const failed = results.some((item) => item.status === "rejected");
  if (failed) {
    setGerencialUpdateMessage("Atualização parcial. Verifique os módulos.", true);
    return;
  }
  setGerencialUpdateMessage("Atualizado com sucesso.");
  setGerencialLastUpdate();
}

function loadGerencialTab(tabId, force = false) {
  if (!tabId) {
    return;
  }
  if (force) {
    gerencialLoadedTabs.delete(tabId);
  }
  if (gerencialLoadedTabs.has(tabId)) {
    return;
  }
  switch (tabId) {
    case "diagnostico":
      carregarHealth(true);
      break;
    case "logs":
      carregarApiLogs(true);
      break;
    case "permissoes":
      carregarPermissoes(true);
      break;
    case "arquivos":
      carregarArquivos(true);
      break;
    case "automacoes":
      carregarAutomacoes(true);
      break;
    case "geral":
      updateGerencialIndicators();
      break;
    default:
      break;
  }
  gerencialLoadedTabs.add(tabId);
}

function setGerencialTabActive(tabId) {
  gerencialTabs.forEach((tab) => {
    const isActive = tab.dataset.tabTarget === tabId;
    tab.classList.toggle("is-active", isActive);
    tab.setAttribute("aria-selected", isActive ? "true" : "false");
    tab.setAttribute("tabindex", isActive ? "0" : "-1");
  });
  gerencialPanels.forEach((panel) => {
    panel.classList.toggle("is-active", panel.dataset.tabPanel === tabId);
  });
  loadGerencialTab(tabId);
}

function updateGerencialTabVisibility() {
  if (!gerencialTabs.length) {
    return;
  }
  const canView = Boolean(currentUser && canViewGerencial(currentUser));
  gerencialTabs.forEach((tab) => {
    const tabId = tab.dataset.tabTarget;
    const allow = canView && canAccessGerencialTab(tabId, currentUser);
    tab.hidden = !allow;
  });
  gerencialIndicators.forEach((card) => {
    const tabId = card.dataset.tabTarget;
    const allow = canView && canAccessGerencialTab(tabId, currentUser);
    card.hidden = !allow;
    const action = card.querySelector(".indicator-card__action");
    if (action) {
      action.disabled = !allow;
    }
  });
  gerencialPanels.forEach((panel) => {
    const tabId = panel.dataset.tabPanel;
    panel.hidden = !canView || !canAccessGerencialTab(tabId, currentUser);
  });
  if (btnGerencialRefreshAll) {
    btnGerencialRefreshAll.disabled = !canView;
  }
  if (gerencialPaletteTrigger) {
    gerencialPaletteTrigger.disabled = !canView;
  }
  if (btnGerencialPalette) {
    btnGerencialPalette.disabled = !canView;
  }
  if (btnGerencialGoLogs) {
    btnGerencialGoLogs.disabled = !canAccessGerencialTab("logs", currentUser);
  }
  if (btnGerencialGoPermissoes) {
    btnGerencialGoPermissoes.disabled = !canAccessGerencialTab("permissoes", currentUser);
  }
  if (btnHealthRunAll) {
    btnHealthRunAll.disabled = !currentUser || !hasGranularPermission(currentUser, "reexecutarTarefas");
  }
  if (btnLogsExport) {
    btnLogsExport.disabled = !currentUser || !hasGranularPermission(currentUser, "verLogsAPI");
  }
  updateGerencialIndicators();
  const activeTab = gerencialTabs.find((tab) => tab.classList.contains("is-active") && !tab.hidden);
  if (activeTab) {
    setGerencialTabActive(activeTab.dataset.tabTarget);
    return;
  }
  const firstVisible = gerencialTabs.find((tab) => !tab.hidden);
  if (firstVisible) {
    setGerencialTabActive(firstVisible.dataset.tabTarget);
  }
}

function getGerencialPaletteItems() {
  const items = [];
  gerencialTabs.forEach((tab) => {
    if (tab.hidden) {
      return;
    }
    const label = tab.textContent.trim();
    items.push({
      type: "tab",
      label,
      tab: tab.dataset.tabTarget,
      hint: "Abrir modulo",
    });
  });
  const actionItems = [
    {
      label: "Ver status de backup",
      tab: "diagnostico",
      scrollTarget: "gerencialHealth",
      permission: "verDiagnostico",
    },
    {
      label: "Atualizar painel",
      tab: "geral",
      selector: "#btnGerencialRefreshAll",
    },
    {
      label: "Reexecutar tudo (diagnóstico)",
      tab: "diagnostico",
      selector: "#btnHealthRunAll",
      permission: "reexecutarTarefas",
    },
    {
      label: "Atualizar diagnóstico",
      tab: "diagnostico",
      selector: "#btnRefreshHealth",
      permission: "verDiagnostico",
    },
    {
      label: "Exportar logs de API",
      tab: "logs",
      selector: "#btnLogsExport",
      permission: "verLogsAPI",
    },
    {
      label: "Atualizar logs",
      tab: "logs",
      selector: "#btnLogsRefresh",
      permission: "verLogsAPI",
    },
    {
      label: "Salvar permissões",
      tab: "permissoes",
      selector: "#btnPermissoesSalvar",
    },
    {
      label: "Atualizar automacoes",
      tab: "automacoes",
      selector: "#btnAutomationRefresh",
      permission: "verAutomacoes",
    },
    {
      label: "Atualizar arquivos",
      tab: "arquivos",
      selector: "#btnFilesRefresh",
      permission: "verArquivos",
    },
  ];
  actionItems.forEach((item) => {
    if (!currentUser || !canAccessGerencialTab(item.tab, currentUser)) {
      return;
    }
    if (item.permission && !hasGranularPermission(currentUser, item.permission)) {
      return;
    }
    items.push({ ...item, type: "action", hint: "Executar ação" });
  });
  return items;
}

function renderGerencialPalette(query = "") {
  if (!gerencialPaletteList) {
    return;
  }
  const normalized = query.trim().toLowerCase();
  gerencialPaletteList.innerHTML = "";
  const items = getGerencialPaletteItems().filter((item) => {
    const text = `${item.label} ${item.hint || ""}`.toLowerCase();
    return !normalized || text.includes(normalized);
  });
  if (!items.length) {
    const empty = document.createElement("div");
    empty.className = "empty-state";
    empty.textContent = "Nenhum resultado encontrado.";
    gerencialPaletteList.append(empty);
    return;
  }
  items.forEach((item) => {
    const row = document.createElement("button");
    row.type = "button";
    row.className = "command-palette__item";
    row.dataset.paletteType = item.type;
    row.dataset.paletteTab = item.tab || "";
    row.dataset.paletteSelector = item.selector || "";
    row.dataset.paletteScroll = item.scrollTarget || "";
    row.innerHTML = `<strong>${item.label}</strong><span>${item.hint || ""}</span>`;
    gerencialPaletteList.append(row);
  });
}

function openGerencialPalette() {
  if (!gerencialPalette) {
    return false;
  }
  const gerencialPanel = document.getElementById("gerencial");
  if (!currentUser || !canViewGerencial(currentUser) || (gerencialPanel && gerencialPanel.hidden)) {
    return false;
  }
  gerencialPalette.hidden = false;
  renderGerencialPalette("");
  if (gerencialPaletteInput) {
    gerencialPaletteInput.value = "";
    gerencialPaletteInput.focus();
  }
  return true;
}

function closeGerencialPalette() {
  if (!gerencialPalette) {
    return;
  }
  gerencialPalette.hidden = true;
}

function canViewUsuarios(user) {
  return hasGranularPermission(user, "verUsuarios");
}

function canInviteUsuarios(user) {
  return hasGranularPermission(user, "convidarUsuarios");
}

function canDesativarUsuarios(user) {
  return hasGranularPermission(user, "desativarUsuarios");
}

function canManageAccess(user) {
  if (!user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return (
    hasAccessPermission(user, "ADMIN") ||
    hasGranularPermission(user, "gerenciarAcessos")
  );
}

function canViewPerformanceTab(user) {
  if (!user) {
    return false;
  }
  if (user.role === "admin" || user.role === "supervisor") {
    return true;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  return getCargoLevel(user.cargo) >= getCargoLevel("SUPERVISOR O&M");
}

function hasSectionPermissionConfig(user) {
  if (!user) {
    return false;
  }
  const list = Array.isArray(user.rolePermissions)
    ? user.rolePermissions
    : Array.isArray(user.accessPermissions)
      ? user.accessPermissions
      : [];
  return ACCESS_SECTION_PERMISSIONS.some((key) => list.includes(key));
}

function canViewSectionTab(tab, user) {
  if (!tab || !user) {
    return false;
  }
  if (isFullAccessUser(user)) {
    return true;
  }
  if (hasSectionPermissionConfig(user)) {
    return hasAccessPermission(user, tab);
  }
  if (hasAccessPermission(user, tab)) {
    return true;
  }
  if (user.sections && typeof user.sections === "object" && tab in user.sections) {
    return Boolean(user.sections[tab]);
  }
  return false;
}

function canViewTab(tab, user, secConfig) {
  if (!tab) {
    return false;
  }
  if (ACCESS_SECTION_PERMISSIONS.includes(tab)) {
    return canViewSectionTab(tab, user);
  }
  if (tab === "acessos") {
    return Boolean(user && canManageAccess(user));
  }
  const permissionKey = TAB_PERMISSION_MAP[tab];
  if (permissionKey) {
    if (!user) {
      return false;
    }
    const keys = Array.isArray(permissionKey) ? permissionKey : [permissionKey];
    const hasPermission = keys.some((key) => hasGranularPermission(user, key));
    if (!hasPermission) {
      return false;
    }
    if (PERFORMANCE_TABS.has(tab)) {
      return canViewPerformanceTab(user);
    }
    return true;
  }
  if (PERFORMANCE_TABS.has(tab)) {
    return canViewPerformanceTab(user);
  }
  return Boolean(secConfig && secConfig[tab]);
}

const ACTION_LABELS = {
  create: "Criar",
  edit: "Editar",
  remove: "Remover",
  reschedule: "Reagendar",
  release: "Liberação registrada",
  execute: "Execução iniciada",
  cancel_start: "Início cancelado",
  execute_register: "Registro de execução",
  complete: "Concluir",
  reopen: "Reaberta",
  note: "Observação",
  backlog_auto: "Backlog automático",
  backlog_reason: "Motivo não executada",
  rdo_delete: "RDO excluído",
};

const MAINTENANCE_STATE_LABELS = {
  overdue: "ATRASADA",
  released: "LIBERADA",
  planned: "PLANEJADA",
  awaiting: "AGUARDANDO CONCLUSÃO",
};

const RESULTADO_LABELS = {
  concluida: "Concluída",
  ressalva: "Concluída com ressalva",
  nao_executada: "Não executada",
};

const dateFormatter = new Intl.DateTimeFormat("pt-BR");
const dateTimeFormatter = new Intl.DateTimeFormat("pt-BR", {
  dateStyle: "short",
  timeStyle: "short",
});
const weekLabelFormatter = new Intl.DateTimeFormat("pt-BR", {
  day: "2-digit",
  month: "2-digit",
});

let manutencoes = [];
let templates = [];
let templatesSyncEnabled = false;
let templatesSyncInFlight = false;
let templatesSyncQueued = false;
let templatesSyncPayload = null;
const templatesLoadedProjects = new Set();
let users = [];
let accessUsers = [];
let accessRoles = [];
let accessRoleMap = new Map();
let accessWriteEnabled = true;
let accessRefreshInFlight = false;
let accessRefreshPromise = null;
let accessRefreshLastAt = 0;
const ACCESS_REFRESH_MIN_INTERVAL = 1500;
let accessRoleEditorState = {
  roleId: "",
  baseline: [],
  selected: new Set(),
  manualLevels: {},
  adminSnapshot: null,
  adminEnabled: false,
  activeModule: ACCESS_ROLE_MODULES.length ? ACCESS_ROLE_MODULES[0].name : "",
  query: "",
  onlyConfigured: false,
  onlyCritical: false,
  renameMode: false,
  showChanges: false,
};
let accessRoleAutoFixRunning = false;
let accessRoleAutoFixDone = false;
let maintenanceServerIdsByProject = new Map();
let accessRoleSelectLocked = false;
let requests = [];
let auditLog = [];
let currentUser = null;
let profileViewingUserId = "";
let authToastTimeout = null;
let execucaoRegistradaAlertTimer = null;
let activeProjectId = "";
let availableProjects = [];
let projectEquipamentos = [];
let projectEquipe = [];
let manutencaoParticipantesSelecionados = [];
let liberacaoParticipantesSelecionados = [];
let templateParticipantesSelecionados = [];
let pmpActivities = [];
let pmpExecutions = [];
let almoxItems = [];
let almoxStock = [];
let almoxMovements = [];
let almoxKits = [];
let almoxEpiByUser = [];
let almoxLoaded = false;
let sstTrainings = [];
let sstTrainingRecords = [];
let sstInspectionTemplates = [];
let sstInspections = [];
let sstVehicles = [];
let sstVehicleEditingId = null;
let vehiclesLoaded = false;
let sstNonconformities = [];
let sstIncidents = [];
let sstDocs = [];
let sstLoaded = false;
let pendingSstDocAprPreview = null;
let sstDocReviewingId = null;
let sstWizardState = null;
let sstInspectionDetailsId = null;
let sstInspectionDetailsData = null;
let pendingSstNcAttachments = [];
let pendingSstNcDetailsAttachments = [];
let sstNcDetailsData = null;
let sstNcDetailsEvidences = [];
const pmpEquipamentosCache = new Map();
const pmpMaintenanceCache = new Map();
let pmpChecklistItems = [];
let pmpFormOrigem = "manual";
let pmpProcedimentoDoc = null;
let pmpImportItems = [];
let pmpImportSelection = new Set();
let pmpLastSnapshot = null;
let pmpCellContext = null;
let adminPermissionCatalog = [];
let reminderDays = DEFAULT_REMINDER_DAYS;
let loadingTimeout = null;
let historicoAtualId = null;
let historicoLimite = HISTORY_PAGE_SIZE;
let manutencaoEmLiberacao = null;
let pendingLiberacaoOverride = null;
let manutencaoEmBacklogMotivo = null;
let manutencaoEmCancelamento = null;
let liberacaoDocsBase = {};
let liberacaoDocsPreview = {};
let previewBlobUrl = "";
let previewCurrentUrl = "";
let auditHashChain = Promise.resolve("");
let kpiDrilldown = null;
let kpiSnapshot = null;
let rdoSnapshots = [];
let rdoPreviewSnapshot = null;
let rdoSelection = new Set();
let feedbacks = [];
let dashboardSummary = null;
let dashboardError = "";
let dashboardLastFetch = 0;
let dashboardRequest = null;
let maintenanceSyncTimer = null;
let maintenanceSyncPromise = null;
let maintenanceLastSync = 0;
let maintenanceSyncFailed = false;
let maintenanceLastUserId = null;
let maintenanceLastFetch = 0;
let maintenancePendingSync = false;
const maintenanceLoadedProjects = new Set();
const maintenanceRenderHashes = new Map();
const templatesRenderHashes = new Map();
let healthSnapshot = null;
let healthLoading = false;
let apiLogsState = {
  items: [],
  total: 0,
  filtered: 0,
  offset: 0,
  limit: 20,
  loading: false,
  filters: {
    endpoint: "",
    user: "",
    status: "",
    from: "",
    to: "",
  },
};
let automationsState = {
  items: [],
  loading: false,
};
let filesState = {
  items: [],
  loading: false,
};
let permissoesState = {
  values: {},
  profiles: [],
  permissions: [],
  loading: false,
  loaded: false,
};
let filesSearchTimer = null;
let rdoUI = {
  card: null,
  list: null,
  empty: null,
  showDeleted: null,
  btnExcluir: null,
  modal: null,
  data: null,
  subestacao: null,
  categoria: null,
  prioridade: null,
  usuario: null,
  registro: null,
  limite: null,
  condutor: null,
  kmInicial: null,
  kmFinal: null,
  clima: null,
  climaOutroField: null,
  climaOutro: null,
  incidente: null,
  bloqueio: null,
  qtPessoas: null,
  local: null,
  numeroSi: null,
  numeroSgi: null,
  preview: null,
  previewBody: null,
  mensagem: null,
  btnGerar: null,
  btnPreview: null,
  btnExportar: null,
  btnFechar: null,
  btnVoltar: null,
  deleteModal: null,
  deleteReason: null,
  deleteMensagem: null,
  btnDeleteConfirm: null,
  btnDeleteCancel: null,
};
let kpiRankingSort = { key: "concluidas", dir: "desc" };
let homeTipsTimer = null;
let homeTipIndex = 0;
const SYNC_POLL_MS = 10 * 60 * 1000;
const SYNC_DEBUG_KEY = "opscope.debugSync";
const COMPAT_SCHEMA_VERSION = 1;
const COMPAT_STATE_KEY = "opscope.compat.state";
const COMPAT_CHECK_TTL_MS = 15000;
const COMPAT_DATASETS = ["maintenance", "templates", "announcements", "feedbacks", "sstDocs"];
let syncEventSource = null;
let syncEventProject = "";
let syncPollTimer = null;
let syncPollRunning = false;
let syncDebugEnabled = false;
let syncLastEventAt = 0;
let syncSiteRunning = false;
let announcements = [];
let announcementsLastFetch = 0;
let announcementsUnreadCount = 0;
let announcementsUnreadSeverity = "baixa";
let reminderTotalCount = 0;
let reminderUnreadCount = 0;
let feedbacksLastFetch = 0;
let feedbacksLastProjectId = "";
let compatLastCheck = 0;
let compatState = { schemaVersion: COMPAT_SCHEMA_VERSION, datasets: {}, updatedAt: "" };
let compatStatus = { state: "idle", message: "" };
let announcementDraftImages = [];
let activeAnnouncementView = null;

function readJson(key, fallback) {
  const raw = localStorage.getItem(key);
  if (!raw) {
    return fallback;
  }
  try {
    return JSON.parse(raw);
  } catch (error) {
    return fallback;
  }
}

function writeJson(key, value) {
  try {
    localStorage.setItem(key, JSON.stringify(value));
    return true;
  } catch (error) {
    console.error(`Falha ao salvar ${key} no storage.`, error);
    return false;
  }
}

function compactEvidencias(list) {
  let changed = false;
  const sanitizeList = (items) => {
    if (!Array.isArray(items)) {
      return items;
    }
    return items.map((evidencia) => {
      if (!evidencia || typeof evidencia !== "object") {
        return evidencia;
      }
      if (!USE_AUTH_API) {
        return evidencia;
      }
      const cleaned = { ...evidencia };
      const dataUrl = typeof cleaned.dataUrl === "string" ? cleaned.dataUrl : "";
      const url = typeof cleaned.url === "string" ? cleaned.url : "";
      if (dataUrl && (url || dataUrl.length > 200000)) {
        delete cleaned.dataUrl;
        changed = true;
      }
      return cleaned;
    });
  };
  const output = Array.isArray(list)
    ? list.map((item) => {
        if (!item || typeof item !== "object") {
          return item;
        }
        let changedItem = false;
        const updated = { ...item };
        if (Array.isArray(item.evidencias)) {
          updated.evidencias = sanitizeList(item.evidencias);
          changedItem = true;
        }
        if (item.registroExecucao && Array.isArray(item.registroExecucao.evidencias)) {
          updated.registroExecucao = {
            ...item.registroExecucao,
            evidencias: sanitizeList(item.registroExecucao.evidencias),
          };
          changedItem = true;
        }
        if (item.conclusao && Array.isArray(item.conclusao.evidencias)) {
          updated.conclusao = {
            ...item.conclusao,
            evidencias: sanitizeList(item.conclusao.evidencias),
          };
          changedItem = true;
        }
        return changedItem ? updated : item;
      })
    : list;
  return { list: output, changed };
}

function getBuildId() {
  const meta = document.querySelector('meta[name="opscope-build"]');
  return meta ? String(meta.content || "").trim() : "";
}

function formatTimeShort(value) {
  const date = value instanceof Date ? value : new Date(value);
  if (!date || Number.isNaN(date.getTime())) {
    return "--:--";
  }
  const hh = String(date.getHours()).padStart(2, "0");
  const mm = String(date.getMinutes()).padStart(2, "0");
  return `${hh}:${mm}`;
}

function getSyncStatusKey() {
  return getProjectStorageKey(SYNC_LAST_AT_KEY);
}

function normalizeSyncMeta(value) {
  if (typeof value === "number") {
    return { at: value, source: "manual" };
  }
  if (value && typeof value === "object") {
    const at = Number(value.at) || 0;
    const source = String(value.source || "").trim() || "manual";
    return { at, source };
  }
  return { at: 0, source: "manual" };
}

function readLastSyncMeta() {
  const stored = readJson(getSyncStatusKey(), 0);
  return normalizeSyncMeta(stored);
}

function updateSyncStatusLabel(meta = readLastSyncMeta()) {
  if (!syncStatusLabel) {
    return;
  }
  const timeLabel = meta.at ? formatTimeShort(meta.at) : "--:--";
  const suffix = meta.source === "auto" ? " automática" : "";
  const label = `Última sincronização${suffix}`;
  syncStatusLabel.textContent = `${timeLabel} · ${label}`;
  syncStatusLabel.title = `${label}: ${timeLabel}`;
}

function setLastSyncAt(value = Date.now(), source = "manual") {
  const payload = { at: Number(value) || Date.now(), source };
  writeJson(getSyncStatusKey(), payload);
  updateSyncStatusLabel(payload);
}

function normalizeCompatState(state) {
  const base = {
    schemaVersion: COMPAT_SCHEMA_VERSION,
    datasets: {},
    updatedAt: "",
  };
  if (!state || typeof state !== "object") {
    return base;
  }
  const schemaVersion = Number(state.schemaVersion) || COMPAT_SCHEMA_VERSION;
  const datasets = state.datasets && typeof state.datasets === "object" ? state.datasets : {};
  return {
    schemaVersion,
    datasets: { ...datasets },
    updatedAt: String(state.updatedAt || ""),
  };
}

function readCompatState() {
  return normalizeCompatState(readJson(COMPAT_STATE_KEY, null));
}

function saveCompatState(state) {
  compatState = normalizeCompatState(state);
  writeJson(COMPAT_STATE_KEY, compatState);
}

function setCompatStatus(state, message = "") {
  compatStatus = { state, message };
  updateCompatStatusLabel();
}

function updateCompatStatusLabel() {
  if (!compatStatusLabel) {
    return;
  }
  if (!currentUser || !USE_AUTH_API) {
    compatStatusLabel.hidden = true;
    compatStatusLabel.classList.remove("is-ok", "is-warn", "is-danger");
    return;
  }
  compatStatusLabel.hidden = false;
  compatStatusLabel.classList.remove("is-ok", "is-warn", "is-danger");
  if (compatStatus.state === "ok") {
    compatStatusLabel.classList.add("is-ok");
  }
  if (compatStatus.state === "warn") {
    compatStatusLabel.classList.add("is-warn");
  }
  if (compatStatus.state === "danger") {
    compatStatusLabel.classList.add("is-danger");
  }
  compatStatusLabel.textContent =
    compatStatus.message || "Compatibilidade: --";
}

async function apiCompatState() {
  if (!USE_AUTH_API) {
    return null;
  }
  return apiRequest("/api/compat");
}

async function checkCompatState(force = false) {
  if (!USE_AUTH_API || !currentUser) {
    setCompatStatus("idle", "Compatibilidade: --");
    return;
  }
  const agora = Date.now();
  if (!force && compatLastCheck && agora - compatLastCheck < COMPAT_CHECK_TTL_MS) {
    return;
  }
  compatLastCheck = agora;
  if (compatStatus.state !== "ok") {
    setCompatStatus("warn", "Compatibilidade: verificando...");
  }
  let remote;
  try {
    remote = await apiCompatState();
  } catch (error) {
    setCompatStatus("warn", "Compatibilidade: offline");
    return;
  }
  const normalized = normalizeCompatState(remote);
  if (normalized.schemaVersion !== COMPAT_SCHEMA_VERSION) {
    setCompatStatus("danger", "Compatibilidade: atualizar");
    showAuthToast("Atualização necessária. Recarregue o sistema.");
    return;
  }
  const local = readCompatState();
  const changed = COMPAT_DATASETS.filter(
    (key) => Number(normalized.datasets[key] || 0) !== Number(local.datasets[key] || 0)
  );
  if (changed.length) {
    setCompatStatus("warn", "Compatibilidade: sincronizando...");
    const tasks = [];
    if (changed.includes("maintenance") && activeProjectId) {
      tasks.push(carregarManutencoesServidor(true));
      tasks.push(loadDashboardSummary(true, { skipSync: true }));
    }
    if (changed.includes("announcements")) {
      tasks.push(carregarAnuncios(true));
    }
    if (changed.includes("feedbacks")) {
      tasks.push(carregarFeedbacks(true));
    }
    if (changed.includes("sstDocs")) {
      tasks.push(carregarSst(true));
    }
    await Promise.allSettled(tasks);
  }
  saveCompatState(normalized);
  setCompatStatus("ok", "Compatibilidade: OK");
}

async function checkForNewBuildAndReload() {
  const currentBuild = getBuildId();
  if (!currentBuild || !window.fetch) {
    return false;
  }
  try {
    const controller = new AbortController();
    const timeout = window.setTimeout(() => controller.abort(), 4000);
    const response = await fetch(window.location.href, {
      cache: "no-store",
      signal: controller.signal,
    });
    window.clearTimeout(timeout);
    if (!response.ok) {
      return false;
    }
    const html = await response.text();
    const match = html.match(/<meta[^>]+name=["']opscope-build["'][^>]+content=["']([^"']+)["']/i);
    const remoteBuild = match ? String(match[1] || "").trim() : "";
    if (remoteBuild && remoteBuild !== currentBuild) {
      setLastSyncAt(Date.now(), "manual");
      showAuthToast("Atualização encontrada. Recarregando...");
      window.location.reload();
      return true;
    }
  } catch (error) {
    return false;
  }
  return false;
}

function initSyncDebug() {
  const params = new URLSearchParams(window.location.search);
  syncDebugEnabled =
    params.get("debugSync") === "1" || localStorage.getItem(SYNC_DEBUG_KEY) === "1";
  if (syncDebugEnabled) {
    logSyncDebug("debug.enabled", { buildId: getBuildId() });
  }
}

function logSyncDebug(event, payload = {}) {
  if (!syncDebugEnabled) {
    return;
  }
  const data = {
    event,
    buildId: getBuildId(),
    projectId: activeProjectId || "",
    userId: currentUser ? currentUser.id : "",
    role: currentUser ? currentUser.role || currentUser.cargo || "" : "",
    timestamp: new Date().toISOString(),
    ...payload,
  };
  console.info("[opscope-sync]", data);
}

function stopSyncPolling() {
  if (syncPollTimer) {
    clearInterval(syncPollTimer);
    syncPollTimer = null;
  }
}

async function runAutoSyncTick() {
  if (!currentUser || syncPollRunning || syncSiteRunning) {
    return;
  }
  syncPollRunning = true;
  try {
    logSyncDebug("poll.tick");
    const tasks = [];
    if (activeProjectId) {
      if (maintenancePendingSync) {
        tasks.push(
          syncMaintenanceNow(manutencoes, true)
            .then(() => carregarManutencoesServidor(true))
            .catch(() => null)
        );
      } else {
        tasks.push(carregarManutencoesServidor(true));
      }
      tasks.push(carregarTemplatesServidor(true));
      tasks.push(loadDashboardSummary(true, { skipSync: true }));
      tasks.push(refreshProjects());
    }
    tasks.push(refreshAccessData({ reason: "poll" }));
    tasks.push(carregarUsuariosServidor());
    tasks.push(carregarAnuncios(true, { auto: true }));
    tasks.push(carregarFeedbacks(true));
    const activeTab = getActiveTabKey();
    if (activeTab && activeTab.startsWith("sst")) {
      tasks.push(carregarSst(true));
    }
    tasks.push(checkCompatState());
    await Promise.allSettled(tasks);
    setLastSyncAt(Date.now(), "auto");
  } finally {
    syncPollRunning = false;
  }
}

function startSyncPolling() {
  if (syncPollTimer || !USE_AUTH_API) {
    return;
  }
  syncPollTimer = setInterval(() => {
    runAutoSyncTick();
  }, SYNC_POLL_MS);
  runAutoSyncTick();
}

function stopSyncEvents() {
  if (syncEventSource) {
    syncEventSource.close();
    syncEventSource = null;
    syncEventProject = "";
  }
}

function handleSyncEvent(eventName, payload = {}) {
  syncLastEventAt = Date.now();
  if (payload.projectId && activeProjectId && payload.projectId !== activeProjectId) {
    return;
  }
  logSyncDebug("event", { name: eventName, payload });
  setLastSyncAt(Date.now(), "auto");
  if (eventName === "maintenance.updated") {
    const removedIds = [];
    if (payload.removedId) {
      removedIds.push(payload.removedId);
    }
    if (Array.isArray(payload.removedIds)) {
      removedIds.push(...payload.removedIds);
    }
    if (removedIds.length) {
      const normalized = removedIds.map((id) => String(id || "").trim()).filter(Boolean);
      if (normalized.length) {
        markMaintenanceDeletedIds(normalized);
        clearMaintenanceDirtyIds(normalized);
        const removedSet = new Set(normalized);
        manutencoes = manutencoes.filter(
          (item) => item && !removedSet.has(String(item.id || ""))
        );
        salvarManutencoes(manutencoes, { skipSync: true, skipDirty: true });
        const serverIds = maintenanceServerIdsByProject.get(activeProjectId || "");
        if (serverIds) {
          removedSet.forEach((id) => serverIds.delete(id));
        }
      }
    }
    carregarManutencoesServidor(true);
    loadDashboardSummary(true, { skipSync: true });
    return;
  }
  if (eventName === "templates.updated") {
    carregarTemplatesServidor(true);
    return;
  }
  if (eventName === "announcements.updated" || eventName === "announcement.created") {
    carregarAnuncios(true, { auto: true });
    return;
  }
  if (eventName === "feedback.created" || eventName === "feedbacks.updated") {
    carregarFeedbacks(true).then(() => {
      atualizarFeedbackBadge();
      renderFeedbackInbox();
      renderFeedbackList();
    });
    return;
  }
  if (eventName === "compat.updated") {
    checkCompatState(true);
    return;
  }
  if (eventName === "sst.docs.updated") {
    carregarSst(true);
    return;
  }
  if (eventName === "projects.updated") {
    refreshProjects();
    return;
  }
  if (eventName === "project.team.updated") {
    carregarEquipeProjeto();
    return;
  }
  if (eventName === "project.equipamentos.updated") {
    carregarEquipamentosProjeto();
    return;
  }
  if (eventName === "access.updated") {
    refreshAccessData({ reason: "sync" });
  }
}

function startSyncEvents() {
  if (!USE_AUTH_API || !currentUser) {
    return;
  }
  const projectId = activeProjectId || "";
  if (syncEventSource && syncEventProject === projectId) {
    return;
  }
  stopSyncEvents();
  const url = projectId
    ? `/api/events?projectId=${encodeURIComponent(projectId)}`
    : "/api/events";
  syncEventProject = projectId;
  const source = new EventSource(url);
  syncEventSource = source;
  source.addEventListener("hello", (event) => {
    let payload = {};
    try {
      payload = JSON.parse(event.data || "{}");
    } catch (error) {
      payload = {};
    }
    logSyncDebug("sse.hello", payload);
  });
  source.addEventListener("ping", () => {
    logSyncDebug("sse.ping");
  });
  [
    "maintenance.updated",
    "templates.updated",
    "projects.updated",
    "project.team.updated",
    "project.equipamentos.updated",
    "access.updated",
    "announcements.updated",
    "announcement.created",
    "feedback.created",
    "feedbacks.updated",
    "sst.docs.updated",
    "compat.updated",
  ].forEach(
    (name) => {
      source.addEventListener(name, (event) => {
        let payload = {};
        try {
          payload = JSON.parse(event.data || "{}");
        } catch (error) {
          payload = {};
        }
        handleSyncEvent(name, payload);
      });
    }
  );
  source.onerror = () => {
    logSyncDebug("sse.error");
    startSyncPolling();
  };
  source.onopen = () => {
    logSyncDebug("sse.open", { projectId });
  };
}

function restartSyncEvents() {
  stopSyncEvents();
  startSyncEvents();
}

function setSyncButtonState(isLoading) {
  if (!btnSyncSite) {
    return;
  }
  btnSyncSite.disabled = isLoading;
  btnSyncSite.classList.toggle("is-loading", isLoading);
  btnSyncSite.setAttribute("aria-busy", String(isLoading));
  const label = btnSyncSite.querySelector("span");
  if (label) {
    label.textContent = isLoading ? "Sincronizando..." : "Sincronizar";
  }
}

async function syncSiteNow() {
  if (syncSiteRunning) {
    return;
  }
  if (!currentUser) {
    showAuthToast("Faça login para sincronizar.");
    return;
  }
  syncSiteRunning = true;
  setSyncButtonState(true);
  mostrarCarregando();
  showAuthToast("Sincronizando atualizações...");
  try {
    const reloaded = await checkForNewBuildAndReload();
    if (reloaded) {
      return;
    }
    if (USE_AUTH_API) {
      await syncMaintenanceNow(manutencoes, true);
      await refreshProjects();
      await refreshAccessData({ force: true });
      await carregarUsuariosServidor();
      await carregarAnuncios(true);
      await carregarFeedbacks(true);
      if (activeProjectId) {
        await Promise.all([carregarEquipeProjeto(), carregarEquipamentosProjeto()]);
        await carregarManutencoesServidor(true);
        await carregarTemplatesServidor(true);
        await carregarPmpDados();
      }
      if (currentUser && canViewSst(currentUser)) {
        await carregarSst(true);
      }
      await loadDashboardSummary(true, { skipSync: true });
      await checkCompatState(true);
      restartSyncEvents();
    } else {
      atualizarSeNecessario();
    }
    renderTudo();
    setLastSyncAt(Date.now(), "manual");
    showAuthToast("Sincronização concluída.");
  } catch (error) {
    showAuthToast("Falha ao sincronizar. Tente novamente.");
  } finally {
    esconderCarregando();
    setSyncButtonState(false);
    syncSiteRunning = false;
  }
}

function setProjectFlag(key, value) {
  const storageKey = getProjectStorageKey(key);
  if (!value) {
    localStorage.removeItem(storageKey);
    return;
  }
  writeJson(storageKey, true);
}

function readProjectFlag(key) {
  return Boolean(readJson(getProjectStorageKey(key), false));
}

function readRecurrenceSuppressions() {
  const stored = readJson(getProjectStorageKey(RECURRENCE_SUPPRESS_KEY), {});
  if (Array.isArray(stored)) {
    return stored.reduce((acc, entry) => {
      const key = String(entry || "").trim();
      if (key) {
        acc[key] = true;
      }
      return acc;
    }, {});
  }
  if (stored && typeof stored === "object") {
    return stored;
  }
  return {};
}

function writeRecurrenceSuppressions(map) {
  const payload = map && typeof map === "object" ? map : {};
  writeJson(getProjectStorageKey(RECURRENCE_SUPPRESS_KEY), payload);
}

function addRecurrenceSuppression(templateId, dateStr) {
  const template = String(templateId || "").trim();
  const date = String(dateStr || "").trim();
  if (!template || !date) {
    return;
  }
  const key = `${template}|${date}`;
  const map = readRecurrenceSuppressions();
  if (!map[key]) {
    map[key] = true;
    writeRecurrenceSuppressions(map);
  }
}

function removeRecurrenceSuppressionsByTemplate(templateId) {
  const template = String(templateId || "").trim();
  if (!template) {
    return;
  }
  const map = readRecurrenceSuppressions();
  let changed = false;
  Object.keys(map).forEach((key) => {
    if (key.startsWith(`${template}|`)) {
      delete map[key];
      changed = true;
    }
  });
  if (changed) {
    writeRecurrenceSuppressions(map);
  }
}

function createLocalSstInspectionsProvider() {
  const readTemplates = () => {
    const list = readJson(SST_TEMPLATES_KEY, []);
    if (!Array.isArray(list)) {
      return [];
    }
    return list.map(normalizeSstChecklistTemplate).filter(Boolean);
  };
  const saveTemplates = (list) => {
    writeJson(SST_TEMPLATES_KEY, list);
    return list;
  };
  const readRuns = () => {
    const list = readJson(SST_INSPECTIONS_KEY, []);
    if (!Array.isArray(list)) {
      return [];
    }
    return list.map(normalizeSstInspectionRun).filter(Boolean);
  };
  const saveRuns = (list) => {
    writeJson(SST_INSPECTIONS_KEY, list);
    return list;
  };
  const readEvidences = () => {
    const list = readJson(SST_EVIDENCES_KEY, []);
    if (!Array.isArray(list)) {
      return [];
    }
    return list.map(normalizeSstEvidence).filter(Boolean);
  };
  const saveEvidences = (list) => {
    writeJson(SST_EVIDENCES_KEY, list);
    return list;
  };
  const readNcs = () => {
    const list = readJson(SST_NCS_KEY, []);
    if (!Array.isArray(list)) {
      return [];
    }
    return list.map(normalizeSstNonconformity).filter(Boolean);
  };
  const saveNcs = (list) => {
    writeJson(SST_NCS_KEY, list);
    return list;
  };

  return {
    listTemplates: async (filters = {}) => {
      let list = readTemplates();
      if (filters.projectId) {
        list = list.filter(
          (item) => !item.projectId || String(item.projectId) === String(filters.projectId)
        );
      }
      if (filters.type) {
        const type = normalizeSstChecklistType(filters.type);
        list = list.filter((item) => normalizeSstChecklistType(item.type) === type);
      }
      if (filters.active !== undefined) {
        list = list.filter((item) => Boolean(item.isActive) === Boolean(filters.active));
      }
      if (filters.q) {
        const term = normalizeSearchValue(filters.q);
        list = list.filter((item) =>
          normalizeSearchValue(item.name).includes(term)
        );
      }
      return list;
    },
    getTemplate: async (id) => {
      if (!id) {
        return null;
      }
      const list = readTemplates();
      return list.find((item) => String(item.id) === String(id)) || null;
    },
    upsertTemplate: async (input) => {
      const templates = readTemplates();
      const now = toIsoUtc(new Date());
      const existingIndex = templates.findIndex((item) => String(item.id) === String(input.id));
      const base = existingIndex >= 0 ? templates[existingIndex] : {};
      const normalized = normalizeSstChecklistTemplate({
        ...base,
        ...input,
        id: base.id || input.id,
        createdAt: base.createdAt || now,
        updatedAt: now,
      });
      if (!normalized) {
        throw new Error("Template invalido.");
      }
      if (existingIndex >= 0) {
        templates[existingIndex] = normalized;
      } else {
        templates.unshift(normalized);
      }
      saveTemplates(templates);
      return normalized;
    },
    deleteTemplate: async (id) => {
      if (!id) {
        return;
      }
      const templates = readTemplates();
      const index = templates.findIndex((item) => String(item.id) === String(id));
      if (index < 0) {
        return;
      }
      templates[index] = {
        ...templates[index],
        isActive: false,
        updatedAt: toIsoUtc(new Date()),
      };
      saveTemplates(templates);
    },
    seedTemplatesIfEmpty: async () => {
      const templates = readTemplates();
      if (templates.length) {
        return { seeded: false, count: templates.length };
      }
      const now = toIsoUtc(new Date());
      const seeds = getSstInspectionSeedTemplates()
        .map((item) =>
          normalizeSstChecklistTemplate({
            ...item,
            createdAt: now,
            updatedAt: now,
            isActive: true,
            createdBy: SYSTEM_USER_ID,
          })
        )
        .filter(Boolean);
      saveTemplates(seeds);
      return { seeded: true, count: seeds.length };
    },
    startRun: async (input) => {
      if (
        !input ||
        !input.templateId ||
        !input.projectId ||
        !input.inspectorId ||
        !input.safetyResponsibleId
      ) {
        throw new Error("Dados insuficientes para iniciar a inspeção.");
      }
      const run = normalizeSstInspectionRun({
        id: criarId(),
        templateId: input.templateId,
        projectId: input.projectId,
        worksiteId: input.worksiteId || "",
        inspectorId: input.inspectorId,
        safetyResponsibleId: input.safetyResponsibleId,
        vehicleId: input.vehicleId || "",
        vehicleSnapshot: input.vehicleSnapshot || null,
        startedAt: input.startedAt || toIsoUtc(new Date()),
        status: "OK",
        score: 100,
        answers: [],
      });
      if (!run) {
        throw new Error("Falha ao iniciar inspeção.");
      }
      const runs = readRuns();
      runs.unshift(run);
      saveRuns(runs);
      return run;
    },
    saveAnswer: async (input) => {
      if (!input || !input.runId || !input.questionId) {
        throw new Error("Resposta invalida.");
      }
      const runs = readRuns();
      const runIndex = runs.findIndex((item) => String(item.id) === String(input.runId));
      if (runIndex < 0) {
        throw new Error("Inspeção não encontrada.");
      }
      const run = runs[runIndex];
      const templates = readTemplates();
      const template = templates.find((item) => item.id === run.templateId) || null;
      const question = template
        ? template.questions.find((q) => String(q.id) === String(input.questionId))
        : null;
      const normalized = normalizeSstInspectionAnswer(
        {
          id: input.id,
          runId: run.id,
          questionId: input.questionId,
          answer: input.answer,
          notes: input.notes || "",
          severitySnapshot: question ? question.severity : input.severitySnapshot,
        },
        run.id,
        question
      );
      if (!normalized) {
        throw new Error("Resposta invalida.");
      }
      const existingIndex = run.answers.findIndex(
        (item) => String(item.questionId) === String(normalized.questionId)
      );
      if (existingIndex >= 0) {
        const existing = run.answers[existingIndex];
        normalized.id = existing.id;
        normalized.evidenceIds = existing.evidenceIds || [];
        run.answers[existingIndex] = normalized;
      } else {
        run.answers.push(normalized);
      }
      runs[runIndex] = run;
      saveRuns(runs);
      return normalized;
    },
    attachEvidence: async (input) => {
      if (!input || !input.ownerType || !input.ownerId || !input.file) {
        throw new Error("Evidencia invalida.");
      }
      const stored = await salvarSstEvidenceArquivo(input.file);
      if (!stored) {
        throw new Error("Falha ao salvar evidencia.");
      }
      const evidence = normalizeSstEvidence({
        id: stored.evidenceId,
        ownerType: input.ownerType,
        ownerId: input.ownerId,
        fileName: stored.name,
        fileType: stored.fileType,
        size: stored.size,
        createdAt: stored.createdAt,
        caption: input.caption || "",
        metadata: input.metadata || null,
        createdBy: currentUser ? currentUser.id : "",
        dataUrl: stored.dataUrl || "",
      });
      if (!evidence) {
        throw new Error("Falha ao registrar evidencia.");
      }
      const evidences = readEvidences();
      evidences.unshift(evidence);
      saveEvidences(evidences);
      if (evidence.ownerType === "INSPECTION_ANSWER") {
        const runs = readRuns();
        const runIndex = runs.findIndex((run) =>
          run.answers.some((answer) => String(answer.id) === String(evidence.ownerId))
        );
        if (runIndex >= 0) {
          const run = runs[runIndex];
          const answerIndex = run.answers.findIndex(
            (answer) => String(answer.id) === String(evidence.ownerId)
          );
          if (answerIndex >= 0) {
            const answer = run.answers[answerIndex];
            const list = Array.isArray(answer.evidenceIds) ? answer.evidenceIds.slice() : [];
            if (!list.includes(evidence.id)) {
              list.push(evidence.id);
              run.answers[answerIndex] = { ...answer, evidenceIds: list };
              runs[runIndex] = run;
              saveRuns(runs);
            }
          }
        }
      }
      return evidence;
    },
    listEvidences: async (input) => {
      const evidences = readEvidences();
      if (!input || (!input.ownerType && !input.ownerId)) {
        return evidences;
      }
      return evidences.filter((evidence) => {
        if (input.ownerType && evidence.ownerType !== input.ownerType) {
          return false;
        }
        if (input.ownerId && String(evidence.ownerId) !== String(input.ownerId)) {
          return false;
        }
        return true;
      });
    },
    finishRun: async (input) => {
      if (!input || !input.runId) {
        throw new Error("Inspeção invalida.");
      }
      const runs = readRuns();
      const index = runs.findIndex((run) => String(run.id) === String(input.runId));
      if (index < 0) {
        throw new Error("Inspeção não encontrada.");
      }
      const run = runs[index];
      const score = calculateSstScore(run.answers);
      const status = calculateSstStatus(run.answers);
      const updated = {
        ...run,
        score,
        status,
        notes: input.notes !== undefined ? input.notes : run.notes,
        finishedAt: toIsoUtc(new Date()),
      };
      runs[index] = updated;
      saveRuns(runs);
      return updated;
    },
    generateNcsFromRun: async (input) => {
      if (!input || !input.runId) {
        throw new Error("Inspeção inválida.");
      }
      const include = Array.isArray(input.includeSeverities) && input.includeSeverities.length
        ? input.includeSeverities
        : ["HIGH", "CRITICAL"];
      const includeSet = new Set(include.map(normalizeSstSeverity));
      const runs = readRuns();
      const run = runs.find((item) => String(item.id) === String(input.runId));
      if (!run) {
        throw new Error("Inspeção não encontrada.");
      }
      const templates = readTemplates();
      const template = templates.find((item) => item.id === run.templateId);
      const existing = readNcs();
      const created = [];
      run.answers.forEach((answer) => {
        if (!answer || answer.answer !== "FAIL") {
          return;
        }
        const severity = normalizeSstSeverity(answer.severitySnapshot);
        if (!includeSet.has(severity)) {
          return;
        }
        const question = template
          ? template.questions.find((q) => String(q.id) === String(answer.questionId))
          : null;
        const title = `${template ? template.name : "Checklist"} - ${
          question ? question.text : "Item"
        }`.slice(0, 140);
        const already = existing.find(
          (nc) => nc.sourceId === run.id && nc.title === title
        );
        if (already) {
          return;
        }
        const novo = normalizeSstNonconformity({
          projectId: run.projectId,
          worksiteId: run.worksiteId || "",
          sourceType: "INSPECTION",
          sourceId: run.id,
          severity,
          title,
          description: `${answer.notes || ""} (gerado por inspeção)`.trim(),
          status: "OPEN",
          dueDate: getSstDueDateForSeverity(severity),
          createdBy: currentUser ? currentUser.id : "",
          updatedBy: currentUser ? currentUser.id : "",
          createdAt: toIsoUtc(new Date()),
          updatedAt: toIsoUtc(new Date()),
          category: template ? template.type : "",
          history: appendSstNcHistory({ history: [] }, "CREATE", "NC gerada por inspecao"),
        });
        if (novo) {
          created.push(novo);
          existing.unshift(novo);
        }
      });
      if (created.length) {
        saveNcs(existing);
      }
      return created;
    },
    createNc: async (payload) => {
      const list = readNcs();
      const now = toIsoUtc(new Date());
      const normalized = normalizeSstNonconformity({
        ...payload,
        id: payload && payload.id ? payload.id : criarId(),
        createdAt: payload && payload.createdAt ? payload.createdAt : now,
        updatedAt: now,
      });
      if (!normalized) {
        throw new Error("NC invalida.");
      }
      list.unshift(normalized);
      saveNcs(list);
      return normalized;
    },
    updateNc: async (id, patch) => {
      if (!id) {
        throw new Error("NC invalida.");
      }
      const list = readNcs();
      const index = list.findIndex((item) => String(item.id) === String(id));
      if (index < 0) {
        throw new Error("NC nao encontrada.");
      }
      const now = toIsoUtc(new Date());
      const normalized = normalizeSstNonconformity({
        ...list[index],
        ...patch,
        updatedAt: patch && patch.updatedAt ? patch.updatedAt : now,
      });
      if (!normalized) {
        throw new Error("NC invalida.");
      }
      list[index] = normalized;
      saveNcs(list);
      return normalized;
    },
    listNcs: async (filters = {}) => {
      let list = readNcs();
      if (filters.projectId) {
        list = list.filter((nc) => String(nc.projectId) === String(filters.projectId));
      }
      if (filters.status) {
        list = list.filter(
          (nc) => String(nc.status).toUpperCase() === String(filters.status).toUpperCase()
        );
      }
      if (filters.severity) {
        const sev = normalizeSstSeverity(filters.severity);
        list = list.filter((nc) => normalizeSstSeverity(nc.severity) === sev);
      }
      if (filters.q) {
        const term = normalizeSearchValue(filters.q);
        list = list.filter(
          (nc) =>
            normalizeSearchValue(nc.title).includes(term) ||
            normalizeSearchValue(nc.description).includes(term)
        );
      }
      return list;
    },
    listRuns: async (filters = {}) => {
      let list = readRuns();
      const templates = readTemplates();
      const templateMap = new Map(templates.map((t) => [String(t.id), t]));
      let summary = list.map((run) => {
        const template = templateMap.get(String(run.templateId));
        const stats = buildSstFailStats(run.answers);
        return {
          id: run.id,
          startedAt: run.startedAt,
          finishedAt: run.finishedAt,
          projectId: run.projectId,
          worksiteId: run.worksiteId || "",
          templateId: run.templateId,
          templateName: template ? template.name : run.templateId,
          inspectorId: run.inspectorId,
          safetyResponsibleId: run.safetyResponsibleId || "",
          vehicleId: run.vehicleId || "",
          vehicleSnapshot: run.vehicleSnapshot || null,
          score: run.score,
          status: normalizeSstInspectionStatus(run.status),
          failCount: stats.total,
          criticalFailCount: stats.CRITICAL,
          notes: run.notes || "",
        };
      });
      if (filters.projectId) {
        summary = summary.filter(
          (run) => String(run.projectId) === String(filters.projectId)
        );
      }
      if (filters.templateId) {
        summary = summary.filter(
          (run) => String(run.templateId) === String(filters.templateId)
        );
      }
      if (filters.status) {
        const status = normalizeSstInspectionStatus(filters.status);
        summary = summary.filter((run) => normalizeSstInspectionStatus(run.status) === status);
      }
      if (filters.from) {
        const fromDate = parseDate(filters.from);
        summary = summary.filter((run) => {
          const when = parseTimestamp(run.startedAt);
          return when && fromDate ? when >= fromDate : true;
        });
      }
      if (filters.to) {
        const toDate = parseDate(filters.to);
        summary = summary.filter((run) => {
          const when = parseTimestamp(run.startedAt);
          return when && toDate ? when <= endOfDay(toDate) : true;
        });
      }
      if (filters.q) {
        const term = normalizeSearchValue(filters.q);
        summary = summary.filter(
          (run) =>
            normalizeSearchValue(run.templateName).includes(term) ||
            normalizeSearchValue(run.notes).includes(term)
        );
      }
      return summary.sort((a, b) => new Date(b.startedAt) - new Date(a.startedAt));
    },
    getRunDetails: async (runId) => {
      if (!runId) {
        return null;
      }
      const runs = readRuns();
      const run = runs.find((item) => String(item.id) === String(runId));
      if (!run) {
        return null;
      }
      const templates = readTemplates();
      const template = templates.find((item) => item.id === run.templateId) || null;
      const evidences = readEvidences();
      const evidencesByAnswerId = {};
      evidences.forEach((evidence) => {
        if (evidence.ownerType !== "INSPECTION_ANSWER") {
          return;
        }
        if (!evidencesByAnswerId[evidence.ownerId]) {
          evidencesByAnswerId[evidence.ownerId] = [];
        }
        evidencesByAnswerId[evidence.ownerId].push(evidence);
      });
      const runEvidences = evidences.filter(
        (evidence) => evidence.ownerType === "INSPECTION_RUN" && evidence.ownerId === run.id
      );
      const failStats = buildSstFailStats(run.answers);
      const ncs = readNcs().filter((nc) => String(nc.sourceId) === String(run.id));
      return {
        ...run,
        template,
        answers: run.answers || [],
        evidencesByAnswerId,
        runEvidences,
        failStats,
        ncs,
      };
    },
  };
}

function createLocalProvider() {
  const readSstDocs = () => {
    let list = readJson(SST_DOCS_KEY, []);
    if (!Array.isArray(list)) {
      list = [];
    }
    return list.map(normalizeSstDoc).filter(Boolean);
  };
  const saveSstDocs = (list) => {
    writeJson(SST_DOCS_KEY, list);
    return list;
  };
  const sstInspections = createLocalSstInspectionsProvider();
  return {
    sstDocs: {
      list: async (filters = {}) => {
        let list = readSstDocs();
        if (filters && filters.projectId) {
          list = list.filter((doc) => String(doc.projectId || "") === String(filters.projectId));
        }
        if (filters && filters.status) {
          const status = String(filters.status).toUpperCase();
          list = list.filter((doc) => String(doc.status || "").toUpperCase() === status);
        }
        return list;
      },
      create: async (payload) => {
        const list = readSstDocs();
        const item = normalizeSstDoc(payload);
        if (!item) {
          return { item: null, list };
        }
        const updated = [item].concat(list);
        return { item, list: saveSstDocs(updated) };
      },
      update: async (id, patch) => {
        const list = readSstDocs();
        const index = list.findIndex((doc) => String(doc.id) === String(id));
        if (index < 0) {
          return { item: null, list };
        }
        const updatedItem = normalizeSstDoc({ ...list[index], ...patch, id: list[index].id });
        list[index] = updatedItem;
        return { item: updatedItem, list: saveSstDocs(list) };
      },
      upsertByRelatedId: async (payload) => {
        const list = readSstDocs();
        const item = normalizeSstDoc(payload);
        if (!item) {
          return { item: null, list };
        }
        let index = -1;
        if (item.relatedId) {
          index = list.findIndex(
            (doc) => doc.relatedId && String(doc.relatedId) === String(item.relatedId)
          );
        }
        if (index >= 0) {
          list[index] = {
            ...list[index],
            ...item,
            status: "PENDENTE",
            reviewedAt: "",
            reviewedBy: "",
            reviewNotes: "",
            correctionInstructions: "",
            notifiedAt: "",
            updatedAt: item.createdAt || list[index].createdAt,
          };
        } else {
          list.unshift(item);
          index = 0;
        }
        return { item: list[index], list: saveSstDocs(list) };
      },
    },
    sstInspections,
    vehicles: {
      listVehicles: async (filters = {}) => listVehiclesFromDb(filters),
      getVehicle: async (id) => getVehicleFromDb(id),
      upsertVehicle: async (input) => upsertVehicleToDb(input || {}),
      deleteVehicle: async (id) => softDeleteVehicle(id),
    },
    roles: {
      listRoles: async (q) => listRolesFromDb(q),
      getRole: async (id) => getRoleFromDb(id),
      upsertRole: async (input) => upsertRoleToDb(input || {}),
      deleteRole: async (id) => deleteRoleFromDb(id),
      seedDefaultRolesIfEmpty: async () => seedDefaultRolesIfEmpty(),
    },
    authAdmin: {
      listUsers: async (filters = {}) => listUsersFromDb(filters),
      getUser: async (id) => getUserFromDb(id),
      createUser: async (input) => createUserToDb(input || {}),
      updateUser: async (input) => updateUserToDb(input || {}),
      deleteUser: async (id) => deleteUserFromDb(id),
      resetPassword: async (input) => resetPasswordForUser(input || {}),
      deactivateUser: async (id) => setUserStatus(id, "INATIVO"),
      activateUser: async (id) => setUserStatus(id, "ATIVO"),
    },
  };
}

function createApiProvider(fallback) {
  const fallbackProvider = fallback || createLocalProvider();
  const buildQuery = (params) =>
    Object.entries(params || {})
      .filter(([, value]) => value !== undefined && value !== null && value !== "")
      .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
      .join("&");

  const normalizeList = (data) => {
    if (!data) {
      return [];
    }
    const list =
      (Array.isArray(data.docs) && data.docs) ||
      (Array.isArray(data.items) && data.items) ||
      (Array.isArray(data.sstDocs) && data.sstDocs) ||
      [];
    return list.map(normalizeSstDoc).filter(Boolean);
  };

  const pickItem = (data, fallbackItem) => {
    if (!data) {
      return fallbackItem || null;
    }
    const item = data.doc || data.item || data.sstDoc || fallbackItem || null;
    return item ? normalizeSstDoc(item) : null;
  };

  const provider = {
    sstDocs: {},
    sstInspections: {},
    vehicles: {},
    roles: {},
    authAdmin: {},
  };

  provider.sstDocs.list = async (filters = {}) => {
    try {
      const query = buildQuery(filters);
      const data = await apiRequest(`/api/sst/docs${query ? `?${query}` : ""}`);
      return normalizeList(data);
    } catch (error) {
      return fallbackProvider.sstDocs.list(filters);
    }
  };

  provider.sstDocs.create = async (payload) => {
    try {
      const data = await apiRequest("/api/sst/docs", {
        method: "POST",
        body: JSON.stringify(payload || {}),
      });
      const item = pickItem(data, payload);
      const list = await provider.sstDocs.list();
      return { item, list };
    } catch (error) {
      return fallbackProvider.sstDocs.create(payload);
    }
  };

  provider.sstDocs.update = async (id, patch) => {
    if (!id) {
      return { item: null, list: await fallbackProvider.sstDocs.list() };
    }
    try {
      const data = await apiRequest(`/api/sst/docs/${encodeURIComponent(id)}`, {
        method: "PUT",
        body: JSON.stringify(patch || {}),
      });
      const item = pickItem(data, patch);
      const list = await provider.sstDocs.list();
      return { item, list };
    } catch (error) {
      return fallbackProvider.sstDocs.update(id, patch);
    }
  };

  provider.sstDocs.upsertByRelatedId = async (payload) => {
    if (!payload || !payload.relatedId) {
      return provider.sstDocs.create(payload);
    }
    try {
      const existing = await provider.sstDocs.list({ relatedId: payload.relatedId });
      if (existing && existing.length) {
        return provider.sstDocs.update(existing[0].id, payload);
      }
      return provider.sstDocs.create(payload);
    } catch (error) {
      return fallbackProvider.sstDocs.upsertByRelatedId(payload);
    }
  };

  provider.sstInspections.listTemplates = async (filters = {}) => {
    if (!USE_SST_INSPECTIONS_API) {
      return fallbackProvider.sstInspections.listTemplates(filters);
    }
    try {
      const query = buildQuery(filters);
      const data = await apiRequest(`/api/sst/inspection-templates${query ? `?${query}` : ""}`);
      const list = Array.isArray(data.templates) ? data.templates : [];
      return list.map(normalizeSstChecklistTemplate).filter(Boolean);
    } catch (error) {
      return fallbackProvider.sstInspections.listTemplates(filters);
    }
  };

  provider.sstInspections.getTemplate = async (id) => {
    if (!USE_SST_INSPECTIONS_API) {
      return fallbackProvider.sstInspections.getTemplate(id);
    }
    return fallbackProvider.sstInspections.getTemplate(id);
  };

  provider.sstInspections.upsertTemplate = async (input) => {
    if (!USE_SST_INSPECTIONS_API) {
      return fallbackProvider.sstInspections.upsertTemplate(input);
    }
    try {
      if (input && input.id) {
        const data = await apiRequest(`/api/sst/inspection-templates/${encodeURIComponent(input.id)}`, {
          method: "PUT",
          body: JSON.stringify(input || {}),
        });
        return normalizeSstChecklistTemplate(data.template || data.item || input);
      }
      const data = await apiRequest("/api/sst/inspection-templates", {
        method: "POST",
        body: JSON.stringify(input || {}),
      });
      return normalizeSstChecklistTemplate(data.template || data.item || input);
    } catch (error) {
      return fallbackProvider.sstInspections.upsertTemplate(input);
    }
  };

  provider.sstInspections.deleteTemplate = async (id) => {
    if (!USE_SST_INSPECTIONS_API) {
      return fallbackProvider.sstInspections.deleteTemplate(id);
    }
    try {
      if (id) {
        await apiRequest(`/api/sst/inspection-templates/${encodeURIComponent(id)}`, {
          method: "DELETE",
        });
      }
      return;
    } catch (error) {
      return fallbackProvider.sstInspections.deleteTemplate(id);
    }
  };

  provider.sstInspections.seedTemplatesIfEmpty = async () => {
    return fallbackProvider.sstInspections.seedTemplatesIfEmpty();
  };


  provider.sstInspections.startRun = async (input) => {
    return fallbackProvider.sstInspections.startRun(input);
  };

  provider.sstInspections.saveAnswer = async (input) => {
    return fallbackProvider.sstInspections.saveAnswer(input);
  };

  provider.sstInspections.attachEvidence = async (input) => {
    return fallbackProvider.sstInspections.attachEvidence(input);
  };

  provider.sstInspections.listEvidences = async (input) => {
    return fallbackProvider.sstInspections.listEvidences(input);
  };

  provider.sstInspections.finishRun = async (input) => {
    return fallbackProvider.sstInspections.finishRun(input);
  };

  provider.sstInspections.generateNcsFromRun = async (input) => {
    return fallbackProvider.sstInspections.generateNcsFromRun(input);
  };

  provider.sstInspections.listNcs = async (filters = {}) => {
    return fallbackProvider.sstInspections.listNcs(filters);
  };

  provider.sstInspections.createNc = async (payload) => {
    return fallbackProvider.sstInspections.createNc(payload);
  };

  provider.sstInspections.updateNc = async (id, patch) => {
    return fallbackProvider.sstInspections.updateNc(id, patch);
  };

  provider.sstInspections.listRuns = async (filters = {}) => {
    return fallbackProvider.sstInspections.listRuns(filters);
  };

  provider.sstInspections.getRunDetails = async (runId) => {
    return fallbackProvider.sstInspections.getRunDetails(runId);
  };

  provider.vehicles.listVehicles = async (filters = {}) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.vehicles.listVehicles(filters);
    }
    try {
      const query = buildQuery(filters);
      const data = await apiRequest(`/api/sst/vehicles${query ? `?${query}` : ""}`);
      const list = Array.isArray(data.vehicles) ? data.vehicles : [];
      return list.map(normalizeSstVehicle).filter(Boolean);
    } catch (error) {
      return fallbackProvider.vehicles.listVehicles(filters);
    }
  };

  provider.vehicles.getVehicle = async (id) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.vehicles.getVehicle(id);
    }
    if (!id) {
      return null;
    }
    try {
      const data = await apiRequest(`/api/sst/vehicles/${encodeURIComponent(id)}`);
      const vehicle = data.vehicle || data.item || data;
      return normalizeSstVehicle(vehicle);
    } catch (error) {
      return fallbackProvider.vehicles.getVehicle(id);
    }
  };

  provider.vehicles.upsertVehicle = async (input) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.vehicles.upsertVehicle(input);
    }
    try {
      const payload = input || {};
      if (payload.id) {
        const data = await apiRequest(`/api/sst/vehicles/${encodeURIComponent(payload.id)}`, {
          method: "PUT",
          body: JSON.stringify(payload),
        });
        return normalizeSstVehicle(data.vehicle || data.item || payload);
      }
      const data = await apiRequest("/api/sst/vehicles", {
        method: "POST",
        body: JSON.stringify(payload),
      });
      return normalizeSstVehicle(data.vehicle || data.item || payload);
    } catch (error) {
      return fallbackProvider.vehicles.upsertVehicle(input);
    }
  };

  provider.vehicles.deleteVehicle = async (id) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.vehicles.deleteVehicle(id);
    }
    if (!id) {
      return;
    }
    try {
      await apiRequest(`/api/sst/vehicles/${encodeURIComponent(id)}`, { method: "DELETE" });
      return;
    } catch (error) {
      return fallbackProvider.vehicles.deleteVehicle(id);
    }
  };

  provider.roles.listRoles = async (q) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.roles.listRoles(q);
    }
    try {
      const query = buildQuery({ q });
      const data = await apiRequest(`/api/admin/access/roles${query ? `?${query}` : ""}`);
      const list = Array.isArray(data.roles) ? data.roles : [];
      return list.map(normalizeAccessRoleRecord).filter(Boolean);
    } catch (error) {
      return fallbackProvider.roles.listRoles(q);
    }
  };

  provider.roles.getRole = async (id) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.roles.getRole(id);
    }
    if (!id) {
      return null;
    }
    try {
      const data = await apiRequest(`/api/admin/access/roles/${encodeURIComponent(id)}`);
      return normalizeAccessRoleRecord(data.role || data.item || data);
    } catch (error) {
      return fallbackProvider.roles.getRole(id);
    }
  };

  provider.roles.upsertRole = async (input) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.roles.upsertRole(input);
    }
    try {
      const payload = input || {};
      const id = payload.id ? String(payload.id) : "";
      const url = id
        ? `/api/admin/access/roles/${encodeURIComponent(id)}`
        : "/api/admin/access/roles";
      const method = id ? "PUT" : "POST";
      const data = await apiRequest(url, { method, body: JSON.stringify(payload) });
      return normalizeAccessRoleRecord(data.role || data.item || payload);
    } catch (error) {
      return fallbackProvider.roles.upsertRole(input);
    }
  };

  provider.roles.deleteRole = async (id) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.roles.deleteRole(id);
    }
    if (!id) {
      return;
    }
    try {
      await apiRequest(`/api/admin/access/roles/${encodeURIComponent(id)}`, { method: "DELETE" });
      return;
    } catch (error) {
      return fallbackProvider.roles.deleteRole(id);
    }
  };

  provider.roles.seedDefaultRolesIfEmpty = async () => {
    if (!USE_AUTH_API) {
      return fallbackProvider.roles.seedDefaultRolesIfEmpty();
    }
    try {
      return await apiRequest("/api/admin/access/roles/seed", { method: "POST", body: "{}" });
    } catch (error) {
      return fallbackProvider.roles.seedDefaultRolesIfEmpty();
    }
  };

  provider.authAdmin.listUsers = async (filters = {}) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.authAdmin.listUsers(filters);
    }
    try {
      const query = buildQuery(filters);
      const data = await apiRequest(`/api/admin/access/users${query ? `?${query}` : ""}`);
      const list = Array.isArray(data.users) ? data.users : [];
      return list.map(normalizeAccessUserRecord).filter(Boolean);
    } catch (error) {
      return fallbackProvider.authAdmin.listUsers(filters);
    }
  };

  provider.authAdmin.getUser = async (id) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.authAdmin.getUser(id);
    }
    if (!id) {
      return null;
    }
    try {
      const data = await apiRequest(`/api/admin/access/users/${encodeURIComponent(id)}`);
      return normalizeAccessUserRecord(data.user || data.item || data);
    } catch (error) {
      return fallbackProvider.authAdmin.getUser(id);
    }
  };

  provider.authAdmin.createUser = async (input) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.authAdmin.createUser(input);
    }
    const payload = input || {};
    try {
      const data = await apiRequest("/api/admin/access/users", {
        method: "POST",
        body: JSON.stringify(payload),
      });
      const user = normalizeAccessUserRecord(data.user || data.item || payload);
      return { user, generatedPassword: data.generatedPassword };
    } catch (error) {
      return fallbackProvider.authAdmin.createUser(input);
    }
  };

  provider.authAdmin.updateUser = async (input) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.authAdmin.updateUser(input);
    }
    const payload = input || {};
    const id = payload.id ? String(payload.id) : "";
    if (!id) {
      return fallbackProvider.authAdmin.updateUser(input);
    }
    try {
      const data = await apiRequest(`/api/admin/access/users/${encodeURIComponent(id)}`, {
        method: "PUT",
        body: JSON.stringify(payload),
      });
      return normalizeAccessUserRecord(data.user || data.item || payload);
    } catch (error) {
      return fallbackProvider.authAdmin.updateUser(input);
    }
  };

  provider.authAdmin.deleteUser = async (id) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.authAdmin.deleteUser(id);
    }
    if (!id) {
      return null;
    }
    try {
      await apiRequest(`/api/admin/access/users/${encodeURIComponent(id)}`, { method: "DELETE" });
      return true;
    } catch (error) {
      return fallbackProvider.authAdmin.deleteUser(id);
    }
  };

  provider.authAdmin.resetPassword = async (input) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.authAdmin.resetPassword(input);
    }
    const payload = input || {};
    const id = payload.id ? String(payload.id) : "";
    if (!id) {
      return fallbackProvider.authAdmin.resetPassword(input);
    }
    try {
      const data = await apiRequest(`/api/admin/access/users/${encodeURIComponent(id)}/reset-password`, {
        method: "POST",
        body: JSON.stringify(payload),
      });
      const user = normalizeAccessUserRecord(data.user || data.item || payload);
      return { user, generatedPassword: data.generatedPassword };
    } catch (error) {
      return fallbackProvider.authAdmin.resetPassword(input);
    }
  };

  provider.authAdmin.deactivateUser = async (id) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.authAdmin.deactivateUser(id);
    }
    if (!id) {
      return null;
    }
    try {
      const data = await apiRequest(`/api/admin/access/users/${encodeURIComponent(id)}/status`, {
        method: "PATCH",
        body: JSON.stringify({ status: "INATIVO" }),
      });
      return normalizeAccessUserRecord(data.user || data.item || data);
    } catch (error) {
      return fallbackProvider.authAdmin.deactivateUser(id);
    }
  };

  provider.authAdmin.activateUser = async (id) => {
    if (!USE_AUTH_API) {
      return fallbackProvider.authAdmin.activateUser(id);
    }
    if (!id) {
      return null;
    }
    try {
      const data = await apiRequest(`/api/admin/access/users/${encodeURIComponent(id)}/status`, {
        method: "PATCH",
        body: JSON.stringify({ status: "ATIVO" }),
      });
      return normalizeAccessUserRecord(data.user || data.item || data);
    } catch (error) {
      return fallbackProvider.authAdmin.activateUser(id);
    }
  };

  return provider;
}

const localProvider = createLocalProvider();
const dataProvider = createApiProvider(localProvider);

function getProjectStorageKey(baseKey) {
  if (!activeProjectId) {
    return baseKey;
  }
  return `${baseKey}.${activeProjectId}`;
}

function isProjectStorageKey(eventKey, baseKey) {
  if (!eventKey) {
    return false;
  }
  return eventKey === baseKey || eventKey.startsWith(`${baseKey}.`);
}

const API_BASE = "";
const USE_AUTH_API = true;
const USE_SST_INSPECTIONS_API = true;
const STRICT_SERVER_SYNC = USE_AUTH_API;
const API_TIMEOUT_MS = 15000;
const AVATAR_MAX_BYTES = 10 * 1024 * 1024;
const AVATAR_ALLOWED_TYPES = ["image/png", "image/jpeg", "image/webp"];
const FILE_MAX_BYTES = 10 * 1024 * 1024;
const FILE_ALLOWED_TYPES = [
  "application/pdf",
  "image/png",
  "image/jpeg",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
];
let pendingAvatarDataUrl = "";
let avatarUploadBound = false;
let lastFocusMaintenanceId = "";
let pendingVerificationEmail = "";
let passwordResetCooldownTimer = null;
let passwordResetCooldownUntil = 0;
let passwordResetCodeSent = false;
let passwordResetCodeValidated = false;

async function apiRequest(path, options = {}) {
  const controller = typeof AbortController !== "undefined" ? new AbortController() : null;
  let timeoutId = null;
  if (controller) {
    timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT_MS);
  }
  let response;
  try {
    const method = String(options.method || "GET").toUpperCase();
    const cache = options.cache || (method === "GET" ? "no-store" : undefined);
    response = await fetch(`${API_BASE}${path}`, {
      credentials: "include",
      headers: {
        "Content-Type": "application/json",
        ...(options.headers || {}),
      },
      signal: controller ? controller.signal : undefined,
      cache,
      ...options,
    });
  } catch (error) {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (error && error.name === "AbortError") {
      throw new Error("Tempo limite da requisicao.");
    }
    throw error;
  } finally {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
  const data = await response.json().catch(() => ({}));
  if (!response.ok) {
    const message = data && data.message ? data.message : "Falha na autenticação.";
    const error = new Error(message);
    error.status = response.status;
    error.data = data;
    throw error;
  }
  return data;
}

function getDisplayName(user) {
  const raw = user && user.name ? String(user.name).trim() : "";
  if (!raw) {
    return user && user.username ? user.username : "-";
  }
  return raw.replace(/\s*\([^)]*\)\s*$/, "").trim() || raw;
}

function getUserMenuRoleText(user) {
  if (!user) {
    return "Perfil";
  }
  const roleLabel = getRoleLabel(user);
  const cargo = String(user.cargo || "").trim();
  if (cargo && roleLabel) {
    return `${cargo} | ${roleLabel}`;
  }
  return cargo || roleLabel || "Perfil";
}

function applyAvatarToElement(element, url) {
  if (!element) {
    return;
  }
  if (url) {
    element.style.backgroundImage = `url("${url}")`;
    element.classList.add("has-photo");
    return;
  }
  element.style.backgroundImage = "";
  element.classList.remove("has-photo");
}

function getAvatarUrl(user) {
  if (!user || !user.avatarUrl) {
    return "";
  }
  if (user.avatarUpdatedAt) {
    const stamp = new Date(user.avatarUpdatedAt).getTime();
    return `${user.avatarUrl}?v=${Number.isFinite(stamp) ? stamp : Date.now()}`;
  }
  return user.avatarUrl;
}

function setAvatarError(message) {
  if (!perfilAvatarErro) {
    return;
  }
  perfilAvatarErro.textContent = message || "";
  perfilAvatarErro.hidden = !message;
}

function setPerfilSaveMessage(message, error = false) {
  const saveMsg = document.getElementById("perfilSaveMsg");
  if (!saveMsg) {
    return;
  }
  saveMsg.textContent = message || "";
  saveMsg.hidden = !message;
  saveMsg.classList.toggle("mensagem--erro", error);
}

function isProfileEditMode() {
  const params = new URLSearchParams(window.location.search);
  return params.get("edit") === "1";
}

function setProfileEditParam(isEdit) {
  const url = new URL(window.location.href);
  if (isEdit) {
    url.searchParams.set("edit", "1");
  } else {
    url.searchParams.delete("edit");
  }
  window.history.replaceState(null, "", url.toString());
}

function setProfileTargetUserId(userId) {
  profileViewingUserId = userId ? String(userId) : "";
}

function clearProfileTargetUserId() {
  profileViewingUserId = "";
}

function getProfileTargetUser() {
  const desiredId = String(profileViewingUserId || "").trim();
  if (!desiredId) {
    return currentUser;
  }
  const pool = accessUsers && accessUsers.length ? accessUsers : users;
  const found = (pool || []).find((item) => String(item.id) === desiredId);
  if (found) {
    return found;
  }
  if (currentUser && String(currentUser.id) === desiredId) {
    return currentUser;
  }
  profileViewingUserId = "";
  return currentUser;
}

function openProfileForUser(userId, options = {}) {
  if (!currentUser) {
    return;
  }
  const targetId = userId ? String(userId) : currentUser.id;
  setProfileTargetUserId(targetId);
  abrirPainelComCarregamento("perfil");
  if (options.edit) {
    setProfileEditParam(true);
    window.setTimeout(() => {
      ativarModoEdicaoPerfil();
    }, 0);
  } else {
    setProfileEditParam(false);
  }
  renderPerfil();
}

function mountProfileTemplate(template, mount) {
  if (!template || !mount || mount.childElementCount) {
    return;
  }
  mount.innerHTML = "";
  mount.appendChild(template.content.cloneNode(true));
}

function unmountProfileTemplate(mount) {
  if (!mount) {
    return;
  }
  mount.textContent = "";
}

function mountProfileEdit() {
  mountProfileTemplate(perfilEditTemplate, perfilEditMount);
}

function unmountProfileEdit() {
  unmountProfileTemplate(perfilEditMount);
}

function mountProfileAvatarActions() {
  mountProfileTemplate(perfilAvatarTemplate, perfilAvatarActionsMount);
}

function unmountProfileAvatarActions() {
  unmountProfileTemplate(perfilAvatarActionsMount);
}

function formatProfileValue(value) {
  const texto = String(value || "").trim();
  return texto ? texto : "N\u00e3o informado";
}

const PROFILE_THEME_OPTIONS = new Set(["dark", "dark-contrast"]);
const PROFILE_DENSITY_OPTIONS = new Set(["comfortable", "compact"]);
const PROFILE_LANGUAGE_OPTIONS = new Set(["pt-br", "en", "es"]);
const PROFILE_TIMEZONE_OPTIONS = new Set([
  "America/Sao_Paulo",
  "America/Manaus",
  "America/Fortaleza",
]);
const PROFILE_DASHBOARD_OPTIONS = new Set(["inicio", "programacao", "desempenho"]);
const DEFAULT_PROFILE_PREFERENCES = {
  theme: "dark",
  density: "comfortable",
  language: "pt-br",
  timezone: "America/Sao_Paulo",
  dashboard: "inicio",
  notifications: {
    assignedOs: true,
    dueSoon: true,
    criticalAlerts: false,
    weeklyReports: true,
  },
};
const DEFAULT_PROFILE_SECURITY = {
  twoFactorEnabled: false,
  blockUnknownDevices: true,
};

function normalizeProfilePreferences(value) {
  const input = value && typeof value === "object" ? value : {};
  const notifications =
    input.notifications && typeof input.notifications === "object" ? input.notifications : {};
  return {
    theme: PROFILE_THEME_OPTIONS.has(input.theme)
      ? input.theme
      : DEFAULT_PROFILE_PREFERENCES.theme,
    density: PROFILE_DENSITY_OPTIONS.has(input.density)
      ? input.density
      : DEFAULT_PROFILE_PREFERENCES.density,
    language: PROFILE_LANGUAGE_OPTIONS.has(input.language)
      ? input.language
      : DEFAULT_PROFILE_PREFERENCES.language,
    timezone: PROFILE_TIMEZONE_OPTIONS.has(input.timezone)
      ? input.timezone
      : DEFAULT_PROFILE_PREFERENCES.timezone,
    dashboard: PROFILE_DASHBOARD_OPTIONS.has(input.dashboard)
      ? input.dashboard
      : DEFAULT_PROFILE_PREFERENCES.dashboard,
    notifications: {
      assignedOs:
        typeof notifications.assignedOs === "boolean"
          ? notifications.assignedOs
          : DEFAULT_PROFILE_PREFERENCES.notifications.assignedOs,
      dueSoon:
        typeof notifications.dueSoon === "boolean"
          ? notifications.dueSoon
          : DEFAULT_PROFILE_PREFERENCES.notifications.dueSoon,
      criticalAlerts:
        typeof notifications.criticalAlerts === "boolean"
          ? notifications.criticalAlerts
          : DEFAULT_PROFILE_PREFERENCES.notifications.criticalAlerts,
      weeklyReports:
        typeof notifications.weeklyReports === "boolean"
          ? notifications.weeklyReports
          : DEFAULT_PROFILE_PREFERENCES.notifications.weeklyReports,
    },
  };
}

function normalizeProfileSecurity(value) {
  const input = value && typeof value === "object" ? value : {};
  return {
    twoFactorEnabled: Boolean(input.twoFactorEnabled),
    blockUnknownDevices:
      typeof input.blockUnknownDevices === "boolean"
        ? input.blockUnknownDevices
        : DEFAULT_PROFILE_SECURITY.blockUnknownDevices,
  };
}

let activeProfileTab = "overview";

function setProfileTab(tabId) {
  if (!tabId) {
    return;
  }
  activeProfileTab = tabId;
  profileTabs.forEach((tab) => {
    const isActive = tab.dataset.profileTab === tabId;
    tab.classList.toggle("is-active", isActive);
    tab.setAttribute("aria-selected", isActive ? "true" : "false");
  });
  profilePanels.forEach((panel) => {
    const isActive = panel.dataset.profilePanel === tabId;
    panel.classList.toggle("is-active", isActive);
    panel.hidden = !isActive;
  });
}

function openProfilePermissionsModal() {
  if (!modalProfilePermissions) {
    return;
  }
  modalProfilePermissions.hidden = false;
}

function closeProfilePermissionsModal() {
  if (!modalProfilePermissions) {
    return;
  }
  modalProfilePermissions.hidden = true;
}

function getProfileStatusInfo(user) {
  const raw = normalizeSearchValue(
    user &&
      (user.statusOperacional ||
        user.operationalStatus ||
        user.statusLabel ||
        user.status ||
        "")
  );
  let label = "Dispon\u00edvel";
  let className = "status-pill--active";

  if (raw) {
    if (raw.includes("campo")) {
      label = "Em campo";
      className = "status-pill--info";
    } else if (raw.includes("trein")) {
      label = "Treinamento";
      className = "status-pill--warning";
    } else if (raw.includes("ferias") || raw.includes("licenca") || raw.includes("ausen")) {
      label = "F\u00e9rias";
      className = "status-pill--inactive";
    } else if (raw.includes("dispon")) {
      label = "Dispon\u00edvel";
      className = "status-pill--active";
    }
  }

  if (
    user &&
    (String(user.status || "").toUpperCase() === "INATIVO" || user.active === false)
  ) {
    label = "F\u00e9rias";
    className = "status-pill--inactive";
  }

  const updatedAt = parseTimestamp(
    user && (user.statusUpdatedAt || user.updatedAt || user.lastLoginAt || user.lastLogin)
  );
  const updatedLabel = updatedAt
    ? `Atualizado em ${formatDateTime(updatedAt)}`
    : "Atualizado agora";
  return { label, className, updatedLabel };
}

function setProfileKpiValue(key, value) {
  const elements = document.querySelectorAll(`[data-kpi=\"${key}\"]`);
  if (!elements.length) {
    return;
  }
  const display =
    value === null || value === undefined || value === "" ? "-" : String(value);
  elements.forEach((element) => {
    element.textContent = display;
  });
}

function getProfileMaintenanceItems(user) {
  const list = Array.isArray(manutencoes) ? manutencoes : [];
  if (!user) {
    return [];
  }
  const userId = String(user.id || "").trim();
  const matriculaNormalized = normalizeMatricula(user.matricula || user.username || "");
  const nameNormalized = normalizeSearchValue(user.name || "");

  return list.filter((item) => {
    if (!item) {
      return false;
    }
    const executadoId = String(
      getExecutadoPorId(item) || item.executadaPor || item.doneBy || item.createdBy || ""
    ).trim();
    if (userId && executadoId && executadoId === userId) {
      return true;
    }
    const ownerName = normalizeSearchValue(getMaintenanceOwner(item));
    if (nameNormalized && ownerName && ownerName === nameNormalized) {
      return true;
    }
    const ownerMatricula = normalizeMatricula(
      item.matricula || item.matriculaResponsavel || item.responsavelMatricula || ""
    );
    if (matriculaNormalized && ownerMatricula && ownerMatricula === matriculaNormalized) {
      return true;
    }
    return false;
  });
}

function calculateProfileSla(items, today) {
  const base = Array.isArray(items) ? items : [];
  const endDay = startOfDay(today || new Date());
  const startDay = addDays(endDay, -29);
  let total = 0;
  let onTime = 0;

  base.forEach((item) => {
    const status = normalizeMaintenanceStatus(item && item.status);
    if (status !== "concluida") {
      return;
    }
    const doneAt = getMaintenanceCompletedAt(item) || getItemConclusaoDate(item);
    if (!doneAt) {
      return;
    }
    const doneDay = startOfDay(doneAt);
    if (doneDay < startDay || doneDay > endDay) {
      return;
    }
    const due = getMaintenanceDueDate(item);
    if (!due) {
      return;
    }
    total += 1;
    if (doneDay <= startOfDay(due)) {
      onTime += 1;
    }
  });

  if (!total) {
    return null;
  }
  return Math.round((onTime / total) * 100);
}

function updateProfileKpis(user) {
  const items = getProfileMaintenanceItems(user);
  const today = startOfDay(new Date());
  const openItems = items.filter((item) => {
    const status = normalizeMaintenanceStatus(item && item.status);
    return status !== "concluida" && status !== "cancelada";
  });
  const overdueItems = openItems.filter((item) => {
    const due = getMaintenanceDueDate(item);
    return due && startOfDay(due) < today;
  });
  const pendingItems = items.filter(
    (item) => normalizeMaintenanceStatus(item && item.status) === "encerramento"
  );
  const sla = calculateProfileSla(items, today);

  setProfileKpiValue("open", openItems.length);
  setProfileKpiValue("overdue", overdueItems.length);
  setProfileKpiValue("pending", pendingItems.length);
  setProfileKpiValue("sla", sla === null ? "-" : `${sla}%`);
  setProfileKpiValue("checklists", "-");

  return { items, openItems, overdueItems, pendingItems };
}

function updateProfilePendencias(overdueItems, pendingItems) {
  if (!perfilPendenciasList) {
    return;
  }
  perfilPendenciasList.innerHTML = "";
  const overdueSet = new Set(overdueItems || []);
  const combined = [];
  const seen = new Set();
  const pushItem = (item) => {
    const key = String(item.id || item._id || item.uuid || item.key || "");
    if (key && seen.has(key)) {
      return;
    }
    if (key) {
      seen.add(key);
    }
    combined.push(item);
  };
  (overdueItems || []).forEach(pushItem);
  (pendingItems || []).forEach(pushItem);
  const items = combined.slice(0, 3);

  if (!items.length) {
    if (perfilPendenciasEmpty) {
      perfilPendenciasEmpty.hidden = false;
    }
    return;
  }

  if (perfilPendenciasEmpty) {
    perfilPendenciasEmpty.hidden = true;
  }

  items.forEach((item) => {
    const listItem = document.createElement("li");
    listItem.className = "profile-list__item";
    if (overdueSet.has(item) || isMaintenanceCritical(item)) {
      listItem.classList.add("profile-list__item--danger");
    }
    const title = document.createElement("span");
    title.className = "profile-list__title";
    title.textContent = getMaintenanceTitle(item);
    const meta = document.createElement("span");
    meta.className = "profile-list__meta";
    const due = getMaintenanceDueDate(item);
    const status = normalizeMaintenanceStatus(item && item.status);
    const statusLabel = status === "encerramento" ? "Aguardando apontamento" : "Atrasada";
    meta.textContent = due ? `${statusLabel} \u00b7 Prazo ${formatDate(due)}` : statusLabel;
    listItem.append(title, meta);
    perfilPendenciasList.append(listItem);
  });
}

function parseProfileTags(raw) {
  return String(raw || "")
    .split(/[,;\\n]/)
    .map((item) => item.trim())
    .filter(Boolean);
}

function renderProfileTags(container, tags) {
  if (!container) {
    return;
  }
  container.innerHTML = "";
  (tags || []).forEach((tag) => {
    const chip = document.createElement("span");
    chip.className = "profile-tag";
    chip.textContent = tag;
    container.append(chip);
  });
}

function renderProfileSimpleList(container, values, emptyLabel) {
  if (!container) {
    return;
  }
  const list = Array.isArray(values) ? values.filter(Boolean) : [];
  container.innerHTML = "";
  if (!list.length) {
    if (emptyLabel) {
      const li = document.createElement("li");
      li.className = "profile-list__item";
      const title = document.createElement("span");
      title.className = "profile-list__title";
      title.textContent = emptyLabel;
      li.append(title);
      container.append(li);
    }
    return;
  }
  list.forEach((value) => {
    const li = document.createElement("li");
    li.className = "profile-list__item";
    const title = document.createElement("span");
    title.className = "profile-list__title";
    title.textContent = value;
    li.append(title);
    container.append(li);
  });
}

function updateProfileAudit(user) {
  if (!perfilAuditoriaList) {
    return;
  }
  const events = [];
  if (user && user.createdAt) {
    events.push({
      title: "Conta criada",
      detail: "Registro inicial do colaborador.",
      when: parseTimestamp(user.createdAt),
    });
  }
  if (user && user.updatedAt) {
    events.push({
      title: "Perfil atualizado",
      detail: "Dados operacionais revisados.",
      when: parseTimestamp(user.updatedAt),
    });
  }
  if (user && (user.lastLoginAt || user.lastLogin)) {
    events.push({
      title: "Login registrado",
      detail: "Acesso autenticado com sucesso.",
      when: parseTimestamp(user.lastLoginAt || user.lastLogin),
    });
  }

  const ordered = events
    .filter((event) => event.when)
    .sort((a, b) => b.when - a.when)
    .slice(0, 6);

  perfilAuditoriaList.innerHTML = "";

  if (!ordered.length) {
    if (perfilAuditoriaEmpty) {
      perfilAuditoriaEmpty.hidden = false;
    }
    return;
  }

  if (perfilAuditoriaEmpty) {
    perfilAuditoriaEmpty.hidden = true;
  }

  ordered.forEach((event) => {
    const item = document.createElement("div");
    item.className = "profile-timeline__item";
    const title = document.createElement("strong");
    title.textContent = event.title;
    const meta = document.createElement("span");
    meta.className = "profile-list__meta";
    meta.textContent = event.when ? formatDateTime(event.when) : "-";
    item.append(title, meta);
    if (event.detail) {
      const detail = document.createElement("span");
      detail.className = "profile-list__meta";
      detail.textContent = event.detail;
      item.append(detail);
    }
    perfilAuditoriaList.append(item);
  });
}

function updateProfileHub(perfilUsuario, context) {
  if (!perfilUsuario) {
    return;
  }

  const statusInfo = getProfileStatusInfo(perfilUsuario);
  if (perfilStatus) {
    perfilStatus.textContent = statusInfo.label;
    perfilStatus.className = `status-pill ${statusInfo.className}`;
  }
  if (perfilStatusUpdated) {
    perfilStatusUpdated.textContent = statusInfo.updatedLabel;
  }

  const { overdueItems, pendingItems } = updateProfileKpis(perfilUsuario);
  updateProfilePendencias(overdueItems, pendingItems);

  const atribTags = parseProfileTags(perfilUsuario.atribuicoes || "");
  renderProfileTags(perfilAtribuicoesTags, atribTags);
  if (perfilAtribuicoesEmpty) {
    perfilAtribuicoesEmpty.hidden = atribTags.length > 0;
  }

  const isAdminUser = Boolean(context && context.isAdminUser);
  const permissoesAtivas = (context && context.permissoesAtivas) || [];
  const secoesAtivas = (context && context.secoesAtivas) || [];

  if (perfilPermissoesResumo) {
    const roleLabel = formatProfileValue(getRoleLabel(perfilUsuario));
    const uenLabel = formatProfileValue(perfilUsuario.uen);
    const nivel = isAdminUser ? "Administrativo" : "Operacional";
    perfilPermissoesResumo.textContent = `Perfil: ${roleLabel} | Escopo: ${uenLabel} | N\u00edvel: ${nivel}`;
  }

  renderProfileSimpleList(
    perfilPermissoesDetalhesList,
    isAdminUser ? ["Total"] : permissoesAtivas,
    "Sem permiss\u00f5es."
  );
  renderProfileSimpleList(
    perfilSecoesDetalhesList,
    isAdminUser ? ["Todas"] : secoesAtivas,
    "Nenhum m\u00f3dulo habilitado."
  );

  const tags = isAdminUser ? ["Todas"] : secoesAtivas.length ? secoesAtivas : ["Nenhum"];
  renderProfileTags(perfilSecoesBadges, tags);

  updateProfileAudit(perfilUsuario);
  setProfileTab(activeProfileTab);
}

function applyProfilePreferencesToUI(preferences, security) {
  if (profileThemeSelect) {
    profileThemeSelect.value = preferences.theme;
  }
  if (profileDensitySelect) {
    profileDensitySelect.value = preferences.density;
  }
  if (profileLanguageSelect) {
    profileLanguageSelect.value = preferences.language;
  }
  if (profileTimezoneSelect) {
    profileTimezoneSelect.value = preferences.timezone;
  }
  if (profileDashboardSelect) {
    profileDashboardSelect.value = preferences.dashboard;
  }
  if (profileNotifyAssigned) {
    profileNotifyAssigned.checked = preferences.notifications.assignedOs;
  }
  if (profileNotifyDue) {
    profileNotifyDue.checked = preferences.notifications.dueSoon;
  }
  if (profileNotifyCritical) {
    profileNotifyCritical.checked = preferences.notifications.criticalAlerts;
  }
  if (profileNotifyWeekly) {
    profileNotifyWeekly.checked = preferences.notifications.weeklyReports;
  }
  if (profile2faToggle) {
    profile2faToggle.checked = security.twoFactorEnabled;
  }
  if (profileBlockUnknown) {
    profileBlockUnknown.checked = security.blockUnknownDevices;
  }
}

function setProfilePreferencesDisabled(disabled) {
  [
    profileThemeSelect,
    profileDensitySelect,
    profileLanguageSelect,
    profileTimezoneSelect,
    profileDashboardSelect,
    profileNotifyAssigned,
    profileNotifyDue,
    profileNotifyCritical,
    profileNotifyWeekly,
    profile2faToggle,
    profileBlockUnknown,
  ]
    .filter(Boolean)
    .forEach((input) => {
      input.disabled = Boolean(disabled);
    });
}

function applyProfilePreferences(user, isSelfProfile) {
  const preferences = normalizeProfilePreferences(user && user.preferences);
  const security = normalizeProfileSecurity(user && (user.security || user.securitySettings));
  applyProfilePreferencesToUI(preferences, security);
  setProfilePreferencesDisabled(!isSelfProfile);
  if (isSelfProfile) {
    lastProfilePrefPayload = stableStringify({ preferences, security });
  }
}

function resetProfilePreferencesUI() {
  applyProfilePreferencesToUI(
    normalizeProfilePreferences(null),
    normalizeProfileSecurity(null)
  );
  setProfilePreferencesDisabled(true);
}

function collectProfilePreferencesFromUI() {
  if (
    !profileThemeSelect &&
    !profileDensitySelect &&
    !profileLanguageSelect &&
    !profileTimezoneSelect &&
    !profileDashboardSelect &&
    !profileNotifyAssigned &&
    !profileNotifyDue &&
    !profileNotifyCritical &&
    !profileNotifyWeekly &&
    !profile2faToggle &&
    !profileBlockUnknown
  ) {
    return null;
  }
  const preferences = normalizeProfilePreferences({
    theme: profileThemeSelect ? profileThemeSelect.value : undefined,
    density: profileDensitySelect ? profileDensitySelect.value : undefined,
    language: profileLanguageSelect ? profileLanguageSelect.value : undefined,
    timezone: profileTimezoneSelect ? profileTimezoneSelect.value : undefined,
    dashboard: profileDashboardSelect ? profileDashboardSelect.value : undefined,
    notifications: {
      assignedOs: profileNotifyAssigned ? profileNotifyAssigned.checked : undefined,
      dueSoon: profileNotifyDue ? profileNotifyDue.checked : undefined,
      criticalAlerts: profileNotifyCritical ? profileNotifyCritical.checked : undefined,
      weeklyReports: profileNotifyWeekly ? profileNotifyWeekly.checked : undefined,
    },
  });
  const security = normalizeProfileSecurity({
    twoFactorEnabled: profile2faToggle ? profile2faToggle.checked : undefined,
    blockUnknownDevices: profileBlockUnknown ? profileBlockUnknown.checked : undefined,
  });
  return { preferences, security };
}

let profilePrefSaveTimer = null;
let lastProfilePrefPayload = "";

function updateUserCache(user) {
  if (!user) {
    return;
  }
  const updateList = (list) => {
    if (!Array.isArray(list)) {
      return;
    }
    const index = list.findIndex((item) => String(item.id) === String(user.id));
    if (index >= 0) {
      list[index] = { ...list[index], ...user };
    }
  };
  updateList(users);
  updateList(accessUsers);
}

function saveProfilePreferences() {
  const perfilUsuario = getProfileTargetUser();
  if (!currentUser || !perfilUsuario) {
    return;
  }
  const isSelfProfile = String(currentUser.id) === String(perfilUsuario.id);
  if (!isSelfProfile) {
    return;
  }
  const payload = collectProfilePreferencesFromUI();
  if (!payload) {
    return;
  }
  const signature = stableStringify(payload);
  if (signature && signature === lastProfilePrefPayload) {
    return;
  }
  lastProfilePrefPayload = signature || "";
  updateProfileForUser(perfilUsuario.id, payload)
    .then((data) => {
      if (data && data.user) {
        currentUser = data.user;
        updateUserCache(data.user);
        applyProfilePreferences(data.user, true);
      }
    })
    .catch(() => {
      lastProfilePrefPayload = "";
    });
}

function queueProfilePreferencesSave() {
  if (profilePrefSaveTimer) {
    clearTimeout(profilePrefSaveTimer);
  }
  profilePrefSaveTimer = setTimeout(() => {
    profilePrefSaveTimer = null;
    saveProfilePreferences();
  }, 500);
}

function clearProfileHub() {
  if (perfilStatus) {
    perfilStatus.textContent = "-";
    perfilStatus.className = "status-pill";
  }
  if (perfilStatusUpdated) {
    perfilStatusUpdated.textContent = "";
  }
  ["open", "overdue", "pending", "sla", "checklists"].forEach((key) =>
    setProfileKpiValue(key, null)
  );
  if (perfilPendenciasList) {
    perfilPendenciasList.innerHTML = "";
  }
  if (perfilPendenciasEmpty) {
    perfilPendenciasEmpty.hidden = false;
  }
  if (perfilAtribuicoesTags) {
    perfilAtribuicoesTags.innerHTML = "";
  }
  if (perfilAtribuicoesEmpty) {
    perfilAtribuicoesEmpty.hidden = true;
  }
  if (perfilPermissoesResumo) {
    perfilPermissoesResumo.textContent = "-";
  }
  renderProfileSimpleList(perfilPermissoesDetalhesList, [], "Sem permiss\u00f5es.");
  renderProfileSimpleList(perfilSecoesDetalhesList, [], "Nenhum m\u00f3dulo habilitado.");
  if (perfilSecoesBadges) {
    perfilSecoesBadges.innerHTML = "";
  }
  if (perfilAuditoriaList) {
    perfilAuditoriaList.innerHTML = "";
  }
  if (perfilAuditoriaEmpty) {
    perfilAuditoriaEmpty.hidden = false;
  }
  resetProfilePreferencesUI();
}

function handleProfileAction(action) {
  if (!action) {
    return;
  }
  if (action === "minhas-os") {
    abrirPainelComCarregamento("programacao");
    return;
  }
  if (action === "criar-solicitacao") {
    abrirPainelComCarregamento("nova");
    return;
  }
  if (action === "ver-escala") {
    abrirPainelComCarregamento("pmp");
    return;
  }
  if (action === "exportar") {
    if (typeof exportarDados === "function") {
      exportarDados();
    } else {
      abrirPainelComCarregamento("relatorios");
    }
    return;
  }
  if (action === "trocar-contexto") {
    ativarModoEdicaoPerfil();
    return;
  }
  if (action === "ver-pendencias") {
    abrirPainelComCarregamento("programacao");
    return;
  }
  if (action === "definir-atribuicoes") {
    ativarModoEdicaoPerfil();
    setTimeout(() => {
      const input = document.getElementById("perfilAtribuicoesInput");
      if (input) {
        input.focus();
      }
    }, 0);
  }
}

function ativarModoEdicaoPerfil() {
  if (!currentUser) {
    return;
  }
  const perfilUsuario = getProfileTargetUser();
  if (!perfilUsuario) {
    return;
  }
  if (!canEditProfile(currentUser, perfilUsuario)) {
    setPerfilSaveMessage("Sem permissão para editar este perfil.", true);
    return;
  }
  setProfileEditParam(true);
  renderPerfil();
  if (perfilModeBadge) {
    perfilModeBadge.hidden = false;
  }
  if (perfilViewActions) {
    perfilViewActions.hidden = true;
  }
  if (perfilEditActions) {
    perfilEditActions.hidden = false;
  }
  const input = document.getElementById("perfilUenInput");
  if (input) {
    input.focus();
  }
}

function cancelarModoEdicaoPerfil() {
  setProfileEditParam(false);
  pendingAvatarDataUrl = "";
  setAvatarError("");
  renderPerfil();
  if (perfilModeBadge) {
    perfilModeBadge.hidden = true;
  }
  if (perfilViewActions) {
    perfilViewActions.hidden = false;
  }
  if (perfilEditActions) {
    perfilEditActions.hidden = true;
  }
}

function getReadNotificationIds() {
  const stored = readJson(NOTIFICATION_READ_KEY, []);
  return new Set(stored.map((id) => String(id)));
}

function saveReadNotificationIds(readSet) {
  writeJson(NOTIFICATION_READ_KEY, Array.from(readSet));
}

function markNotificationRead(id) {
  if (!id) {
    return;
  }
  const readSet = getReadNotificationIds();
  const key = String(id);
  if (!readSet.has(key)) {
    readSet.add(key);
    saveReadNotificationIds(readSet);
  }
}

function getMaintenanceTeamNameFromItem(item) {
  if (!item) {
    return "";
  }
  const raw = String(
    item.executadaPor || item.responsavel || item.responsavelManutencao || ""
  ).trim();
  if (!raw) {
    return "";
  }
  return normalizeTeamName(raw);
}

function buildTeamMaintenanceNotifications() {
  if (!currentUser || !activeProjectId) {
    return [];
  }
  if (!isUserFromActiveProject(currentUser)) {
    return [];
  }
  const prefs = normalizeProfilePreferences(currentUser.preferences);
  if (prefs && prefs.notifications && prefs.notifications.assignedOs === false) {
    return [];
  }
  const teamName = getProjectTeamName(activeProjectId);
  if (!teamName) {
    return [];
  }
  const teamKey = normalizeSearchValue(teamName);
  const now = Date.now();
  const windowMs = TEAM_NOTIFICATION_WINDOW_DAYS * 24 * 60 * 60 * 1000;
  return manutencoes
    .filter((item) => item && item.projectId === activeProjectId)
    .map((item) => {
      const assignedTeam = getMaintenanceTeamNameFromItem(item);
      if (!assignedTeam) {
        return null;
      }
      if (normalizeSearchValue(assignedTeam) !== teamKey) {
        return null;
      }
      const timestamp =
        getTimeValue(item.executionStartedAt) ||
        getTimeValue(item.abertaEm) ||
        getTimeValue(item.createdAt) ||
        0;
      if (timestamp && now - timestamp > windowMs) {
        return null;
      }
      return {
        id: `maintenance:${item.id}:team:${teamKey}`,
        message: `Nova manutenção para ${assignedTeam}: ${getMaintenanceTitle(item)}`,
        timestamp,
      };
    })
    .filter(Boolean)
    .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
}

function showTeamMaintenanceNotifications() {
  if (!authToast) {
    return;
  }
  const readSet = getReadNotificationIds();
  const notifications = buildTeamMaintenanceNotifications().filter(
    (notice) => !readSet.has(String(notice.id))
  );
  if (!notifications.length) {
    return;
  }
  notifications.slice(0, 3).forEach((notice, index) => {
    window.setTimeout(() => {
      showAuthToast(notice.message);
      markNotificationRead(notice.id);
    }, index * 2200);
  });
}

function getExecucaoRegistradaPendentes(projectId = activeProjectId) {
  if (!projectId) {
    return [];
  }
  return manutencoes.filter((item) => {
    if (!item || !hasExecucaoRegistradaCompleta(item)) {
      return false;
    }
    if (item.projectId && String(item.projectId) !== String(projectId)) {
      return false;
    }
    const status = normalizeMaintenanceStatus(item.status);
    return status === "em_execucao" || status === "encerramento";
  });
}

function isExecucaoRegistradaResponsavel(item, user) {
  if (!user) {
    return false;
  }
  const responsavelId =
    getExecutadoPorId(item) || item.responsavel || item.responsavelManutencao || item.createdBy || "";
  if (!responsavelId) {
    return isUserFromActiveProject(user);
  }
  if (isTeamUserId(responsavelId)) {
    return isUserFromActiveProject(user);
  }
  if (String(user.id) === String(responsavelId)) {
    return true;
  }
  const resolved = getUserById(responsavelId);
  if (!resolved) {
    return isUserFromActiveProject(user);
  }
  return false;
}

function getExecucaoRegistradaAlertState() {
  const stored = readJson(EXECUCAO_REG_ALERT_KEY, {});
  return stored && typeof stored === "object" ? stored : {};
}

function setExecucaoRegistradaAlertState(state) {
  writeJson(EXECUCAO_REG_ALERT_KEY, state && typeof state === "object" ? state : {});
}

function hasExecucaoRegistradaAlertSent(projectId, dateKey) {
  if (!projectId || !dateKey) {
    return false;
  }
  const state = getExecucaoRegistradaAlertState();
  return Boolean(state[projectId] === dateKey);
}

function markExecucaoRegistradaAlertSent(projectId, dateKey) {
  if (!projectId || !dateKey) {
    return;
  }
  const state = getExecucaoRegistradaAlertState();
  state[projectId] = dateKey;
  setExecucaoRegistradaAlertState(state);
}

function isExecucaoRegistradaAlertDue(now = new Date()) {
  if (!activeProjectId) {
    return false;
  }
  if (now.getHours() < 7) {
    return false;
  }
  const hojeKey = formatDateISO(now);
  return !hasExecucaoRegistradaAlertSent(activeProjectId, hojeKey);
}

function triggerExecucaoRegistradaAlertIfDue(force = false) {
  if (!force && !isExecucaoRegistradaAlertDue()) {
    return false;
  }
  showExecucaoRegistradaAlert(force);
  return true;
}

function showExecucaoRegistradaAlert(force = false) {
  if (!currentUser || !activeProjectId) {
    return;
  }
  if (!isUserFromActiveProject(currentUser)) {
    return;
  }
  const pendentes = getExecucaoRegistradaPendentes(activeProjectId).filter((item) =>
    isExecucaoRegistradaResponsavel(item, currentUser)
  );
  if (!pendentes.length) {
    return;
  }
  const hojeKey = formatDateISO(new Date());
  if (!force && hasExecucaoRegistradaAlertSent(activeProjectId, hojeKey)) {
    return;
  }
  const total = pendentes.length;
  let mensagem =
    total === 1
      ? `Execução registrada aguardando encerramento: ${pendentes[0].titulo || "Manutenção"}.`
      : `${total} manutenções com execução registrada aguardando encerramento.`;
  if (total > 1 && total <= 3) {
    const exemplos = pendentes
      .slice(0, 3)
      .map((item) => item.titulo || "Manutenção")
      .join("; ");
    mensagem += ` Ex.: ${exemplos}.`;
  }
  showAuthToast(mensagem);
  markExecucaoRegistradaAlertSent(activeProjectId, hojeKey);
}

function scheduleExecucaoRegistradaAlerts() {
  if (execucaoRegistradaAlertTimer) {
    window.clearTimeout(execucaoRegistradaAlertTimer);
    execucaoRegistradaAlertTimer = null;
  }
  const now = new Date();
  const next = new Date();
  next.setHours(7, 0, 0, 0);
  if (now >= next) {
    triggerExecucaoRegistradaAlertIfDue();
    next.setDate(next.getDate() + 1);
  }
  const delay = Math.max(0, next.getTime() - now.getTime());
  execucaoRegistradaAlertTimer = window.setTimeout(() => {
    triggerExecucaoRegistradaAlertIfDue();
    scheduleExecucaoRegistradaAlerts();
  }, delay);
}

function setFocusParam(id) {
  const url = new URL(window.location.href);
  url.searchParams.set("focus", id);
  window.history.replaceState(null, "", url.toString());
}

function clearFocusParam() {
  const url = new URL(window.location.href);
  if (!url.searchParams.has("focus")) {
    return;
  }
  url.searchParams.delete("focus");
  window.history.replaceState(null, "", url.toString());
}

function focusMaintenanceById(id, attempt = 0) {
  if (!id) {
    return;
  }
  const rawId = String(id);
  const safeId =
    window.CSS && CSS.escape ? CSS.escape(rawId) : rawId.replace(/["\\]/g, "\\$&");
  const selector = `[data-maintenance-id="${safeId}"]`;
  const target =
    document.querySelector(selector) || document.getElementById(`maintenance-${rawId}`);
  if (!target) {
    if (attempt < 8) {
      window.setTimeout(() => focusMaintenanceById(id, attempt + 1), 180);
    }
    return;
  }
  const prefersReduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  target.scrollIntoView({
    behavior: prefersReduced ? "auto" : "smooth",
    block: "center",
  });
  target.classList.remove("focus-pulse", "focus-state-pulse");
  void target.offsetWidth;
  target.classList.add("focus-pulse", "focus-state-pulse");
  const cleanup = () => {
    target.classList.remove("focus-pulse", "focus-state-pulse");
    target.removeEventListener("animationend", cleanup);
  };
  if (prefersReduced) {
    window.setTimeout(cleanup, 2000);
    return;
  }
  target.addEventListener("animationend", cleanup);
  window.setTimeout(cleanup, 4000);
}

function openMaintenanceFromNotification(id) {
  if (!id) {
    return;
  }
  lastFocusMaintenanceId = String(id);
  setFocusParam(id);
  abrirPainelComCarregamento("programacao");
  window.setTimeout(() => focusMaintenanceById(id), 200);
  clearFocusParam();
}

function handleFocusFromUrl() {
  if (!currentUser) {
    return;
  }
  const params = new URLSearchParams(window.location.search);
  const focusId = params.get("focus");
  if (!focusId) {
    return;
  }
  if (focusId === lastFocusMaintenanceId) {
    clearFocusParam();
    return;
  }
  lastFocusMaintenanceId = focusId;
  abrirPainelComCarregamento("programacao");
  window.setTimeout(() => focusMaintenanceById(focusId), 200);
  clearFocusParam();
}

async function handleEmailVerification() {
  const params = new URLSearchParams(window.location.search);
  const token = params.get("verify");
  if (!token) {
    return false;
  }
  try {
    await apiVerifyEmail(token);
    pendingVerificationEmail = "";
    mostrarFormularioRegistro();
    mostrarMensagemConta("Email confirmado. Faca login.", false);
  } catch (error) {
    const message = error && error.message ? error.message : "Falha ao confirmar email.";
    mostrarMensagemConta(message, true);
  } finally {
    params.delete("verify");
    const url = new URL(window.location.href);
    url.searchParams.delete("verify");
    window.history.replaceState(null, "", url.toString());
    mostrarAuthPanel("login");
    if (loginUsuario && pendingVerificationEmail) {
      loginUsuario.value = pendingVerificationEmail;
    }
  }
  return true;
}

function togglePassword(button) {
  if (!button) {
    return;
  }
  const wrapper = button.closest(".input-wrap");
  const input = wrapper ? wrapper.querySelector("input") : null;
  if (!input) {
    return;
  }
  const isPassword = input.type === "password";
  input.type = isPassword ? "text" : "password";
  button.setAttribute("aria-pressed", isPassword ? "true" : "false");
  button.setAttribute("aria-label", isPassword ? "Ocultar senha" : "Mostrar senha");
}

function bindCapsLockIndicator(input, hint) {
  if (!input || !hint) {
    return;
  }
  input.addEventListener("keyup", (event) => {
    const ativo = event.getModifierState && event.getModifierState("CapsLock");
    hint.hidden = !ativo;
  });
  input.addEventListener("blur", () => {
    hint.hidden = true;
  });
}

function checkPasswordPolicy(value) {
  const senha = String(value || "");
  return {
    length: senha.length >= 12,
    upper: /[A-Z]/.test(senha),
    lower: /[a-z]/.test(senha),
    number: /[0-9]/.test(senha),
    symbol: /[^A-Za-z0-9]/.test(senha),
  };
}

function atualizarSenhaRules() {
  if (!reqSenhaRules || !reqSenha) {
    return true;
  }
  const rules = checkPasswordPolicy(reqSenha.value);
  let ok = true;
  reqSenhaRules.querySelectorAll("[data-rule]").forEach((item) => {
    const key = item.dataset.rule;
    const valido = Boolean(rules[key]);
    item.classList.toggle("is-valid", valido);
    if (!valido) {
      ok = false;
    }
  });
  return ok;
}

function mostrarMensagemManutencao(texto, erro = false) {
  if (!mensagemManutencao) {
    return;
  }
  mensagemManutencao.textContent = texto;
  mensagemManutencao.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemConta(texto, erro = false) {
  if (!mensagemConta) {
    return;
  }
  mensagemConta.textContent = texto;
  mensagemConta.classList.toggle("mensagem--erro", erro);
}

function setPasswordResetMessage(texto, erro = false) {
  if (!passwordResetMsg) {
    return;
  }
  passwordResetMsg.textContent = texto || "";
  passwordResetMsg.classList.toggle("mensagem--erro", erro);
}

function isValidEmail(value) {
  const raw = String(value || "").trim();
  if (!raw) {
    return false;
  }
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(raw);
}

function normalizeVerificationEmail(value) {
  return String(value || "")
    .trim()
    .toLowerCase();
}

function mostrarFormularioRegistro() {
  if (reqForm) {
    reqForm.hidden = false;
  }
  if (verifyForm) {
    verifyForm.hidden = true;
  }
  setFieldError(verifyCodeError, "");
}

function mostrarFormularioVerificacao(email) {
  pendingVerificationEmail = normalizeVerificationEmail(email);
  if (verifyEmail) {
    verifyEmail.value = pendingVerificationEmail;
  }
  if (verifyHintEmail) {
    verifyHintEmail.textContent = pendingVerificationEmail || "seu e-mail";
  }
  if (verifyCode) {
    verifyCode.value = "";
  }
  setFieldError(verifyCodeError, "");
  if (reqForm) {
    reqForm.hidden = true;
  }
  if (verifyForm) {
    verifyForm.hidden = false;
  }
}

function mostrarMensagemGerencial(texto, erro = false) {
  if (!mensagemGerencial) {
    return;
  }
  mensagemGerencial.textContent = texto;
  mensagemGerencial.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemHealth(texto, erro = false) {
  if (!healthMessage) {
    return;
  }
  healthMessage.textContent = texto;
  healthMessage.classList.toggle("mensagem--erro", erro);
}

function getHealthLabel(status) {
  if (status === "ok") {
    return "OK";
  }
  if (status === "warn") {
    return "Atenção";
  }
  if (status === "error") {
    return "Falha";
  }
  return "Indef.";
}

function buildHealthBadge(status) {
  const badge = document.createElement("span");
  badge.className = `health-badge health-badge--${status || "warn"}`;
  badge.textContent = getHealthLabel(status);
  return badge;
}

function formatHealthDate(value) {
  const parsed = parseTimestamp(value);
  return parsed ? formatDateTime(parsed) : "-";
}

function renderHealthSummary(snapshot) {
  if (!healthSummary) {
    return;
  }
  healthSummary.innerHTML = "";
  if (!snapshot || !snapshot.modules) {
    const vazio = document.createElement("p");
    vazio.className = "empty-state";
    vazio.textContent = "Diagnóstico indisponível.";
    healthSummary.append(vazio);
    return;
  }
  const { modules } = snapshot;
  const dbFiles = modules.database && modules.database.files ? modules.database.files : [];
  const dbResumo = dbFiles.length
    ? dbFiles
        .map((file) =>
          file.ok
            ? `${file.label}: ${file.count} registros`
            : `${file.label}: erro`
        )
        .join(" | ")
    : "Sem arquivos monitorados.";
  const tarefas = modules.queue && modules.queue.tasks ? modules.queue.tasks : [];
  const tarefasEmAtraso = tarefas.filter((task) => task.status !== "ok").length;
  const cards = [
    {
      titulo: "Banco de dados",
      status: modules.database ? modules.database.status : "warn",
      resumo: dbResumo,
    },
    {
      titulo: "Backup",
      status: modules.backups ? modules.backups.status : "warn",
      resumo: `Última execução: ${formatHealthDate(modules.backups && modules.backups.lastRun)}`,
    },
    {
      titulo: "Fila de tarefas",
      status: modules.queue ? modules.queue.status : "warn",
      resumo: `Tarefas: ${tarefas.length} | Alertas: ${tarefasEmAtraso}`,
    },
    {
      titulo: "Integridade",
      status: modules.integrity ? modules.integrity.status : "warn",
      resumo: (() => {
        const issues = modules.integrity && modules.integrity.issues
          ? modules.integrity.issues
          : [];
        const count = issues.length;
        if (!count) {
          return "Sem inconsistências.";
        }
        const detail = issues
          .slice(0, 2)
          .map((issue) => issue.message || "Inconsistência")
          .join(" | ");
        return `Inconsistências: ${count}${detail ? ` | ${detail}` : ""}`;
      })(),
    },
  ];
  cards.forEach((cardData) => {
    const card = document.createElement("div");
    card.className = "health-card";
    const title = document.createElement("h4");
    title.textContent = cardData.titulo;
    const badge = buildHealthBadge(cardData.status);
    const resumo = document.createElement("p");
    resumo.textContent = cardData.resumo;
    card.append(title, badge, resumo);
    healthSummary.append(card);
  });
  updateGerencialIndicators();
}

function renderHealthTasks(snapshot) {
  if (!healthTasks) {
    return;
  }
  healthTasks.innerHTML = "";
  const tasks = snapshot && snapshot.modules && snapshot.modules.queue
    ? snapshot.modules.queue.tasks || []
    : [];
  if (!tasks.length) {
    const vazio = document.createElement("p");
    vazio.className = "empty-state";
    vazio.textContent = "Nenhuma tarefa registrada.";
    healthTasks.append(vazio);
    return;
  }
  tasks.forEach((task) => {
    const card = document.createElement("div");
    card.className = "health-task";
    card.dataset.taskId = task.id;

    const meta = document.createElement("div");
    meta.className = "health-task__meta";
    const title = document.createElement("div");
    title.className = "health-task__title";
    title.textContent = task.label || task.id;
    const details = document.createElement("div");
    details.className = "health-task__details";
    details.textContent = `Última execução: ${formatHealthDate(task.lastRun)} | Intervalo: ${task.intervalMinutes} min`;
    meta.append(title, details);
    if (task.lastError) {
      const error = document.createElement("div");
      error.className = "health-task__details";
      error.textContent = `Erro: ${task.lastError}`;
      meta.append(error);
    }

    const actions = document.createElement("div");
    actions.className = "health-task__actions";
    actions.append(buildHealthBadge(task.status));
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn btn--ghost btn--small";
    btn.dataset.action = "run-task";
    btn.dataset.taskId = task.id;
    btn.textContent = "Reexecutar";
    if (!currentUser || !hasGranularPermission(currentUser, "reexecutarTarefas")) {
      btn.disabled = true;
    }
    actions.append(btn);

    card.append(meta, actions);
    healthTasks.append(card);
  });
}

function renderHealthIntegrity(snapshot) {
  if (!healthIntegrity) {
    return;
  }
  healthIntegrity.innerHTML = "";
  const issues = snapshot && snapshot.modules && snapshot.modules.integrity
    ? snapshot.modules.integrity.issues || []
    : [];
  if (!issues.length) {
    const ok = document.createElement("p");
    ok.className = "empty-state";
    ok.textContent = "Sem inconsistências detectadas.";
    healthIntegrity.append(ok);
    return;
  }
  issues.forEach((issue) => {
    const item = document.createElement("div");
    const level = issue.level === "error" ? "error" : "warn";
    item.className = `health-issue health-issue--${level}`;
    item.textContent = issue.message || "Inconsistência detectada.";
    healthIntegrity.append(item);
  });
}

async function carregarHealth(forcar = false) {
  if (!currentUser || !canViewGerencial(currentUser) || !hasGranularPermission(currentUser, "verDiagnostico") || healthLoading) {
    return;
  }
  if (!forcar && healthSnapshot) {
    renderHealthSummary(healthSnapshot);
    renderHealthTasks(healthSnapshot);
    renderHealthIntegrity(healthSnapshot);
    return;
  }
  healthLoading = true;
  mostrarMensagemHealth("Carregando diagnóstico...");
  try {
    const data = await apiAdminHealth();
    healthSnapshot = data;
    renderHealthSummary(data);
    renderHealthTasks(data);
    renderHealthIntegrity(data);
    mostrarMensagemHealth(`Atualizado em ${formatHealthDate(data.generatedAt)}.`);
  } catch (error) {
    mostrarMensagemHealth(error.message || "Falha ao carregar diagnóstico.", true);
  } finally {
    healthLoading = false;
  }
}

async function runAllHealthTasks() {
  if (!currentUser || !hasGranularPermission(currentUser, "reexecutarTarefas")) {
    return;
  }
  const tasks = healthSnapshot && healthSnapshot.modules && healthSnapshot.modules.queue
    ? healthSnapshot.modules.queue.tasks || []
    : [];
  if (!tasks.length) {
    mostrarMensagemHealth("Nenhuma tarefa para reexecutar.");
    return;
  }
  mostrarMensagemHealth("Reexecutando tarefas...");
  for (const task of tasks) {
    try {
      await apiRunHealthTask(task.id);
    } catch (error) {
      mostrarMensagemHealth(error.message || "Falha ao reexecutar tarefas.", true);
      break;
    }
  }
  await carregarHealth(true);
  mostrarMensagemHealth("Tarefas reexecutadas.");
}

function exportarApiLogs() {
  if (!apiLogsState.items.length) {
    if (apiLogsMessage) {
      apiLogsMessage.textContent = "Sem logs para exportar.";
      apiLogsMessage.classList.add("mensagem--erro");
    }
    return;
  }
  const payload = {
    generatedAt: new Date().toISOString(),
    filters: apiLogsState.filters,
    logs: apiLogsState.items,
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {
    type: "application/json",
  });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  const stamp = new Date().toISOString().slice(0, 10);
  link.href = url;
  link.download = `logs-api-${stamp}.json`;
  document.body.append(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);
}

function buildLogStatusClass(status) {
  if (status >= 500) {
    return "log-status--error";
  }
  if (status >= 400) {
    return "log-status--error";
  }
  if (status >= 300) {
    return "log-status--warn";
  }
  return "log-status--ok";
}

function renderApiLogs() {
  if (!apiLogsTable) {
    return;
  }
  apiLogsTable.innerHTML = "";
  const items = apiLogsState.items || [];
  if (!items.length) {
    if (apiLogsEmpty) {
      apiLogsEmpty.hidden = false;
    }
    if (btnLogsLoadMore) {
      btnLogsLoadMore.hidden = true;
    }
    if (apiLogsCount) {
      apiLogsCount.textContent = "";
    }
    return;
  }
  if (apiLogsEmpty) {
    apiLogsEmpty.hidden = true;
  }
  const table = document.createElement("table");
  table.innerHTML = `
    <thead>
      <tr>
        <th>Data</th>
        <th>Endpoint</th>
        <th>Usuário</th>
        <th>Status</th>
        <th>Duração</th>
        <th>Ações</th>
      </tr>
    </thead>
  `;
  const tbody = document.createElement("tbody");
  items.forEach((entry) => {
    const row = document.createElement("tr");
    const data = parseTimestamp(entry.timestamp);
    const userLabel = entry.userName || entry.userId || "Anônimo";
    const status = Number(entry.status) || 0;
    const statusClass = buildLogStatusClass(status);
    row.innerHTML = `
      <td>${escapeHtml(data ? formatDateTime(data) : "-")}</td>
      <td>${escapeHtml(entry.method || "")} ${escapeHtml(entry.endpoint || "")}</td>
      <td>${escapeHtml(userLabel)}</td>
      <td><span class="log-status ${statusClass}">${status || "-"}</span></td>
      <td>${escapeHtml(entry.durationMs ? `${entry.durationMs}ms` : "-")}</td>
      <td>
        <button class="btn btn--ghost btn--small" data-action="toggle-log" data-log-id="${escapeHtml(entry.id)}">
          Ver JSON
        </button>
      </td>
    `;
    tbody.append(row);

    const detailRow = document.createElement("tr");
    detailRow.className = "log-details";
    detailRow.dataset.logDetails = entry.id;
    detailRow.hidden = true;
    const detailCell = document.createElement("td");
    detailCell.colSpan = 6;
    const pre = document.createElement("pre");
    pre.textContent = JSON.stringify(entry, null, 2);
    detailCell.append(pre);
    detailRow.append(detailCell);
    tbody.append(detailRow);
  });
  table.append(tbody);
  apiLogsTable.append(table);
  if (apiLogsCount) {
    apiLogsCount.textContent = `Mostrando ${apiLogsState.items.length} de ${apiLogsState.filtered}`;
  }
  if (btnLogsLoadMore) {
    btnLogsLoadMore.hidden = apiLogsState.items.length >= apiLogsState.filtered;
  }
  updateGerencialIndicators();
}

function getApiLogsFilters() {
  return {
    endpoint: logsFilterEndpoint ? logsFilterEndpoint.value.trim() : "",
    user: logsFilterUser ? logsFilterUser.value.trim() : "",
    status: logsFilterStatus ? logsFilterStatus.value : "",
    from: logsFilterFrom ? logsFilterFrom.value : "",
    to: logsFilterTo ? logsFilterTo.value : "",
  };
}

async function carregarApiLogs(reset = false) {
  if (!currentUser || !canViewGerencial(currentUser) || !hasGranularPermission(currentUser, "verLogsAPI") || apiLogsState.loading) {
    return;
  }
  if (!apiLogsTable) {
    return;
  }
  if (reset) {
    apiLogsState.offset = 0;
    apiLogsState.items = [];
  }
  apiLogsState.loading = true;
  const filtros = getApiLogsFilters();
  apiLogsState.filters = filtros;
  if (apiLogsMessage) {
    apiLogsMessage.textContent = "Carregando logs...";
    apiLogsMessage.classList.remove("mensagem--erro");
  }
  try {
    const params = {
      limit: apiLogsState.limit,
      offset: apiLogsState.offset,
      endpoint: filtros.endpoint,
      userId: filtros.user,
      status: filtros.status,
      from: filtros.from,
      to: filtros.to,
    };
    const data = await apiAdminLogs(params);
    apiLogsState.total = data.total || 0;
    apiLogsState.filtered = data.filteredTotal || 0;
    const novos = Array.isArray(data.logs) ? data.logs : [];
    apiLogsState.items = reset ? novos : apiLogsState.items.concat(novos);
    apiLogsState.offset = apiLogsState.items.length;
    renderApiLogs();
    if (apiLogsMessage) {
      apiLogsMessage.textContent = "";
    }
  } catch (error) {
    if (apiLogsMessage) {
      apiLogsMessage.textContent = error.message || "Falha ao carregar logs.";
      apiLogsMessage.classList.add("mensagem--erro");
    }
  } finally {
    apiLogsState.loading = false;
  }
}

function carregarPainelGerencial(forcar = false) {
  if (!currentUser || !canViewGerencial(currentUser)) {
    return;
  }
  updateGerencialTabVisibility();
  if (forcar) {
    gerencialLoadedTabs.clear();
    gerencialTabs.forEach((tab) => {
      if (!tab.hidden) {
        loadGerencialTab(tab.dataset.tabTarget, true);
      }
    });
    return;
  }
  const activeTab = gerencialTabs.find((tab) => tab.classList.contains("is-active") && !tab.hidden);
  if (activeTab) {
    loadGerencialTab(activeTab.dataset.tabTarget);
  }
}

function mostrarMensagemAutomacoes(texto, erro = false) {
  if (!automationMessage) {
    return;
  }
  automationMessage.textContent = texto;
  automationMessage.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemPermissoes(texto, erro = false) {
  if (!permissoesMessage) {
    return;
  }
  permissoesMessage.textContent = texto;
  permissoesMessage.classList.toggle("mensagem--erro", erro);
}

function getPermissoesProfiles() {
  if (Array.isArray(permissoesState.profiles) && permissoesState.profiles.length) {
    return permissoesState.profiles;
  }
  return GRANULAR_PROFILE_ORDER.map((key) => ({
    key,
    label: RBAC_ROLE_LABELS[key] || key.toUpperCase(),
  }));
}

function getPermissoesCatalog() {
  if (Array.isArray(permissoesState.permissions) && permissoesState.permissions.length) {
    return permissoesState.permissions;
  }
  return Object.keys(GRANULAR_PERMISSION_LABELS).map((key) => ({
    key,
    label: GRANULAR_PERMISSION_LABELS[key],
  }));
}

function buildPermissoesGroups(permissions) {
  const permMap = new Map(permissions.map((perm) => [perm.key, perm]));
  const used = new Set();
  const groups = PERMISSION_GROUPS.map((group) => {
    const items = group.items
      .map((key) => permMap.get(key))
      .filter(Boolean);
    items.forEach((item) => used.add(item.key));
    return { key: group.key, label: group.label, items };
  });
  const extras = permissions.filter((perm) => !used.has(perm.key));
  if (extras.length) {
    groups.push({ key: "outros", label: "Outros", items: extras });
  }
  return groups;
}

function renderPermissoesGerenciais() {
  if (!permissoesList) {
    return;
  }
  const profiles = getPermissoesProfiles();
  const permissions = getPermissoesCatalog();
  const groups = buildPermissoesGroups(permissions);
  const podeEditar = Boolean(currentUser && isAdmin() && canViewGerencial(currentUser));
  const query = permissoesSearch ? normalizeSearchValue(permissoesSearch.value) : "";
  const allowedPermissions = query
    ? new Set(
        permissions
          .filter((perm) => normalizeSearchValue(perm.label || perm.key).includes(query))
          .map((perm) => perm.key)
      )
    : null;

  permissoesList.innerHTML = "";
  if (!profiles.length || !permissions.length) {
    return;
  }

  let totalEnabled = 0;
  let visibleProfiles = 0;

  profiles.forEach((profile) => {
    const card = document.createElement("div");
    card.className = "permissions-card";
    card.dataset.profile = profile.key;

    const title = document.createElement("div");
    title.className = "permissions-title";
    const values = (permissoesState.values && permissoesState.values[profile.key]) || {};
    title.textContent = profile.label || profile.key;

    const groupsWrap = document.createElement("div");
    groupsWrap.className = "permissions-groups";
    let profileEnabled = 0;
    let hasVisibleGroup = false;

    groups.forEach((group) => {
      const visiblePerms = group.items.filter(
        (perm) => !allowedPermissions || allowedPermissions.has(perm.key)
      );
      if (!visiblePerms.length) {
        return;
      }
      hasVisibleGroup = true;
      const groupEl = document.createElement("div");
      groupEl.className = "permissions-group";
      const groupTitle = document.createElement("div");
      groupTitle.className = "permissions-group__title";
      groupTitle.textContent = group.label;

      const list = document.createElement("div");
      list.className = "permissions-list";
      visiblePerms.forEach((perm) => {
        const label = document.createElement("label");
        label.className = "permissions-item";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.dataset.profile = profile.key;
        checkbox.dataset.permission = perm.key;
        checkbox.checked = Boolean(values[perm.key]);
        checkbox.disabled = !podeEditar;
        if (checkbox.checked) {
          profileEnabled += 1;
        }
        const text = document.createElement("span");
        text.textContent = perm.label || perm.key;
        label.append(checkbox, text);
        list.append(label);
      });

      groupEl.append(groupTitle, list);
      groupsWrap.append(groupEl);
    });

    if (!hasVisibleGroup) {
      return;
    }

    const count = document.createElement("span");
    count.className = "permissions-count";
    const totalVisible = allowedPermissions ? allowedPermissions.size : permissions.length;
    count.textContent = `${profileEnabled}/${totalVisible} ativos`;
    title.append(count);

    card.append(title, groupsWrap);
    permissoesList.append(card);
    totalEnabled += profileEnabled;
    visibleProfiles += 1;
  });

  if (!permissoesList.childElementCount) {
    const vazio = document.createElement("p");
    vazio.className = "empty-state";
    vazio.textContent = "Nenhuma permissão encontrada com esse filtro.";
    permissoesList.append(vazio);
  }

  if (permissoesSummary) {
    const totalVisible = allowedPermissions ? allowedPermissions.size : permissions.length;
    permissoesSummary.innerHTML = "";
    const pills = [
      `Perfis: ${visibleProfiles}`,
      `Permissões: ${totalVisible}`,
      `Ativas: ${totalEnabled}`,
    ];
    pills.forEach((text) => {
      const pill = document.createElement("span");
      pill.className = "permissions-pill";
      pill.textContent = text;
      permissoesSummary.append(pill);
    });
  }
  if (btnPermissoesSalvar) {
    btnPermissoesSalvar.disabled = !podeEditar;
  }
}

function coletarPermissoesGerenciais() {
  const payload = {};
  if (!permissoesList) {
    return payload;
  }
  permissoesList.querySelectorAll(".permissions-card").forEach((card) => {
    const profileKey = card.dataset.profile;
    if (!profileKey) {
      return;
    }
    const profilePermissions = {};
    card.querySelectorAll("input[data-permission]").forEach((input) => {
      profilePermissions[input.dataset.permission] = input.checked;
    });
    payload[profileKey] = profilePermissions;
  });
  return payload;
}

async function carregarPermissoes(forcar = false) {
  if (!currentUser || !canViewGerencial(currentUser)) {
    return;
  }
  if (permissoesState.loading) {
    return;
  }
  if (!forcar && permissoesState.loaded) {
    renderPermissoesGerenciais();
    return;
  }
  permissoesState.loading = true;
  mostrarMensagemPermissoes("Carregando permissões...");
  try {
    const data = await apiAdminPermissoes();
    permissoesState.values = data.values || {};
    permissoesState.profiles = Array.isArray(data.profiles) ? data.profiles : [];
    permissoesState.permissions = Array.isArray(data.permissions) ? data.permissions : [];
    permissoesState.loaded = true;
    renderPermissoesGerenciais();
    mostrarMensagemPermissoes("");
  } catch (error) {
    mostrarMensagemPermissoes(error.message || "Falha ao carregar permissões.", true);
  } finally {
    permissoesState.loading = false;
  }
}

function getAutomationEventLabel(evento) {
  if (evento === "maintenance_created") {
    return "Manutenção criada";
  }
  return "Evento";
}

function getAutomationConditionLabel(condition) {
  if (condition && condition.type === "critical") {
    return "Tag crítica";
  }
  return "Sem condição";
}

function getAutomationActionLabel(action) {
  if (action && action.type === "notify_email") {
    return "Notificar e-mail";
  }
  return "Ação";
}

function formatAutomationDate(value) {
  const parsed = parseTimestamp(value);
  return parsed ? formatDateTime(parsed) : "Nunca";
}

function renderAutomacoes() {
  if (!automationList) {
    return;
  }
  automationList.innerHTML = "";
  const items = automationsState.items || [];
  if (!items.length) {
    const vazio = document.createElement("p");
    vazio.className = "empty-state";
    vazio.textContent = "Nenhuma automação configurada.";
    automationList.append(vazio);
    return;
  }
  items.forEach((automation) => {
    const row = document.createElement("div");
    row.className = "automation-item";
    row.dataset.automationId = automation.id;

    const main = document.createElement("div");
    main.className = "automation-main";
    const title = document.createElement("div");
    title.className = "automation-title";
    title.textContent = automation.name || "Automação";
    const meta = document.createElement("div");
    meta.className = "automation-meta";
    meta.textContent = `Evento: ${getAutomationEventLabel(automation.event)} | Condição: ${getAutomationConditionLabel(
      automation.condition
    )} | Ação: ${getAutomationActionLabel(automation.action)}`;
    const status = document.createElement("div");
    status.className = "automation-status";
    const lastLabel = formatAutomationDate(automation.lastRunAt);
    const statusLabel = automation.lastStatus
      ? automation.lastStatus.toUpperCase()
      : "PENDENTE";
    status.textContent = `Última execução: ${lastLabel} | ${statusLabel}`;
    main.append(title, meta, status);

    const actions = document.createElement("div");
    actions.className = "automation-actions";
    const toggle = document.createElement("label");
    toggle.className = "automation-toggle";
    toggle.innerHTML = `
      <input type="checkbox" data-action="toggle-automation" data-automation-id="${escapeHtml(
        automation.id
      )}">
      <span>Ativa</span>
    `;
    const input = toggle.querySelector("input");
    if (input) {
      input.checked = Boolean(automation.enabled);
      input.disabled = !hasGranularPermission(currentUser, "gerenciarAutomacoes");
    }
    const note = document.createElement("div");
    note.className = "automation-note";
    note.textContent = "Destino: e-mail do admin logado.";
    actions.append(toggle, note);

    row.append(main, actions);
    automationList.append(row);
  });
  updateGerencialIndicators();
}

async function carregarAutomacoes(forcar = false) {
  if (!currentUser || !canViewGerencial(currentUser) || !hasGranularPermission(currentUser, "verAutomacoes") || automationsState.loading) {
    return;
  }
  if (!forcar && automationsState.items.length) {
    renderAutomacoes();
    return;
  }
  automationsState.loading = true;
  mostrarMensagemAutomacoes("Carregando automações...");
  try {
    const data = await apiAdminAutomations();
    automationsState.items = Array.isArray(data.automations) ? data.automations : [];
    renderAutomacoes();
    mostrarMensagemAutomacoes("");
  } catch (error) {
    mostrarMensagemAutomacoes(error.message || "Falha ao carregar automações.", true);
  } finally {
    automationsState.loading = false;
  }
}

function mostrarMensagemArquivos(texto, erro = false) {
  if (!filesMessage) {
    return;
  }
  filesMessage.textContent = texto;
  filesMessage.classList.toggle("mensagem--erro", erro);
}

function getFileTypeLabel(tipo) {
  if (tipo === "evidence") {
    return "Evidências";
  }
  if (tipo === "rdo") {
    return "Anexos de RDO";
  }
  if (tipo === "audit") {
    return "Documentos de auditoria";
  }
  return "Arquivo";
}

function formatFileSize(bytes) {
  const value = Number(bytes) || 0;
  if (value >= 1024 * 1024) {
    return `${(value / (1024 * 1024)).toFixed(1)} MB`;
  }
  if (value >= 1024) {
    return `${Math.round(value / 1024)} KB`;
  }
  return `${value} B`;
}

function renderFilesList() {
  if (!filesList) {
    return;
  }
  filesList.innerHTML = "";
  const items = filesState.items || [];
  if (!items.length) {
    if (filesEmpty) {
      filesEmpty.hidden = false;
    }
    return;
  }
  if (filesEmpty) {
    filesEmpty.hidden = true;
  }
  items.forEach((file) => {
    const row = document.createElement("div");
    row.className = "file-item";
    row.dataset.fileId = file.id;

    const preview = document.createElement("div");
    preview.className = "file-preview";
    if (String(file.mime || "").startsWith("image/")) {
      const img = document.createElement("img");
      img.src = resolvePublicUrl(file.url);
      img.alt = file.originalName || file.name;
      preview.append(img);
    } else {
      const tag = document.createElement("span");
      tag.textContent = (file.name || "").split(".").pop()?.toUpperCase() || "ARQ";
      preview.append(tag);
    }

    const info = document.createElement("div");
    info.className = "file-info";
    const title = document.createElement("div");
    title.className = "file-title";
    title.textContent = file.originalName || file.name;
    const meta = document.createElement("div");
    meta.className = "file-meta";
    const data = parseTimestamp(file.createdAt);
    meta.textContent = `${getFileTypeLabel(file.type)} | ${formatFileSize(file.size)} | ${
      data ? formatDateTime(data) : "-"
    }`;
    info.append(title, meta);

    const actions = document.createElement("div");
    actions.className = "file-actions";
    const open = document.createElement("a");
    open.href = resolvePublicUrl(file.url);
    open.target = "_blank";
    open.rel = "noopener";
    open.className = "btn btn--ghost btn--small";
    open.textContent = "Ver";
    actions.append(open);
    const podeExcluir = currentUser && canDeleteFilesClient(currentUser);
    if (podeExcluir) {
      const remove = document.createElement("button");
      remove.type = "button";
      remove.className = "btn btn--ghost btn--small";
      remove.dataset.action = "delete-file";
      remove.dataset.fileId = file.id;
      remove.textContent = "Excluir";
      actions.append(remove);
    }

    row.append(preview, info, actions);
    filesList.append(row);
  });
  updateGerencialIndicators();
}

async function carregarArquivos(forcar = false) {
  if (!currentUser || !canManageFilesClient(currentUser) || !canViewGerencial(currentUser) || filesState.loading) {
    return;
  }
  if (!forcar && filesState.items.length) {
    renderFilesList();
    return;
  }
  filesState.loading = true;
  mostrarMensagemArquivos("Carregando arquivos...");
  try {
    const params = {
      type: filesFilterType ? filesFilterType.value : "",
      search: filesSearch ? filesSearch.value.trim() : "",
    };
    const data = await apiAdminFiles(params);
    filesState.items = Array.isArray(data.files) ? data.files : [];
    renderFilesList();
    mostrarMensagemArquivos("");
  } catch (error) {
    mostrarMensagemArquivos(error.message || "Falha ao carregar arquivos.", true);
  } finally {
    filesState.loading = false;
  }
}

function mostrarMensagemTemplate(texto, erro = false) {
  if (!templateMensagem) {
    return;
  }
  templateMensagem.textContent = texto;
  templateMensagem.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemConclusao(texto, erro = false) {
  if (!mensagemConclusao) {
    return;
  }
  mensagemConclusao.textContent = texto;
  mensagemConclusao.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemReagendar(texto, erro = false) {
  if (!mensagemReagendar) {
    return;
  }
  mensagemReagendar.textContent = texto;
  mensagemReagendar.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemBacklogMotivo(texto, erro = false) {
  if (!mensagemBacklogMotivo) {
    return;
  }
  mensagemBacklogMotivo.textContent = texto;
  mensagemBacklogMotivo.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemInicioExecucao(texto, erro = false) {
  if (!mensagemInicioExecucao) {
    return;
  }
  mensagemInicioExecucao.textContent = texto;
  mensagemInicioExecucao.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemRegistroExecucao(texto, erro = false) {
  if (!mensagemRegistroExecucao) {
    return;
  }
  mensagemRegistroExecucao.textContent = texto;
  mensagemRegistroExecucao.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemCancelarExecucao(texto, erro = false) {
  if (!mensagemCancelarExecucao) {
    return;
  }
  mensagemCancelarExecucao.textContent = texto;
  mensagemCancelarExecucao.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemLiberacao(texto, erro = false) {
  if (!mensagemLiberacao) {
    return;
  }
  mensagemLiberacao.textContent = texto;
  mensagemLiberacao.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemOverride(texto, erro = false) {
  if (!overrideMensagem) {
    return;
  }
  overrideMensagem.textContent = texto;
  overrideMensagem.classList.toggle("mensagem--erro", erro);
}

function mostrarMensagemCancelarInicio(texto, erro = false) {
  if (!mensagemCancelarInicio) {
    return;
  }
  mensagemCancelarInicio.textContent = texto;
  mensagemCancelarInicio.classList.toggle("mensagem--erro", erro);
}

function setFieldError(element, mensagem) {
  if (!element) {
    return;
  }
  if (mensagem) {
    element.textContent = mensagem;
    element.hidden = false;
    return;
  }
  element.textContent = "";
  element.hidden = true;
}

function syncObsEditor(forceSanitize = false) {
  if (!obsManutencaoEditor || !obsManutencaoHtml || !obsManutencao) {
    return;
  }
  const raw = obsManutencaoEditor.innerHTML || "";
  const sanitized = forceSanitize ? sanitizeRichText(raw) : raw;
  if (forceSanitize && raw !== sanitized) {
    obsManutencaoEditor.innerHTML = sanitized;
  }
  obsManutencaoHtml.value = sanitized;
  obsManutencao.value = stripHtml(sanitized).trim();
}

function setObsEditorContent({ html = "", text = "" } = {}) {
  if (!obsManutencaoEditor || !obsManutencaoHtml || !obsManutencao) {
    return;
  }
  const sanitized = html ? sanitizeRichText(html) : "";
  obsManutencaoEditor.innerHTML = sanitized || "";
  if (!sanitized && text) {
    obsManutencaoEditor.textContent = text;
  }
  obsManutencaoHtml.value = sanitized;
  obsManutencao.value = (text || stripHtml(sanitized)).trim();
}

function initRichEditors() {
  if (!obsManutencaoEditor || !obsManutencaoToolbar || !obsManutencao) {
    return;
  }
  try {
    document.execCommand("defaultParagraphSeparator", false, "p");
  } catch (error) {
    // ignore
  }
  obsManutencaoEditor.addEventListener("input", () => {
    syncObsEditor(false);
  });
  obsManutencaoEditor.addEventListener("blur", () => {
    syncObsEditor(true);
  });
  obsManutencaoEditor.addEventListener("paste", (event) => {
    if (!event.clipboardData) {
      return;
    }
    const html = event.clipboardData.getData("text/html");
    const text = event.clipboardData.getData("text/plain");
    if (!html && !text) {
      return;
    }
    event.preventDefault();
    if (html) {
      const sanitized = sanitizeRichText(html);
      document.execCommand("insertHTML", false, sanitized);
      syncObsEditor(false);
      return;
    }
    document.execCommand("insertText", false, text);
    syncObsEditor(false);
  });
  obsManutencaoToolbar.addEventListener("click", (event) => {
    const btn = event.target.closest("button[data-cmd]");
    if (!btn) {
      return;
    }
    event.preventDefault();
    const cmd = btn.dataset.cmd;
    let value = btn.dataset.value || null;
    if (cmd === "formatBlock" && value && !value.startsWith("<")) {
      value = `<${value}>`;
    }
    document.execCommand(cmd, false, value);
    obsManutencaoEditor.focus();
    syncObsEditor(false);
  });
  obsManutencaoToolbar.addEventListener("change", (event) => {
    const select = event.target.closest("select[data-cmd]");
    if (!select) {
      return;
    }
    const cmd = select.dataset.cmd;
    const value = select.value;
    if (value) {
      document.execCommand(cmd, false, value);
      select.value = "";
      obsManutencaoEditor.focus();
      syncObsEditor(false);
    }
  });
  syncObsEditor(true);
}

function initFontGroups() {
  const textareas = Array.from(document.querySelectorAll("textarea"));
  if (!textareas.length) {
    return;
  }
  const fonts = ["Segoe UI", "Arial", "Georgia", "Courier New"];
  const sizes = [12, 14, 16, 18, 20];
  let counter = 0;

  textareas.forEach((textarea) => {
    if (!textarea) {
      return;
    }
    if (textarea.hidden || textarea.classList.contains("visually-hidden")) {
      return;
    }
    if (textarea.dataset && textarea.dataset.fontGroup === "false") {
      return;
    }
    if (textarea.closest && textarea.closest(".rich-editor")) {
      return;
    }
    if (textarea.closest && textarea.closest(".auth-layout")) {
      return;
    }
    const parent = textarea.parentElement;
    if (!parent) {
      return;
    }
    if (!textarea.id) {
      counter += 1;
      textarea.id = `textarea-font-${counter}`;
    }
    if (parent.querySelector(`.font-toolbar[data-font-toolbar-for="${textarea.id}"]`)) {
      return;
    }

    const toolbar = document.createElement("div");
    toolbar.className = "font-toolbar";
    toolbar.dataset.fontToolbarFor = textarea.id;

    const group = document.createElement("div");
    group.className = "font-toolbar__group";

    const fontSelect = document.createElement("select");
    fontSelect.className = "font-select";
    fontSelect.setAttribute("aria-label", "Fonte");
    const fontDefault = document.createElement("option");
    fontDefault.value = "";
    fontDefault.textContent = "Fonte";
    fontSelect.append(fontDefault);
    fonts.forEach((font) => {
      const option = document.createElement("option");
      option.value = font;
      option.textContent = font;
      fontSelect.append(option);
    });

    const sizeSelect = document.createElement("select");
    sizeSelect.className = "font-select";
    sizeSelect.setAttribute("aria-label", "Tamanho da fonte");
    const sizeDefault = document.createElement("option");
    sizeDefault.value = "";
    sizeDefault.textContent = "Tamanho";
    sizeSelect.append(sizeDefault);
    sizes.forEach((size) => {
      const option = document.createElement("option");
      option.value = String(size);
      option.textContent = `${size} px`;
      sizeSelect.append(option);
    });

    group.append(fontSelect, sizeSelect);
    toolbar.append(group);
    parent.insertBefore(toolbar, textarea);

    const applyFont = () => {
      if (fontSelect.value) {
        textarea.style.fontFamily = fontSelect.value;
      } else {
        textarea.style.removeProperty("font-family");
      }
      if (sizeSelect.value) {
        textarea.style.fontSize = `${sizeSelect.value}px`;
      } else {
        textarea.style.removeProperty("font-size");
      }
    };

    fontSelect.addEventListener("change", applyFont);
    sizeSelect.addEventListener("change", applyFont);

    try {
      const computed = window.getComputedStyle(textarea);
      const computedFont = (computed.fontFamily || "")
        .split(",")[0]
        .replace(/['"]/g, "")
        .trim();
      if (fonts.includes(computedFont)) {
        fontSelect.value = computedFont;
      }
      const computedSize = parseInt(computed.fontSize || "", 10);
      if (sizes.includes(computedSize)) {
        sizeSelect.value = String(computedSize);
      }
    } catch (error) {
      // ignore
    }
  });
}

function clearTemplateErrors() {
  setFieldError(templateNomeErro, "");
  setFieldError(templateInicioErro, "");
  setFieldError(templateDailyErro, "");
  setFieldError(templateWeeklyIntervalErro, "");
  setFieldError(templateMonthlyDayErro, "");
  setFieldError(templateMonthlyDaysErro, "");
  setFieldError(templateParticipantesErro, "");
}

function clearTemplateFieldError(target) {
  if (!target) {
    return;
  }
  if (target === templateNome) {
    setFieldError(templateNomeErro, "");
  } else if (target === templateInicio) {
    setFieldError(templateInicioErro, "");
  } else if (target === templateWeeklyInterval) {
    setFieldError(templateWeeklyIntervalErro, "");
  } else if (target === templateMonthlyDay) {
    setFieldError(templateMonthlyDayErro, "");
  } else if (target === templateMonthlyDaysInput) {
    setFieldError(templateMonthlyDaysErro, "");
  } else if (target.matches && target.matches("[data-template-daily-day]")) {
    setFieldError(templateDailyErro, "");
  }
}

function mostrarAuthPanel(nome) {
  if (!authPanels || currentUser) {
    return;
  }
  atualizarTituloAuth(nome);
  authPanels.hidden = false;
  if (authPanels.classList.contains("auth-panels--dual")) {
    if (authPanelLogin) {
      authPanelLogin.hidden = false;
    }
    if (authPanelRegistro) {
      authPanelRegistro.hidden = false;
    }
    return;
  }
  if (authPanelLogin) {
    authPanelLogin.hidden = nome !== "login";
  }
  if (authPanelRegistro) {
    authPanelRegistro.hidden = nome !== "registro";
  }
  if (btnTabLogin) {
    btnTabLogin.classList.toggle("is-active", nome === "login");
  }
  if (btnTabRegistro) {
    btnTabRegistro.classList.toggle("is-active", nome === "registro");
  }
}

function esconderAuthPanels() {
  if (!authPanels) {
    return;
  }
  authPanels.hidden = true;
  if (authPanelLogin) {
    authPanelLogin.hidden = true;
  }
  if (authPanelRegistro) {
    authPanelRegistro.hidden = true;
  }
  if (btnTabLogin) {
    btnTabLogin.classList.remove("is-active");
  }
  if (btnTabRegistro) {
    btnTabRegistro.classList.remove("is-active");
  }
}

function getTabLabel(tabName) {
  if (!tabName) {
    return "";
  }
  const button = document.querySelector(`[data-tab="${tabName}"]`);
  if (!button) {
    return "";
  }
  const tooltip = button.getAttribute("data-tooltip");
  if (tooltip) {
    return tooltip.trim();
  }
  const text = (button.textContent || "").trim();
  return text;
}

function atualizarTituloPagina(tabName) {
  const label = getTabLabel(tabName);
  if (!label) {
    document.title = BASE_DOCUMENT_TITLE;
    return;
  }
  document.title = `${label} - OPSCOPE`;
}

function atualizarTituloAuth(panelName) {
  if (panelName === "registro") {
    document.title = "Cadastro - OPSCOPE";
    return;
  }
  document.title = "Acesso seguro - OPSCOPE";
}



function fecharPainelLembretes() {
  if (!painelLembretes || !btnLembretes) {
    return;
  }
  painelLembretes.hidden = true;
  btnLembretes.setAttribute("aria-expanded", "false");
}

function fecharUserMenu() {
  if (!userMenuPanel || !btnUserMenu) {
    return;
  }
  userMenuPanel.hidden = true;
  btnUserMenu.setAttribute("aria-expanded", "false");
}

function alternarPainelLembretes() {
  if (!painelLembretes || !btnLembretes) {
    return;
  }
  const abrir = painelLembretes.hidden;
  if (abrir) {
    fecharUserMenu();
    painelLembretes.hidden = false;
    btnLembretes.setAttribute("aria-expanded", "true");
    renderAnuncios();
    return;
  }
  fecharPainelLembretes();
}

function alternarUserMenu() {
  if (!userMenuPanel || !btnUserMenu) {
    return;
  }
  const abrir = userMenuPanel.hidden;
  if (abrir) {
    fecharPainelLembretes();
    userMenuPanel.hidden = false;
    btnUserMenu.setAttribute("aria-expanded", "true");
    return;
  }
  fecharUserMenu();
}

function mostrarCarregando() {
  if (!loadingOverlay) {
    return;
  }
  loadingOverlay.hidden = false;
  document.body.classList.add("is-loading");
}

function esconderCarregando() {
  if (!loadingOverlay) {
    return;
  }
  loadingOverlay.hidden = true;
  document.body.classList.remove("is-loading");
  if (loadingTimeout) {
    window.clearTimeout(loadingTimeout);
    loadingTimeout = null;
  }
}

function abrirPainelComCarregamento(tab, scrollTarget = null) {
  if (!tab) {
    return;
  }
  fecharPainelLembretes();

  const abrir = () => {
    ativarTab(tab);
    if (tab === "gerencial") {
      carregarPainelGerencial(false);
    }
    if (tab.startsWith("almoxarifado")) {
      carregarAlmoxarifado(false);
    }
    if (tab.startsWith("sst")) {
      carregarSst(false);
    }
    if (scrollTarget) {
      const alvo = document.getElementById(scrollTarget);
      if (alvo) {
        alvo.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }
  };

  if (!loadingOverlay) {
    abrir();
    return;
  }

  if (loadingTimeout) {
    window.clearTimeout(loadingTimeout);
  }

  mostrarCarregando();
  loadingTimeout = window.setTimeout(() => {
    abrir();
    esconderCarregando();
    loadingTimeout = null;
  }, LOADING_DELAY_MS);
}

function fecharPainelPerfil() {
  setProfileEditParam(false);
  clearProfileTargetUserId();
  abrirPainelComCarregamento("inicio");
}

function readSidebarState() {
  const state = localStorage.getItem(SIDEBAR_STATE_KEY);
  if (state === "collapsed") {
    return true;
  }
  if (state === "expanded") {
    return false;
  }
  const stored = localStorage.getItem(SIDEBAR_KEY);
  if (stored === "1") {
    return true;
  }
  if (stored === "0") {
    return false;
  }
  return null;
}

function setSidebarState(collapsed) {
  localStorage.setItem(SIDEBAR_KEY, collapsed ? "1" : "0");
  localStorage.setItem(SIDEBAR_STATE_KEY, collapsed ? "collapsed" : "expanded");
}

function hasSidebarToggle() {
  return Boolean(btnToggleSidebar && btnToggleSidebar.length);
}

function applyCollapsedState(collapsed) {
  if (!appShell) {
    return;
  }
  let resolved = collapsed;
  if (typeof resolved !== "boolean") {
    const stored = readSidebarState();
    resolved = stored === null ? false : stored;
  } else {
    setSidebarState(resolved);
  }
  if (!hasSidebarToggle()) {
    resolved = false;
    setSidebarState(false);
  }
  appShell.classList.toggle("is-collapsed", resolved);
  if (sidebar) {
    sidebar.dataset.state = resolved ? "collapsed" : "expanded";
  }
}

function initSidebarAccordions() {
  const groups = document.querySelectorAll(".nav-group");
  groups.forEach((group) => {
    const header = group.querySelector(".nav-group__header");
    if (!header) {
      return;
    }
    const groupName = group.dataset.group;
    const storageKey = groupName ? `sb_group_${groupName}` : "";
    const stored = storageKey ? localStorage.getItem(storageKey) : null;
    const collapsed = stored === "collapsed";
    group.dataset.collapsed = collapsed ? "true" : "false";
    header.setAttribute("aria-expanded", collapsed ? "false" : "true");
    header.addEventListener("click", () => {
      const isCollapsed = group.dataset.collapsed !== "true";
      group.dataset.collapsed = isCollapsed ? "true" : "false";
      header.setAttribute("aria-expanded", isCollapsed ? "false" : "true");
      if (storageKey) {
        localStorage.setItem(storageKey, isCollapsed ? "collapsed" : "expanded");
      }
    });
  });
}

function isMobileView() {
  return window.matchMedia("(max-width: 1023px)").matches;
}

function openSidebarDrawer() {
  if (!appShell) {
    return;
  }
  appShell.classList.add("is-drawer-open");
  if (sidebarBackdrop) {
    sidebarBackdrop.hidden = false;
  }
  if (sidebar) {
    sidebar.classList.add("is-open");
  }
  document.body.classList.add("sidebar-open");
}

function closeSidebarDrawer() {
  if (!appShell) {
    return;
  }
  appShell.classList.remove("is-drawer-open");
  if (sidebarBackdrop) {
    sidebarBackdrop.hidden = true;
  }
  if (sidebar) {
    sidebar.classList.remove("is-open");
  }
  document.body.classList.remove("sidebar-open");
}

function toggleSidebar() {
  if (!appShell) {
    return;
  }
  if (isMobileView()) {
    if (appShell.classList.contains("is-drawer-open")) {
      closeSidebarDrawer();
    } else {
      openSidebarDrawer();
    }
    return;
  }
  const novoEstado = !appShell.classList.contains("is-collapsed");
  applyCollapsedState(novoEstado);
}

function syncSidebarLayout() {
  if (!appShell) {
    return;
  }
  if (isMobileView()) {
    if (sidebar) {
      sidebar.removeAttribute("data-state");
    }
    appShell.classList.remove("is-collapsed");
    closeSidebarDrawer();
    return;
  }
  closeSidebarDrawer();
  applyCollapsedState();
}

function initSidebarToggle() {
  if (!appShell) {
    return;
  }
  syncSidebarLayout();
  if (btnToggleSidebar && btnToggleSidebar.length) {
    btnToggleSidebar.forEach((btn) => btn.addEventListener("click", toggleSidebar));
  }
  if (sidebarBackdrop) {
    sidebarBackdrop.addEventListener("click", closeSidebarDrawer);
  }
  if (tabButtons && tabButtons.length) {
    tabButtons.forEach((botao) => {
      botao.addEventListener("click", () => {
        if (isMobileView()) {
          closeSidebarDrawer();
        }
      });
    });
  }
  let estavaMobile = isMobileView();
  window.addEventListener("resize", () => {
    const agoraMobile = isMobileView();
    if (agoraMobile !== estavaMobile) {
      syncSidebarLayout();
      estavaMobile = agoraMobile;
      return;
    }
    if (!agoraMobile) {
      closeSidebarDrawer();
    }
  });
  initSidebarAccordions();
}

function carregarConfiguracoes() {
  const valor = Number(readJson(REMINDER_KEY, DEFAULT_REMINDER_DAYS));
  reminderDays = Number.isFinite(valor) && valor > 0 ? valor : DEFAULT_REMINDER_DAYS;
  if (configDiasLembrete) {
    configDiasLembrete.value = reminderDays;
  }
}

function salvarConfiguracoes() {
  if (!isAdmin()) {
    mostrarMensagemGerencial("Apenas administradores podem alterar configuracoes.", true);
    return;
  }
  const valor = Number(configDiasLembrete.value);
  if (!Number.isFinite(valor) || valor < 1 || valor > 60) {
    mostrarMensagemGerencial("Informe um numero entre 1 e 60.", true);
    return;
  }
  reminderDays = Math.round(valor);
  writeJson(REMINDER_KEY, reminderDays);
  gerarManutencoesRecorrentes();
  renderTudo();
mostrarMensagemGerencial("Configuração atualizada.");
}

function startOfDay(date) {
  const copia = new Date(date);
  copia.setHours(0, 0, 0, 0);
  return copia;
}

function parseDate(value) {
  if (!value) {
    return null;
  }
  const partes = value.split("-");
  if (partes.length !== 3) {
    return null;
  }
  const ano = Number(partes[0]);
  const mes = Number(partes[1]);
  const dia = Number(partes[2]);
  if (!ano || !mes || !dia) {
    return null;
  }
  const data = new Date(ano, mes - 1, dia);
  if (Number.isNaN(data.getTime())) {
    return null;
  }
  if (data.getFullYear() !== ano || data.getMonth() !== mes - 1 || data.getDate() !== dia) {
    return null;
  }
  return data;
}

function isUnauthorizedError(error) {
  if (!error) {
    return false;
  }
  const status = Number(error.status || error.statusCode || 0);
  if (status === 401 || status === 403) {
    return true;
  }
  const message = String(error.message || "").toLowerCase();
  return message.includes("nao autorizado") || message.includes("não autorizado") || message.includes("unauthorized");
}

function shouldFallbackAdminRequest(error) {
  if (!USE_AUTH_API) {
    return true;
  }
  if (!isUnauthorizedError(error)) {
    return false;
  }
  return Boolean(currentUser && isFullAccessUser(currentUser));
}

function parseDateOnly(value) {
  if (!value) {
    return null;
  }
  if (value instanceof Date) {
    return startOfDay(value);
  }
  if (typeof value === "number") {
    const date = new Date(value);
    return Number.isNaN(date.getTime()) ? null : startOfDay(date);
  }
  const text = String(value).trim();
  if (!text) {
    return null;
  }
  if (/^\d{4}-\d{2}-\d{2}$/.test(text)) {
    const parsed = parseDate(text);
    return parsed ? startOfDay(parsed) : null;
  }
  const parsed = parseTimestamp(text);
  return parsed ? startOfDay(parsed) : null;
}

function parseDateTime(value) {
  const parsed = parseTimestamp(value);
  return parsed || null;
}

function isSameDay(dateA, dateB) {
  if (!dateA || !dateB) {
    return false;
  }
  return startOfDay(dateA).getTime() === startOfDay(dateB).getTime();
}

function diffInDays(from, to) {
  return Math.round((to - from) / DAY_MS);
}

function formatDate(date) {
  return dateFormatter.format(date);
}

function formatDateTime(date) {
  return dateTimeFormatter.format(date);
}

function toIsoUtc(value) {
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (typeof value === "number") {
    return new Date(value).toISOString();
  }
  if (typeof value === "string") {
    const parsed = new Date(value);
    if (!Number.isNaN(parsed.getTime())) {
      return parsed.toISOString();
    }
  }
  return "";
}

function parseTimestamp(value) {
  if (!value) {
    return null;
  }
  if (value instanceof Date) {
    return Number.isNaN(value.getTime()) ? null : value;
  }
  if (typeof value === "number") {
    const parsed = new Date(value);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }
  if (typeof value === "string") {
    const parsed = new Date(value);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }
  return null;
}

function getTimeValue(value) {
  const parsed = parseTimestamp(value);
  return parsed ? parsed.getTime() : null;
}

function stableStringify(value) {
  if (value === null || value === undefined) {
    return "";
  }
  if (Array.isArray(value)) {
    return `[${value.map((item) => stableStringify(item)).join(",")}]`;
  }
  if (typeof value === "object") {
    return `{${Object.keys(value)
      .sort()
      .map((key) => `${key}:${stableStringify(value[key])}`)
      .join(",")}}`;
  }
  return String(value);
}

function readGerencialPermissoesStorage() {
  const stored = readJson(GERENCIAL_PERMISSOES_KEY, {});
  return stored && typeof stored === "object" ? stored : {};
}

function writeGerencialPermissoesStorage(values) {
  writeJson(GERENCIAL_PERMISSOES_KEY, values && typeof values === "object" ? values : {});
}

function readGerencialAutomationsStorage() {
  const stored = readJson(GERENCIAL_AUTOMATIONS_KEY, []);
  return Array.isArray(stored) ? stored : [];
}

function writeGerencialAutomationsStorage(list) {
  writeJson(GERENCIAL_AUTOMATIONS_KEY, Array.isArray(list) ? list : []);
}

function readGerencialFilesStorage() {
  const stored = readJson(GERENCIAL_FILES_KEY, []);
  return Array.isArray(stored) ? stored : [];
}

function writeGerencialFilesStorage(list) {
  writeJson(GERENCIAL_FILES_KEY, Array.isArray(list) ? list : []);
}

function buildLocalHealthSnapshot() {
  const now = new Date().toISOString();
  const manutCount = Array.isArray(manutencoes) ? manutencoes.length : 0;
  const templatesCount = Array.isArray(templates) ? templates.length : 0;
  const usersCount = Array.isArray(users) ? users.length : 0;
  return {
    generatedAt: now,
    modules: {
      database: {
        status: "ok",
        files: [
          { label: "Manutenções", count: manutCount, ok: true },
          { label: "Modelos", count: templatesCount, ok: true },
          { label: "Usuários", count: usersCount, ok: true },
        ],
      },
      backups: {
        status: "warn",
        lastRun: "",
      },
      queue: {
        status: "ok",
        tasks: [],
      },
      integrity: {
        status: "ok",
        issues: [],
      },
    },
  };
}

async function hashSha256(text) {
  if (typeof crypto !== "undefined" && crypto.subtle && typeof TextEncoder !== "undefined") {
    const encoder = new TextEncoder();
    const data = encoder.encode(text);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  let hash = 2166136261;
  for (let i = 0; i < text.length; i += 1) {
    hash ^= text.charCodeAt(i);
    hash = (hash * 16777619) >>> 0;
  }
  return hash.toString(16).padStart(8, "0");
}

function buildAuditPayload(entry, prevHash) {
  const payload = {
    timestamp: entry.timestamp,
    userId: entry.userId,
    action: entry.action,
    manutencaoId: entry.manutencaoId,
    source: entry.source,
    detalhes: entry.detalhes || {},
    prevHash: prevHash || "",
  };
  return stableStringify(payload);
}

async function recomputeAuditChain() {
  let prevHash = "";
  for (let i = 0; i < auditLog.length; i += 1) {
    const entry = auditLog[i];
    const timestampIso = normalizeIso(entry.timestamp);
    if (timestampIso && timestampIso !== entry.timestamp) {
      entry.timestamp = timestampIso;
    }
    if (!entry.source) {
      entry.source = entry.userId === SYSTEM_USER_ID ? "Sistema" : "UI";
    }
    const payload = buildAuditPayload(entry, prevHash);
    const hash = await hashSha256(payload);
    entry.prevHash = prevHash;
    entry.hash = hash;
    prevHash = hash;
  }
  salvarAuditoria(auditLog);
  return prevHash;
}

function iniciarAuditChain() {
  if (!auditLog.length) {
    auditHashChain = Promise.resolve("");
    return;
  }
  const precisa = auditLog.some(
    (entry) =>
      !entry.hash ||
      entry.prevHash === undefined ||
      !entry.source ||
      typeof entry.timestamp === "number"
  );
  if (precisa) {
    auditHashChain = recomputeAuditChain();
    return;
  }
  const last = auditLog[auditLog.length - 1];
  auditHashChain = Promise.resolve(last.hash || "");
}

function formatUpcoming(diff) {
  if (diff === null) {
    return "";
  }
  if (diff === 0) {
    return "Vence hoje";
  }
  if (diff === 1) {
    return "Vence amanha";
  }
  if (diff > 1) {
    return `Vence em ${diff} dias`;
  }
  return "data passou";
}

function formatReminder(diff) {
  if (diff === 0) {
    return "hoje";
  }
  if (diff === 1) {
    return "amanha";
  }
  return `em ${diff} dias`;
}

function formatOverdue(diff) {
  if (diff === null) {
    return "";
  }
  const dias = Math.abs(diff);
  if (dias === 0) {
    return "Atrasada desde hoje";
  }
  if (dias === 1) {
    return "Atrasada ha 1 dia";
  }
  return `atrasada ha ${dias} dias`;
}

function renderSubestacoes() {
  const selects = [subestacaoManutencao, templateSubestacao].filter(Boolean);
  const subestacoes = getSubestacoesBase();
  selects.forEach((select) => {
    const atual = select.value;
    select.innerHTML = "";
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "Selecione";
    select.append(placeholder);
    subestacoes.forEach((nome) => {
      const option = document.createElement("option");
      option.value = nome;
      option.textContent = nome;
      select.append(option);
    });
    if (atual && !subestacoes.includes(atual)) {
      const option = document.createElement("option");
      option.value = atual;
      option.textContent = atual;
      select.append(option);
      select.value = atual;
      return;
    }
    if (atual && subestacoes.includes(atual)) {
      select.value = atual;
    } else if (!atual && subestacoes.length) {
      select.value = subestacoes[0];
    }
  });
}

function renderTipoOptions() {
  if (!tipoManutencao) {
    return;
  }
  const atual = tipoManutencao.value;
  const tituloAtual = tituloManutencao ? tituloManutencao.value : "";
  tipoManutencao.innerHTML = "";
  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "Selecione um tipo";
  tipoManutencao.append(placeholder);

  const ordenados = [...templates]
    .filter((item) => item && item.nome && item.ativo !== false)
    .sort((a, b) => a.nome.localeCompare(b.nome, "pt-BR"));
  ordenados.forEach((template) => {
    const option = document.createElement("option");
    option.value = template.id;
    option.textContent = template.nome;
    tipoManutencao.append(option);
  });

  const custom = document.createElement("option");
  custom.value = CUSTOM_TIPO_OPTION;
  custom.textContent = "Personalizada";
  tipoManutencao.append(custom);

  const valores = new Set(ordenados.map((item) => item.id));
  if (valores.has(atual)) {
    tipoManutencao.value = atual;
  } else if (atual === CUSTOM_TIPO_OPTION) {
    tipoManutencao.value = CUSTOM_TIPO_OPTION;
  } else if (manutencaoEmEdicao && tituloAtual) {
    tipoManutencao.value = CUSTOM_TIPO_OPTION;
  } else if (ordenados.length === 0) {
    tipoManutencao.value = CUSTOM_TIPO_OPTION;
  } else {
    tipoManutencao.value = "";
  }
  atualizarTipoSelecionado();
  if (manutencaoEmEdicao && tituloManutencao && tituloAtual) {
    tituloManutencao.value = tituloAtual;
  }
}

function atualizarTipoSelecionado() {
  if (!tipoManutencao) {
    return;
  }
  const valor = tipoManutencao.value;
  const custom = valor === CUSTOM_TIPO_OPTION;
  if (customTipoField) {
    customTipoField.hidden = !custom;
  }
  if (tituloManutencao) {
    tituloManutencao.required = custom;
    tituloManutencao.disabled = !custom;
    if (!custom) {
      tituloManutencao.value = "";
    }
  }

  if (valor && !custom) {
    const template = getTemplateById(valor);
    if (template && subestacaoManutencao) {
      subestacaoManutencao.value = template.subestacao || subestacaoManutencao.value;
    }
    if (template && template.equipamentoId && equipamentoManutencao) {
      setEquipamentoSelectValue(equipamentoManutencao, template.equipamentoId);
    }
    if (template && template.equipeResponsavel) {
      renderManutencaoEquipeOptions(template.equipeResponsavel);
    }
    if (template && template.participantes) {
      const lista = Array.isArray(template.participantes)
        ? template.participantes
        : String(template.participantes || "")
            .split(";")
            .map((item) => normalizeParticipantName(item))
            .filter(Boolean);
      if (lista.length) {
        setManutencaoParticipantes(lista);
      }
    }
    if (
      template &&
      obsManutencao &&
      !obsManutencao.value &&
      (!obsManutencaoHtml || !obsManutencaoHtml.value) &&
      (template.observacao || template.observacaoHtml)
    ) {
      setObsEditorContent({
        html: template.observacaoHtml || "",
        text: template.observacao || "",
      });
    }
  }
}

function criarId() {
  if (window.crypto && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `manu-${Date.now()}-${Math.round(Math.random() * 1000)}`;
}

function carregarManutencoes() {
  const storageKey = getProjectStorageKey(STORAGE_KEY);
  const data = readJson(storageKey, []);
  if (!Array.isArray(data)) {
    return [];
  }
  const filtered = data.filter((item) => item && typeof item === "object");
  const compacted = compactEvidencias(filtered);
  if (compacted.changed) {
    try {
      localStorage.removeItem(storageKey);
    } catch (error) {
      // noop
    }
    writeJson(storageKey, compacted.list);
  }
  return compacted.list;
}

function readMaintenanceDirtyMap() {
  const raw = readJson(getProjectStorageKey(MAINT_DIRTY_KEY), {});
  return raw && typeof raw === "object" ? { ...raw } : {};
}

function writeMaintenanceDirtyMap(map) {
  writeJson(getProjectStorageKey(MAINT_DIRTY_KEY), map || {});
}

function markMaintenanceDirtyIds(ids) {
  const list = Array.isArray(ids) ? ids : [];
  if (!list.length) {
    return;
  }
  const map = readMaintenanceDirtyMap();
  const now = Date.now();
  list.forEach((id) => {
    const key = String(id || "").trim();
    if (key) {
      map[key] = now;
    }
  });
  writeMaintenanceDirtyMap(map);
}

function clearMaintenanceDirtyIds(ids = null) {
  if (!ids) {
    writeMaintenanceDirtyMap({});
    return;
  }
  const list = Array.isArray(ids) ? ids : [ids];
  if (!list.length) {
    return;
  }
  const map = readMaintenanceDirtyMap();
  list.forEach((id) => {
    const key = String(id || "").trim();
    if (key && Object.prototype.hasOwnProperty.call(map, key)) {
      delete map[key];
    }
  });
  writeMaintenanceDirtyMap(map);
}

function isMaintenanceDirtyId(id) {
  const key = String(id || "").trim();
  if (!key) {
    return false;
  }
  const map = readMaintenanceDirtyMap();
  return Boolean(map[key]);
}

function readMaintenanceTombstoneMap() {
  const raw = readJson(getProjectStorageKey(MAINT_TOMBSTONE_KEY), {});
  return raw && typeof raw === "object" ? { ...raw } : {};
}

function writeMaintenanceTombstoneMap(map) {
  writeJson(getProjectStorageKey(MAINT_TOMBSTONE_KEY), map || {});
}

function markMaintenanceDeletedIds(ids) {
  const list = Array.isArray(ids) ? ids : [ids];
  if (!list.length) {
    return;
  }
  const map = readMaintenanceTombstoneMap();
  const now = Date.now();
  list.forEach((id) => {
    const key = String(id || "").trim();
    if (key) {
      map[key] = now;
    }
  });
  writeMaintenanceTombstoneMap(map);
}

function clearMaintenanceDeletedIds(ids = null) {
  if (!ids) {
    writeMaintenanceTombstoneMap({});
    return;
  }
  const list = Array.isArray(ids) ? ids : [ids];
  if (!list.length) {
    return;
  }
  const map = readMaintenanceTombstoneMap();
  list.forEach((id) => {
    const key = String(id || "").trim();
    if (key && Object.prototype.hasOwnProperty.call(map, key)) {
      delete map[key];
    }
  });
  writeMaintenanceTombstoneMap(map);
}

function isMaintenanceDeletedId(id) {
  const key = String(id || "").trim();
  if (!key) {
    return false;
  }
  const map = readMaintenanceTombstoneMap();
  return Boolean(map[key]);
}

function salvarManutencoes(lista, options = {}) {
  const sanitized = Array.isArray(lista)
    ? lista.map((item) =>
        item && typeof item === "object" && activeProjectId
          ? { ...item, projectId: item.projectId || activeProjectId }
          : item
      )
    : [];
  const storageKey = getProjectStorageKey(STORAGE_KEY);
  const prevList = options.skipDirty ? [] : readJson(storageKey, []);
  const prevMap = new Map(
    Array.isArray(prevList)
      ? prevList
          .filter((item) => item && item.id)
          .map((item) => [String(item.id), getMaintenanceItemFingerprint(item)])
      : []
  );
  const dirtyIds = [];
  if (!options.skipDirty) {
    sanitized.forEach((item) => {
      if (!item || !item.id) {
        return;
      }
      const id = String(item.id);
      const prevFingerprint = prevMap.get(id) || "";
      const nextFingerprint = getMaintenanceItemFingerprint(item);
      if (!prevFingerprint || prevFingerprint !== nextFingerprint) {
        dirtyIds.push(id);
      }
    });
  }
  const compacted = compactEvidencias(sanitized);
  let ok = writeJson(storageKey, compacted.list);
  if (!ok) {
    try {
      localStorage.removeItem(storageKey);
    } catch (error) {
      // noop
    }
    ok = writeJson(storageKey, compacted.list);
  }
  if (!options.skipDirty && dirtyIds.length) {
    markMaintenanceDirtyIds(dirtyIds);
  }
  if (!options.skipSync) {
    scheduleMaintenanceSync(lista);
  }
}

function carregarUsuarios() {
  const data = readJson(USER_KEY, []);
  if (!Array.isArray(data)) {
    return [];
  }
  return data.filter((item) => item && typeof item === "object");
}

function salvarUsuarios(lista) {
  const sanitized = Array.isArray(lista)
    ? lista.map((user) => {
        const { password, passwordHash, ...rest } = user || {};
        return rest;
      })
    : [];
  writeJson(USER_KEY, sanitized);
}

function carregarSolicitacoes() {
  const data = readJson(getProjectStorageKey(REQUEST_KEY), []);
  if (!Array.isArray(data)) {
    return [];
  }
  return data.filter((item) => item && typeof item === "object");
}

function salvarSolicitacoes(lista) {
  writeJson(getProjectStorageKey(REQUEST_KEY), lista);
}

function carregarAuditoria() {
  const data = readJson(getProjectStorageKey(AUDIT_KEY), []);
  if (!Array.isArray(data)) {
    return [];
  }
  return data.filter((item) => item && typeof item === "object");
}

function salvarAuditoria(lista) {
  writeJson(getProjectStorageKey(AUDIT_KEY), lista);
}

function carregarTemplates() {
  const data = readJson(getProjectStorageKey(TEMPLATE_KEY), []);
  if (!Array.isArray(data)) {
    return [];
  }
  return data.filter((item) => item && typeof item === "object");
}

async function syncTemplatesNow(list) {
  if (!USE_AUTH_API || !templatesSyncEnabled || !currentUser || !activeProjectId) {
    return;
  }
  const payload = Array.isArray(list)
    ? list.map((item) => ({ ...item, projectId: item.projectId || activeProjectId }))
    : [];
  if (templatesSyncInFlight) {
    templatesSyncQueued = true;
    templatesSyncPayload = payload;
    return;
  }
  templatesSyncInFlight = true;
  try {
    await apiTemplatesSync(payload, activeProjectId);
    templatesLoadedProjects.add(activeProjectId);
  } catch (error) {
    const message = error && error.message ? error.message : "Falha ao sincronizar modelos.";
    showAuthToast(message);
  } finally {
    templatesSyncInFlight = false;
  }
  if (templatesSyncQueued) {
    templatesSyncQueued = false;
    const next = templatesSyncPayload || payload;
    templatesSyncPayload = null;
    syncTemplatesNow(next);
  }
}

function salvarTemplates(lista, options = {}) {
  writeJson(getProjectStorageKey(TEMPLATE_KEY), lista);
  setProjectFlag(TEMPLATE_SEED_DISABLED_KEY, Array.isArray(lista) && lista.length === 0);
  if (USE_AUTH_API && !options.skipSync) {
    syncTemplatesNow(lista);
  }
}

function carregarRdoSnapshots() {
  const data = readJson(getProjectStorageKey(RDO_KEY), []);
  if (!Array.isArray(data)) {
    return [];
  }
  return data.filter((item) => item && typeof item === "object");
}

function salvarRdoSnapshots(lista) {
  writeJson(getProjectStorageKey(RDO_KEY), lista);
}

function garantirTemplatesPadrao() {
  if (templates.length > 0) {
    return;
  }
  if (readProjectFlag(TEMPLATE_SEED_DISABLED_KEY)) {
    return;
  }
  if (!isDefaultProjectActive()) {
    return;
  }
  const hoje = formatDateISO(new Date());
  const subestacao = getSubestacoesBase()[0] || DEFAULT_PROJECT_LABEL;
  const criarPadrao = (nome, config) => {
    const agoraIso = toIsoUtc(new Date());
    const modelo = {
      id: criarId(),
      nome,
      subestacao,
      frequencia: config.frequencia,
      inicio: hoje,
      observacao: "",
      ativo: true,
      createdAt: agoraIso,
      createdBy: SYSTEM_USER_ID,
      updatedAt: agoraIso,
      updatedBy: SYSTEM_USER_ID,
    };

    if (config.frequencia === "daily") {
      modelo.dailyDays = [...DEFAULT_DAILY_DAYS];
    }
    if (config.frequencia === "weekly") {
      modelo.weeklyDay = Number.isFinite(config.weeklyDay) ? config.weeklyDay : 1;
      modelo.weeklyInterval = Number.isFinite(config.weeklyInterval)
        ? config.weeklyInterval
        : 1;
    }
    if (config.frequencia === "monthly") {
      modelo.monthlyMode = "fixed";
      modelo.monthlyDay = Number.isFinite(config.monthlyDay) ? config.monthlyDay : 10;
      modelo.monthlyDays = [];
    }

    modelo.proximaData = calcularProximaData(modelo);
    return modelo;
  };

  templates = [
    criarPadrao("Inspeção diária da subestação", { frequencia: "daily" }),
    criarPadrao("Inspeção mensal da subestação", { frequencia: "monthly", monthlyDay: 10 }),
    criarPadrao("Inspeção semanal do GMG BSO2", { frequencia: "weekly", weeklyDay: 3, weeklyInterval: 1 }),
    criarPadrao("Inspeção semanal dos GMG PCT4", { frequencia: "weekly", weeklyDay: 4, weeklyInterval: 1 }),
    criarPadrao("Inspeção mensal do GMG BSO2", { frequencia: "monthly", monthlyDay: 25 }),
    criarPadrao("Inspeção mensal dos GMG PCT4", { frequencia: "monthly", monthlyDay: 25 }),
  ];

  salvarTemplates(templates, { skipSync: true });
}

function formatDateISO(date) {
  if (!date) {
    return "";
  }
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function formatShortLabel(date) {
  if (!date) {
    return "";
  }
  const day = String(date.getDate()).padStart(2, "0");
  const month = String(date.getMonth() + 1).padStart(2, "0");
  return `${day}/${month}`;
}

function getSectionConfig(user) {
  if (!user) {
    return {};
  }
  const config = { ...DEFAULT_SECTIONS };
  if (user.sections && typeof user.sections === "object") {
    Object.keys(DEFAULT_SECTIONS).forEach((key) => {
      if (key in user.sections) {
        config[key] = Boolean(user.sections[key]);
      }
    });
  }
  const rolePermissions = Array.isArray(user.rolePermissions)
    ? user.rolePermissions
    : Array.isArray(user.accessPermissions)
      ? user.accessPermissions
      : [];
  const derivedSections = deriveSectionsFromAccessPermissions(rolePermissions);
  if (derivedSections) {
    Object.keys(derivedSections).forEach((key) => {
      config[key] = derivedSections[key];
    });
  }
  if (user.role === "admin" || rolePermissions.includes("ADMIN")) {
    ADMIN_SECTIONS.forEach((key) => {
      config[key] = true;
    });
  }
  return config;
}

function getTemplateById(id) {
  return templates.find((item) => item.id === id);
}

function isDailySubstationInspection(item) {
  if (!item) {
    return false;
  }
  const template = item.templateId ? getTemplateById(item.templateId) : null;
  const nome = template && template.nome ? template.nome : item.titulo || "";
  const nomeNormalizado = normalizeSearchValue(nome);
  const tituloNormalizado = normalizeSearchValue(item.titulo || "");
  const isDaily =
    nomeNormalizado.includes("inspecao diaria") ||
    tituloNormalizado.includes("inspecao diaria");
  const isSubestacao =
    nomeNormalizado.includes("subestacao") ||
    tituloNormalizado.includes("subestacao");
  if (!isDaily || !isSubestacao) {
    return false;
  }
  const frequencia = template && template.frequencia ? String(template.frequencia).toLowerCase() : "";
  if (frequencia) {
    return frequencia === "daily";
  }
  return true;
}

function getDefaultPermissions() {
  return Object.keys(PERMISSIONS).reduce((acc, key) => {
    acc[key] = true;
    return acc;
  }, {});
}

function getEmptyPermissions() {
  return Object.keys(PERMISSIONS).reduce((acc, key) => {
    acc[key] = false;
    return acc;
  }, {});
}

function garantirAdmin() {
  const existeAdmin = users.some(
    (user) => (user.username || "").toLowerCase() === "admin"
  );
  if (existeAdmin) {
    return;
  }
  const admin = {
    id: criarId(),
    username: "Admin",
    matricula: "ADMIN",
    name: "Administrador",
    role: "admin",
    password: "12345",
    permissions: getDefaultPermissions(),
    sections: { ...DEFAULT_SECTIONS },
    createdAt: toIsoUtc(new Date()),
  };
  users = [admin];
  salvarUsuarios(users);
}

function carregarSessao() {
  return readJson(SESSION_KEY, null);
}

function salvarSessao(session) {
  if (!session) {
    localStorage.removeItem(SESSION_KEY);
    return;
  }
  writeJson(SESSION_KEY, session);
}

function persistActiveProjectId(projectId) {
  if (!projectId) {
    localStorage.removeItem(ACTIVE_PROJECT_KEY);
    return;
  }
  localStorage.setItem(ACTIVE_PROJECT_KEY, projectId);
}

function ensureMaintenanceCacheOwnership() {
  if (!USE_AUTH_API || !currentUser || !currentUser.id) {
    return;
  }
  const currentId = String(currentUser.id);
  const storedId = localStorage.getItem(MAINT_CACHE_USER_KEY) || "";
  if (storedId && storedId !== currentId) {
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i += 1) {
      const key = localStorage.key(i);
      if (!key) {
        continue;
      }
      if (key === STORAGE_KEY || key.startsWith(`${STORAGE_KEY}.`)) {
        keysToRemove.push(key);
      }
      if (key === MAINT_DIRTY_KEY || key.startsWith(`${MAINT_DIRTY_KEY}.`)) {
        keysToRemove.push(key);
      }
      if (key === MAINT_TOMBSTONE_KEY || key.startsWith(`${MAINT_TOMBSTONE_KEY}.`)) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach((key) => {
      try {
        localStorage.removeItem(key);
      } catch (error) {
        // noop
      }
    });
  }
  localStorage.setItem(MAINT_CACHE_USER_KEY, currentId);
}

function reloadProjectState() {
  templates = carregarTemplates();
  if (!isDefaultProjectActive() && shouldClearDefaultTemplates(templates)) {
    templates = [];
    salvarTemplates(templates, { skipSync: true });
  }
  garantirTemplatesPadrao();
  const normalizados = normalizarTemplates(templates);
  templates = normalizados.normalizadas;
  if (normalizados.mudou) {
    salvarTemplates(templates, { skipSync: true });
  }
  requests = carregarSolicitacoes();
  auditLog = carregarAuditoria();
  iniciarAuditChain();
  carregarConfiguracoes();
  manutencoes = carregarManutencoes();
  gerarManutencoesRecorrentes();
  const resultado = normalizarManutencoes(manutencoes);
  manutencoes = resultado.normalizadas;
  salvarManutencoes(manutencoes);
  rdoSnapshots = carregarRdoSnapshots();
  carregarFeedbacks();
  montarRdoUI();
  renderRdoLocaisOptions();
  updateRdoShiftLabels();
  renderTudo();
}

async function setActiveProjectId(nextId, options = {}) {
  const trimmed = String(nextId || "").trim();
  if (!trimmed) {
    activeProjectId = "";
    persistActiveProjectId("");
    updateSyncStatusLabel();
    return;
  }
  if (activeProjectId === trimmed && !options.force) {
    return;
  }
  activeProjectId = trimmed;
  templatesSyncEnabled = false;
  persistActiveProjectId(trimmed);
  if (options.sync !== false) {
    try {
      await apiProjetosSetActive(trimmed);
    } catch (error) {
      // noop: fallback local
    }
  }
  reloadProjectState();
  loadDashboardSummary(true);
  renderProjectSelector();
  renderProjectPanel();
  renderPmpModule();
  await carregarEquipeProjeto();
  await carregarEquipamentosProjeto();
  await carregarManutencoesServidor(true);
  await carregarTemplatesServidor(true);
  await carregarPmpDados();
  restartSyncEvents();
  scheduleExecucaoRegistradaAlerts();
  updateSyncStatusLabel();
}

async function carregarSessaoServidor() {
  if (!currentUser) {
    mostrarAuthPanel("login");
  }
  if (USE_AUTH_API) {
    try {
      const data = await apiRequest("/api/auth/me");
      currentUser = data.user || null;
      availableProjects = Array.isArray(data.projects) ? data.projects : [];
      if (currentUser) {
        ensureMaintenanceCacheOwnership();
      }
      const storedProjectId = localStorage.getItem(ACTIVE_PROJECT_KEY) || "";
      const validStored = availableProjects.some((item) => item.id === storedProjectId);
      const resolvedProjectId =
        data.activeProjectId ||
        (validStored ? storedProjectId : availableProjects[0]?.id || "");
      if (resolvedProjectId) {
        await setActiveProjectId(resolvedProjectId, { sync: false, force: true });
      }
    } catch (error) {
      currentUser = null;
      availableProjects = [];
      activeProjectId = "";
    }
  } else {
    currentUser = null;
    activeProjectId = "";
    await dataProvider.roles.seedDefaultRolesIfEmpty();
    try {
      await ensureBootstrapAccessAccount();
    } catch (error) {
      // noop
    }
    await refreshAccessRoles();
    const session = carregarSessao();
    if (session && session.userId) {
      const account = await dataProvider.authAdmin.getUser(session.userId);
      if (account && normalizeAccessUserStatus(account.status, account.active) !== "INATIVO") {
        const role = await resolveRoleFromDb(account);
        currentUser = buildSessionUser(account, role);
      } else {
        salvarSessao(null);
      }
    }
  }
  await carregarUsuariosServidor();
  renderAuthUI();
  await refreshProjects();
  await carregarAnuncios(true);
  await carregarFeedbacks(true);
  await carregarPmpDados();
  await checkCompatState(true);
  if (currentUser) {
    const activeTab = getActiveTabKey();
    if (activeTab && activeTab.startsWith("almoxarifado")) {
      await carregarAlmoxarifado(true);
    }
    if (activeTab && activeTab.startsWith("sst")) {
      await carregarSst(true);
    }
  }
  if (!currentUser) {
    renderProjectSelector();
    renderProjectPanel();
  }
  if (USE_AUTH_API) {
    await handleEmailVerification();
  }
  handleFocusFromUrl();
  if (!currentUser) {
    mostrarAuthPanel("login");
  }
  if (currentUser) {
    startSyncEvents();
    startSyncPolling();
  } else {
    stopSyncEvents();
    stopSyncPolling();
  }
}

async function carregarUsuariosServidor() {
  if (!currentUser) {
    users = [];
    accessUsers = [];
    renderManutencaoParticipantesOptions();
    renderManutencaoParticipantesSelected();
    return;
  }
  if (!USE_AUTH_API) {
    await refreshAccessData({ force: true });
    renderEquipeSelectOptions();
    renderManutencaoParticipantesOptions();
    renderManutencaoParticipantesSelected();
    return;
  }
  try {
    const data = canAdminUsersRead() ? await apiAdminUsers() : await apiRequest("/api/auth/users");
    users = Array.isArray(data.users) ? data.users : [];
  } catch (error) {
    users = currentUser ? [currentUser] : [];
  }
  await carregarPermissoesAdmin();
  renderUsuarios();
  renderEquipeSelectOptions();
  renderManutencaoParticipantesOptions();
  renderManutencaoParticipantesSelected();
}

async function carregarPermissoesAdmin() {
  if (!USE_AUTH_API || !canAdminUsersRead()) {
    adminPermissionCatalog = [];
    return;
  }
  try {
    const data = await apiAdminPermissions();
    adminPermissionCatalog = Array.isArray(data.permissions) ? data.permissions : [];
  } catch (error) {
    adminPermissionCatalog = [];
  }
}

function getUserById(id) {
  if (currentUser && currentUser.id === id) {
    return currentUser;
  }
  return users.find((user) => user.id === id);
}

function isAdminUser(user) {
  if (!user) {
    return false;
  }
  const role = String(user.role || user.rbacRole || "").toLowerCase();
  const cargo = String(user.cargo || "").toLowerCase();
  const username = String(user.username || "").toLowerCase();
  const matricula = String(user.matricula || "").toLowerCase();
  const nome = String(user.name || "").toLowerCase();
  return (
    role === "admin" ||
    role === "administrador" ||
    username === "admin" ||
    matricula === "admin" ||
    cargo.includes("admin") ||
    cargo.includes("administrador") ||
    nome.includes("administrador")
  );
}

function isSystemUserId(id) {
  return String(id || "") === SYSTEM_USER_ID;
}

function isTeamUserId(id) {
  return typeof id === "string" && (id.startsWith("team:") || id.startsWith("time:"));
}

function isRealUser(user) {
  if (!user || !user.id) {
    return false;
  }
  if (isSystemUserId(user.id)) {
    return false;
  }
  if (user.active === false || String(user.status || "").toUpperCase() === "INATIVO") {
    return false;
  }
  return !isAdminUser(user);
}

function isRealUserId(id) {
  if (!id) {
    return false;
  }
  if (isTeamUserId(id)) {
    return true;
  }
  if (isSystemUserId(id)) {
    return false;
  }
  const user = getUserById(id);
  if (!user) {
    return true;
  }
  return !isAdminUser(user);
}

function getOperationalUsers() {
  return users.filter(isRealUser);
}

function getUserLabel(id) {
  if (!id) {
    return "Desconhecido";
  }
  if (id === SYSTEM_USER_ID) {
    return "Sistema";
  }
  if (typeof id === "string" && id.startsWith("team:")) {
    const name = id.slice(5).trim();
    return name || "Time";
  }
  if (typeof id === "string" && id.startsWith("time:")) {
    const name = id.slice(5).trim();
    return name || "Time";
  }
  const user = getUserById(id);
  if (!user) {
    return String(id);
  }
  return `${user.name} (${user.matricula})`;
}

function getProjectLabel(project) {
  if (!project) {
    return "";
  }
  return `${project.codigo || "-"} - ${project.nome || "-"}`;
}

const TAB_LABELS = {
  inicio: "In\u00edcio",
  programacao: "Programa\u00e7\u00e3o",
  nova: "Nova Manuten\u00e7\u00e3o",
  modelos: "Modelos e Recorr\u00eancias",
  pmp: "PMP / Cronograma",
  execucao: "Execu\u00e7\u00e3o do Dia",
  backlog: "Backlog",
  solicitacoes: "Solicita\u00e7\u00f5es Pendentes",
  projetos: "Locais de Trabalho",
  desempenho: "Desempenho Geral",
  "performance-projects": "Desempenho por Projeto",
  "performance-people": "Desempenho por Colaborador",
  tendencias: "KPIs e Tend\u00eancias",
  relatorios: "Relat\u00f3rios Gerenciais",
  feedbacks: "Feedbacks",
  almoxarifado: "Almoxarifado",
  "almoxarifado-itens": "Itens",
  "almoxarifado-estoque": "Estoque por Projeto",
  "almoxarifado-movimentacoes": "Movimenta\u00e7\u00f5es",
  "almoxarifado-epis": "EPIs por Colaborador",
  sst: "Seguran\u00e7a do Trabalho (SST)",
  "sst-treinamentos": "Treinamentos",
  "sst-inspecoes": "Inspe\u00e7\u00f5es",
  "sst-ncs": "N\u00e3o conformidades",
  "sst-incidentes": "Incidentes",
  "sst-apr-pt": "Documentações",
  rastreabilidade: "Hist\u00f3rico de Execu\u00e7\u00e3o",
  gerencial: "Configura\u00e7\u00f5es Gerais",
  contas: "Equipe / Usu\u00e1rios",
  perfil: "Meu Perfil",
};

function getActiveTabKey() {
  const activeBtn = Array.from(tabButtons || []).find(
    (botao) => botao.classList.contains("is-active") || botao.classList.contains("active")
  );
  if (activeBtn && activeBtn.dataset.tab) {
    return activeBtn.dataset.tab;
  }
  const activePanel = Array.from(panels || []).find((panel) =>
    panel.classList.contains("is-active")
  );
  return activePanel ? activePanel.dataset.panel : "inicio";
}

function getActiveTabLabel() {
  const activeBtn = Array.from(tabButtons || []).find(
    (botao) => botao.classList.contains("is-active") || botao.classList.contains("active")
  );
  if (activeBtn) {
    const labelEl = activeBtn.querySelector(".nav-item__label");
    const label = labelEl ? labelEl.textContent.trim() : "";
    if (label) {
      return label;
    }
    const tab = activeBtn.dataset.tab || "";
    return TAB_LABELS[tab] || tab || "In\u00edcio";
  }
  const tabKey = getActiveTabKey();
  return TAB_LABELS[tabKey] || "In\u00edcio";
}

function renderBreadcrumb() {
  if (!crumbs) {
    return;
  }
  const activeProject = getActiveProject();
  const projectLabel = activeProject ? getProjectLabel(activeProject) : "Projeto n\u00e3o definido";
  const moduleLabel = getActiveTabLabel();
  crumbs.innerHTML = `<span class=\"crumbs__label\">Projeto:</span> <span class=\"crumbs__project\">${escapeHtml(
    projectLabel
  )}</span> <span class=\"crumbs__sep\">&#8250;</span> <span class=\"crumbs__module\">${escapeHtml(
    moduleLabel
  )}</span>`;
}

const HELP_OVERVIEW = [
  "A OPSCOPE \u00e9 uma plataforma de gest\u00e3o operacional e manuten\u00e7\u00e3o que centraliza processos, evid\u00eancias e indicadores.",
  "Ela organiza a rotina entre planejamento, execu\u00e7\u00e3o, controle e relat\u00f3rios em um fluxo \u00fanico, com rastreabilidade e padroniza\u00e7\u00e3o.",
  "Fluxo principal: Planejamento -> Execu\u00e7\u00e3o -> Controle -> Relat\u00f3rios.",
];

const HELP_NAVIGATION = [
  "Use o menu lateral (sidebar) para alternar entre m\u00f3dulos.",
  "Troque o projeto ativo no seletor de projetos antes de iniciar qualquer a\u00e7\u00e3o.",
  "O breadcrumb mostra Projeto e M\u00f3dulo atuais; utilize-o para se orientar.",
  "Notifica\u00e7\u00f5es destacam prazos e pend\u00eancias; mensagens concentram feedbacks.",
  "Filtros e buscas refinam listas por status, per\u00edodo, prioridade e equipe.",
];

const HELP_BEST_PRACTICES = [
  "Padronize nomes, descri\u00e7\u00f5es e categorias para facilitar auditoria.",
  "Registre evid\u00eancias completas antes de concluir uma execu\u00e7\u00e3o.",
  "Mantenha os status atualizados para refletir a realidade operacional.",
  "Revise o projeto ativo antes de salvar altera\u00e7\u00f5es.",
  "Utilize checklists para garantir conformidade e seguran\u00e7a.",
];

const HELP_GLOSSARY = [
  { term: "OS", desc: "Ordem de Servi\u00e7o vinculada \u00e0 execu\u00e7\u00e3o." },
  { term: "RDO", desc: "Relat\u00f3rio Di\u00e1rio de Opera\u00e7\u00e3o." },
  { term: "PMP", desc: "Plano de Manuten\u00e7\u00e3o Preventiva." },
  { term: "SLA", desc: "N\u00edvel de servi\u00e7o acordado." },
  { term: "Backlog", desc: "Fila de atividades pendentes." },
  { term: "KPI", desc: "Indicador-chave de desempenho." },
  { term: "Conforme", desc: "Atividade executada dentro do padr\u00e3o esperado." },
  { term: "N\u00e3o conforme", desc: "Atividade com desvios ou pend\u00eancias relevantes." },
];

const HELP_EXAMPLES = [
  "Execu\u00e7\u00e3o de manuten\u00e7\u00e3o com checklist e evid\u00eancias anexadas.",
  "Preenchimento do RDO di\u00e1rio com jornada, clima e ocorr\u00eancias.",
  "Uso do PMP para programar atividades preventivas ao longo do ano.",
  "Gera\u00e7\u00e3o de relat\u00f3rios com exporta\u00e7\u00e3o em PDF ou Excel.",
];

const HELP_SUPPORT = [
  "Consulte a base interna de conhecimento da opera\u00e7\u00e3o.",
  "Acione o PCM/O&M respons\u00e1vel pelo projeto para d\u00favidas operacionais.",
  "Registre chamados na Central de Suporte OPSCOPE quando necess\u00e1rio.",
];

const HELP_MODULES = {
  inicio: {
    purpose: "Centraliza indicadores, alertas e atalhos do projeto ativo.",
    when: "Use no in\u00edcio do dia para revisar prioridades e pend\u00eancias.",
    examples: [
      "Abrir Execu\u00e7\u00e3o do Dia a partir dos alertas.",
      "Identificar pend\u00eancias cr\u00edticas antes de iniciar a rotina.",
    ],
  },
  programacao: {
    purpose: "Organiza a agenda de manuten\u00e7\u00f5es e libera\u00e7\u00f5es.",
    when: "Use para planejar datas, recursos e acompanhar status.",
    examples: [
      "Reprogramar uma atividade atrasada com novo prazo.",
      "Registrar observa\u00e7\u00e3o operacional antes da execu\u00e7\u00e3o.",
    ],
  },
  nova: {
    purpose: "Registra novas manuten\u00e7\u00f5es e tarefas operacionais.",
    when: "Use sempre que uma nova OS precisar ser criada.",
    examples: [
      "Criar uma nova OS com prioridade e categoria.",
      "Vincular equipamentos e participantes antes de salvar.",
    ],
  },
  modelos: {
    purpose: "Padroniza modelos e recorr\u00eancias de manuten\u00e7\u00e3o.",
    when: "Use para manter modelos consistentes e repet\u00edveis.",
    examples: [
      "Criar um modelo mensal para inspe\u00e7\u00f5es preventivas.",
      "Ativar ou revisar recorr\u00eancias vigentes.",
    ],
  },
  pmp: {
    purpose: "Organiza o Plano de Manuten\u00e7\u00e3o Preventiva (PMP).",
    when: "Use para programar atividades preventivas no calend\u00e1rio.",
    examples: [
      "Importar manuten\u00e7\u00f5es existentes para o PMP.",
      "Ajustar frequ\u00eancia e respons\u00e1veis.",
    ],
  },
  execucao: {
    purpose: "Registra e acompanha execu\u00e7\u00f5es do dia.",
    when: "Use durante a opera\u00e7\u00e3o para registrar in\u00edcio, fim e evid\u00eancias.",
    examples: [
      "Iniciar uma execu\u00e7\u00e3o e anexar evid\u00eancias.",
      "Encerrar atividade com OS e descri\u00e7\u00e3o t\u00e9cnica.",
    ],
  },
  backlog: {
    purpose: "Controla atividades pendentes e atrasadas.",
    when: "Use para justificar pend\u00eancias e reprogramar prazos.",
    examples: [
      "Registrar motivo de backlog por indisponibilidade.",
      "Priorizar atividades cr\u00edticas para a pr\u00f3xima semana.",
    ],
  },
  solicitacoes: {
    purpose: "Gerencia solicita\u00e7\u00f5es de acesso e aprova\u00e7\u00f5es.",
    when: "Use para aprovar ou recusar solicita\u00e7\u00f5es pendentes.",
    examples: [
      "Aprovar solicita\u00e7\u00e3o com justificativa registrada.",
      "Recusar solicita\u00e7\u00e3o com motivo claro.",
    ],
  },
};

Object.assign(HELP_MODULES, {
  projetos: {
    purpose: "Administra projetos, locais, equipes e equipamentos.",
    when: "Use quando for necess\u00e1rio ajustar dados do projeto.",
    examples: [
      "Cadastrar novos locais de trabalho.",
      "Atualizar informa\u00e7\u00f5es de equipamentos.",
    ],
  },
  desempenho: {
    purpose: "Apresenta indicadores de desempenho consolidados.",
    when: "Use para acompanhar resultados do projeto.",
    examples: [
      "Comparar KPI do m\u00eas atual com per\u00edodo anterior.",
      "Identificar aumento de backlog.",
    ],
  },
  "performance-projects": {
    purpose: "Compara desempenho entre projetos.",
    when: "Use para analisar SLA e criticidade por contrato.",
    examples: ["Comparar dois projetos e identificar desvios."],
  },
  "performance-people": {
    purpose: "Analisa desempenho por colaborador.",
    when: "Use para balancear carga e identificar gargalos.",
    examples: ["Revisar ranking de colaboradores por execu\u00e7\u00e3o."],
  },
  tendencias: {
    purpose: "Exibe KPIs e tend\u00eancias de longo prazo.",
    when: "Use para avaliar padr\u00f5es e riscos operacionais.",
    examples: ["Avaliar tend\u00eancia trimestral de SLA."],
  },
  relatorios: {
    purpose: "Gera relat\u00f3rios operacionais e gerenciais.",
    when: "Use para consolidar resultados e exportar dados.",
    examples: [
      "Gerar relat\u00f3rio mensal e exportar PDF.",
      "Emitir RDO mensal para o cliente.",
    ],
  },
  feedbacks: {
    purpose: "Centraliza feedbacks operacionais.",
    when: "Use para registrar feedbacks e acompanhar retornos.",
    examples: ["Enviar feedback ap\u00f3s execu\u00e7\u00e3o conclu\u00edda."],
  },
  rastreabilidade: {
    purpose: "Permite auditar hist\u00f3rico de execu\u00e7\u00f5es.",
    when: "Use para consultar registros e evid\u00eancias.",
    examples: ["Buscar uma OS e verificar status e evid\u00eancias."],
  },
  gerencial: {
    purpose: "Re\u00fane configura\u00e7\u00f5es e diagn\u00f3sticos do sistema.",
    when: "Use para governan\u00e7a e ajustes globais.",
    examples: ["Revisar logs e permiss\u00f5es quando autorizado."],
  },
  contas: {
    purpose: "Gerencia contas, equipes e permiss\u00f5es.",
    when: "Use para administrar usu\u00e1rios e perfis.",
    examples: ["Inativar usu\u00e1rio e ajustar cargo."],
  },
  perfil: {
    purpose: "Exibe e permite ajustar informa\u00e7\u00f5es do perfil.",
    when: "Use para atualizar dados pessoais quando permitido.",
    examples: ["Atualizar telefone e confirmar altera\u00e7\u00f5es."],
  },
});

const HELP_MODULE_ACTIONS = {
  inicio: [
    { label: "Visualizar indicadores e alertas do projeto ativo.", allow: () => true },
    { label: "Acessar atalhos para m\u00f3dulos operacionais.", allow: () => true },
  ],
  programacao: [
    { label: "Visualizar agenda e filtros operacionais.", allow: () => true },
    { label: "Reprogramar prazos e janelas de execu\u00e7\u00e3o.", allow: () => can("reschedule") },
    { label: "Editar observa\u00e7\u00f5es e dados de manuten\u00e7\u00e3o.", allow: () => can("edit") },
    { label: "Liberar ou registrar execu\u00e7\u00f5es.", allow: () => can("complete") },
    { label: "Remover registros quando autorizado.", allow: () => can("remove") },
  ],
  nova: [
    { label: "Criar manuten\u00e7\u00f5es e definir prioridades.", allow: () => can("create") },
    { label: "Anexar evid\u00eancias, documentos e checklists.", allow: () => can("create") },
    { label: "Visualizar par\u00e2metros do projeto ativo.", allow: () => true },
  ],
  modelos: [
    { label: "Visualizar modelos e recorr\u00eancias.", allow: () => true },
    { label: "Criar ou editar modelos conforme permiss\u00e3o.", allow: () => can("create") || can("edit") },
    { label: "Ativar ou desativar modelos.", allow: () => can("edit") },
  ],
  pmp: [
    { label: "Visualizar o cronograma PMP.", allow: () => true },
    { label: "Cadastrar e editar atividades PMP.", allow: () => canManagePmpActivities(currentUser) },
    { label: "Anexar procedimentos e documentos PMP.", allow: () => canUploadPmpProcedimento(currentUser) },
    { label: "Exportar o plano PMP quando permitido.", allow: () => canManagePmpActivities(currentUser) },
  ],
  execucao: [
    { label: "Registrar in\u00edcio e t\u00e9rmino das execu\u00e7\u00f5es.", allow: () => can("complete") },
    { label: "Anexar evid\u00eancias e concluir atividades.", allow: () => can("complete") },
    { label: "Visualizar pend\u00eancias do dia.", allow: () => true },
  ],
  backlog: [
    { label: "Visualizar atividades pendentes e prioriza\u00e7\u00f5es.", allow: () => true },
    { label: "Registrar motivo de backlog.", allow: () => can("edit") },
    { label: "Reprogramar datas e recursos.", allow: () => can("reschedule") },
  ],
  solicitacoes: [
    { label: "Visualizar solicita\u00e7\u00f5es pendentes.", allow: () => true },
    { label: "Aprovar ou recusar solicita\u00e7\u00f5es.", allow: () => can("edit") || isAdmin() },
  ],
};

Object.assign(HELP_MODULE_ACTIONS, {
  projetos: [
    { label: "Visualizar dados do projeto ativo.", allow: () => true },
    { label: "Gerenciar projetos e contratos.", allow: () => canManageProjetos(currentUser) },
    { label: "Gerenciar equipamentos e tags.", allow: () => canManageEquipamentos(currentUser) },
    { label: "Gerenciar equipe do projeto.", allow: () => canManageEquipeProjeto(currentUser) },
  ],
  desempenho: [{ label: "Visualizar indicadores consolidados.", allow: () => true }],
  "performance-projects": [{ label: "Comparar desempenho entre projetos.", allow: () => true }],
  "performance-people": [{ label: "Comparar desempenho por colaborador.", allow: () => true }],
  tendencias: [{ label: "Analisar tend\u00eancias e KPIs.", allow: () => true }],
  relatorios: [
    { label: "Visualizar relat\u00f3rios gerenciais.", allow: () => canViewRelatorios(currentUser) },
    { label: "Exportar relat\u00f3rios em PDF ou Excel.", allow: () => canExportRelatorios(currentUser) },
  ],
  feedbacks: [{ label: "Enviar e acompanhar feedbacks.", allow: () => true }],
  rastreabilidade: [
    { label: "Consultar hist\u00f3rico e auditoria de execu\u00e7\u00f5es.", allow: () => true },
  ],
  gerencial: [
    { label: "Acessar configura\u00e7\u00f5es gerais do sistema.", allow: () => canViewGerencial(currentUser) },
    { label: "Revisar diagn\u00f3sticos e logs (quando permitido).", allow: () =>
        canAccessGerencialTab("diagnostico", currentUser) || canAccessGerencialTab("logs", currentUser) },
    { label: "Gerenciar permiss\u00f5es e perfis.", allow: () => canAccessGerencialTab("permissoes", currentUser) },
    { label: "Administrar arquivos e automa\u00e7\u00f5es.", allow: () =>
        canAccessGerencialTab("arquivos", currentUser) || canAccessGerencialTab("automacoes", currentUser) },
  ],
  contas: [
    { label: "Visualizar contas e equipes.", allow: () => true },
    { label: "Cadastrar e editar usu\u00e1rios.", allow: () => canViewUsuarios(currentUser) && isAdmin() },
  ],
  perfil: [
    { label: "Visualizar dados do perfil.", allow: () => true },
    { label: "Editar informa\u00e7\u00f5es pessoais quando permitido.", allow: () =>
        Boolean(currentUser && canEditProfile(currentUser, currentUser)) },
  ],
});

function getHelpRoleKey(user) {
  if (!user) {
    return "tecnico";
  }
  const cargo = normalizeCargo(user.cargo);
  const role = String(user.role || user.rbacRole || "").trim().toLowerCase();
  if (cargo.includes("admin") || role === "admin" || role === "administrator") {
    return "administrador";
  }
  if (cargo.includes("gerente") || cargo.includes("coordenador") || cargo.includes("diretor") || role.includes("gerente")) {
    return "gerente";
  }
  if (cargo.includes("supervisor") || role.includes("supervisor")) {
    return "supervisor";
  }
  if (cargo.includes("tecnico") || role.includes("tecnico") || role.includes("executor")) {
    return "tecnico";
  }
  return "tecnico";
}

function getHelpRoleLabel(roleKey) {
  const labels = {
    tecnico: "T\u00e9cnico",
    supervisor: "Supervisor",
    gerente: "Gerente / Coordenador",
    administrador: "Administrador",
  };
  return labels[roleKey] || "T\u00e9cnico";
}

function getRoleHelpData(roleKey, user) {
  const canRdoGenerate = Boolean(user && canGerarRelatorio(user));
  const canRel = Boolean(user && canViewRelatorios(user));
  const canExport = Boolean(user && canExportRelatorios(user));
  const baseTechCan = [
    "Executar e registrar manuten\u00e7\u00f5es do projeto ativo.",
    "Preencher checklists e registrar evid\u00eancias (fotos e documentos).",
    "Atualizar status das atividades (Agendada, Executada, Conforme, Atrasada).",
    "Finalizar atividades com OS e descri\u00e7\u00e3o t\u00e9cnica.",
  ];
  if (canRdoGenerate) {
    baseTechCan.push("Preencher o RDO di\u00e1rio com registros da opera\u00e7\u00e3o.");
  }

  const baseTechHow = [
    "Siga os procedimentos aprovados antes de iniciar a execu\u00e7\u00e3o.",
    "Registre in\u00edcio e fim das atividades conforme o padr\u00e3o.",
    "Anexe evid\u00eancias obrigat\u00f3rias e confirme o checklist.",
  ];
  if (canRdoGenerate) {
    baseTechHow.push("Preencha o RDO di\u00e1rio com jornada, clima e ocorr\u00eancias.");
  }

  const baseTechRestrictions = [
    "Configura\u00e7\u00f5es de usu\u00e1rios, permiss\u00f5es e par\u00e2metros globais.",
    "Edi\u00e7\u00e3o de projetos, equipes e templates (restrito \u00e0 gest\u00e3o).",
  ];

  const baseTechPractices = [
    "Mantenha evid\u00eancias organizadas e completas.",
    "Registre observa\u00e7\u00f5es t\u00e9cnicas em caso de exce\u00e7\u00f5es.",
    "N\u00e3o finalize atividades sem OS e valida\u00e7\u00e3o.",
  ];

  if (roleKey === "supervisor") {
    const supervisorExtras = [
      "Revisar execu\u00e7\u00f5es e validar evid\u00eancias da equipe.",
      "Controlar backlog e priorizar atividades cr\u00edticas.",
      "Acompanhar equipe e distribuir carga de trabalho.",
      "Garantir cumprimento do PMP e prazos contratuais.",
    ];
    const atrasoActions = [
      "Registrar motivo do atraso e reprogramar prazo.",
      "Comunicar riscos ao gestor e ajustar recursos.",
      "Priorizar atividades com impacto em SLA.",
    ];
    return {
      title: "Supervisor",
      intro: "Perfil respons\u00e1vel por execu\u00e7\u00e3o e valida\u00e7\u00e3o da equipe.",
      sections: [
        { title: "O que voc\u00ea pode fazer", items: baseTechCan.concat(supervisorExtras) },
        { title: "Como atuar no dia a dia", items: baseTechHow },
        { title: "A\u00e7\u00f5es em atraso ou n\u00e3o conformidade", items: atrasoActions },
        { title: "Boas pr\u00e1ticas operacionais", items: baseTechPractices },
      ],
    };
  }

  if (roleKey === "gerente") {
    const managerIndicators = [
      "Interpretar KPIs, tend\u00eancias e SLA do projeto.",
      "Comparar desempenho entre projetos e colaboradores.",
      "Identificar desvios e definir planos de a\u00e7\u00e3o.",
    ];
    const managerReports = [
      "Gerar relat\u00f3rios gerenciais para tomada de decis\u00e3o.",
      "Emitir RDO di\u00e1rio e RDO mensal quando permitido.",
      "Exportar dados para auditoria e contratos.",
    ].filter((item) => {
      if (item.includes("RDO") && !canRdoGenerate) {
        return false;
      }
      if (item.includes("Exportar") && !canExport) {
        return false;
      }
      if (item.includes("relat\u00f3rios") && !canRel) {
        return false;
      }
      return true;
    });
    return {
      title: "Gerente / Coordenador",
      intro: "Perfil focado em gest\u00e3o, an\u00e1lise de desempenho e relat\u00f3rios.",
      sections: [
        { title: "Indicadores e an\u00e1lise", items: managerIndicators },
        { title: "Relat\u00f3rios e consolida\u00e7\u00e3o", items: managerReports },
        { title: "Boas pr\u00e1ticas de gest\u00e3o", items: [
          "Defina metas claras e acompanhe desvios semanalmente.",
          "Garanta alinhamento entre planejamento e execu\u00e7\u00e3o.",
          "Use dados para orientar ajustes de equipe e contrato.",
        ] },
      ],
    };
  }

  if (roleKey === "administrador") {
    return {
      title: "Administrador",
      intro: "Perfil respons\u00e1vel por configura\u00e7\u00e3o, governan\u00e7a e seguran\u00e7a da OPSCOPE.",
      sections: [
        { title: "Configura\u00e7\u00f5es do sistema", items: [
          "Cadastrar e gerenciar usu\u00e1rios e perfis.",
          "Definir permiss\u00f5es e acessos por cargo.",
          "Administrar projetos, equipes e equipamentos.",
          "Configurar templates, padr\u00f5es e PMP.",
        ] },
        { title: "Boas pr\u00e1ticas de governan\u00e7a", items: [
          "Revisar permiss\u00f5es periodicamente.",
          "Padronizar cadastros para evitar inconsist\u00eancias.",
          "Auditar logs e registros sens\u00edveis.",
        ] },
      ],
    };
  }

  return {
    title: "T\u00e9cnico",
    intro: "Perfil focado na execu\u00e7\u00e3o das atividades de manuten\u00e7\u00e3o.",
    sections: [
      { title: "O que voc\u00ea pode fazer", items: baseTechCan },
      { title: "Como executar as atividades", items: baseTechHow },
      { title: "O que n\u00e3o pode acessar", items: baseTechRestrictions },
      { title: "Boas pr\u00e1ticas operacionais", items: baseTechPractices },
    ],
  };
}

function buildHelpList(items = []) {
  if (!items.length) {
    return "<p class=\"help-empty\">Conte\u00fado indispon\u00edvel para este perfil.</p>";
  }
  return `<ul class=\"help-list\">${items
    .map((item) => `<li>${escapeHtml(item)}</li>`)
    .join("")}</ul>`;
}

function buildHelpGlossary(items = []) {
  if (!items.length) {
    return "";
  }
  return `<dl class=\"help-glossary\">${items
    .map(
      (item) =>
        `<div class=\"help-glossary__item\"><dt>${escapeHtml(
          item.term
        )}</dt><dd>${escapeHtml(item.desc)}</dd></div>`
    )
    .join("")}</dl>`;
}

function buildHelpParagraphs(paragraphs = []) {
  return paragraphs
    .map((item) => `<p class=\"help-section__text\">${escapeHtml(item)}</p>`)
    .join("");
}

function buildHelpSubsections(sections = []) {
  return sections
    .map(
      (section) => `
        <div class="help-subsection">
          <h5>${escapeHtml(section.title)}</h5>
          ${buildHelpList(section.items)}
        </div>
      `
    )
    .join("");
}

function getModuleHelpData(moduleKey, moduleLabel) {
  const fallback = {
    purpose: `Conte\u00fado de apoio para o m\u00f3dulo ${moduleLabel || "atual"}.`,
    when: "Utilize conforme a rotina operacional do projeto.",
    examples: ["Revise filtros e indicadores antes de confirmar a\u00e7\u00f5es."],
  };
  return HELP_MODULES[moduleKey] || fallback;
}

function getModuleActions(moduleKey) {
  const entries = HELP_MODULE_ACTIONS[moduleKey] || [];
  const allowed = entries.filter((item) => {
    try {
      return item.allow();
    } catch (error) {
      return false;
    }
  });
  if (!allowed.length) {
    return ["Somente visualiza\u00e7\u00e3o conforme permiss\u00e3o."];
  }
  return allowed.map((item) => item.label);
}

function renderHelpModal() {
  if (!modalHelp || !helpContent || !helpTitle || !helpMeta) {
    return;
  }
  const activeProject = getActiveProject();
  const projectLabel = activeProject ? getProjectLabel(activeProject) : "Projeto n\u00e3o definido";
  const moduleKey = getActiveTabKey();
  const moduleLabel = getActiveTabLabel();
  const roleKey = getHelpRoleKey(currentUser);
  const roleData = getRoleHelpData(roleKey, currentUser);
  const cargoLabel = currentUser && String(currentUser.cargo || "").trim();
  const profileLabel = cargoLabel || getHelpRoleLabel(roleKey);
  const moduleHelp = getModuleHelpData(moduleKey, moduleLabel);
  const moduleActions = getModuleActions(moduleKey);

  helpTitle.textContent = "Ajuda / Como usar a OPSCOPE";
  helpMeta.textContent = `M\u00f3dulo: ${moduleLabel} \u00b7 Projeto: ${projectLabel} \u00b7 Perfil: ${profileLabel}`;

  helpContent.innerHTML = `
    <div class="help-intro">
      <strong>Ajuda / Como usar a OPSCOPE</strong>
      <p>Documenta\u00e7\u00e3o operacional contextual ao m\u00f3dulo, projeto e perfil.</p>
    </div>
    <section class="help-section">
      <h4 class="help-section__title">Vis\u00e3o Geral da OPSCOPE</h4>
      ${buildHelpParagraphs(HELP_OVERVIEW)}
    </section>
    <section class="help-section">
      <h4 class="help-section__title">Navega\u00e7\u00e3o na Plataforma</h4>
      ${buildHelpList(HELP_NAVIGATION)}
    </section>
    <section class="help-section">
      <h4 class="help-section__title">Como usar o M\u00f3dulo Atual</h4>
      <div class="help-subsection">
        <h5>Para que serve</h5>
        <p class="help-section__text">${escapeHtml(moduleHelp.purpose)}</p>
      </div>
      <div class="help-subsection">
        <h5>Quando usar</h5>
        <p class="help-section__text">${escapeHtml(moduleHelp.when)}</p>
        <p class="help-section__text">As a\u00e7\u00f5es abaixo aplicam-se ao projeto ativo: ${escapeHtml(
          projectLabel
        )}.</p>
      </div>
      <div class="help-subsection">
        <h5>O que voc\u00ea pode fazer</h5>
        ${buildHelpList(moduleActions)}
      </div>
      <div class="help-subsection">
        <h5>Exemplos pr\u00e1ticos no m\u00f3dulo</h5>
        ${buildHelpList(moduleHelp.examples)}
      </div>
    </section>
    <section class="help-section">
      <h4 class="help-section__title">Se\u00e7\u00e3o por Cargo: ${escapeHtml(roleData.title)}</h4>
      <p class="help-section__text">${escapeHtml(roleData.intro)}</p>
      ${buildHelpSubsections(roleData.sections)}
    </section>
    <section class="help-section">
      <h4 class="help-section__title">Boas Pr\u00e1ticas Gerais</h4>
      ${buildHelpList(HELP_BEST_PRACTICES)}
    </section>
    <section class="help-section">
      <h4 class="help-section__title">Gloss\u00e1rio de Termos</h4>
      ${buildHelpGlossary(HELP_GLOSSARY)}
    </section>
    <section class="help-section">
      <h4 class="help-section__title">Exemplos Pr\u00e1ticos</h4>
      ${buildHelpList(HELP_EXAMPLES)}
    </section>
    <section class="help-section">
      <h4 class="help-section__title">Suporte</h4>
      ${buildHelpList(HELP_SUPPORT)}
    </section>
  `;
}

function openHelpModal() {
  if (!modalHelp) {
    return;
  }
  renderHelpModal();
  modalHelp.hidden = false;
}

function closeHelpModal() {
  if (!modalHelp) {
    return;
  }
  modalHelp.hidden = true;
}

function getActiveProjectClient() {
  const project = getActiveProject();
  const cliente = project && project.cliente ? String(project.cliente).trim() : "";
  return cliente || RDO_CLIENTE;
}

function isDefaultProjectActive() {
  const project = getActiveProject();
  return project && String(project.codigo || "").trim() === DEFAULT_PROJECT_CODE;
}

function normalizeLocaisList(value) {
  if (!value) {
    return [];
  }
  let items = [];
  if (Array.isArray(value)) {
    items = value;
  } else if (typeof value === "string") {
    items = value.split(/[\n,;]+/g);
  } else {
    return [];
  }
  const normalized = items
    .map((item) => String(item || "").trim())
    .filter(Boolean);
  return Array.from(new Set(normalized));
}

function parseProjectLocaisInput(value) {
  return normalizeLocaisList(value);
}

function getActiveProjectLocais() {
  const project = getActiveProject();
  const locais = project && Array.isArray(project.locais) ? project.locais : [];
  if (!locais.length && isDefaultProjectActive()) {
    return DEFAULT_PROJECT_LOCAIS.slice();
  }
  return normalizeLocaisList(locais);
}

function getDefaultRdoLocal() {
  const locais = getActiveProjectLocais();
  return locais.length ? locais[0] : "";
}

function getActiveProjectShortLabel() {
  const project = getActiveProject();
  if (!project) {
    return "projeto";
  }
  const codigo = String(project.codigo || "").trim();
  const nome = String(project.nome || "").trim();
  if (codigo) {
    return `projeto ${codigo}`;
  }
  if (nome) {
    return `projeto ${nome}`;
  }
  return "projeto";
}

function getSubestacoesBase() {
  const project = getActiveProject();
  return project ? [getProjectLabel(project)] : [];
}

function isDefaultSeedTemplate(template) {
  if (!template || typeof template !== "object") {
    return false;
  }
  return template.createdBy === SYSTEM_USER_ID && DEFAULT_TEMPLATE_NAMES.has(template.nome);
}

function shouldClearDefaultTemplates(list) {
  return Array.isArray(list) && list.length > 0 && list.every(isDefaultSeedTemplate);
}

function getUserProjectLabel(user) {
  if (!user) {
    return "-";
  }
  const projectId = user.projectId || "";
  if (projectId && Array.isArray(availableProjects)) {
    const project = availableProjects.find((item) => item.id === projectId);
    if (project) {
      return getProjectLabel(project);
    }
  }
  return user.projeto || user.localizacao || "-";
}

function renderProjectSelectOptions(select, selectedId) {
  if (!select) {
    return;
  }
  const baseOption = document.createElement("option");
  baseOption.value = "";
  baseOption.textContent = "Selecione";
  select.innerHTML = "";
  select.append(baseOption);
  if (Array.isArray(availableProjects)) {
    availableProjects.forEach((project) => {
      const opt = document.createElement("option");
      opt.value = project.id;
      opt.textContent = getProjectLabel(project);
      select.append(opt);
    });
  }
  select.disabled = !availableProjects.length;
  if (selectedId) {
    select.value = selectedId;
  }
}

function isAdmin() {
  return Boolean(currentUser && isFullAccessUser(currentUser));
}

function getMaintenancePermissionsForUser(user) {
  if (!user) {
    return getEmptyPermissions();
  }
  const rolePermissions = Array.isArray(user.rolePermissions) ? user.rolePermissions : [];
  const accessPermissions = Array.isArray(user.accessPermissions) ? user.accessPermissions : [];
  const permissionList = rolePermissions.length ? rolePermissions : accessPermissions;
  if (permissionList.length) {
    return deriveMaintenancePermissions(permissionList, user.permissions, true);
  }
  if (user.permissions && typeof user.permissions === "object" && !Array.isArray(user.permissions)) {
    return user.permissions;
  }
  return getEmptyPermissions();
}

function can(action) {
  if (!currentUser) {
    return false;
  }
  if (currentUser.role === "admin" || isFullAccessUser(currentUser)) {
    return true;
  }
  const permissions = getMaintenancePermissionsForUser(currentUser);
  return Boolean(permissions[action]);
}

function requirePermission(action) {
  if (!currentUser) {
    mostrarMensagemManutencao("Faça login para executar esta ação.", true);
    return false;
  }
  if (!can(action)) {
    mostrarMensagemManutencao("Você não tem permissão para esta ação.", true);
    return false;
  }
  return true;
}

function statusValido(status) {
  return Boolean(STATUS_LABELS[status]);
}

function hasExecucaoRegistrada(item) {
  if (!item) {
    return false;
  }
  const registro = item.registroExecucao || {};
  const registradoEm =
    registro.registradoEm ||
    registro.registrado_em ||
    registro.executadoEm ||
    registro.executedAt;
  const executadoPor = registro.executadoPor || registro.executedBy;
  const comentario = registro.comentario || registro.descricao || registro.resumo;
  const observacao = registro.observacaoExecucao || registro.observacao;
  const resultado = registro.resultado || registro.status;
  const evidencias =
    Array.isArray(registro.evidencias) && registro.evidencias.length > 0;
  const marcadorTopo =
    item.execucaoRegistradaEm || item.executionRegisteredAt || item.execucaoRegistradaAt;
  return Boolean(
    registradoEm ||
      executadoPor ||
      comentario ||
      resultado ||
      observacao ||
      evidencias ||
      marcadorTopo
  );
}

function hasExecucaoRegistradaCompleta(item) {
  if (!item) {
    return false;
  }
  const registro = item.registroExecucao || {};
  const executadoPor =
    registro.executadoPor ||
    registro.executedBy ||
    item.executadaPor ||
    item.executionStartedBy ||
    item.createdBy ||
    "";
  const comentario = registro.comentario || registro.descricao || registro.resumo || "";
  const comentarioNormalizado = normalizeResumoRdoTexto(comentario);
  return Boolean(executadoPor && comentarioNormalizado.length >= MIN_RESUMO_RDO_CHARS);
}

function buildManutencaoResumoTexto(item) {
  if (!item) {
    return "-";
  }
  const titulo = item.titulo || "Manutenção";
  const local = item.local || "-";
  const equipamentoLabel = getMaintenanceEquipamentoLabel(item);
  const equipamentoTexto =
    equipamentoLabel && equipamentoLabel !== "-"
      ? `Equipamento: ${equipamentoLabel}`
      : "Equipamento não informado";
  const dataParsed = item.data ? parseDate(item.data) : null;
  const dataTexto = dataParsed ? formatDate(dataParsed) : "data indefinida";
  return `${titulo} | ${local} | ${equipamentoTexto} | ${dataTexto}`;
}

function normalizeIso(value) {
  if (!value) {
    return value;
  }
  const iso = toIsoUtc(value);
  return iso || value;
}

function normalizarManutencoes(lista) {
  const hoje = startOfDay(new Date());
  const changes = [];
  let mudouTempo = false;
  const normalizadas = lista.map((item) => {
    if (!item || typeof item !== "object") {
      return item;
    }
    const projectId = activeProjectId || item.projectId || "";
    const createdAt = normalizeIso(item.createdAt);
    const updatedAt = normalizeIso(item.updatedAt);
    const doneAt = normalizeIso(item.doneAt);
    const executionStartedAt = normalizeIso(item.executionStartedAt);
    const executionFinishedAt = normalizeIso(item.executionFinishedAt);
    let conclusao = item.conclusao;
    if (conclusao && typeof conclusao === "object") {
      const inicio = normalizeIso(conclusao.inicio);
      const fim = normalizeIso(conclusao.fim);
      if (inicio !== conclusao.inicio || fim !== conclusao.fim) {
        conclusao = { ...conclusao, inicio, fim };
      }
    }
    if (
      createdAt !== item.createdAt ||
      updatedAt !== item.updatedAt ||
      doneAt !== item.doneAt ||
      executionStartedAt !== item.executionStartedAt ||
      executionFinishedAt !== item.executionFinishedAt ||
      conclusao !== item.conclusao
    ) {
      mudouTempo = true;
    }
    const statusOriginal = normalizeMaintenanceStatus(item.status);
    if (statusOriginal === "concluida") {
      return {
        ...item,
        status: statusOriginal,
        createdAt,
        updatedAt,
        doneAt,
        executionStartedAt,
        executionFinishedAt,
        conclusao,
      };
    }
    if (hasExecucaoRegistrada(item)) {
      const registro = item.registroExecucao || {};
      const statusEsperado = registro.resultado ? "encerramento" : "em_execucao";
      if (statusEsperado !== statusOriginal) {
        changes.push({ id: item.id, from: statusOriginal, to: statusEsperado });
      }
      return {
        ...item,
        status: statusEsperado,
        updatedAt: statusEsperado !== statusOriginal ? toIsoUtc(new Date()) : updatedAt,
        updatedBy: statusEsperado !== statusOriginal ? SYSTEM_USER_ID : item.updatedBy,
        createdAt,
        doneAt,
        executionStartedAt,
        executionFinishedAt,
        conclusao,
      };
    }
    if (statusOriginal === "em_execucao" || statusOriginal === "encerramento") {
      return {
        ...item,
        status: statusOriginal,
        createdAt,
        updatedAt,
        doneAt,
        executionStartedAt,
        executionFinishedAt,
        conclusao,
      };
    }
    const data = parseDate(item.data);
    const atrasada = Boolean(data && data < hoje);
    let novoStatus = statusOriginal;
    if (atrasada) {
      novoStatus = "backlog";
    } else if (isLiberacaoOk(item)) {
      novoStatus = "liberada";
    } else {
      novoStatus = "agendada";
    }
    if (novoStatus !== statusOriginal) {
      changes.push({ id: item.id, from: statusOriginal, to: novoStatus });
      return {
        ...item,
        projectId: item.projectId || projectId,
        status: novoStatus,
        updatedAt: toIsoUtc(new Date()),
        updatedBy: SYSTEM_USER_ID,
        createdAt,
        doneAt,
        executionStartedAt,
        executionFinishedAt,
        conclusao,
      };
    }
    return {
      ...item,
      projectId: item.projectId || projectId,
      status: statusOriginal,
      createdAt,
      updatedAt,
      doneAt,
      executionStartedAt,
      executionFinishedAt,
      conclusao,
    };
  });
  return { normalizadas, mudou: changes.length > 0 || mudouTempo, changes };
}

function getMaintenanceEquipamentoKey(item) {
  if (!item || typeof item !== "object") {
    return "";
  }
  const raw =
    item.equipamentoId ||
    (item.equipamento && item.equipamento.id) ||
    (item.equipamento && (item.equipamento.tag || item.equipamento.nome || item.equipamento.name)) ||
    (typeof item.equipamento === "string" ? item.equipamento : "");
  const label = raw || getMaintenanceEquipamentoLabel(item);
  const normalized = normalizeSearchValue(String(label || ""));
  if (!normalized || normalized === "-") {
    return "";
  }
  return normalized;
}

function getMaintenanceDedupKey(item) {
  if (!item || typeof item !== "object") {
    return "";
  }
  const projectId = item.projectId || activeProjectId || "";
  const templateId = String(item.templateId || "").trim();
  const data = String(item.data || "").trim();
  if (templateId && data) {
    const equipamentoKey = getMaintenanceEquipamentoKey(item);
    return equipamentoKey
      ? `tpl|${projectId}|${templateId}|${data}|eq:${equipamentoKey}`
      : `tpl|${projectId}|${templateId}|${data}`;
  }
  const osRef = String(getMaintenanceOsReferencia(item) || "").trim();
  if (osRef && data) {
    const titulo = normalizeSearchValue(item.titulo || "");
    const local = normalizeSearchValue(item.local || "");
    const equipamentoKey = getMaintenanceEquipamentoKey(item);
    const equipSuffix = equipamentoKey ? `|eq:${equipamentoKey}` : "";
    return `os|${projectId}|${data}|${osRef}|${titulo}|${local}${equipSuffix}`;
  }
  return "";
}

function getMaintenanceItemScore(item) {
  if (!item || typeof item !== "object") {
    return 0;
  }
  let score = 0;
  if (item.equipamentoId) {
    score += 4;
  }
  if (getMaintenanceOsReferencia(item)) {
    score += 4;
  }
  if (item.liberacao) {
    score += 5;
  }
  if (hasExecucaoRegistrada(item)) {
    score += 4;
  }
  if (item.conclusao) {
    score += 4;
  }
  if (item.documentos && Object.keys(item.documentos || {}).length) {
    score += 2;
  }
  if (item.observacao || item.observacaoHtml) {
    score += 1;
  }
  return score;
}

function dedupeMaintenanceList(list) {
  if (!Array.isArray(list)) {
    return [];
  }
  const byKey = new Map();
  const output = [];
  list.forEach((item) => {
    const key = getMaintenanceDedupKey(item);
    if (!key) {
      output.push(item);
      return;
    }
    if (!byKey.has(key)) {
      byKey.set(key, item);
      return;
    }
    const current = byKey.get(key);
    const scoreA = getMaintenanceItemScore(current);
    const scoreB = getMaintenanceItemScore(item);
    if (scoreB > scoreA) {
      byKey.set(key, item);
      return;
    }
    if (scoreB < scoreA) {
      return;
    }
    const updatedA = getMaintenanceUpdatedAtValue(current);
    const updatedB = getMaintenanceUpdatedAtValue(item);
    if (updatedB > updatedA) {
      byKey.set(key, item);
    }
  });
  if (!byKey.size) {
    return output;
  }
  const ids = new Set();
  byKey.forEach((item) => {
    if (!item) {
      return;
    }
    ids.add(item.id);
  });
  output.forEach((item) => {
    if (!item || !item.id) {
      return;
    }
    if (ids.has(item.id)) {
      return;
    }
    byKey.set(`id|${item.id}`, item);
  });
  return Array.from(byKey.values());
}

function shouldKeepLocalOnlyMaintenance(item, lastFetchAt) {
  if (!item || !item.id) {
    return false;
  }
  if (isMaintenanceDeletedId(item.id)) {
    return false;
  }
  const dirty = isMaintenanceDirtyId(item.id);
  if (!dirty) {
    return false;
  }
  const updatedAt = getMaintenanceUpdatedAtValue(item);
  if (lastFetchAt > 0 && updatedAt <= lastFetchAt && !dirty) {
    return false;
  }
  if (!USE_AUTH_API) {
    return true;
  }
  if (!currentUser) {
    return false;
  }
  const createdBy = String(item.createdBy || "");
  const updatedBy = String(item.updatedBy || "");
  const isSystem = createdBy === SYSTEM_USER_ID && updatedBy === SYSTEM_USER_ID;
  const hasUserPayload = Boolean(
    item.liberacao ||
      item.conclusao ||
      item.registroExecucao ||
      item.documentos ||
      item.participantes ||
      item.osReferencia
  );
  if (isSystem && !hasUserPayload) {
    return false;
  }
  return true;
}

function logAction(action, item, detalhes = {}, userId = null) {
  const resolvedUserId = userId || (currentUser ? currentUser.id : SYSTEM_USER_ID);
  const source = detalhes.origem || (resolvedUserId === SYSTEM_USER_ID ? "Sistema" : "UI");
  const entry = {
    id: criarId(),
    action,
    manutencaoId: item ? item.id : null,
    title: item ? item.titulo : null,
    userId: resolvedUserId,
    source,
    timestamp: toIsoUtc(new Date()),
    detalhes,
    prevHash: "",
    hash: "",
  };
  auditLog = [...auditLog, entry];
  salvarAuditoria(auditLog);
  auditHashChain = auditHashChain.then(async (prevHash) => {
    if (entry.hash) {
      return entry.hash;
    }
    const payload = buildAuditPayload(entry, prevHash);
    const hash = await hashSha256(payload);
    entry.prevHash = prevHash || "";
    entry.hash = hash;
    salvarAuditoria(auditLog);
    return hash;
  });
  return auditLog;
}

function getHistoricoManutencao(manutencaoId) {
  return auditLog
    .filter((entry) => entry && entry.manutencaoId === manutencaoId)
    .sort((a, b) => (getTimeValue(b.timestamp) || 0) - (getTimeValue(a.timestamp) || 0));
}

function getUltimaAcao(item) {
  if (!item) {
    return null;
  }
  const historico = getHistoricoManutencao(item.id);
  return historico.length ? historico[0] : null;
}

function getHistoricoDetalhes(manutencaoId, campos = []) {
  if (!manutencaoId) {
    return null;
  }
  const historico = getHistoricoManutencao(manutencaoId);
  if (!historico.length) {
    return null;
  }
  const listaCampos = Array.isArray(campos) ? campos : [];
  for (const entry of historico) {
    if (!entry || !entry.detalhes) {
      continue;
    }
    if (!listaCampos.length) {
      return entry.detalhes;
    }
    const possui = listaCampos.some((campo) => {
      const valor = entry.detalhes[campo];
      return valor !== undefined && valor !== null && valor !== "";
    });
    if (possui) {
      return entry.detalhes;
    }
  }
  return null;
}

function getOrigemLabel(entry) {
  if (!entry) {
    return "UI";
  }
  if (entry.source) {
    return entry.source;
  }
  if (entry.detalhes && entry.detalhes.origem) {
    return entry.detalhes.origem;
  }
  if (entry.userId === SYSTEM_USER_ID) {
    return "Sistema";
  }
  return "UI";
}

function getUltimoReagendamento(item) {
  if (!item) {
    return null;
  }
  const historico = getHistoricoManutencao(item.id);
  return historico.find((entry) => entry.action === "reschedule") || null;
}

function getLiberacao(item) {
  if (!item || !item.liberacao || typeof item.liberacao !== "object") {
    return null;
  }
  return item.liberacao;
}

function isLiberacaoOk(item) {
  const liberacao = getLiberacao(item);
  if (!liberacao) {
    return false;
  }
  const critico = isCriticoValor(liberacao.critico);
  const osNumero = (liberacao.osNumero || "").trim();
  if (!osNumero) {
    return false;
  }
  const participantes = Array.isArray(liberacao.participantes)
    ? liberacao.participantes.filter(Boolean)
    : [];
  if (!participantes.length) {
    return false;
  }
  if (critico && participantes.length < 2) {
    return false;
  }
  const documentos = liberacao.documentos || {};
  if (!documentos.apr || !documentos.os || !documentos.pte) {
    return false;
  }
  if (critico && !documentos.pt) {
    return false;
  }
  return true;
}

function isMeaningfulValue(value) {
  if (value === undefined || value === null) {
    return false;
  }
  if (typeof value === "string") {
    return value.trim().length > 0;
  }
  if (Array.isArray(value)) {
    return value.length > 0;
  }
  if (typeof value === "object") {
    return Object.keys(value).length > 0;
  }
  return true;
}

function mergePreferLocal(remote, local) {
  if (!remote) {
    return local || null;
  }
  if (!local) {
    return remote || null;
  }
  if (Array.isArray(remote) || Array.isArray(local)) {
    return isMeaningfulValue(remote) ? remote : local;
  }
  if (typeof remote !== "object" || typeof local !== "object") {
    return isMeaningfulValue(remote) ? remote : local;
  }
  const merged = {};
  const keys = new Set([...Object.keys(local), ...Object.keys(remote)]);
  keys.forEach((key) => {
    const r = remote[key];
    const l = local[key];
    if (r && l && typeof r === "object" && typeof l === "object" && !Array.isArray(r) && !Array.isArray(l)) {
      merged[key] = mergePreferLocal(r, l);
      return;
    }
    if (isMeaningfulValue(r)) {
      merged[key] = r;
      return;
    }
    if (isMeaningfulValue(l)) {
      merged[key] = l;
      return;
    }
    merged[key] = r !== undefined ? r : l;
  });
  return merged;
}

function getMaintenanceUpdatedAtValue(item) {
  if (!item || typeof item !== "object") {
    return 0;
  }
  const registro = item.registroExecucao || {};
  const candidates = [
    item.updatedAt,
    item.doneAt,
    item.executionFinishedAt,
    item.executionStartedAt,
    item.concluidaEm,
    item.dataConclusao,
    registro.registradoEm,
    registro.registrado_em,
    registro.executedAt,
    registro.executadoEm,
    item.execucaoRegistradaEm,
    item.executionRegisteredAt,
    item.createdAt,
  ];
  const times = candidates
    .map((value) => getTimeValue(value))
    .filter((value) => Number.isFinite(value));
  return times.length ? Math.max(...times) : 0;
}

function getMaintenanceItemFingerprint(item) {
  if (!item || !item.id) {
    return "";
  }
  const liberacao = item.liberacao || {};
  const registro = item.registroExecucao || {};
  const conclusao = item.conclusao || {};
  const execMark =
    item.execucaoRegistradaEm || item.executionRegisteredAt || item.execucaoRegistradaAt || "";
  return [
    String(item.id),
    normalizeMaintenanceStatus(item.status),
    getMaintenanceUpdatedAtValue(item),
    item.projectId || "",
    item.data || "",
    item.equipamentoId || "",
    getMaintenanceOsReferencia(item) || "",
    registro.registradoEm || registro.registrado_em || registro.executedAt || "",
    conclusao.fim || item.doneAt || "",
    execMark,
    liberacao.osNumero || "",
    Array.isArray(liberacao.participantes) ? liberacao.participantes.length : 0,
    Boolean(item.registroExecucao),
    Boolean(item.conclusao),
    Boolean(item.liberacao),
  ].join("|");
}

function getMaintenanceListFingerprint(list) {
  if (!Array.isArray(list)) {
    return "";
  }
  const snapshot = list
    .filter((item) => item && item.id)
    .map((item) => ({
      id: String(item.id),
      status: normalizeMaintenanceStatus(item.status),
      updatedAt: getMaintenanceUpdatedAtValue(item),
      data: item.data || "",
      projectId: item.projectId || "",
      equipamento:
        item.equipamento ||
        item.equipamentoId ||
        item.equipamentoNome ||
        item.equipamentoTag ||
        "",
      executionStartedAt: item.executionStartedAt || "",
      executionFinishedAt: item.executionFinishedAt || "",
      doneAt: item.doneAt || "",
      participantes: Array.isArray(item.participantes) ? item.participantes.length : 0,
      execRegistrada: hasExecucaoRegistrada(item) ? 1 : 0,
      execRegistradaAt:
        (item.registroExecucao && (item.registroExecucao.registradoEm || item.registroExecucao.registrado_em || item.registroExecucao.executedAt || item.registroExecucao.executadoEm)) ||
        item.execucaoRegistradaEm ||
        item.executionRegisteredAt ||
        "",
    }))
    .sort((a, b) => a.id.localeCompare(b.id));
  return hashString(JSON.stringify(snapshot));
}

function isMaintenanceConcluded(item) {
  return normalizeMaintenanceStatus(item && item.status) === "concluida";
}

function pickMaintenanceMerge(remote, local) {
  if (!remote && !local) {
    return { item: null, source: "none" };
  }
  if (!remote) {
    return { item: local, source: "local" };
  }
  if (!local) {
    return { item: remote, source: "remote" };
  }
  const remoteTime = getMaintenanceUpdatedAtValue(remote);
  const localTime = getMaintenanceUpdatedAtValue(local);
  const remoteConcluida = isMaintenanceConcluded(remote);
  const localConcluida = isMaintenanceConcluded(local);

  if (localConcluida && !remoteConcluida && (!remoteTime || localTime >= remoteTime)) {
    return { item: mergePreferLocal(local, remote), source: "local" };
  }
  if (remoteConcluida && !localConcluida && (!localTime || remoteTime >= localTime)) {
    return { item: mergePreferLocal(remote, local), source: "remote" };
  }
  if (localTime && (!remoteTime || localTime > remoteTime + 1000)) {
    return { item: mergePreferLocal(local, remote), source: "local" };
  }
  if (remoteTime && (!localTime || remoteTime > localTime + 1000)) {
    return { item: mergePreferLocal(remote, local), source: "remote" };
  }
  return { item: mergePreferLocal(remote, local), source: "remote" };
}

function mergeMaintenanceFallback(remote, local) {
  return pickMaintenanceMerge(remote, local).item;
}

function mergeLocalExecucaoRegistro(remote, local) {
  if (!remote || !local) {
    return remote;
  }
  const localDirty = isMaintenanceDirtyId(local.id);
  const localTime = getMaintenanceUpdatedAtValue(local);
  const remoteTime = getMaintenanceUpdatedAtValue(remote);
  const localStatus = normalizeMaintenanceStatus(local.status);
  const remoteStatus = normalizeMaintenanceStatus(remote.status);
  if (localDirty && (!remoteTime || localTime >= remoteTime)) {
    return mergePreferLocal(local, remote);
  }
  if (localTime && (!remoteTime || localTime > remoteTime + 1000)) {
    return mergePreferLocal(local, remote);
  }
  if (remoteTime && (!localTime || remoteTime > localTime + 1000)) {
    return remote;
  }
  if (localStatus === "concluida" && remoteStatus !== "concluida") {
    return mergePreferLocal(local, remote);
  }
  if (!hasExecucaoRegistrada(local) || hasExecucaoRegistrada(remote)) {
    return remote;
  }
  const merged = { ...remote };
  if (local.registroExecucao) {
    merged.registroExecucao = local.registroExecucao;
  }
  if (local.execucaoRegistradaEm && !remote.execucaoRegistradaEm) {
    merged.execucaoRegistradaEm = local.execucaoRegistradaEm;
  }
  if (local.executionRegisteredAt && !remote.executionRegisteredAt) {
    merged.executionRegisteredAt = local.executionRegisteredAt;
  }
  if (local.executionStartedAt && !remote.executionStartedAt) {
    merged.executionStartedAt = local.executionStartedAt;
  }
  if (local.executionStartedBy && !remote.executionStartedBy) {
    merged.executionStartedBy = local.executionStartedBy;
  }
  if (local.executionFinishedAt && !remote.executionFinishedAt) {
    merged.executionFinishedAt = local.executionFinishedAt;
  }
  if (local.updatedAt && (!remote.updatedAt || local.updatedAt > remote.updatedAt)) {
    merged.updatedAt = local.updatedAt;
  }
  if (local.updatedBy && !remote.updatedBy) {
    merged.updatedBy = local.updatedBy;
  }
  return merged;
}

function getParticipantesLabel(participantes) {
  if (!Array.isArray(participantes) || !participantes.length) {
    return "-";
  }
  return participantes
    .map((id) => {
      if (isTeamUserId(id)) {
        return getUserLabel(id);
      }
      if (isRealUserId(id)) {
        return getUserLabel(id);
      }
      const user = getUserById(id);
      if (user && isRealUser(user)) {
        return getUserLabel(user.id);
      }
      return typeof id === "string" ? id : "";
    })
    .map((label) => String(label || "").trim())
    .filter((label) => {
      if (!label) {
        return false;
      }
      const normalizado = normalizeSearchValue(label).replace(/\(.*?\)/g, " ");
      return !normalizado.includes("sistema") && !normalizado.includes("admin");
    })
    .join(", ");
}

function openOpscopeDb() {
  return new Promise((resolve, reject) => {
    if (typeof indexedDB === "undefined") {
      reject(new Error("IndexedDB indisponivel"));
      return;
    }
    const request = indexedDB.open("opscope", OPSCOPE_DB_VERSION);
    request.onupgradeneeded = () => {
      const db = request.result;
      if (!db.objectStoreNames.contains("docs")) {
        db.createObjectStore("docs", { keyPath: "docId" });
      }
      if (!db.objectStoreNames.contains("sst_evidences")) {
        db.createObjectStore("sst_evidences", { keyPath: "evidenceId" });
      }
      if (!db.objectStoreNames.contains("roles")) {
        const store = db.createObjectStore("roles", { keyPath: "id" });
        store.createIndex("nameNormalized", "nameNormalized", { unique: true });
      }
      if (!db.objectStoreNames.contains("users")) {
        const store = db.createObjectStore("users", { keyPath: "id" });
        store.createIndex("matriculaNormalized", "matriculaNormalized", { unique: true });
        store.createIndex("roleId", "roleId", { unique: false });
        store.createIndex("status", "status", { unique: false });
        store.createIndex("projectId", "projectId", { unique: false });
      }
      if (!db.objectStoreNames.contains("vehicles")) {
        const store = db.createObjectStore("vehicles", { keyPath: "id" });
        store.createIndex("projectId", "projectId", { unique: false });
        store.createIndex("plateNormalized", "plateNormalized", { unique: false });
        store.createIndex("project_plate", ["projectId", "plateNormalized"], { unique: true });
      }
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

function openDocsDB() {
  return openOpscopeDb();
}

function touchAccessSync() {
  writeJson(ACCESS_SYNC_KEY, Date.now());
}

function normalizeAccessRoleRecord(role) {
  if (!role || typeof role !== "object") {
    return null;
  }
  const id = String(role.id || "").trim();
  const name = String(role.name || "").trim();
  if (!id || !name) {
    return null;
  }
  const order = Number(role.order);
  return {
    id,
    name,
    nameNormalized: normalizeRoleName(name),
    permissions: ensureSectionPermissions(normalizeAccessRoleKeys(role.permissions || [])),
    isSystem: Boolean(role.isSystem),
    order: Number.isFinite(order) ? order : null,
    createdAt: role.createdAt || "",
    updatedAt: role.updatedAt || "",
  };
}

function getAccessRoleOrderValue(role, fallback = 0) {
  const order = Number(role && role.order);
  return Number.isFinite(order) ? order : fallback;
}

function ensureAccessRoleOrder(list = []) {
  let changed = false;
  const result = list
    .map((role, index) => {
      if (!role || typeof role !== "object") {
        return null;
      }
      const order = Number(role.order);
      if (Number.isFinite(order)) {
        return role;
      }
      changed = true;
      return { ...role, order: index };
    })
    .filter(Boolean);
  return { list: result, changed };
}

function sortAccessRolesByOrder(list = []) {
  return list
    .map((role, index) => ({ role, index }))
    .sort((a, b) => {
      const ao = getAccessRoleOrderValue(a.role, a.index);
      const bo = getAccessRoleOrderValue(b.role, b.index);
      if (ao !== bo) {
        return ao - bo;
      }
      return String(a.role.name || "").localeCompare(String(b.role.name || ""), "pt-BR");
    })
    .map((entry) => entry.role);
}

function normalizeAccessUserStatus(value, active) {
  const normalized = String(value || "").trim().toUpperCase();
  if (normalized === "INATIVO" || normalized === "INACTIVE" || normalized === "DESATIVADO") {
    return "INATIVO";
  }
  if (normalized === "ATIVO" || normalized === "ACTIVE") {
    return "ATIVO";
  }
  if (active === false || String(active).toLowerCase() === "false") {
    return "INATIVO";
  }
  return "ATIVO";
}

function normalizeAccessUserRecord(user) {
  if (!user || typeof user !== "object") {
    return null;
  }
  const id = String(user.id || "").trim();
  const name = String(user.name || "").trim();
  const matricula = String(user.matricula || "").trim();
  if (!id || !name || !matricula) {
    return null;
  }
  const status = normalizeAccessUserStatus(user.status, user.active);
  const roleName = String(user.roleName || user.cargo || user.role || "").trim();
  const cargo = String(user.cargo || user.roleName || user.role || "").trim();
  const rolePermissions = Array.isArray(user.rolePermissions)
    ? ensureSectionPermissions(normalizeAccessPermissionList(user.rolePermissions))
    : undefined;
  const accessPermissions = Array.isArray(user.accessPermissions)
    ? ensureSectionPermissions(normalizeAccessPermissionList(user.accessPermissions))
    : undefined;
  const permissions =
    user.permissions && typeof user.permissions === "object" && !Array.isArray(user.permissions)
      ? user.permissions
      : null;
  const sections =
    user.sections && typeof user.sections === "object" && !Array.isArray(user.sections)
      ? user.sections
      : null;
  const rbacRole = String(user.rbacRole || "").trim();
  const legacyRole = String(user.role || "").trim();
  return {
    id,
    name,
    matricula,
    matriculaNormalized: normalizeMatricula(matricula),
    email: normalizeEmail(user.email || ""),
    roleId: user.roleId || "",
    roleName,
    cargo,
    rbacRole,
    role: legacyRole,
    rolePermissions,
    accessPermissions,
    permissions,
    sections,
    projectId: user.projectId || null,
    projeto: user.projeto || "",
    localizacao: user.localizacao || "",
    project: user.project || null,
    projects: Array.isArray(user.projects) ? user.projects : undefined,
    uen: user.uen || "",
    atribuicoes: user.atribuicoes || "",
    avatarUrl: user.avatarUrl || "",
    avatarUpdatedAt: user.avatarUpdatedAt || "",
    status,
    active: status !== "INATIVO",
    passwordHash: user.passwordHash || "",
    passwordUpdatedAt: user.passwordUpdatedAt || "",
    createdAt: user.createdAt || "",
    updatedAt: user.updatedAt || "",
  };
}

function readRolesStorage() {
  const list = readJson(ACCESS_ROLES_KEY, []);
  if (!Array.isArray(list)) {
    return [];
  }
  const normalized = list.map(normalizeAccessRoleRecord).filter(Boolean);
  if (normalized.length) {
    const ensured = ensureAccessRoleOrder(normalized);
    if (ensured.changed) {
      writeRolesStorage(ensured.list);
      return ensured.list;
    }
    return normalized;
  }
  const backup = readJson(ACCESS_ROLES_BACKUP_KEY, []);
  if (!Array.isArray(backup)) {
    return [];
  }
  const normalizedBackup = backup.map(normalizeAccessRoleRecord).filter(Boolean);
  const ensuredBackup = ensureAccessRoleOrder(normalizedBackup);
  if (ensuredBackup.changed) {
    writeRolesStorage(ensuredBackup.list);
  }
  return ensuredBackup.list;
}

function writeRolesStorage(list) {
  const ensured = ensureAccessRoleOrder(Array.isArray(list) ? list : []);
  const payload = ensured.list;
  writeJson(ACCESS_ROLES_KEY, payload);
  writeJson(ACCESS_ROLES_BACKUP_KEY, payload);
  touchAccessSync();
  return payload;
}

function upsertRoleBackup(role) {
  if (!role || !role.id) {
    return;
  }
  const list = readRolesStorage();
  const index = list.findIndex((item) => String(item.id) === String(role.id));
  if (index >= 0) {
    list[index] = role;
  } else {
    list.unshift(role);
  }
  writeRolesStorage(list);
}

function deleteRoleBackup(roleId) {
  if (!roleId) {
    return;
  }
  const list = readRolesStorage().filter((item) => String(item.id) !== String(roleId));
  writeRolesStorage(list);
}

function collectAccessRoleLevelMarkers(list = []) {
  const normalized = normalizeAccessRoleKeys(list);
  return normalized.filter((key) => {
    if (!isAccessRoleLevelKey(key)) {
      return false;
    }
    const itemKey = getAccessRoleLevelItemKey(key);
    return itemKey && ACCESS_ROLE_VIEWONLY_KEYS.has(itemKey);
  });
}

function readAccessRoleLevelStorage() {
  const raw = readJson(ACCESS_ROLE_LEVELS_KEY, {});
  if (!raw || typeof raw !== "object") {
    return {};
  }
  return raw;
}

function writeAccessRoleLevelStorage(payload) {
  if (!payload || typeof payload !== "object") {
    return false;
  }
  const ok = writeJson(ACCESS_ROLE_LEVELS_KEY, payload);
  if (ok) {
    touchAccessSync();
  }
  return ok;
}

function getStoredAccessRoleLevelMarkers(roleId) {
  if (!roleId) {
    return [];
  }
  const storage = readAccessRoleLevelStorage();
  const markers = Array.isArray(storage[roleId]) ? storage[roleId] : [];
  return collectAccessRoleLevelMarkers(markers);
}

function setStoredAccessRoleLevelMarkers(roleId, markers) {
  if (!roleId) {
    return;
  }
  const storage = readAccessRoleLevelStorage();
  const next = collectAccessRoleLevelMarkers(markers);
  if (next.length) {
    storage[roleId] = next;
  } else {
    delete storage[roleId];
  }
  writeAccessRoleLevelStorage(storage);
}

function mergeAccessRoleLevelMarkers(role) {
  if (!role || !role.id) {
    return role;
  }
  const markers = getStoredAccessRoleLevelMarkers(role.id);
  if (!markers.length) {
    return role;
  }
  const merged = new Set(normalizeAccessRoleKeys(role.permissions || []));
  markers.forEach((key) => merged.add(key));
  return { ...role, permissions: Array.from(merged) };
}

function syncAccessRoleLevelStorage(roles = []) {
  const storage = readAccessRoleLevelStorage();
  const validIds = new Set((roles || []).map((role) => String(role.id)));
  let changed = false;
  Object.keys(storage).forEach((roleId) => {
    if (!validIds.has(String(roleId))) {
      delete storage[roleId];
      changed = true;
    }
  });
  if (changed) {
    writeAccessRoleLevelStorage(storage);
  }
}

function readUsersStorage() {
  const list = readJson(ACCESS_USERS_KEY, []);
  if (!Array.isArray(list)) {
    return [];
  }
  const normalized = list.map(normalizeAccessUserRecord).filter(Boolean);
  if (normalized.length) {
    return normalized;
  }
  const backup = readJson(ACCESS_USERS_BACKUP_KEY, []);
  if (!Array.isArray(backup)) {
    return [];
  }
  return backup.map(normalizeAccessUserRecord).filter(Boolean);
}

function writeUsersStorage(list) {
  writeJson(ACCESS_USERS_KEY, list);
  writeJson(ACCESS_USERS_BACKUP_KEY, list);
  touchAccessSync();
  return list;
}

function upsertUserBackup(user) {
  if (!user || !user.id) {
    return;
  }
  const list = readUsersStorage();
  const index = list.findIndex((item) => String(item.id) === String(user.id));
  if (index >= 0) {
    list[index] = user;
  } else {
    list.unshift(user);
  }
  writeUsersStorage(list);
}

function touchProjectsSync() {
  writeJson(PROJECTS_SYNC_KEY, Date.now());
}

function readProjectsBackup() {
  const list = readJson(PROJECTS_BACKUP_KEY, []);
  if (!Array.isArray(list)) {
    return [];
  }
  return list.map(normalizeProjectRecord).filter(Boolean);
}

function normalizeProjectRecord(project) {
  if (!project || typeof project !== "object") {
    return null;
  }
  const id = String(project.id || "").trim() || criarId();
  const codigo = String(project.codigo || "").trim();
  const nome = String(project.nome || "").trim();
  if (!codigo || !nome) {
    return null;
  }
  const locais = Array.isArray(project.locais)
    ? project.locais.map((item) => String(item || "").trim()).filter(Boolean)
    : [];
  const cliente = String(project.cliente || "").trim();
  const descricao = String(project.descricao || "").trim();
  const nomeTime = String(project.nomeTime || project.timeName || project.time || "").trim();
  return {
    ...project,
    id,
    codigo,
    nome,
    cliente,
    descricao,
    nomeTime,
    locais,
    createdAt: project.createdAt || "",
    updatedAt: project.updatedAt || "",
  };
}

function readProjectsStorage() {
  const list = readJson(PROJECTS_KEY, []);
  if (!Array.isArray(list)) {
    return [];
  }
  const normalized = list.map(normalizeProjectRecord).filter(Boolean);
  if (!normalized.length) {
    return readProjectsBackup();
  }
  return normalized;
}

function writeProjectsStorage(list) {
  writeJson(PROJECTS_KEY, list);
  writeJson(PROJECTS_BACKUP_KEY, list);
  touchProjectsSync();
  return list;
}

function seedDefaultProjectsIfEmpty() {
  const existing = readProjectsStorage();
  if (existing.length) {
    return { seeded: false, count: existing.length };
  }
  const defaults = (DEFAULT_PROJECTS_SEED || []).map(normalizeProjectRecord).filter(Boolean);
  if (!defaults.length) {
    return { seeded: false, count: 0 };
  }
  writeProjectsStorage(defaults);
  return { seeded: true, count: defaults.length };
}

async function listRolesFromDb(q = "") {
  const query = normalizeSearchValue(q);
  if (typeof indexedDB === "undefined") {
    const list = sortAccessRolesByOrder(readRolesStorage());
    return query
      ? list.filter((role) => normalizeSearchValue(role.name).includes(query))
      : list;
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("roles", "readonly");
      const store = tx.objectStore("roles");
      const request = store.getAll();
      request.onsuccess = () => {
        let list = (request.result || []).map(normalizeAccessRoleRecord).filter(Boolean);
        if (!list.length) {
          const fallback = readRolesStorage();
          if (fallback.length) {
            const writeTx = db.transaction("roles", "readwrite");
            const writeStore = writeTx.objectStore("roles");
            fallback.forEach((role) => writeStore.put(role));
            writeTx.oncomplete = () => {
              list = sortAccessRolesByOrder(fallback.slice());
              writeRolesStorage(list);
              resolve(
                query
                  ? list.filter((role) => normalizeSearchValue(role.name).includes(query))
                  : list
              );
            };
            writeTx.onerror = () => {
              const orderedFallback = sortAccessRolesByOrder(fallback);
              writeRolesStorage(orderedFallback);
              resolve(
                query
                  ? orderedFallback.filter((role) => normalizeSearchValue(role.name).includes(query))
                  : orderedFallback
              );
            };
            return;
          }
        }
        const ensured = ensureAccessRoleOrder(list);
        const ordered = sortAccessRolesByOrder(ensured.list);
        writeRolesStorage(ordered);
        resolve(
          query
            ? ordered.filter((role) => normalizeSearchValue(role.name).includes(query))
            : ordered
        );
      };
      request.onerror = () => resolve(sortAccessRolesByOrder(readRolesStorage()));
    });
  } catch (error) {
    return sortAccessRolesByOrder(readRolesStorage());
  }
}

async function getRoleFromDb(id) {
  if (!id) {
    return null;
  }
  if (typeof indexedDB === "undefined") {
    return readRolesStorage().find((role) => String(role.id) === String(id)) || null;
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("roles", "readonly");
      const store = tx.objectStore("roles");
      const request = store.get(id);
      request.onsuccess = () => resolve(normalizeAccessRoleRecord(request.result));
      request.onerror = () => resolve(null);
    });
  } catch (error) {
    return null;
  }
}

async function getRoleByNameNormalized(nameNormalized) {
  const normalized = normalizeRoleName(nameNormalized);
  if (!normalized) {
    return null;
  }
  if (typeof indexedDB === "undefined") {
    return readRolesStorage().find((role) => role.nameNormalized === normalized) || null;
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("roles", "readonly");
      const store = tx.objectStore("roles");
      const index = store.index("nameNormalized");
      const request = index.get(normalized);
      request.onsuccess = () => resolve(normalizeAccessRoleRecord(request.result));
      request.onerror = () => resolve(null);
    });
  } catch (error) {
    return null;
  }
}

async function upsertRoleToDb(input) {
  const payload = input || {};
  const name = String(payload.name || "").trim();
  if (!name) {
    throw new Error("Informe o nome do cargo.");
  }
  const now = toIsoUtc(new Date());
  const id = payload.id ? String(payload.id) : criarId();
  const nameNormalized = normalizeRoleName(name);
  const existing = await getRoleFromDb(id);
  const duplicate = await getRoleByNameNormalized(nameNormalized);
  if (duplicate && String(duplicate.id) !== String(id)) {
    throw new Error("Ja existe um cargo com esse nome.");
  }
  const existingOrder = existing ? Number(existing.order) : NaN;
  const providedOrder = payload.order !== undefined ? Number(payload.order) : NaN;
  let order = Number.isFinite(providedOrder) ? providedOrder : existingOrder;
  if (!Number.isFinite(order)) {
    const list = readRolesStorage();
    const maxOrder = list.reduce((acc, role) => {
      const value = Number(role.order);
      return Number.isFinite(value) ? Math.max(acc, value) : acc;
    }, -1);
    order = maxOrder + 1;
  }
  const role = {
    id,
    name,
    nameNormalized,
    permissions: normalizeAccessRoleKeys(payload.permissions || existing?.permissions || []),
    isSystem: existing ? Boolean(existing.isSystem) : Boolean(payload.isSystem),
    order,
    createdAt: existing && existing.createdAt ? existing.createdAt : now,
    updatedAt: now,
  };
  if (typeof indexedDB === "undefined") {
    const list = readRolesStorage();
    const index = list.findIndex((item) => String(item.id) === String(id));
    if (index >= 0) {
      list[index] = role;
    } else {
      list.unshift(role);
    }
    writeRolesStorage(list);
    return role;
  }
  const db = await openOpscopeDb();
  return await new Promise((resolve, reject) => {
    const tx = db.transaction("roles", "readwrite");
    const store = tx.objectStore("roles");
    const request = store.put(role);
    request.onsuccess = () => {
      touchAccessSync();
      upsertRoleBackup(role);
      resolve(role);
    };
    request.onerror = () => reject(request.error || new Error("Falha ao salvar cargo."));
  });
}

async function deleteRoleFromDb(id) {
  if (!id) {
    return;
  }
  const role = await getRoleFromDb(id);
  if (!role) {
    return;
  }
  const usersWithRole = await listUsersFromDb({ roleId: id });
  if (usersWithRole.length) {
    throw new Error("Cargo em uso por usuarios.");
  }
  if (typeof indexedDB === "undefined") {
    const list = readRolesStorage().filter((item) => String(item.id) !== String(id));
    writeRolesStorage(list);
    return;
  }
  const db = await openOpscopeDb();
  await new Promise((resolve, reject) => {
    const tx = db.transaction("roles", "readwrite");
    const store = tx.objectStore("roles");
    const request = store.delete(id);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error || new Error("Falha ao remover cargo."));
  });
  touchAccessSync();
  deleteRoleBackup(id);
}

function buildDefaultAccessRoles() {
  const now = toIsoUtc(new Date());
  return [
    {
      id: criarId(),
      name: "Administrador",
      permissions: ["ADMIN"],
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    },
    {
      id: criarId(),
      name: "PCM",
      permissions: [
        "USER_READ",
        "USER_WRITE",
        "ROLE_READ",
        "PROJECT_READ",
        "SST_WRITE",
        "ALMOX_READ",
        "REPORTS_READ",
      ],
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    },
    {
      id: criarId(),
      name: "Supervisor O&M",
      permissions: ["SST_WRITE", "REPORTS_READ", "PROJECT_READ"],
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    },
    {
      id: criarId(),
      name: "Tecnico Junior",
      permissions: ["SST_READ", "ALMOX_READ", "PROJECT_READ"],
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    },
    {
      id: criarId(),
      name: "Tecnico Pleno",
      permissions: ["SST_READ", "ALMOX_READ", "PROJECT_READ"],
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    },
    {
      id: criarId(),
      name: "Tecnico Senior",
      permissions: ["SST_READ", "ALMOX_READ", "PROJECT_READ"],
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    },
    {
      id: criarId(),
      name: "Gerente de Contrato",
      permissions: ["REPORTS_READ", "KPIS_READ", "PROJECT_READ"],
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    },
    {
      id: criarId(),
      name: "Diretor O&M",
      permissions: ["REPORTS_READ", "KPIS_READ", "PROJECT_READ"],
      isSystem: true,
      createdAt: now,
      updatedAt: now,
    },
  ];
}

async function seedDefaultRolesIfEmpty() {
  const existing = await listRolesFromDb();
  if (existing.length) {
    return { seeded: false, count: existing.length };
  }
  const defaults = buildDefaultAccessRoles();
  if (typeof indexedDB === "undefined") {
    writeRolesStorage(defaults);
    return { seeded: true, count: defaults.length };
  }
  const db = await openOpscopeDb();
  await new Promise((resolve, reject) => {
    const tx = db.transaction("roles", "readwrite");
    const store = tx.objectStore("roles");
    defaults.forEach((role) => store.put(role));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error || new Error("Falha ao criar cargos."));
  });
  writeRolesStorage(defaults);
  return { seeded: true, count: defaults.length };
}

async function ensureBootstrapAccessAccount() {
  if (USE_AUTH_API) {
    return { seeded: false, reason: "api" };
  }
  if (
    !ACCESS_BOOTSTRAP_USER ||
    !ACCESS_BOOTSTRAP_USER.matricula ||
    !ACCESS_BOOTSTRAP_USER.password
  ) {
    return { seeded: false, reason: "missing" };
  }
  const matriculaNormalized = normalizeMatricula(ACCESS_BOOTSTRAP_USER.matricula);
  const existing = await getUserByMatriculaNormalized(matriculaNormalized);
  const roleName = ACCESS_BOOTSTRAP_USER.roleName || "Administrador";
  let role =
    (await getRoleByNameNormalized(roleName)) ||
    (await listRolesFromDb()).find((item) => (item.permissions || []).includes("ADMIN")) ||
    null;
  if (!role) {
    return { seeded: false, reason: "role" };
  }
  if (existing) {
    await updateUserToDb({
      id: existing.id,
      name: ACCESS_BOOTSTRAP_USER.name || existing.name,
      roleId: role.id,
      status: "ATIVO",
    });
    await resetPasswordForUser({
      id: existing.id,
      mode: "MANUAL",
      password: ACCESS_BOOTSTRAP_USER.password,
    });
    return { seeded: false, updated: true, id: existing.id };
  }
  const created = await createUserToDb({
    name: ACCESS_BOOTSTRAP_USER.name || "Administrador",
    matricula: ACCESS_BOOTSTRAP_USER.matricula,
    roleId: role.id,
    status: "ATIVO",
    passwordMode: "MANUAL",
    password: ACCESS_BOOTSTRAP_USER.password,
  });
  return { seeded: true, id: created && created.user ? created.user.id : "" };
}

async function listUsersFromDb(filters = {}) {
  const query = normalizeSearchValue(filters.q || "");
  const roleId = filters.roleId ? String(filters.roleId) : "";
  const status = filters.status ? String(filters.status).toUpperCase() : "";
  const projectId = filters.projectId ? String(filters.projectId) : "";
  const applyFilters = (list) =>
    list.filter((user) => {
      const userStatus = normalizeAccessUserStatus(user.status, user.active);
      if (roleId && String(user.roleId || "") !== roleId) {
        return false;
      }
      if (status && userStatus !== status) {
        return false;
      }
      if (projectId && String(user.projectId || "") !== projectId) {
        return false;
      }
      if (query) {
        const nome = normalizeSearchValue(user.name);
        const matricula = normalizeSearchValue(user.matricula);
        const email = normalizeSearchValue(user.email || "");
        if (!nome.includes(query) && !matricula.includes(query) && !email.includes(query)) {
          return false;
        }
      }
      return true;
    });
  if (typeof indexedDB === "undefined") {
    return applyFilters(readUsersStorage());
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("users", "readonly");
      const store = tx.objectStore("users");
      const request = store.getAll();
      request.onsuccess = () => {
        let list = (request.result || []).map(normalizeAccessUserRecord).filter(Boolean);
        if (!list.length) {
          const fallback = readUsersStorage();
          if (fallback.length) {
            const writeTx = db.transaction("users", "readwrite");
            const writeStore = writeTx.objectStore("users");
            fallback.forEach((user) => writeStore.put(user));
            writeTx.oncomplete = () => {
              list = fallback.slice();
              writeUsersStorage(list);
              resolve(applyFilters(list));
            };
            writeTx.onerror = () => {
              writeUsersStorage(fallback);
              resolve(applyFilters(fallback));
            };
            return;
          }
        }
        writeUsersStorage(list);
        resolve(applyFilters(list));
      };
      request.onerror = () => resolve(applyFilters(readUsersStorage()));
    });
  } catch (error) {
    return applyFilters(readUsersStorage());
  }
}

async function getUserFromDb(id) {
  if (!id) {
    return null;
  }
  if (typeof indexedDB === "undefined") {
    return readUsersStorage().find((user) => String(user.id) === String(id)) || null;
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("users", "readonly");
      const store = tx.objectStore("users");
      const request = store.get(id);
      request.onsuccess = () => resolve(normalizeAccessUserRecord(request.result));
      request.onerror = () => resolve(null);
    });
  } catch (error) {
    return null;
  }
}

async function getUserByMatriculaNormalized(matriculaNormalized) {
  const normalized = normalizeMatricula(matriculaNormalized);
  if (!normalized) {
    return null;
  }
  if (typeof indexedDB === "undefined") {
    return readUsersStorage().find((user) => user.matriculaNormalized === normalized) || null;
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("users", "readonly");
      const store = tx.objectStore("users");
      const index = store.index("matriculaNormalized");
      const request = index.get(normalized);
      request.onsuccess = () => resolve(normalizeAccessUserRecord(request.result));
      request.onerror = () => resolve(null);
    });
  } catch (error) {
    return null;
  }
}

async function createUserToDb(input) {
  const payload = input || {};
  const name = String(payload.name || "").trim();
  const matricula = String(payload.matricula || "").trim();
  const roleId = String(payload.roleId || "").trim();
  if (!name) {
    throw new Error("Informe o nome do usuario.");
  }
  if (!matricula) {
    throw new Error("Informe a matricula.");
  }
  if (!roleId) {
    throw new Error("Selecione o cargo.");
  }
  const normalizedMatricula = normalizeMatricula(matricula);
  const duplicate = await getUserByMatriculaNormalized(normalizedMatricula);
  const duplicateStatus = duplicate
    ? normalizeAccessUserStatus(duplicate.status, duplicate.active)
    : "";
  if (duplicate && duplicateStatus !== "INATIVO") {
    throw new Error("Matricula ja cadastrada.");
  }
  const role = await getRoleFromDb(roleId);
  if (!role) {
    throw new Error("Cargo invalido.");
  }
  const roleName = String(role.name || "").trim();
  const status = String(payload.status || "ATIVO").toUpperCase() === "INATIVO" ? "INATIVO" : "ATIVO";
  const mode = String(payload.passwordMode || "MANUAL").toUpperCase();
  let generatedPassword = "";
  let password = String(payload.password || "");
  if (mode === "GERADA") {
    generatedPassword = generatePassword(12);
    password = generatedPassword;
  }
  if (!password) {
    throw new Error("Informe a senha.");
  }
  if (duplicate && duplicateStatus === "INATIVO") {
    await updateUserToDb({
      id: duplicate.id,
      name,
      roleId,
      status,
      projectId: payload.projectId ? String(payload.projectId) : null,
      email: payload.email !== undefined ? normalizeEmail(payload.email || "") : duplicate.email || "",
    });
    await resetPasswordForUser({ id: duplicate.id, mode, password });
    const refreshed = await getUserFromDb(duplicate.id);
    return {
      user: refreshed || duplicate,
      generatedPassword: generatedPassword || undefined,
      reactivated: true,
    };
  }
  const now = toIsoUtc(new Date());
  const passwordHash = await hashPasswordWithSalt(password);
  const user = {
    id: criarId(),
    name,
    matricula,
    matriculaNormalized: normalizedMatricula,
    email: normalizeEmail(payload.email || ""),
    roleId,
    roleName,
    projectId: payload.projectId ? String(payload.projectId) : null,
    status,
    passwordHash,
    passwordUpdatedAt: now,
    createdAt: now,
    updatedAt: now,
  };
  if (typeof indexedDB === "undefined") {
    const list = readUsersStorage();
    list.unshift(user);
    writeUsersStorage(list);
    return { user, generatedPassword: generatedPassword || undefined };
  }
  const db = await openOpscopeDb();
  await new Promise((resolve, reject) => {
    const tx = db.transaction("users", "readwrite");
    const store = tx.objectStore("users");
    const request = store.put(user);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error || new Error("Falha ao salvar usuario."));
  });
  touchAccessSync();
  upsertUserBackup(user);
  return { user, generatedPassword: generatedPassword || undefined };
}

async function updateUserToDb(input) {
  const payload = input || {};
  const id = String(payload.id || "").trim();
  if (!id) {
    throw new Error("Usuario invalido.");
  }
  const existing = await getUserFromDb(id);
  if (!existing) {
    throw new Error("Usuario nao encontrado.");
  }
  const now = toIsoUtc(new Date());
  if (payload.name !== undefined && !String(payload.name || "").trim()) {
    throw new Error("Informe o nome do usuario.");
  }
  let resolvedRoleName = existing.roleName || "";
  if (payload.roleId !== undefined) {
    const nextRoleId = String(payload.roleId || "").trim();
    if (nextRoleId) {
      const role = await getRoleFromDb(nextRoleId);
      if (!role) {
        throw new Error("Cargo invalido.");
      }
      resolvedRoleName = String(role.name || "").trim();
    } else {
      resolvedRoleName = "";
    }
  } else if (!resolvedRoleName && existing.roleId) {
    const role = await getRoleFromDb(existing.roleId);
    if (role) {
      resolvedRoleName = String(role.name || "").trim();
    }
  }
  const status =
    payload.status !== undefined
      ? String(payload.status).toUpperCase() === "INATIVO"
        ? "INATIVO"
        : "ATIVO"
      : existing.status || "ATIVO";
  const updated = {
    ...existing,
    name: payload.name !== undefined ? String(payload.name || "").trim() : existing.name,
    email:
      payload.email !== undefined ? normalizeEmail(payload.email || "") : existing.email || "",
    roleId: payload.roleId !== undefined ? String(payload.roleId || "").trim() : existing.roleId,
    roleName: resolvedRoleName,
    projectId:
      payload.projectId !== undefined
        ? payload.projectId
          ? String(payload.projectId)
          : null
        : existing.projectId || null,
    uen: payload.uen !== undefined ? String(payload.uen || "").trim() : existing.uen || "",
    atribuicoes:
      payload.atribuicoes !== undefined
        ? String(payload.atribuicoes || "").trim()
        : existing.atribuicoes || "",
    preferences:
      payload.preferences !== undefined
        ? normalizeProfilePreferences(payload.preferences)
        : normalizeProfilePreferences(existing.preferences),
    security:
      payload.security !== undefined || payload.securitySettings !== undefined
        ? normalizeProfileSecurity(payload.security || payload.securitySettings)
        : normalizeProfileSecurity(existing.security || existing.securitySettings),
    avatarUrl:
      payload.avatarUrl !== undefined ? String(payload.avatarUrl || "").trim() : existing.avatarUrl || "",
    avatarUpdatedAt:
      payload.avatarUpdatedAt !== undefined
        ? String(payload.avatarUpdatedAt || "").trim()
        : existing.avatarUpdatedAt || "",
    status,
    updatedAt: now,
  };
  if (typeof indexedDB === "undefined") {
    const list = readUsersStorage();
    const index = list.findIndex((item) => String(item.id) === String(id));
    if (index >= 0) {
      list[index] = updated;
      writeUsersStorage(list);
    }
    return updated;
  }
  const db = await openOpscopeDb();
  await new Promise((resolve, reject) => {
    const tx = db.transaction("users", "readwrite");
    const store = tx.objectStore("users");
    const request = store.put(updated);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error || new Error("Falha ao salvar usuario."));
  });
  touchAccessSync();
  upsertUserBackup(updated);
  return updated;
}

async function deleteUserFromDb(id) {
  const targetId = String(id || "").trim();
  if (!targetId) {
    return;
  }
  const existing = await getUserFromDb(targetId);
  if (!existing) {
    return;
  }
  const status = normalizeAccessUserStatus(existing.status, existing.active);
  if (status !== "INATIVO") {
    throw new Error("Apenas contas inativas podem ser excluidas.");
  }
  const filtered = readUsersStorage().filter((item) => String(item.id) !== targetId);
  if (typeof indexedDB === "undefined") {
    writeUsersStorage(filtered);
    return;
  }
  const db = await openOpscopeDb();
  await new Promise((resolve, reject) => {
    const tx = db.transaction("users", "readwrite");
    const store = tx.objectStore("users");
    const request = store.delete(targetId);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error || new Error("Falha ao remover usuario."));
  });
  writeUsersStorage(filtered);
  touchAccessSync();
}

async function resetPasswordForUser(input) {
  const payload = input || {};
  const id = String(payload.id || "").trim();
  if (!id) {
    throw new Error("Usuario invalido.");
  }
  const existing = await getUserFromDb(id);
  if (!existing) {
    throw new Error("Usuario nao encontrado.");
  }
  const mode = String(payload.mode || "MANUAL").toUpperCase();
  let generatedPassword = "";
  let password = String(payload.password || "");
  if (mode === "GERADA") {
    generatedPassword = generatePassword(12);
    password = generatedPassword;
  }
  if (!password) {
    throw new Error("Informe a senha.");
  }
  const now = toIsoUtc(new Date());
  const passwordHash = await hashPasswordWithSalt(password);
  const updated = {
    ...existing,
    passwordHash,
    passwordUpdatedAt: now,
    updatedAt: now,
  };
  if (typeof indexedDB === "undefined") {
    const list = readUsersStorage();
    const index = list.findIndex((item) => String(item.id) === String(id));
    if (index >= 0) {
      list[index] = updated;
      writeUsersStorage(list);
    }
    return { user: updated, generatedPassword: generatedPassword || undefined };
  }
  const db = await openOpscopeDb();
  await new Promise((resolve, reject) => {
    const tx = db.transaction("users", "readwrite");
    const store = tx.objectStore("users");
    const request = store.put(updated);
    request.onsuccess = () => resolve();
    request.onerror = () => reject(request.error || new Error("Falha ao salvar senha."));
  });
  touchAccessSync();
  upsertUserBackup(updated);
  return { user: updated, generatedPassword: generatedPassword || undefined };
}

async function setUserStatus(id, status) {
  const targetStatus = String(status || "").toUpperCase() === "INATIVO" ? "INATIVO" : "ATIVO";
  return updateUserToDb({ id, status: targetStatus });
}

function readVehiclesStorage() {
  const list = readJson(SST_VEHICLES_KEY, []);
  if (!Array.isArray(list)) {
    return [];
  }
  return list.map(normalizeSstVehicle).filter(Boolean);
}

function writeVehiclesStorage(list) {
  writeJson(SST_VEHICLES_KEY, list);
  return list;
}

function filterVehicles(list, filters = {}) {
  let filtered = Array.isArray(list) ? list.slice() : [];
  if (filters.projectId) {
    filtered = filtered.filter(
      (item) => String(item.projectId) === String(filters.projectId)
    );
  }
  if (filters.status && filters.status !== "ALL") {
    const status = normalizeVehicleStatusValue(filters.status);
    filtered = filtered.filter(
      (item) => normalizeVehicleStatusValue(item.status) === status
    );
  }
  if (filters.q) {
    const term = normalizeSearchValue(filters.q);
    filtered = filtered.filter(
      (item) =>
        normalizeSearchValue(item.plate).includes(term) ||
        normalizeSearchValue(item.model).includes(term)
    );
  }
  return filtered;
}

async function listVehiclesFromDb(filters = {}) {
  if (typeof indexedDB === "undefined") {
    return filterVehicles(readVehiclesStorage(), filters);
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("vehicles", "readonly");
      const store = tx.objectStore("vehicles");
      const request = filters.projectId
        ? store.index("projectId").getAll(filters.projectId)
        : store.getAll();
      request.onsuccess = () => {
        const list = (request.result || []).map(normalizeSstVehicle).filter(Boolean);
        resolve(filterVehicles(list, filters));
      };
      request.onerror = () => resolve(filterVehicles(readVehiclesStorage(), filters));
    });
  } catch (error) {
    return filterVehicles(readVehiclesStorage(), filters);
  }
}

async function getVehicleFromDb(id) {
  if (!id) {
    return null;
  }
  if (typeof indexedDB === "undefined") {
    const list = readVehiclesStorage();
    return list.find((item) => String(item.id) === String(id)) || null;
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("vehicles", "readonly");
      const store = tx.objectStore("vehicles");
      const request = store.get(id);
      request.onsuccess = () => resolve(normalizeSstVehicle(request.result));
      request.onerror = () => resolve(null);
    });
  } catch (error) {
    return null;
  }
}

async function getVehicleByProjectPlate(projectId, plateNormalized) {
  if (!projectId || !plateNormalized) {
    return null;
  }
  if (typeof indexedDB === "undefined") {
    const list = readVehiclesStorage();
    return (
      list.find(
        (item) =>
          String(item.projectId) === String(projectId) &&
          String(item.plateNormalized) === String(plateNormalized)
      ) || null
    );
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("vehicles", "readonly");
      const store = tx.objectStore("vehicles");
      const index = store.index("project_plate");
      const request = index.get([projectId, plateNormalized]);
      request.onsuccess = () => resolve(normalizeSstVehicle(request.result));
      request.onerror = () => resolve(null);
    });
  } catch (error) {
    return null;
  }
}

async function upsertVehicleToDb(input) {
  const now = toIsoUtc(new Date());
  const id = input && input.id ? input.id : criarId();
  const existing = await getVehicleFromDb(id);
  const normalized = normalizeSstVehicle({
    ...existing,
    ...input,
    id,
    createdAt: existing && existing.createdAt ? existing.createdAt : now,
    updatedAt: now,
    createdBy: existing && existing.createdBy ? existing.createdBy : currentUser ? currentUser.id : "",
  });
  if (!normalized) {
    throw new Error("Veiculo invalido.");
  }
  const duplicate = await getVehicleByProjectPlate(
    normalized.projectId,
    normalized.plateNormalized
  );
  if (duplicate && String(duplicate.id) !== String(normalized.id)) {
    throw new Error("Ja existe veiculo com essa placa neste projeto.");
  }
  if (typeof indexedDB === "undefined") {
    const list = readVehiclesStorage();
    const index = list.findIndex((item) => String(item.id) === String(normalized.id));
    if (index >= 0) {
      list[index] = normalized;
    } else {
      list.unshift(normalized);
    }
    writeVehiclesStorage(list);
    return normalized;
  }
  const db = await openOpscopeDb();
  return await new Promise((resolve, reject) => {
    const tx = db.transaction("vehicles", "readwrite");
    const store = tx.objectStore("vehicles");
    const request = store.put(normalized);
    request.onsuccess = () => resolve(normalized);
    request.onerror = () => reject(request.error || new Error("Falha ao salvar veiculo."));
  });
}

async function softDeleteVehicle(id) {
  if (!id) {
    return;
  }
  const existing = await getVehicleFromDb(id);
  if (!existing) {
    return;
  }
  const updated = {
    ...existing,
    status: "Inativo",
    updatedAt: toIsoUtc(new Date()),
  };
  await upsertVehicleToDb(updated);
}

function getDocById(docId) {
  if (!docId) {
    return Promise.resolve(null);
  }
  if (typeof indexedDB === "undefined") {
    return Promise.resolve(null);
  }
  return openDocsDB()
    .then(
      (db) =>
        new Promise((resolve) => {
          const tx = db.transaction("docs", "readonly");
          const store = tx.objectStore("docs");
          const request = store.get(docId);
          request.onsuccess = () => resolve(request.result || null);
          request.onerror = () => resolve(null);
        })
    )
    .catch(() => null);
}

async function uploadLiberacaoDoc(file, docType) {
  if (!file) {
    return null;
  }
  const formData = new FormData();
  formData.append("type", docType || "");
  formData.append("file", file);
  try {
    const data = await apiUploadLiberacaoDoc(formData);
    const info = data && data.file ? data.file : null;
    if (!info || !info.url) {
      throw new Error("Falha ao enviar o documento.");
    }
    const name = info.originalName || info.name || file.name || "Documento";
    return {
      id: info.id || "",
      url: info.url,
      name,
      nome: name,
      mime: info.mime || file.type || "",
      docType: info.docType || docType || "",
    };
  } catch (error) {
    if (!isUnauthorizedError(error)) {
      throw error;
    }
    const doc = await lerDocumentoFile(file);
    if (!doc || !doc.dataUrl) {
      throw error;
    }
    const name = file.name || doc.nome || "Documento";
    return {
      id: criarId(),
      url: doc.dataUrl,
      dataUrl: doc.dataUrl,
      name,
      nome: name,
      mime: file.type || doc.type || "",
      docType: docType || "",
      localFallback: true,
    };
  }
}

async function uploadEvidenceFile(file) {
  if (!file) {
    return null;
  }
  if (!USE_AUTH_API) {
    const doc = await lerDocumentoFile(file);
    if (!doc || !doc.dataUrl) {
      throw new Error("Falha ao ler evidência.");
    }
    const name = file.name || doc.nome || "Evidência";
    return {
      id: criarId(),
      url: doc.dataUrl,
      dataUrl: doc.dataUrl,
      name,
      nome: name,
      mime: file.type || doc.type || "",
      type: file.type || doc.type || "",
      size: file.size || 0,
    };
  }
  const formData = new FormData();
  formData.append("file", file);
  try {
    const data = await apiUploadEvidence(formData);
    const info = data && data.file ? data.file : null;
    if (!info || !info.url) {
      throw new Error("Falha ao enviar evidência.");
    }
    const name = info.originalName || info.name || file.name || "Evidência";
    return {
      id: info.id || "",
      url: info.url,
      name,
      nome: name,
      mime: info.mime || file.type || "",
      type: info.mime || file.type || "",
      size: info.size || file.size || 0,
      uploadedAt: info.createdAt || new Date().toISOString(),
    };
  } catch (error) {
    if (!isUnauthorizedError(error)) {
      throw error;
    }
    const doc = await lerDocumentoFile(file);
    if (!doc || !doc.dataUrl) {
      throw error;
    }
    const name = file.name || doc.nome || "Evidência";
    return {
      id: criarId(),
      url: doc.dataUrl,
      dataUrl: doc.dataUrl,
      name,
      nome: name,
      mime: file.type || doc.type || "",
      type: file.type || doc.type || "",
      size: file.size || 0,
      localFallback: true,
    };
  }
}

function base64ToBlob(base64, mimeType) {
  const byteChars = atob(base64 || "");
  const sliceSize = 1024;
  const slices = [];
  for (let offset = 0; offset < byteChars.length; offset += sliceSize) {
    const slice = byteChars.slice(offset, offset + sliceSize);
    const byteNumbers = new Array(slice.length);
    for (let i = 0; i < slice.length; i += 1) {
      byteNumbers[i] = slice.charCodeAt(i);
    }
    slices.push(new Uint8Array(byteNumbers));
  }
  return new Blob(slices, { type: mimeType || "application/octet-stream" });
}

function isAbsoluteUrl(url) {
  return /^(https?:|blob:|data:)/i.test(url || "");
}

function resolvePublicUrl(url) {
  if (!url) {
    return "";
  }
  if (isAbsoluteUrl(url) || url.startsWith("data:")) {
    return url;
  }
  const base = API_BASE ? API_BASE.replace(/\/$/, "") : window.location.origin;
  const path = url.startsWith("/") ? url : `/${url}`;
  return `${base}${path}`;
}

function dataUrlToBlobUrl(dataUrl) {
  if (!dataUrl || !dataUrl.startsWith("data:")) {
    return "";
  }
  const match = dataUrl.match(/^data:([^;,]+)?(;base64)?,(.*)$/);
  if (!match) {
    return "";
  }
  const mime = match[1] || "application/octet-stream";
  const isBase64 = Boolean(match[2]);
  const payload = match[3] || "";
  try {
    const blob = isBase64
      ? base64ToBlob(payload, mime)
      : new Blob([decodeURIComponent(payload)], { type: mime });
    return URL.createObjectURL(blob);
  } catch (error) {
    return "";
  }
}

function openInNewTab(url) {
  if (!url) {
    return;
  }
  let targetUrl = url;
  let tempBlobUrl = "";
  if (url.startsWith("data:")) {
    const blobUrl = dataUrlToBlobUrl(url);
    if (blobUrl) {
      targetUrl = blobUrl;
      tempBlobUrl = blobUrl;
    }
  }
  const janela = window.open(targetUrl, "_blank", "noopener");
  if (!janela) {
    const link = document.createElement("a");
    link.href = targetUrl;
    link.target = "_blank";
    link.rel = "noopener";
    document.body.append(link);
    link.click();
    link.remove();
  }
  if (tempBlobUrl) {
    setTimeout(() => URL.revokeObjectURL(tempBlobUrl), 300000);
  }
}

function abrirPreview(url, blobUrl = "") {
  if (!modalPreview || !previewFrame) {
    return;
  }
  if (previewBlobUrl) {
    URL.revokeObjectURL(previewBlobUrl);
    previewBlobUrl = "";
  }
  if (blobUrl) {
    previewBlobUrl = blobUrl;
  }
  previewCurrentUrl = resolvePublicUrl(url || "");
  previewFrame.src = previewCurrentUrl;
  if (btnAbrirPreview) {
    btnAbrirPreview.disabled = !previewCurrentUrl;
  }
  modalPreview.hidden = false;
}

function fecharPreview() {
  if (!modalPreview || !previewFrame) {
    return;
  }
  modalPreview.hidden = true;
  previewFrame.src = "";
  previewCurrentUrl = "";
  if (btnAbrirPreview) {
    btnAbrirPreview.disabled = true;
  }
  if (previewBlobUrl) {
    URL.revokeObjectURL(previewBlobUrl);
    previewBlobUrl = "";
  }
}

async function abrirDocumento(doc) {
  if (!doc) {
    return;
  }
  const dataUrl = doc.dataUrl || "";
  if (dataUrl && dataUrl.startsWith("data:")) {
    abrirPreview(dataUrl);
    return;
  }
  if (doc.docId) {
    const registro = await getDocById(doc.docId);
    if (registro && registro.blob) {
      const blobUrl = URL.createObjectURL(registro.blob);
      abrirPreview(blobUrl, blobUrl);
      return;
    }
    window.alert("Documento não encontrado.");
    return;
  }
  const url = resolvePublicUrl(doc.url || "");
  if (!url) {
    window.alert("Documento não encontrado.");
    return;
  }
  abrirPreview(url);
}

function renderDocList(container, documentos, critico = false) {
  if (!container) {
    return;
  }
  container.innerHTML = "";
  const docs = documentos || {};
  const criticoAtual = isCriticoValor(critico);
  let exibiu = false;
  DOC_KEYS.forEach((key) => {
    if (key === "pt" && !criticoAtual) {
      return;
    }
    exibiu = true;
    const row = document.createElement("div");
    row.className = "doc-row";
    const label = document.createElement("span");
    label.textContent = DOC_LABELS[key] || key;
    const action = document.createElement("div");
    const doc = docs[key];
    if (doc && (doc.dataUrl || doc.url || doc.docId)) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "btn btn--ghost btn--small";
      btn.textContent = "Visualizar";
      btn.addEventListener("click", () => abrirDocumento(doc));
      action.append(btn);
    } else {
      row.classList.add("is-pending");
      const pending = document.createElement("small");
      pending.textContent = "Pendente";
      action.append(pending);
    }
    row.append(label, action);
    container.append(row);
  });
  if (!exibiu) {
    const vazio = document.createElement("p");
    vazio.className = "empty-state";
    vazio.textContent = "Sem documentos.";
    container.append(vazio);
  }
}

function getRescheduleCount(item) {
  if (!item) {
    return 0;
  }
  return auditLog.filter(
    (entry) => entry.action === "reschedule" && entry.manutencaoId === item.id
  ).length;
}

function getOutrosMensalCount() {
  const agora = new Date();
  const inicioMes = new Date(agora.getFullYear(), agora.getMonth(), 1);
  const fimMes = new Date(agora.getFullYear(), agora.getMonth() + 1, 0, 23, 59, 59, 999);
  const inicioMs = inicioMes.getTime();
  const fimMs = fimMes.getTime();
  return auditLog.filter((entry) => {
    if (entry.action !== "reschedule") {
      return false;
    }
    if (!entry.detalhes || entry.detalhes.motivo !== "Outros") {
      return false;
    }
    const stamp = getTimeValue(entry.timestamp);
    return stamp !== null && stamp >= inicioMs && stamp <= fimMs;
  }).length;
}

function renderAlertaProgramacao() {
  if (!alertaProgramacao) {
    return;
  }
  const count = getOutrosMensalCount();
  if (count > OUTROS_ALERT_THRESHOLD) {
    alertaProgramacao.textContent =
      `Alerta: motivo Outros usado ${count}x neste mês. Revisar governança.`;
    alertaProgramacao.hidden = false;
    return;
  }
  alertaProgramacao.hidden = true;
}
function atualizarResumo() {
  const contagem = {
    agendada: 0,
    liberada: 0,
    backlog: 0,
    em_execucao: 0,
    encerramento: 0,
    concluida: 0,
  };

  manutencoes.forEach((item) => {
    const status = normalizeMaintenanceStatus(item.status);
    contagem[status] += 1;
  });
  const execucoesRegistradas = manutencoes.filter((item) => {
    if (!hasExecucaoRegistradaCompleta(item)) {
      return false;
    }
    const status = normalizeMaintenanceStatus(item.status);
    return status === "em_execucao" || status === "encerramento";
  }).length;

  countAgendadas.textContent = contagem.agendada;
  if (countLiberadas) {
    countLiberadas.textContent = contagem.liberada;
  }
  countBacklog.textContent = contagem.backlog;
  if (badgeBacklog) {
    badgeBacklog.textContent = contagem.backlog;
  }
  if (countEmExecucao) {
    const emExecucaoAtivas = manutencoes.filter((item) => {
      if (!item) {
        return false;
      }
      const status = normalizeMaintenanceStatus(item.status);
      return status === "em_execucao" && !hasExecucaoRegistradaCompleta(item);
    }).length;
    countEmExecucao.textContent = emExecucaoAtivas;
  }
  if (countEncerramento) {
    countEncerramento.textContent = execucoesRegistradas;
  }
  countConcluidas.textContent = contagem.concluida;
  renderHome();
}

function getDateInfo(item, hoje) {
  const data = parseDate(item.data);
  if (!data) {
    return null;
  }
  const diff = diffInDays(hoje, data);
  return { data, diff };
}

function getReleaseLockInfo(item, data, hoje) {
  if (!item || !data) {
    return null;
  }
  if (item.status !== "agendada") {
    return null;
  }
  if (data <= hoje) {
    return null;
  }
  return { date: data, canOverride: canOverrideRelease(currentUser) };
}

function getMaintenanceState(item, data, hoje) {
  if (!item) {
    return "planned";
  }
  const status = normalizeMaintenanceStatus(item.status);
  if (status === "concluida" || status === "cancelada") {
    return "planned";
  }
  if (hasExecucaoRegistradaCompleta(item)) {
    return "awaiting";
  }
  if (data && data.getTime() === hoje.getTime()) {
    return "released";
  }
  if (data && data < hoje) {
    return "overdue";
  }
  return "planned";
}

function renderHome() {
  loadDashboardSummary();
  renderDashboardHome();
}

function renderDashboardHome() {
  if (!dashboardHome) {
    return;
  }
  if (currentUser && !activeProjectId) {
    dashboardHome.innerHTML = `<p class="dashboard-message">Selecione um projeto ativo.</p>`;
    return;
  }
  if (!dashboardSummary) {
    const mensagem = dashboardError || "Carregando indicadores...";
    dashboardHome.innerHTML = `<p class="dashboard-message">${mensagem}</p>`;
    return;
  }
  const {
    kpis,
    saudeOperacional,
    graficoEficiencia,
    proximasAtividades,
    miniSeries: summaryMiniSeries,
  } = dashboardSummary;
  const useLocalSummary = !STRICT_SERVER_SYNC;
  const scopedManutencoes = useLocalSummary && Array.isArray(manutencoes)
    ? manutencoes.filter(
        (item) =>
          item && (!activeProjectId || !item.projectId || item.projectId === activeProjectId)
      )
    : [];
  const localSummary = useLocalSummary
    ? buildLocalDashboardSummary(scopedManutencoes, activeProjectId)
    : null;
  const kpisFinal = useLocalSummary
    ? { ...(kpis || {}), ...(localSummary ? localSummary.kpis || {} : {}) }
    : (kpis || {});
  const saudeFinal = useLocalSummary
    ? {
        ...(saudeOperacional || {}),
        ...(localSummary ? localSummary.saudeOperacional || {} : {}),
      }
    : (saudeOperacional || {});
  const miniSeries = useLocalSummary
    ? (localSummary && localSummary.miniSeries) || {}
    : (summaryMiniSeries || {});

  const renderKpiCard = (label, value) =>
    `<article class="kpi-card"><span>${label}</span><strong>${value}</strong></article>`;

  const atrasoMedioPct = Math.round((Number(saudeFinal.atrasoMedioDias) || 0) * 100);
  const pieValues = [
    Number(saudeFinal.pontualidadePct) || 0,
    Number(saudeFinal.backlogTotal) || 0,
    Number(saudeFinal.concluidasPeriodo) || 0,
    atrasoMedioPct,
  ];
  const pieLabels = ["Pontualidade", "Backlog", "Concluídas", "Atraso médio"];
  const pieDisplay = [
    `${saudeFinal.pontualidadePct}%`,
    String(saudeFinal.backlogTotal),
    String(saudeFinal.concluidasPeriodo),
    `${atrasoMedioPct}%`,
  ];
  const chart = buildNeonPieChart(pieValues, pieLabels, pieDisplay);

  const pontualidadePct = clampPercent(Number(saudeFinal.pontualidadePct) || 0);
  const atrasoMedioDias = Number(saudeFinal.atrasoMedioDias) || 0;
  const atrasoScale = clampPercent((Math.min(atrasoMedioDias, 10) / 10) * 100);
  const atrasoLabel = Number.isFinite(atrasoMedioDias)
    ? `${atrasoMedioDias % 1 ? atrasoMedioDias.toFixed(1) : Math.round(atrasoMedioDias)}d`
    : "-";
  const backlogTotal = Number(saudeFinal.backlogTotal) || 0;
  const concluidasTotal = Number(saudeFinal.concluidasPeriodo) || 0;
  const backlogBars = buildEfficiencyBars(miniSeries.backlog || []);
  const concluidasBars = buildEfficiencyBars(miniSeries.concluidas || []);
  const efficiencyKpisHtml = `
    <div class="efficiency-kpis">
      ${buildEfficiencyKpiBlock(
        "Pontualidade",
        `${pontualidadePct}%`,
        "#22c55e",
        buildEfficiencyBar(pontualidadePct),
        "Percentual de entregas no prazo."
      )}
      ${buildEfficiencyKpiBlock(
        "Atraso médio",
        atrasoLabel,
        "#ef4444",
        buildEfficiencyBar(atrasoScale),
        "Tempo médio de atraso (dias)."
      )}
      ${buildEfficiencyKpiBlock(
        "Backlog",
        String(backlogTotal),
        "#3b82f6",
        backlogBars,
        "Pendências acumuladas."
      )}
      ${buildEfficiencyKpiBlock(
        "Concluídas",
        String(concluidasTotal),
        "#facc15",
        concluidasBars,
        "Volume total concluído no período."
      )}
    </div>
  `;

  const today = startOfDay(new Date());
  const sortedAtividades = Array.isArray(proximasAtividades)
    ? proximasAtividades
        .map((item) => {
          const parsed = parseTimestamp(item.prazo);
          const date = parsed ? startOfDay(parsed) : null;
          let bucket = 1;
          if (date && date.getTime() === today.getTime()) {
            bucket = 0;
          } else if (date && date < today) {
            bucket = 2;
          }
          return { ...item, _bucket: bucket, _date: date };
        })
        .sort((a, b) => {
          if (a._bucket !== b._bucket) {
            return a._bucket - b._bucket;
          }
          const at = a._date ? a._date.getTime() : Number.MAX_SAFE_INTEGER;
          const bt = b._date ? b._date.getTime() : Number.MAX_SAFE_INTEGER;
          return at - bt;
        })
    : [];

  const rows = sortedAtividades
    .map((item) => {
      const badge = getStatusBadge(item.status);
      return `<tr>
        <td>${escapeHtml(item.atividade)}</td>
        <td>${escapeHtml(formatResponsavelText(item.responsavel))}</td>
        <td>${escapeHtml(item.prazo)}</td>
        <td>${badge}</td>
      </tr>`;
    })
    .join("");
  const updatedAt = dashboardSummary.generatedAt
    ? formatDateTime(parseTimestamp(dashboardSummary.generatedAt) || new Date())
    : formatDateTime(new Date());

  dashboardHome.innerHTML = `
    <div class="home-shell">
      <div class="home-header">
        <div class="home-header__title">
          <h2>Centro de controle operacional</h2>
          <p class="hint">Visão tático-operacional com indicadores críticos e foco no dia.</p>
        </div>
        <div class="home-header__meta">
          <span class="hint">${updatedAt}</span>
        </div>
      </div>

      <section class="home-section">
        <h3 class="home-section__title">Indicadores do dia</h3>
        <div class="kpi-grid">
          ${renderKpiCard("VENCE HOJE", kpisFinal.venceHoje)}
          ${renderKpiCard("ATRASADAS", kpisFinal.atrasadas)}
          ${renderKpiCard("AGUARDANDO CONCLUSÃO", kpisFinal.aguardandoConclusao)}
          ${renderKpiCard("CRÍTICAS", kpisFinal.criticas)}
          ${renderKpiCard("RISCO IMEDIATO", kpisFinal.riscoImediato)}
        </div>
      </section>

      <section class="home-section">
        <h3 class="home-section__title">Suporte e saúde</h3>
        <div class="dashboard-row">
          <article class="card panel-card">
            <div class="panel-head">
              <h3>DICAS DA OPSCOPE</h3>
            </div>
            <div class="opscope-tips" id="opscopeTips">
              <p class="opscope-tip" data-tip></p>
            </div>
          </article>
          <article class="card panel-card">
            <div class="panel-head">
              <h3>SAÚDE OPERACIONAL</h3>
            </div>
            <div class="health-grid">
              <div class="health-item">
                <span>Pontualidade</span>
                <strong>${saudeFinal.pontualidadePct}%</strong>
              </div>
              <div class="health-item">
                <span>Backlog</span>
                <strong>${saudeFinal.backlogTotal}</strong>
              </div>
              <div class="health-item">
                <span>Concluídas</span>
                <strong>${saudeFinal.concluidasPeriodo}</strong>
              </div>
              <div class="health-item">
                <span>Atraso médio</span>
                <strong>${saudeFinal.atrasoMedioDias}d</strong>
              </div>
            </div>
          </article>
        </div>
      </section>

      <section class="home-section">
        <h3 class="home-section__title">Performance e previsão</h3>
        <div class="dashboard-row">
          <article class="card panel-card">
            <div class="panel-head">
              <h3>EFICIÊNCIA OPERACIONAL</h3>
              <span class="trend-tag">+8%</span>
            </div>
            <div class="mini-chart neon-pie">
              ${efficiencyKpisHtml}
              <div class="pie-legend">
                <div class="pie-legend__item">
                  <span class="pie-legend__dot pie-legend__dot--green"></span>
                  <div>
                    <strong>Pontualidade</strong>
                    <span>Percentual de entregas no prazo.</span>
                  </div>
                </div>
                <div class="pie-legend__item">
                  <span class="pie-legend__dot pie-legend__dot--red"></span>
                  <div>
                    <strong>Atraso médio</strong>
                    <span>Tempo médio de atraso (dias).</span>
                  </div>
                </div>
                <div class="pie-legend__item">
                  <span class="pie-legend__dot pie-legend__dot--blue"></span>
                  <div>
                    <strong>Backlog</strong>
                    <span>Pendências acumuladas.</span>
                  </div>
                </div>
                <div class="pie-legend__item">
                  <span class="pie-legend__dot pie-legend__dot--yellow"></span>
                  <div>
                    <strong>Concluídas</strong>
                    <span>Volume total concluído no período.</span>
                  </div>
                </div>
              </div>
            </div>
          </article>
          <article class="card panel-card">
            <div class="panel-head">
              <h3>PRÓXIMAS ATIVIDADES</h3>
            </div>
            <div class="table-wrap">
              <table class="data-table">
                <thead>
                  <tr>
                    <th>Atividade</th>
                    <th>Responsável</th>
                    <th>Prazo</th>
                    <th>Status</th>
                  </tr>
                </thead>
                <tbody>
                  ${rows || `<tr><td colspan="4" class="empty-state">Sem registros.</td></tr>`}
                </tbody>
              </table>
            </div>
          </article>
        </div>
      </section>
    </div>
  `;
  startHomeTipsRotation();
}

function buildNeonPieChart(series, labels, displayValues = []) {
  const base = Array.isArray(series) ? series : [];
  const safeValues = base.length
    ? base.map((value) => {
        const numeric = Number(value);
        if (!Number.isFinite(numeric) || numeric <= 0) {
          return 0;
        }
        return numeric;
      })
    : [1, 1, 1, 1];
  const chartValues = safeValues.map((value) => (value === 0 ? 0.1 : value));
  const total = chartValues.reduce((sum, value) => sum + value, 0) || 1;
  const colors = ["#22c55e", "#3b82f6", "#facc15", "#ef4444"];
  const radius = 38;
  const center = 50;
  let startAngle = -Math.PI / 2;
  const slices = chartValues
    .map((value, index) => {
      const angle = (value / total) * Math.PI * 2;
      const endAngle = startAngle + angle;
      const largeArc = angle > Math.PI ? 1 : 0;
      const x1 = center + radius * Math.cos(startAngle);
      const y1 = center + radius * Math.sin(startAngle);
      const x2 = center + radius * Math.cos(endAngle);
      const y2 = center + radius * Math.sin(endAngle);
      const path = `M ${center} ${center} L ${x1.toFixed(2)} ${y1.toFixed(2)} A ${radius} ${radius} 0 ${largeArc} 1 ${x2.toFixed(2)} ${y2.toFixed(2)} Z`;
      const label = labels && labels[index] ? labels[index] : `Indicador ${index + 1}`;
      const display = displayValues[index] ? displayValues[index] : safeValues[index];
      const title = `${label}: ${display}`;
      startAngle = endAngle;
      return `<path class="pie-slice" d="${path}" fill="${colors[index % colors.length]}"><title>${escapeHtml(title)}</title></path>`;
    })
    .join("");
  const title = labels && labels.length ? labels.join(", ") : "Distribuição";
  return `
    <svg viewBox="0 0 100 100" aria-hidden="true" focusable="false" role="img">
      <title>${escapeHtml(title)}</title>
      <defs>
        <filter id="neonGlow" x="-50%" y="-50%" width="200%" height="200%">
          <feDropShadow dx="0" dy="0" stdDeviation="4" flood-color="rgba(88, 210, 255, 0.7)" />
          <feDropShadow dx="0" dy="0" stdDeviation="8" flood-color="rgba(246, 208, 138, 0.5)" />
        </filter>
      </defs>
      <g filter="url(#neonGlow)">
        ${slices}
      </g>
      <circle cx="${center}" cy="${center}" r="20" fill="rgba(12, 26, 40, 0.85)" />
    </svg>
  `;
}

function buildEfficiencyBar(valuePercent) {
  const width = clampPercent(Number(valuePercent) || 0);
  return `<div class="efficiency-kpi__bar"><span style="width:${width}%"></span></div>`;
}

function buildEfficiencyBars(values, maxBars = 8) {
  const safe = Array.isArray(values)
    ? values.filter((val) => Number.isFinite(val))
    : [];
  const slice = safe.slice(-maxBars);
  const max = slice.length ? Math.max(...slice, 1) : 1;
  const bars = slice
    .map((value) => {
      const height = Math.max(6, Math.round((value / max) * 28));
      return `<span style="height:${height}px"></span>`;
    })
    .join("");
  if (!bars) {
    return `<div class="efficiency-kpi__bars efficiency-kpi__bars--empty"><span style="height:6px"></span></div>`;
  }
  return `<div class="efficiency-kpi__bars">${bars}</div>`;
}

function buildEfficiencyKpiBlock(label, value, accentColor, detailHtml, tooltipText) {
  const tooltip = tooltipText
    ? `<div class="efficiency-kpi__tooltip" role="tooltip">${escapeHtml(tooltipText)}</div>`
    : "";
  return `
    <div class="efficiency-kpi" style="--accent-color:${accentColor}">
      <div class="efficiency-kpi__label">
        <span class="efficiency-kpi__dot"></span>
        <span>${escapeHtml(label)}</span>
      </div>
      <div class="efficiency-kpi__value">${escapeHtml(value)}</div>
      ${detailHtml || ""}
      ${tooltip}
    </div>
  `;
}

function startHomeTipsRotation() {
  const tipBox = document.querySelector("#opscopeTips [data-tip]");
  if (!tipBox) {
    return;
  }
  const tips = [
    "Antes de iniciar a atividade, confirme subestação, OS e referência no OPSCOPE; isso evita retrabalho e garante que a equipe execute o procedimento correto.",
    "Use o painel para registrar evidências completas (fotos, observações técnicas e resultados); um registro detalhado acelera liberações futuras e evita dúvidas em campo.",
    "Ao identificar falha recorrente, registre a causa provável e a ação corretiva; isso ajuda outros técnicos a repetir o diagnóstico com mais rapidez.",
    "Revise os documentos obrigatórios (APR, OS, PTE, PT) diretamente no sistema; manter anexos consistentes reduz bloqueios e atrasos na execução.",
    "Atualize o status assim que finalizar a intervenção; o OPSCOPE sincroniza a equipe e evita que duas frentes atuem no mesmo ponto.",
    "Em atividades críticas, confirme participantes e horários no registro; isso facilita auditoria técnica e garante rastreabilidade total da operação.",
    "Use o histórico de manutenção para comparar sintomas anteriores; padrões repetidos indicam ajustes na causa raiz e economizam tempo.",
    "Quando houver atraso, registre o motivo tecnico com clareza; isso protege a equipe e evita retrabalho no fechamento da OS.",
    "Acompanhe as automações para tarefas recorrentes; elas ajudam a lembrar prazos e liberações sem depender de controles manuais.",
    "Se encontrar divergência entre campo e sistema, registre a observação no OPSCOPE imediatamente; isso evita falhas de comunicação entre turnos.",
  ];
  if (homeTipsTimer) {
    window.clearInterval(homeTipsTimer);
  }
  homeTipIndex = homeTipIndex % tips.length;
  tipBox.textContent = tips[homeTipIndex];
  homeTipsTimer = window.setInterval(() => {
    homeTipIndex = (homeTipIndex + 1) % tips.length;
    tipBox.textContent = tips[homeTipIndex];
    tipBox.classList.remove("tip-fade");
    void tipBox.offsetWidth;
    tipBox.classList.add("tip-fade");
  }, 6000);
}

function buildMiniChart(series, labels) {
  const safeSeries = Array.isArray(series) && series.length ? series : [0];
  const width = 240;
  const height = 90;
  const pad = 10;
  const values = safeSeries.filter((value) => typeof value === "number");
  const min = values.length ? Math.min(...values) : 0;
  const max = values.length ? Math.max(...values) : 100;
  const range = max - min || 1;
  const count = safeSeries.length;
  const points = safeSeries.map((value, index) => {
    const x = count === 1 ? width / 2 : pad + (index / (count - 1)) * (width - pad * 2);
    if (typeof value !== "number") {
      return { x, y: null };
    }
    const y = height - pad - ((value - min) / range) * (height - pad * 2);
    return { x, y };
  });
  const paths = [];
  let current = [];
  points.forEach((point) => {
    if (point.y === null) {
      if (current.length > 0) {
        paths.push(current);
        current = [];
      }
      return;
    }
    current.push(point);
  });
  if (current.length > 0) {
    paths.push(current);
  }
  const pathMarkup = paths
    .map((segment) => {
      const d = segment
        .map((point, idx) => `${idx === 0 ? "M" : "L"} ${point.x.toFixed(1)} ${point.y.toFixed(1)}`)
        .join(" ");
      return `<path class="chart-line" d="${d}" />`;
    })
    .join("");
  const circles = points
    .map((point) => {
      if (point.y === null) {
        return "";
      }
      return `<circle class="chart-point" cx="${point.x.toFixed(1)}" cy="${point.y.toFixed(1)}" r="2.2" />`;
    })
    .join("");
  const gridLines = [0, 1, 2, 3]
    .map((step) => {
      const y = pad + (step / 3) * (height - pad * 2);
      return `<line x1="${pad}" y1="${y}" x2="${width - pad}" y2="${y}" />`;
    })
    .join("");
  const labelText = labels && labels.length ? labels.join(", ") : "";

  return `
    <svg viewBox="0 0 ${width} ${height}" aria-hidden="true" focusable="false" role="img">
      ${labelText ? `<title>${escapeHtml(labelText)}</title>` : ""}
      <g class="chart-grid">${gridLines}</g>
      ${pathMarkup}
      ${circles}
    </svg>
  `;
}

function getStatusBadge(status) {
  const texto = status || "";
  const normalizado = texto.toLowerCase();
  let classe = "badge";
  if (normalizado.includes("crit")) {
    classe += " badge--crit";
  } else if (
    normalizado.includes("atras") ||
    normalizado.includes("risco") ||
    normalizado.includes("hoje")
  ) {
    classe += " badge--warn";
  } else {
    classe += " badge--ok";
  }
  return `<span class="${classe}">${escapeHtml(texto || "OK")}</span>`;
}

const ANNOUNCEMENT_TYPES = {
  info: "Informativo",
  aviso: "Aviso",
  alerta: "Alerta",
};

const ANNOUNCEMENT_SEVERITIES = {
  baixa: "Baixa",
  media: "Média",
  alta: "Alta",
  critica: "Crítica",
};

const ANNOUNCEMENT_SEVERITY_ORDER = ["baixa", "media", "alta", "critica"];

function shouldFallbackAnnouncements(error) {
  const status = Number(error && error.status) || 0;
  return status === 404 || status === 405 || status === 501;
}

function normalizeAnnouncementType(value) {
  const normalized = normalizeSearchValue(value);
  if (normalized.includes("alert")) {
    return "alerta";
  }
  if (normalized.includes("aviso")) {
    return "aviso";
  }
  return "info";
}

function normalizeAnnouncementSeverity(value) {
  const normalized = normalizeSearchValue(value);
  if (normalized.includes("crit")) {
    return "critica";
  }
  if (normalized.includes("alta")) {
    return "alta";
  }
  if (normalized.includes("med")) {
    return "media";
  }
  return "baixa";
}

function getAnnouncementSeverityLabel(severity) {
  return ANNOUNCEMENT_SEVERITIES[severity] || ANNOUNCEMENT_SEVERITIES.baixa;
}

function getAnnouncementSeverityRank(severity) {
  const index = ANNOUNCEMENT_SEVERITY_ORDER.indexOf(severity);
  return index === -1 ? 0 : index;
}

function getHighestAnnouncementSeverity(items) {
  let highest = "baixa";
  items.forEach((item) => {
    const rank = getAnnouncementSeverityRank(item.severity || "baixa");
    if (rank > getAnnouncementSeverityRank(highest)) {
      highest = item.severity || "baixa";
    }
  });
  return highest;
}

function getUserHierarchyRank(user) {
  if (!user) {
    return 99;
  }
  const role = String(user.rbacRole || user.role || "").trim().toLowerCase();
  const cargo = normalizeSearchValue(user.cargo || user.roleName || "");
  if (role === "admin" || role === "gestor" || cargo.includes("admin")) {
    return 0;
  }
  if (
    role === "diretor_om" ||
    role === "gerente_contrato" ||
    cargo.includes("diretor") ||
    cargo.includes("gerente") ||
    cargo.includes("coordenador")
  ) {
    return 1;
  }
  if (
    role === "supervisor" ||
    role === "supervisor_om" ||
    role === "pcm" ||
    cargo.includes("supervisor") ||
    cargo.includes("pcm")
  ) {
    return 2;
  }
  return 3;
}

function getAnnouncementSenderRank(record) {
  if (record && Number.isFinite(record.senderRank)) {
    return record.senderRank;
  }
  const roleLabel = normalizeSearchValue(record && record.senderRoleLabel);
  if (roleLabel.includes("admin")) {
    return 0;
  }
  if (roleLabel.includes("diretor") || roleLabel.includes("gerente") || roleLabel.includes("coordenador")) {
    return 1;
  }
  if (roleLabel.includes("supervisor") || roleLabel.includes("pcm")) {
    return 2;
  }
  return 3;
}

function getAnnouncementProjectLabel(projectId) {
  if (!projectId) {
    return "";
  }
  const match = availableProjects.find((project) => String(project.id) === String(projectId));
  return match ? getProjectLabel(match) : "";
}

function isUserInProject(user, projectId, projectLabel = "") {
  if (!user || !projectId) {
    return false;
  }
  const normalizedTarget = [
    projectId,
    projectLabel,
    getAnnouncementProjectLabel(projectId),
  ]
    .map((value) => normalizeSearchValue(value))
    .filter(Boolean);

  const userTokens = [
    user.projectId,
    user.projetoId,
    user.project_id,
    user.project,
    user.projectKey,
    user.projectCode,
    user.projectName,
    user.projectLabel,
    user.projeto,
    getUserProjectLabel(user),
  ];
  if (user.project && typeof user.project === "object") {
    userTokens.push(user.project.id, user.project.codigo, user.project.nome, user.project.label);
  }
  if (Array.isArray(user.projects)) {
    user.projects.forEach((entry) => {
      if (entry && typeof entry === "object") {
        userTokens.push(entry.id, entry.codigo, entry.nome, entry.label);
      } else {
        userTokens.push(entry);
      }
    });
  }
  const normalizedUser = userTokens.map((value) => normalizeSearchValue(value)).filter(Boolean);
  if (normalizedUser.some((token) => normalizedTarget.includes(token))) {
    return true;
  }
  if (activeProjectId && String(activeProjectId) === String(projectId)) {
    const equipeIds = getActiveProjectEquipeIds();
    if (equipeIds.size && user.id && equipeIds.has(user.id)) {
      return true;
    }
  }
  return false;
}

function canReceiveAnnouncement(item, user) {
  if (!item || !user) {
    return false;
  }
  if (!canViewAnnouncements(user)) {
    return false;
  }
  if (item.scope === "project" && item.projectId) {
    if (!isUserInProject(user, item.projectId, item.projectLabel)) {
      return false;
    }
  }
  if (item.createdBy && user.id && String(item.createdBy) === String(user.id)) {
    return true;
  }
  const senderRank = getAnnouncementSenderRank(item);
  const userRank = getUserHierarchyRank(user);
  return userRank >= senderRank;
}

function normalizeAnnouncementImage(entry) {
  if (!entry) {
    return null;
  }
  if (typeof entry === "string") {
    const src = entry.trim();
    return src ? { src, name: "" } : null;
  }
  if (typeof entry === "object") {
    const src = String(entry.src || entry.url || entry.dataUrl || entry.data || "").trim();
    if (!src) {
      return null;
    }
    return {
      src,
      name: String(entry.name || entry.filename || "").trim(),
    };
  }
  return null;
}

function normalizeAnnouncementImages(list) {
  if (!Array.isArray(list)) {
    return [];
  }
  return list.map((item) => normalizeAnnouncementImage(item)).filter(Boolean);
}

function normalizeAnnouncementRecord(record) {
  if (!record || typeof record !== "object") {
    return null;
  }
  const id = record.id || record._id || criarId();
  const title = String(record.title || record.titulo || "").trim();
  const message = String(record.message || record.mensagem || record.text || "").trim();
  if (!title && !message) {
    return null;
  }
  const createdAt = normalizeIso(record.createdAt || record.created || new Date());
  const type = normalizeAnnouncementType(record.type || record.tipo || "info");
  const severity = normalizeAnnouncementSeverity(record.severity || record.criticidade || "baixa");
  const scope = record.scope || (record.projectId || record.project ? "project" : "all");
  const projectId = String(record.projectId || record.project || "").trim();
  const projectLabel =
    String(record.projectLabel || record.projectName || "").trim() || getAnnouncementProjectLabel(projectId);
  const images = normalizeAnnouncementImages(
    record.images || record.fotos || record.photos || record.imagens || []
  );
  const readByRaw = Array.isArray(record.readBy || record.reads || record.lidos)
    ? record.readBy || record.reads || record.lidos
    : [];
  const readBy = readByRaw
    .map((entry) => {
      if (!entry) {
        return null;
      }
      if (typeof entry === "string") {
        return { userId: entry };
      }
      if (typeof entry === "object") {
        return {
          userId: entry.userId || entry.id || entry.user || "",
          readAt: entry.readAt || entry.at || entry.date || "",
        };
      }
      return null;
    })
    .filter((entry) => entry && entry.userId);
  return {
    id,
    title: title || "Anúncio",
    message,
    type,
    severity,
    scope,
    projectId,
    projectLabel,
    images,
    readBy,
    createdAt,
    createdBy: record.createdBy || record.authorId || record.userId || "",
    createdByName: record.createdByName || record.authorName || record.userName || "",
    senderRank: Number.isFinite(record.senderRank) ? record.senderRank : undefined,
    senderRoleLabel: record.senderRoleLabel || record.senderRole || record.roleLabel || "",
  };
}

function readAnnouncementsStorage() {
  return readJson(ANNOUNCEMENTS_KEY, []);
}

function saveAnnouncementsStorage(list) {
  writeJson(ANNOUNCEMENTS_KEY, Array.isArray(list) ? list : []);
}

function normalizeAnnouncements(list) {
  return (Array.isArray(list) ? list : [])
    .map((item) => normalizeAnnouncementRecord(item))
    .filter(Boolean)
    .sort((a, b) => {
      const ta = parseTimestamp(a.createdAt);
      const tb = parseTimestamp(b.createdAt);
      return (tb ? tb.getTime() : 0) - (ta ? ta.getTime() : 0);
    });
}

function getAnnouncementTypeLabel(type) {
  return ANNOUNCEMENT_TYPES[type] || ANNOUNCEMENT_TYPES.info;
}

function getAnnouncementScopeLabel(item) {
  if (!item) {
    return "Geral";
  }
  if (item.scope === "project" && (item.projectLabel || item.projectId)) {
    return item.projectLabel || getAnnouncementProjectLabel(item.projectId) || "Projeto";
  }
  return "Geral";
}

function getAnnouncementReadState() {
  const stored = readJson(ANNOUNCEMENTS_READ_KEY, {});
  if (Array.isArray(stored)) {
    const state = {};
    if (currentUser && currentUser.id) {
      state[currentUser.id] = stored;
    }
    return state;
  }
  return stored && typeof stored === "object" ? stored : {};
}

function getReadAnnouncementIds(user = currentUser) {
  const state = getAnnouncementReadState();
  const readSet = new Set();
  if (user && user.id && state[user.id]) {
    (state[user.id] || []).forEach((id) => readSet.add(String(id)));
  } else if (Array.isArray(state)) {
    state.forEach((id) => readSet.add(String(id)));
  }
  if (user && user.id && Array.isArray(announcements)) {
    announcements.forEach((item) => {
      if (!item || !item.id) {
        return;
      }
      const readers = Array.isArray(item.readBy) ? item.readBy : [];
      if (readers.some((entry) => String(entry.userId || entry.id || "") === String(user.id))) {
        readSet.add(String(item.id));
      }
    });
  }
  return readSet;
}

function saveReadAnnouncementIds(readSet, user = currentUser) {
  if (!user || !user.id) {
    writeJson(ANNOUNCEMENTS_READ_KEY, Array.from(readSet));
    return;
  }
  const state = getAnnouncementReadState();
  state[user.id] = Array.from(readSet);
  writeJson(ANNOUNCEMENTS_READ_KEY, state);
}

function getAnnouncementReadersMap() {
  return readJson(ANNOUNCEMENTS_READERS_KEY, {});
}

function saveAnnouncementReadersMap(map) {
  writeJson(ANNOUNCEMENTS_READERS_KEY, map || {});
}

function markAnnouncementReadByUser(id, user = currentUser) {
  if (!id || !user || !user.id) {
    return;
  }
  const key = String(id);
  const map = getAnnouncementReadersMap();
  const entry = map[key] && typeof map[key] === "object" ? map[key] : {};
  if (!entry[user.id]) {
    entry[user.id] = toIsoUtc(new Date());
    map[key] = entry;
    saveAnnouncementReadersMap(map);
  }
}

function getAnnouncementReaders(item) {
  if (!item) {
    return [];
  }
  const result = new Map();
  const list = Array.isArray(item.readBy) ? item.readBy : [];
  list.forEach((entry) => {
    if (!entry) {
      return;
    }
    const userId = String(entry.userId || entry.id || entry.user || "").trim();
    if (!userId) {
      return;
    }
    result.set(userId, entry.readAt || entry.at || entry.date || "");
  });
  const map = getAnnouncementReadersMap();
  const local = map[String(item.id)];
  if (local && typeof local === "object") {
    Object.entries(local).forEach(([userId, readAt]) => {
      if (!result.has(userId)) {
        result.set(userId, readAt);
      }
    });
  }
  return Array.from(result.entries()).map(([userId, readAt]) => ({
    userId,
    readAt,
  }));
}

function markAnnouncementRead(id, user = currentUser) {
  if (!id) {
    return;
  }
  const readSet = getReadAnnouncementIds();
  const key = String(id);
  if (!readSet.has(key)) {
    readSet.add(key);
    saveReadAnnouncementIds(readSet);
  }
  markAnnouncementReadByUser(id, user);
  if (USE_AUTH_API && user && user.id) {
    apiAnnouncementsRead([id]).catch(() => null);
  }
}

function markVisibleAnnouncementsRead() {
  if (!currentUser) {
    return;
  }
  const readSet = getReadAnnouncementIds();
  const ids = [];
  let changed = false;
  announcements
    .filter((item) => canReceiveAnnouncement(item, currentUser))
    .forEach((item) => {
      const key = String(item.id);
      if (!readSet.has(key)) {
        readSet.add(key);
        changed = true;
        ids.push(item.id);
      }
    });
  if (changed) {
    saveReadAnnouncementIds(readSet);
    if (USE_AUTH_API && ids.length) {
      apiAnnouncementsRead(ids).catch(() => null);
    }
  }
}

function setBadgeSeverity(element, severity) {
  if (!element) {
    return;
  }
  element.classList.remove(
    "bell-dot--low",
    "bell-dot--medium",
    "bell-dot--high",
    "bell-dot--critical"
  );
  if (!severity) {
    return;
  }
  const key = normalizeAnnouncementSeverity(severity);
  const map = {
    baixa: "bell-dot--low",
    media: "bell-dot--medium",
    alta: "bell-dot--high",
    critica: "bell-dot--critical",
  };
  element.classList.add(map[key] || "bell-dot--low");
}

function updateBellDot() {
  if (!lembretesCount) {
    return;
  }
  const total = reminderUnreadCount + announcementsUnreadCount;
  lembretesCount.textContent = total ? String(total) : "";
  lembretesCount.hidden = total === 0;
  lembretesCount.classList.toggle("is-zero", total === 0);
  if (total > 0) {
    const severity = announcementsUnreadCount ? announcementsUnreadSeverity : "baixa";
    setBadgeSeverity(lembretesCount, severity);
  } else {
    setBadgeSeverity(lembretesCount, null);
  }
}

function renderAnuncios() {
  if (!listaAnuncios || !anunciosVazio) {
    return;
  }
  listaAnuncios.innerHTML = "";
  if (btnNovoAnuncio) {
    btnNovoAnuncio.hidden = !(currentUser && canCreateAnnouncements(currentUser));
  }
  if (btnAnunciosLidos) {
    btnAnunciosLidos.hidden = !(currentUser && canViewAnnouncements(currentUser));
  }
  if (!currentUser) {
    anunciosVazio.hidden = false;
    anunciosVazio.textContent = "Nenhum anúncio não lido.";
    announcementsUnreadCount = 0;
    updateBellDot();
    return;
  }
  if (!canViewAnnouncements(currentUser)) {
    anunciosVazio.hidden = false;
    anunciosVazio.textContent = "Sem permissão para visualizar anúncios.";
    announcementsUnreadCount = 0;
    announcementsUnreadSeverity = "baixa";
    updateBellDot();
    return;
  }
  const readSet = getReadAnnouncementIds();
  const visible = announcements.filter((item) => canReceiveAnnouncement(item, currentUser));
  const unreadVisible = visible.filter((item) => !readSet.has(String(item.id)));
  if (!visible.length || !unreadVisible.length) {
    anunciosVazio.hidden = false;
    anunciosVazio.textContent = visible.length
      ? "Nenhum anúncio não lido."
      : "Nenhum anúncio recente.";
    announcementsUnreadCount = 0;
    announcementsUnreadSeverity = "baixa";
    updateBellDot();
    return;
  }
  anunciosVazio.hidden = true;
  announcementsUnreadCount = unreadVisible.length;
  announcementsUnreadSeverity = unreadVisible.length
    ? getHighestAnnouncementSeverity(unreadVisible)
    : "baixa";

  const limited = unreadVisible.slice(0, 5);
  limited.forEach((item) => {
    const card = document.createElement("div");
    card.className = `announcement-item announcement-item--${item.type}`;
    card.dataset.announcementId = item.id;
    if (!readSet.has(String(item.id))) {
      card.classList.add("is-unread");
    }

    const head = document.createElement("div");
    head.className = "announcement-item__head";
    const title = document.createElement("strong");
    title.textContent = item.title || "Anúncio";
    const tag = document.createElement("span");
    tag.className = `announcement-tag announcement-tag--${item.type}`;
    tag.textContent = getAnnouncementTypeLabel(item.type);
    const severityTag = document.createElement("span");
    severityTag.className = `announcement-severity announcement-severity--${item.severity || "baixa"}`;
    severityTag.textContent = getAnnouncementSeverityLabel(item.severity || "baixa");
    const tags = document.createElement("div");
    tags.className = "announcement-item__tags";
    tags.append(tag, severityTag);
    head.append(title, tags);

    const body = document.createElement("span");
    body.textContent = item.message || "";

    const meta = document.createElement("small");
    const when = item.createdAt ? formatDateTime(parseTimestamp(item.createdAt) || new Date()) : "-";
    const scopeLabel = getAnnouncementScopeLabel(item);
    meta.textContent = `${scopeLabel} • ${when}`;

    card.append(head, body, meta);
    listaAnuncios.append(card);
  });
  updateBellDot();

  if (btnNovoAnuncio) {
    btnNovoAnuncio.hidden = !(currentUser && canCreateAnnouncements(currentUser));
  }
}

function renderAnunciosLidos() {
  if (!listaAnunciosLidos || !anunciosLidosVazio) {
    return;
  }
  listaAnunciosLidos.innerHTML = "";
  if (!currentUser) {
    anunciosLidosVazio.hidden = false;
    return;
  }
  if (!canViewAnnouncements(currentUser)) {
    anunciosLidosVazio.hidden = false;
    anunciosLidosVazio.textContent = "Sem permissão para visualizar anúncios.";
    return;
  }
  const readSet = getReadAnnouncementIds();
  const visible = announcements.filter((item) => canReceiveAnnouncement(item, currentUser));
  const readVisible = visible.filter((item) => readSet.has(String(item.id)));
  if (!readVisible.length) {
    anunciosLidosVazio.hidden = false;
    return;
  }
  anunciosLidosVazio.hidden = true;
  readVisible.slice(0, 20).forEach((item) => {
    const card = document.createElement("div");
    card.className = `announcement-item announcement-item--${item.type} is-read`;
    card.dataset.announcementId = item.id;

    const head = document.createElement("div");
    head.className = "announcement-item__head";
    const title = document.createElement("strong");
    title.textContent = item.title || "Anúncio";
    const tag = document.createElement("span");
    tag.className = `announcement-tag announcement-tag--${item.type}`;
    tag.textContent = getAnnouncementTypeLabel(item.type);
    const severityTag = document.createElement("span");
    severityTag.className = `announcement-severity announcement-severity--${item.severity || "baixa"}`;
    severityTag.textContent = getAnnouncementSeverityLabel(item.severity || "baixa");
    const tags = document.createElement("div");
    tags.className = "announcement-item__tags";
    tags.append(tag, severityTag);
    head.append(title, tags);

    const body = document.createElement("span");
    body.textContent = item.message || "";

    const meta = document.createElement("small");
    const when = item.createdAt ? formatDateTime(parseTimestamp(item.createdAt) || new Date()) : "-";
    const scopeLabel = getAnnouncementScopeLabel(item);
    meta.textContent = `${scopeLabel} • ${when}`;

    card.append(head, body, meta);
    listaAnunciosLidos.append(card);
  });
}

async function apiAnnouncementsList() {
  if (!USE_AUTH_API) {
    return { items: readAnnouncementsStorage() };
  }
  try {
    return await apiRequest("/api/announcements");
  } catch (error) {
    if (shouldFallbackAnnouncements(error)) {
      return { items: readAnnouncementsStorage(), fallback: true };
    }
    throw error;
  }
}

async function apiAnnouncementsCreate(payload) {
  if (!USE_AUTH_API) {
    const list = readAnnouncementsStorage();
    const record = normalizeAnnouncementRecord(payload);
    if (!record) {
      throw new Error("Anúncio inválido.");
    }
    list.unshift(record);
    saveAnnouncementsStorage(list);
    return { item: record, items: list };
  }
  try {
    return await apiRequest("/api/announcements", {
      method: "POST",
      body: JSON.stringify(payload || {}),
    });
  } catch (error) {
    if (shouldFallbackAnnouncements(error)) {
      const list = readAnnouncementsStorage();
      const record = normalizeAnnouncementRecord(payload);
      if (!record) {
        throw new Error("Anúncio inválido.");
      }
      list.unshift(record);
      saveAnnouncementsStorage(list);
      return { item: record, items: list, fallback: true };
    }
    throw error;
  }
}

async function apiAnnouncementsRead(ids = []) {
  if (!USE_AUTH_API) {
    return { ok: true };
  }
  return apiRequest("/api/announcements/read", {
    method: "POST",
    body: JSON.stringify({ ids }),
  });
}

async function apiFeedbackList(projectId = "") {
  if (!USE_AUTH_API) {
    return { items: readJson(getProjectStorageKey(FEEDBACK_KEY), []) };
  }
  const query = projectId ? `?projectId=${encodeURIComponent(projectId)}` : "";
  return apiRequest(`/api/feedbacks${query}`);
}

async function apiFeedbackCreate(payload) {
  if (!USE_AUTH_API) {
    const list = readJson(getProjectStorageKey(FEEDBACK_KEY), []);
    const record = normalizeFeedbackRecord(payload);
    if (!record) {
      throw new Error("Feedback inválido.");
    }
    list.unshift(record);
    writeJson(getProjectStorageKey(FEEDBACK_KEY), list);
    return { item: record, items: list };
  }
  return apiRequest("/api/feedbacks", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiFeedbackRead(ids = []) {
  if (!USE_AUTH_API) {
    return { ok: true };
  }
  return apiRequest("/api/feedbacks/read", {
    method: "POST",
    body: JSON.stringify({ ids }),
  });
}

async function carregarAnuncios(force = false, options = {}) {
  if (!currentUser) {
    announcements = [];
    announcementsLastFetch = 0;
    renderAnuncios();
    return;
  }
  if (!canViewAnnouncements(currentUser)) {
    announcements = [];
    announcementsLastFetch = 0;
    renderAnuncios();
    renderAnunciosLidos();
    return;
  }
  const agora = Date.now();
  if (!force && announcementsLastFetch && agora - announcementsLastFetch < ANNOUNCEMENTS_TTL_MS) {
    renderAnuncios();
    return;
  }
  try {
    const data = await apiAnnouncementsList();
    const list = data && (data.items || data.announcements || data.list);
    announcements = normalizeAnnouncements(list);
    announcementsLastFetch = Date.now();
  } catch (error) {
    announcements = normalizeAnnouncements(readAnnouncementsStorage());
  }
  renderAnuncios();
  if (options.auto) {
    setLastSyncAt(Date.now(), "auto");
  }
  renderAnunciosLidos();
}

function renderAnnouncementProjectOptions() {
  if (!anuncioProjeto) {
    return;
  }
  anuncioProjeto.innerHTML = "";
  availableProjects.forEach((project) => {
    const opt = document.createElement("option");
    opt.value = project.id;
    opt.textContent = getProjectLabel(project);
    anuncioProjeto.append(opt);
  });
  if (activeProjectId) {
    anuncioProjeto.value = activeProjectId;
  }
}

function updateAnnouncementScopeField() {
  if (!anuncioEscopo || !anuncioProjetoField) {
    return;
  }
  const scope = anuncioEscopo.value || "all";
  anuncioProjetoField.hidden = scope !== "project";
  if (scope === "project") {
    renderAnnouncementProjectOptions();
  }
}

function resetAnnouncementDraftImages() {
  announcementDraftImages = [];
  if (anuncioImagens) {
    anuncioImagens.value = "";
  }
  if (anuncioImagensPreview) {
    anuncioImagensPreview.innerHTML = "";
  }
}

function renderAnnouncementDraftImages() {
  if (!anuncioImagensPreview) {
    return;
  }
  anuncioImagensPreview.innerHTML = "";
  if (!announcementDraftImages.length) {
    anuncioImagensPreview.hidden = true;
    return;
  }
  anuncioImagensPreview.hidden = false;
  announcementDraftImages.forEach((image, index) => {
    const card = document.createElement("div");
    card.className = "announcement-image";
    const img = document.createElement("img");
    img.src = image.src;
    img.alt = image.name || "Imagem do anúncio";
    const remove = document.createElement("button");
    remove.type = "button";
    remove.className = "announcement-image__remove";
    remove.textContent = "x";
    remove.addEventListener("click", () => {
      announcementDraftImages.splice(index, 1);
      renderAnnouncementDraftImages();
    });
    card.append(img, remove);
    anuncioImagensPreview.append(card);
  });
}

function readFileAsDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(String(reader.result || ""));
    reader.onerror = () => reject(reader.error || new Error("Falha ao ler imagem."));
    reader.readAsDataURL(file);
  });
}

async function handleAnnouncementImageInput(event) {
  const files = Array.from(event.target.files || []);
  if (!files.length) {
    return;
  }
  const maxFiles = 4;
  const maxSize = 2 * 1024 * 1024;
  const availableSlots = Math.max(0, maxFiles - announcementDraftImages.length);
  if (availableSlots === 0) {
    showAuthToast("Limite de 4 imagens atingido.");
    return;
  }
  const selected = files.slice(0, availableSlots);
  for (const file of selected) {
    if (file.size > maxSize) {
      showAuthToast("Imagem muito grande (máx 2MB).");
      continue;
    }
    try {
      const src = await readFileAsDataUrl(file);
      if (src) {
        announcementDraftImages.push({ src, name: file.name || "" });
      }
    } catch (error) {
      // ignore individual failures
    }
  }
  renderAnnouncementDraftImages();
  event.target.value = "";
}

function openAnnouncementModal() {
  if (!modalAnuncio) {
    return;
  }
  if (!currentUser || !canCreateAnnouncements(currentUser)) {
    showAuthToast("Sem permissão para criar anúncios.");
    return;
  }
  fecharPainelLembretes();
  if (formAnuncio) {
    formAnuncio.reset();
  }
  resetAnnouncementDraftImages();
  if (mensagemAnuncio) {
    mensagemAnuncio.textContent = "";
    mensagemAnuncio.classList.remove("mensagem--erro");
  }
  updateAnnouncementScopeField();
  modalAnuncio.hidden = false;
}

function closeAnnouncementModal() {
  if (!modalAnuncio) {
    return;
  }
  modalAnuncio.hidden = true;
  resetAnnouncementDraftImages();
}

function renderAnnouncementImages(container, images = []) {
  if (!container) {
    return;
  }
  container.innerHTML = "";
  if (!images.length) {
    container.hidden = true;
    return;
  }
  container.hidden = false;
  images.forEach((image) => {
    const card = document.createElement("div");
    card.className = "announcement-image";
    const img = document.createElement("img");
    img.src = image.src;
    img.alt = image.name || "Imagem do anúncio";
    card.append(img);
    container.append(card);
  });
}

function renderAnnouncementReadersList(item) {
  if (!anuncioViewReadsWrap || !anuncioViewReads) {
    return;
  }
  const readers = getAnnouncementReaders(item);
  if (!currentUser || !item || String(item.createdBy || "") !== String(currentUser.id || "")) {
    anuncioViewReadsWrap.hidden = true;
    anuncioViewReads.innerHTML = "";
    return;
  }
  if (!readers.length) {
    anuncioViewReadsWrap.hidden = true;
    anuncioViewReads.innerHTML = "";
    return;
  }
  anuncioViewReadsWrap.hidden = false;
  anuncioViewReads.innerHTML = "";
  readers.forEach((entry) => {
    const chip = document.createElement("span");
    const label = getUserLabel(entry.userId) || entry.userId || "-";
    chip.textContent = label;
    anuncioViewReads.append(chip);
  });
}

function renderAnnouncementView(item) {
  if (!item || !modalAnuncioView) {
    return;
  }
  if (anuncioViewTitulo) {
    anuncioViewTitulo.textContent = item.title || "Anúncio";
  }
  if (anuncioViewTipo) {
    anuncioViewTipo.className = `announcement-tag announcement-tag--${item.type}`;
    anuncioViewTipo.textContent = getAnnouncementTypeLabel(item.type);
  }
  if (anuncioViewSeveridade) {
    const severity = item.severity || "baixa";
    anuncioViewSeveridade.className = `announcement-severity announcement-severity--${severity}`;
    anuncioViewSeveridade.textContent = getAnnouncementSeverityLabel(severity);
  }
  if (anuncioViewMeta) {
    const scopeLabel = getAnnouncementScopeLabel(item);
    const when = item.createdAt
      ? formatDateTime(parseTimestamp(item.createdAt) || new Date())
      : "-";
    const author =
      item.createdByName ||
      getUserLabel(item.createdBy) ||
      getDisplayName(currentUser) ||
      "Sistema";
    anuncioViewMeta.textContent = `${scopeLabel} • ${author} • ${when}`;
  }
  if (anuncioViewMensagem) {
    anuncioViewMensagem.textContent = item.message || "";
  }
  renderAnnouncementImages(anuncioViewImagens, item.images || []);
  renderAnnouncementReadersList(item);
  if (btnAnuncioViewMarkRead) {
    const readSet = getReadAnnouncementIds();
    const isRead = readSet.has(String(item.id));
    const isSender =
      currentUser && item.createdBy && String(item.createdBy) === String(currentUser.id);
    btnAnuncioViewMarkRead.hidden =
      isRead || isSender || !currentUser || !canReceiveAnnouncement(item, currentUser);
  }
}

function openAnnouncementView(item) {
  if (!modalAnuncioView) {
    return;
  }
  if (currentUser && !canViewAnnouncements(currentUser)) {
    showAuthToast("Sem permissão para visualizar anúncios.");
    return;
  }
  fecharPainelLembretes();
  activeAnnouncementView = item;
  renderAnnouncementView(item);
  modalAnuncioView.hidden = false;
}

function closeAnnouncementView() {
  if (!modalAnuncioView) {
    return;
  }
  modalAnuncioView.hidden = true;
  activeAnnouncementView = null;
}

function openAnnouncementsReadModal() {
  if (!modalAnunciosLidos) {
    return;
  }
  if (currentUser && !canViewAnnouncements(currentUser)) {
    showAuthToast("Sem permissão para visualizar anúncios.");
    return;
  }
  fecharPainelLembretes();
  renderAnunciosLidos();
  modalAnunciosLidos.hidden = false;
}

function closeAnnouncementsReadModal() {
  if (!modalAnunciosLidos) {
    return;
  }
  modalAnunciosLidos.hidden = true;
}

function renderLembretes() {
  if (!listaLembretes || !lembretesVazio) {
    return;
  }
  listaLembretes.innerHTML = "";
  const hoje = startOfDay(new Date());
  const readSet = getReadNotificationIds();
  const scopedManutencoes = activeProjectId
    ? manutencoes.filter(
        (item) => item && (!item.projectId || item.projectId === activeProjectId)
      )
    : [];

  const proximos = scopedManutencoes
    .filter((item) => item.status === "agendada" || item.status === "liberada")
    .map((item) => {
      const data = parseDate(item.data);
      return { item, data };
    })
    .filter((entrada) => entrada.data)
    .map((entrada) => {
      const diff = diffInDays(hoje, entrada.data);
      return { ...entrada, diff };
    })
    .filter((entrada) => entrada.diff >= 0 && entrada.diff <= reminderDays)
    .sort((a, b) => a.data - b.data);

  reminderTotalCount = proximos.length;
  reminderUnreadCount = proximos.filter(({ item }) => !readSet.has(String(item.id))).length;

  if (lembretesCount) {
    const ids = new Set(proximos.map(({ item }) => String(item.id)));
    let changed = false;
    readSet.forEach((id) => {
      if (!ids.has(id)) {
        readSet.delete(id);
        changed = true;
      }
    });
    if (changed) {
      saveReadNotificationIds(readSet);
    }
    reminderTotalCount = proximos.length;
    const unreadTotal = proximos.filter(({ item }) => !readSet.has(String(item.id))).length;
    reminderUnreadCount = unreadTotal;
    updateBellDot();
    if (lembretesCount.id !== "bellDot") {
      lembretesCount.textContent = unreadTotal + announcementsUnreadCount;
      lembretesCount.hidden = unreadTotal + announcementsUnreadCount === 0;
      lembretesCount.classList.toggle("is-zero", unreadTotal + announcementsUnreadCount === 0);
    }
  }

  if (proximos.length === 0) {
    lembretesVazio.hidden = false;
    updateBellDot();
    return;
  }

  lembretesVazio.hidden = true;
  proximos.forEach(({ item, data, diff }) => {
    const card = document.createElement("div");
    card.className = "lembrete-item";
    card.dataset.maintenanceId = item.id;

    const titulo = document.createElement("strong");
    titulo.textContent = item.titulo;

    const detalhe = document.createElement("span");
    detalhe.textContent = `${item.local} - ${formatDate(data)} (${formatReminder(diff)})`;

    card.append(titulo, detalhe);
    listaLembretes.append(card);
  });
  updateBellDot();
}

function criarBotaoAcao(texto, acao, perigo = false) {
  const botao = document.createElement("button");
  botao.type = "button";
  botao.textContent = texto;
  botao.dataset.action = acao;
  botao.className = `btn btn--ghost btn--small${perigo ? " btn--danger" : ""}`;
  return botao;
}

function criarCardManutencao(item, permissoes, options = {}) {
  const data = parseDate(item.data);
  const hoje = startOfDay(new Date());
  const diff = data ? diffInDays(hoje, data) : null;
  const liberacao = getLiberacao(item);
  const lockInfo = getReleaseLockInfo(item, data, hoje);
  const state = getMaintenanceState(item, data, hoje);
  const statusNormalized = normalizeMaintenanceStatus(item.status);

  const card = document.createElement("article");
  card.className = `manutencao-item status-${statusNormalized} state-${state}`;
  card.dataset.id = item.id;
  card.dataset.maintenanceId = item.id;
  card.id = `maintenance-${item.id}`;

  const rail = document.createElement("div");
  rail.className = "status-rail";
  rail.setAttribute("aria-hidden", "true");

  const header = document.createElement("div");
  header.className = "manutencao-header";

  const info = document.createElement("div");
  info.className = "manutencao-info";

  const titulo = document.createElement("h3");
  titulo.textContent = item.titulo;

  const meta = document.createElement("p");
  meta.className = "meta";
  const dataTexto = data ? formatDate(data) : "data indefinida";
  meta.textContent = `${item.local} - ${dataTexto}`;

  const equipamentoLinha = document.createElement("p");
  equipamentoLinha.className = "submeta submeta--equip";
  const equipamentoLabel = getMaintenanceEquipamentoLabel(item);
  equipamentoLinha.textContent = `Equipamento: ${
    equipamentoLabel && equipamentoLabel !== "-" ? equipamentoLabel : "não informado"
  }`;

  const statusInfo = document.createElement("p");
  statusInfo.className = "submeta";
  if (statusNormalized === "agendada" || statusNormalized === "liberada") {
    statusInfo.textContent = formatUpcoming(diff);
  } else if (statusNormalized === "backlog") {
    statusInfo.textContent = formatOverdue(diff);
  } else if (statusNormalized === "em_execucao") {
    const inicio = parseTimestamp(item.executionStartedAt);
    statusInfo.textContent = inicio
      ? `Em execução desde ${formatDateTime(inicio)}`
      : "Em execução";
  } else if (statusNormalized === "encerramento") {
    statusInfo.textContent = "Encerramento em preenchimento";
  } else if (statusNormalized === "concluida" && item.doneAt) {
    const feitoEm = parseTimestamp(item.doneAt);
    if (feitoEm) {
      statusInfo.textContent = `concluída em ${formatDate(startOfDay(feitoEm))}`;
    }
  }

  const autoria = document.createElement("p");
  autoria.className = "submeta";
  const ultimaAcao = getUltimaAcao(item);
  if (ultimaAcao) {
    const label = ACTION_LABELS[ultimaAcao.action] || ultimaAcao.action;
    const dataAcao = parseTimestamp(ultimaAcao.timestamp);
    autoria.textContent = `Última ação: ${label} em ${
      dataAcao ? formatDateTime(dataAcao) : "-"
    } por ${getUserLabel(ultimaAcao.userId)}`;
  } else {
    autoria.textContent = `Criada por ${getUserLabel(item.createdBy)}`;
  }

  info.append(titulo, meta, equipamentoLinha);
  if (statusInfo.textContent) {
    info.append(statusInfo);
  }
  if (lockInfo) {
    const lockLine = document.createElement("p");
    lockLine.className = "submeta submeta--lock";
    const lockIcon = document.createElement("span");
    lockIcon.className = "lock-icon";
    lockIcon.innerHTML = LOCK_ICON_SVG;
    const lockText = document.createElement("span");
    lockText.textContent = `Trancada - libera em ${formatDate(lockInfo.date)}`;
    lockLine.append(lockIcon, lockText);
    info.append(lockLine);
  }
  if (statusNormalized === "liberada") {
    const liberadaInfo = document.createElement("p");
    liberadaInfo.className = "submeta";
    liberadaInfo.textContent = "Liberada para iniciar";
    info.append(liberadaInfo);
  }
  if (
    (statusNormalized === "em_execucao" || statusNormalized === "encerramento") &&
    liberacao
  ) {
    const osLinha = document.createElement("p");
    osLinha.className = "submeta";
    osLinha.textContent = `OS: ${liberacao.osNumero || "-"}`;
    info.append(osLinha);
    const participantesLinha = document.createElement("p");
    participantesLinha.className = "submeta";
    participantesLinha.textContent = `Participantes: ${getParticipantesLabel(
      liberacao.participantes
    )}`;
    info.append(participantesLinha);
  }
  info.append(autoria);

  if (statusNormalized === "backlog" && item.backlogMotivo && item.backlogMotivo.motivo) {
    const motivo = document.createElement("p");
    motivo.className = "submeta";
    const motivoData = parseTimestamp(item.backlogMotivo.registradoEm);
    const dataTexto = motivoData ? ` em ${formatDateTime(motivoData)}` : "";
    motivo.textContent = `Motivo não executada: ${item.backlogMotivo.motivo}${dataTexto}`;
    info.append(motivo);
  }
  if (statusNormalized === "backlog" && item.backlogMotivo && item.backlogMotivo.observacao) {
    const obs = document.createElement("p");
    obs.className = "submeta";
    obs.textContent = `Obs.: ${item.backlogMotivo.observacao}`;
    info.append(obs);
  }

  const ultimoReagendamento = getUltimoReagendamento(item);
  if (ultimoReagendamento && ultimoReagendamento.detalhes && ultimoReagendamento.detalhes.motivo) {
    const motivo = document.createElement("p");
    motivo.className = "submeta";
    motivo.textContent = `Motivo do último reagendamento: ${ultimoReagendamento.detalhes.motivo}`;
    info.append(motivo);
  }
  const rescheduleCount = getRescheduleCount(item);
  if (rescheduleCount >= MAX_REAGENDAMENTOS) {
    const alerta = document.createElement("p");
    alerta.className = "submeta submeta--alert";
    alerta.textContent = `Reagendada ${rescheduleCount}x`;
    info.append(alerta);
  }

  if (item.observacao || item.observacaoHtml) {
    const obs = document.createElement("div");
    if (item.observacaoHtml) {
      obs.className = "obs obs--rich";
      obs.innerHTML = sanitizeRichText(item.observacaoHtml);
    } else {
      obs.className = "obs";
      obs.textContent = item.observacao;
    }
    info.append(obs);
  }

  const badge = document.createElement("span");
  const statusBase =
    statusNormalized === "concluida"
      ? "concluida"
      : statusNormalized === "em_execucao"
        ? "em_execucao"
      : statusNormalized === "encerramento"
        ? "encerramento"
      : statusNormalized === "backlog" || (diff !== null && diff < 0)
        ? "backlog"
      : statusNormalized === "liberada"
        ? "liberada"
      : diff === 0
        ? "hoje"
        : "agendada";
  const label =
    statusBase === "concluida"
      ? STATUS_LABELS.concluida
      : statusBase === "em_execucao"
        ? STATUS_LABELS.em_execucao
      : statusBase === "encerramento"
        ? STATUS_LABELS.encerramento
      : statusBase === "backlog"
        ? "BACKLOG"
      : statusBase === "liberada"
        ? STATUS_LABELS.liberada
      : statusBase === "hoje"
        ? "Vence hoje"
      : STATUS_LABELS.agendada;
  badge.className = `status status--${statusBase}`;
  badge.textContent = label;

  const stateBadge = document.createElement("span");
  stateBadge.className = `status-flag status-flag--${state}`;
  const stateLabel = MAINTENANCE_STATE_LABELS[state] || "PLANEJADA";
  stateBadge.textContent = stateLabel;

  const statusGroup = document.createElement("div");
  statusGroup.className = "status-group";
  const execucaoRegistrada = hasExecucaoRegistradaCompleta(item);
  const esconderEmExecucao =
    execucaoRegistrada && statusBase === "em_execucao" && statusNormalized !== "concluida";
  if (!esconderEmExecucao) {
    statusGroup.append(badge);
  }
  if (execucaoRegistrada && statusNormalized !== "concluida") {
    const execBadge = document.createElement("span");
    execBadge.className = "status status--execucao-registrada";
    execBadge.textContent = "Execução registrada";
    statusGroup.append(execBadge);
  }
  if (
    statusNormalized !== "concluida" &&
    statusNormalized !== "cancelada" &&
    (!badge.textContent || badge.textContent !== stateLabel)
  ) {
    statusGroup.append(stateBadge);
  }

  header.append(info, statusGroup);

  const actions = document.createElement("div");
  actions.className = "manutencao-actions";
  const allowed = options.allowedActions || null;
  const permite = (key) => {
    const base =
      key === "register" || key === "finish" || key === "release" || key === "cancel_start"
        ? permissoes.execute
        : permissoes[key];
    return (allowed ? allowed.includes(key) : true) && base;
  };

  const liberacaoOk = isLiberacaoOk(item);
  const podeEditar =
    statusNormalized === "agendada" ||
    statusNormalized === "backlog" ||
    statusNormalized === "liberada" ||
    (statusNormalized === "concluida" && canEditConcludedMaintenance(currentUser));
  if (permite("edit") && podeEditar) {
    actions.append(criarBotaoAcao("Editar", "edit"));
  }

  if (permite("note") && podeEditar) {
    actions.append(criarBotaoAcao("Observação", "note"));
  }

  if (statusNormalized === "agendada" || statusNormalized === "liberada") {
    if (permite("execute")) {
      const action = liberacaoOk ? "execute" : "release";
      const actionLabel = liberacaoOk ? "Iniciar execução" : "Liberar execução";
      const botao = criarBotaoAcao(actionLabel, action);
      if (action === "release" && lockInfo && !lockInfo.canOverride) {
        botao.disabled = true;
        botao.classList.add("is-disabled");
        botao.title = `Trancada - libera em ${formatDate(lockInfo.date)}`;
      }
      actions.append(botao);
    }
    if (permite("reschedule") && !isDailySubstationInspection(item)) {
      actions.append(criarBotaoAcao("Reagendar", "reschedule"));
    }
  } else if (statusNormalized === "backlog") {
    if (permite("backlog_reason")) {
      actions.append(criarBotaoAcao("Motivo não executada", "backlog_reason"));
    }
    if (permite("reschedule") && !isDailySubstationInspection(item)) {
      actions.append(criarBotaoAcao("Reagendar", "reschedule"));
    }
  } else if (statusNormalized === "em_execucao") {
    if (permite("execute") && !execucaoRegistrada) {
      actions.append(criarBotaoAcao("Registrar execução", "register"));
    }
    if (permite("execute") && !execucaoRegistrada) {
      actions.append(criarBotaoAcao("Cancelar início", "cancel_start"));
    }
    if (permite("execute") && execucaoRegistrada) {
      actions.append(criarBotaoAcao("Concluir manutenção", "finish"));
    }
  } else if (statusNormalized === "encerramento") {
    if (permite("execute") && !execucaoRegistrada) {
      actions.append(criarBotaoAcao("Registrar execução", "register"));
    }
    if (permite("execute") && execucaoRegistrada) {
      actions.append(criarBotaoAcao("Concluir manutenção", "finish"));
    }
  } else if (statusNormalized === "concluida") {
    if (permite("reopen")) {
      actions.append(criarBotaoAcao("Reabrir", "reopen"));
    }
  }

  if (permite("history")) {
    actions.append(criarBotaoAcao("Histórico", "history"));
  }

  const podeExcluir = canDeleteMaintenance(currentUser);
  if (
    podeExcluir &&
    statusNormalized !== "em_execucao" &&
    statusNormalized !== "encerramento"
  ) {
    actions.append(criarBotaoAcao("Excluir", "remove", true));
  }

  card.append(rail, header);
  if (actions.childElementCount > 0) {
    card.append(actions);
  }
  return card;
}

function renderListaStatus(status, container, emptyEl, options = {}) {
  if (!container || !emptyEl) {
    return;
  }
  container.innerHTML = "";
  const permissoes = {
    edit: can("edit"),
    note: can("edit"),
    remove: can("remove"),
    reschedule: can("reschedule"),
    execute: can("complete"),
    backlog_reason: can("edit"),
    reopen: canReopenMaintenance(currentUser),
    history: true,
  };
  const items = manutencoes
    .filter((item) => normalizeMaintenanceStatus(item && item.status) === status)
    .sort((a, b) => {
      const dataA = parseDate(a.data);
      const dataB = parseDate(b.data);
      if (status === "concluida") {
        return (getTimeValue(b.doneAt) || 0) - (getTimeValue(a.doneAt) || 0);
      }
      if (dataA && dataB) {
        return dataA - dataB;
      }
      if (dataA) {
        return -1;
      }
      if (dataB) {
        return 1;
      }
      return 0;
    });

  const limit = options.limit || items.length;
  const allowedActions = options.allowedActions || null;
  items.slice(0, limit).forEach((item) => {
    container.append(criarCardManutencao(item, permissoes, { allowedActions }));
  });

  emptyEl.hidden = items.length > 0;
}

function renderProgramacao() {
  if (!listaAgendadas || !listaAgendadasVazia) {
    return;
  }
  listaAgendadas.innerHTML = "";
  renderAlertaProgramacao();

  const hoje = startOfDay(new Date());
  const filtroStatus = filtroProgramacaoStatus ? filtroProgramacaoStatus.value : "";
  const incluirConcluidas = filtroStatus === "concluida";
  const existentes = manutencoes.filter(
    (item) =>
      item &&
      (() => {
        const status = normalizeMaintenanceStatus(item.status);
        return (
          status === "agendada" ||
          status === "liberada" ||
          status === "backlog" ||
          status === "em_execucao" ||
          status === "encerramento" ||
          (incluirConcluidas && status === "concluida")
        );
      })()
  );

  if (filtroProgramacaoSubestacao) {
    const atual = filtroProgramacaoSubestacao.value;
    const subestacoes = Array.from(
      new Set([...getSubestacoesBase(), ...existentes.map((item) => item.local).filter(Boolean)])
    ).sort((a, b) => a.localeCompare(b, "pt-BR"));
    filtroProgramacaoSubestacao.innerHTML = "";
    const optionAll = document.createElement("option");
    optionAll.value = "";
    optionAll.textContent = "Todas";
    filtroProgramacaoSubestacao.append(optionAll);
    subestacoes.forEach((nome) => {
      const option = document.createElement("option");
      option.value = nome;
      option.textContent = nome;
      filtroProgramacaoSubestacao.append(option);
    });
    if (atual && subestacoes.includes(atual)) {
      filtroProgramacaoSubestacao.value = atual;
    }
  }

  const filtroSubestacao = filtroProgramacaoSubestacao ? filtroProgramacaoSubestacao.value : "";
  const filtroPeriodo = filtroProgramacaoPeriodo ? filtroProgramacaoPeriodo.value : "";

  const filtrados = existentes.filter((item) => {
    const status = normalizeMaintenanceStatus(item.status);
    if (filtroSubestacao && item.local !== filtroSubestacao) {
      return false;
    }
    const info = status === "concluida"
      ? (() => {
          const dataConclusao = getItemConclusaoDate(item) || parseDate(item.data);
          if (!dataConclusao) {
            return null;
          }
          return { data: startOfDay(dataConclusao), diff: diffInDays(hoje, startOfDay(dataConclusao)) };
        })()
      : getDateInfo(item, hoje);
    const diff = info ? info.diff : null;

    if (filtroStatus === "backlog") {
      if (
        !(
          status === "backlog" ||
          (status !== "em_execucao" && status !== "encerramento" && diff !== null && diff < 0)
        )
      ) {
        return false;
      }
    } else if (filtroStatus === "liberada") {
      if (status !== "liberada") {
        return false;
      }
    } else if (filtroStatus === "em_execucao") {
      if (status !== "em_execucao" || hasExecucaoRegistradaCompleta(item)) {
        return false;
      }
    } else if (filtroStatus === "encerramento") {
      if (status !== "encerramento") {
        return false;
      }
    } else if (filtroStatus === "execucao_registrada") {
      if (
        !(
          hasExecucaoRegistradaCompleta(item) &&
          (status === "em_execucao" || status === "encerramento")
        )
      ) {
        return false;
      }
    } else if (filtroStatus === "concluida") {
      if (status !== "concluida") {
        return false;
      }
    } else if (filtroStatus === "hoje") {
      if (diff !== 0) {
        return false;
      }
    } else if (filtroStatus === "agendada") {
      if (
        (status !== "agendada" && status !== "liberada") ||
        diff === null ||
        diff < 1
      ) {
        return false;
      }
    }

    if (filtroPeriodo) {
      const data = info ? info.data : null;
      if (!data) {
        return false;
      }
      if (filtroPeriodo === "hoje") {
        if (diff !== 0) {
          return false;
        }
      } else if (filtroPeriodo === "semana") {
        if (diff === null || diff < 0 || diff > 6) {
          return false;
        }
      } else if (filtroPeriodo === "mes") {
        const base = startOfDay(data);
        if (base.getMonth() !== hoje.getMonth() || base.getFullYear() !== hoje.getFullYear()) {
          return false;
        }
      }
    }

    return true;
  });

  if (!filtrados.length) {
    listaAgendadasVazia.textContent = "Nenhuma manutenção encontrada.";
    listaAgendadasVazia.hidden = false;
    return;
  }

  const getRank = (state) => {
    if (state === "released") {
      return 0;
    }
    if (state === "overdue") {
      return 1;
    }
    return 2;
  };

  const ordenados = filtrados.sort((a, b) => {
    const dataA = parseDate(a.data);
    const dataB = parseDate(b.data);
    const stateA = getMaintenanceState(a, dataA, hoje);
    const stateB = getMaintenanceState(b, dataB, hoje);
    const rankA = getRank(stateA);
    const rankB = getRank(stateB);
    if (rankA !== rankB) {
      return rankA - rankB;
    }
    if (dataA && dataB) {
      return dataA - dataB;
    }
    if (dataA) {
      return -1;
    }
    if (dataB) {
      return 1;
    }
    const createdA = getTimeValue(a.createdAt) || 0;
    const createdB = getTimeValue(b.createdAt) || 0;
    if (createdA !== createdB) {
      return createdA - createdB;
    }
    return String(a.id || "").localeCompare(String(b.id || ""), "pt-BR", {
      numeric: true,
      sensitivity: "base",
    });
  });

  const permissoes = {
    edit: can("edit"),
    note: can("edit"),
    remove: can("remove"),
    reschedule: can("reschedule"),
    execute: can("complete"),
    backlog_reason: can("edit"),
    reopen: canReopenMaintenance(currentUser),
    history: true,
  };

  ordenados.forEach((item) => {
    listaAgendadas.append(
      criarCardManutencao(item, permissoes, {
        allowedActions: [
          "edit",
          "release",
          "execute",
          "cancel_start",
          "reschedule",
          "register",
          "finish",
          "reopen",
          "remove",
          "history",
          "backlog_reason",
        ],
      })
    );
  });

  listaAgendadasVazia.textContent = "Nenhuma manutenção agendada.";
  listaAgendadasVazia.hidden = true;
}

function renderListaCustom(items, container, emptyEl, allowedActions) {
  if (!container || !emptyEl) {
    return;
  }
  container.innerHTML = "";
  const permissoes = {
    edit: can("edit"),
    note: can("edit"),
    remove: can("remove"),
    reschedule: can("reschedule"),
    execute: can("complete"),
    backlog_reason: can("edit"),
    reopen: canReopenMaintenance(currentUser),
    history: true,
  };
  items.forEach((item) => {
    container.append(criarCardManutencao(item, permissoes, { allowedActions }));
  });
  emptyEl.hidden = items.length > 0;
}

function renderExecucao() {
  if (!listaExecucaoHoje || !listaExecucaoVencidas || !listaExecucaoCriticas) {
    return;
  }
  const hoje = startOfDay(new Date());

  const agendadasHoje = manutencoes
    .filter((item) => item.status === "agendada" || item.status === "liberada")
    .map((item) => {
      const info = getDateInfo(item, hoje);
      return info ? { item, ...info } : null;
    })
    .filter((entry) => entry && entry.diff === 0)
    .map((entry) => entry.item);

  const vencidasInfo = manutencoes
    .filter((item) => item.status === "backlog")
    .map((item) => {
      const info = getDateInfo(item, hoje);
      return info ? { item, ...info } : null;
    })
    .filter(Boolean)
    .sort((a, b) => a.diff - b.diff);

  const vencidas = vencidasInfo.map((entry) => entry.item);
  const criticas = vencidasInfo.filter((entry) => entry.diff <= -3).map((entry) => entry.item);

  renderListaCustom(agendadasHoje, listaExecucaoHoje, listaExecucaoHojeVazia, [
    "note",
    "release",
    "execute",
    "reschedule",
    "history",
    "backlog_reason",
  ]);
  renderListaCustom(vencidas, listaExecucaoVencidas, listaExecucaoVencidasVazia, [
    "note",
    "release",
    "execute",
    "reschedule",
    "history",
    "backlog_reason",
  ]);
  renderListaCustom(criticas, listaExecucaoCriticas, listaExecucaoCriticasVazia, [
    "note",
    "release",
    "execute",
    "reschedule",
    "history",
    "backlog_reason",
  ]);
}

function getRelatorioItemDate(item) {
  return (
    parseAnyDate(item && item.doneAt) ||
    parseAnyDate(item && item.data) ||
    parseAnyDate(item && item.createdAt) ||
    null
  );
}

function getRelatorioResponsavel(item) {
  const id =
    getExecutadoPorId(item) ||
    item.doneBy ||
    item.responsavel ||
    item.createdBy ||
    item.updatedBy ||
    "";
  if (item.responsavel && typeof item.responsavel === "string") {
    return item.responsavel;
  }
  return getUserLabel(id);
}

function mapRelatorioStatusFiltro(valor) {
  if (!valor) {
    return null;
  }
  if (valor === "concluido") {
    return ["concluida"];
  }
  if (valor === "em-andamento") {
    return ["em_execucao", "executando"];
  }
  if (valor === "pendente") {
    return ["agendada", "backlog", "liberada", "planejada"];
  }
  return null;
}

function filtrarRelatorioLista(lista, filtros) {
  return lista.filter((item) => {
    const baseDate = getRelatorioItemDate(item);
    if (filtros.start && filtros.end && baseDate) {
      const dia = startOfDay(baseDate);
      if (!inRange(dia, filtros.start, filtros.end)) {
        return false;
      }
    }
    if (filtros.status) {
      if (!filtros.status.includes(item.status)) {
        return false;
      }
    }
    if (filtros.tipo) {
      const categoria = (item.categoria || "").toLowerCase();
      if (categoria !== filtros.tipo) {
        return false;
      }
    }
    if (filtros.responsavel) {
      const responsavel = getRelatorioResponsavel(item);
      if (responsavel !== filtros.responsavel) {
        return false;
      }
    }
    return true;
  });
}

function contarEvidencias(item) {
  let total = 0;
  const grupos = [];
  if (Array.isArray(item.evidencias)) {
    grupos.push(item.evidencias);
  }
  if (item.registroExecucao && Array.isArray(item.registroExecucao.evidencias)) {
    grupos.push(item.registroExecucao.evidencias);
  }
  if (item.conclusao && Array.isArray(item.conclusao.evidencias)) {
    grupos.push(item.conclusao.evidencias);
  }
  if (Array.isArray(item.anexos)) {
    grupos.push(item.anexos);
  }
  grupos.forEach((grupo) => {
    total += grupo.length;
  });
  return total;
}

function atualizarResumoRelatorios(lista) {
  if (!relatorioResumoTotal || !relatorioResumoConcluidas) {
    return;
  }
  const concluidas = lista.filter((item) => item.status === "concluida");
  const criticos = lista.filter(
    (item) => item.critico || (item.prioridade || "").toLowerCase() === "critica"
  );
  const evidencias = lista.reduce((acc, item) => acc + contarEvidencias(item), 0);
  const pontuais = concluidas.filter((item) => {
    const data = parseDate(item.data);
    const doneAt = parseTimestamp(item.doneAt);
    if (!data || !doneAt) {
      return false;
    }
    return startOfDay(doneAt) <= startOfDay(data);
  });
  const sla = concluidas.length ? Math.round((pontuais.length / concluidas.length) * 100) : 0;

  relatorioResumoTotal.textContent = String(lista.length);
  relatorioResumoConcluidas.textContent = `${concluidas.length} concluídas`;
  if (relatorioResumoCriticos) {
    relatorioResumoCriticos.textContent = String(criticos.length);
  }
  if (relatorioResumoAlertas) {
    relatorioResumoAlertas.textContent = criticos.length ? "Alertas priorizados" : "Sem alertas";
  }
  if (relatorioResumoEvidencias) {
    relatorioResumoEvidencias.textContent = String(evidencias);
  }
  if (relatorioResumoEvidenciasLabel) {
    relatorioResumoEvidenciasLabel.textContent = "Fotos, PDFs e registros";
  }
  if (relatorioResumoSla) {
    relatorioResumoSla.textContent = `${sla}%`;
  }
  if (relatorioResumoSlaLabel) {
    relatorioResumoSlaLabel.textContent = "Conformidade no prazo";
  }
}

function atualizarFiltroResponsavel() {
  if (!relatorioResponsavelFiltro) {
    return;
  }
  const atual = relatorioResponsavelFiltro.value;
  const valores = new Set();
  manutencoes.forEach((item) => {
    const responsavel = getRelatorioResponsavel(item);
    if (responsavel && responsavel !== "-") {
      valores.add(responsavel);
    }
  });
  relatorioResponsavelFiltro.innerHTML = "";
  const optAll = document.createElement("option");
  optAll.value = "";
  optAll.textContent = "Todas as equipes";
  relatorioResponsavelFiltro.append(optAll);
  Array.from(valores)
    .sort()
    .forEach((responsavel) => {
      const opt = document.createElement("option");
      opt.value = responsavel;
      opt.textContent = responsavel;
      relatorioResponsavelFiltro.append(opt);
    });
  if (atual && Array.from(relatorioResponsavelFiltro.options).some((opt) => opt.value === atual)) {
    relatorioResponsavelFiltro.value = atual;
  }
}

function getRelatorioFiltros() {
  const dias = relatorioPeriodoFiltro ? Number(relatorioPeriodoFiltro.value) : 30;
  const hoje = startOfDay(new Date());
  const inicio = addDays(hoje, -(Math.max(dias, 1) - 1));
  const statusValores = mapRelatorioStatusFiltro(
    relatorioStatusFiltro ? relatorioStatusFiltro.value : ""
  );
  return {
    start: inicio,
    end: hoje,
    status: statusValores,
    responsavel: relatorioResponsavelFiltro ? relatorioResponsavelFiltro.value : "",
    tipo: relatorioTipoFiltro ? relatorioTipoFiltro.value : "",
  };
}

function renderRelatorios() {
  if (!listaRelatorios || !listaRelatoriosVazia) {
    return;
  }
  atualizarFiltroResponsavel();
  const filtros = getRelatorioFiltros();
  const filtrados = filtrarRelatorioLista(manutencoes, filtros);
  atualizarResumoRelatorios(filtrados);
  listaRelatorios.innerHTML = "";
  const concluidas = filtrados
    .filter((item) => item.status === "concluida")
    .sort((a, b) => (getTimeValue(b.doneAt) || 0) - (getTimeValue(a.doneAt) || 0));

  if (concluidas.length === 0) {
    listaRelatoriosVazia.hidden = false;
    return;
  }
  listaRelatoriosVazia.hidden = true;

  concluidas.forEach((item) => {
    const card = document.createElement("div");
    card.className = "report-item";
    card.dataset.id = item.id;

    const info = document.createElement("div");
    const titulo = document.createElement("strong");
    titulo.textContent = item.titulo;
    const meta = document.createElement("p");
    meta.className = "meta";
    const data = parseDate(item.data);
    const doneAt = parseTimestamp(item.doneAt);
    const dataReferencia = doneAt
      ? formatDate(doneAt)
      : data
        ? formatDate(data)
        : "data indefinida";
    meta.textContent = `${item.local} - ${dataReferencia}`;
    info.append(titulo, meta);

    const actions = document.createElement("div");
    actions.className = "report-actions";
    const btnVer = document.createElement("button");
    btnVer.type = "button";
    btnVer.className = "btn btn--ghost btn--small";
    btnVer.dataset.action = "open-report";
    btnVer.textContent = "Ver relatório";
    actions.append(btnVer);

    card.append(info, actions);
    listaRelatorios.append(card);
  });
}

function getPeriodoFiltro(value) {
  const dias = Number(value) || 30;
  const fim = startOfDay(new Date());
  const inicio = addDays(fim, -(Math.max(dias, 1) - 1));
  return { inicio, fim };
}

function getProjetoLabel(item) {
  return item.local || item.projeto || item.projectKey || "Sem projeto";
}

function formatResponsavelText(value) {
  const text = String(value || "").trim();
  if (!text) {
    return "-";
  }
  if (text.startsWith("team:") || text.startsWith("time:")) {
    const name = text.slice(5).trim();
    return name || "Time";
  }
  return text;
}

function getResponsavelLabel(item) {
  const id = getExecutadoPorId(item) || item.doneBy || item.createdBy || "";
  return getUserLabel(id) || "Sistema";
}

function contarDocsItem(item) {
  const docs = getItemDocs(item) || {};
  const critico = isItemCritico(item);
  return {
    apr: docs.apr ? 1 : 0,
    os: docs.os ? 1 : 0,
    pte: docs.pte ? 1 : 0,
    pt: docs.pt && critico ? 1 : 0,
  };
}

function calcPercent(value, total) {
  if (!total) {
    return 0;
  }
  return Math.round((value / total) * 100);
}

function getPerfSlaClass(value) {
  if (value >= 90) {
    return "perf-badge--ok";
  }
  if (value >= 75) {
    return "perf-badge--warn";
  }
  return "perf-badge--danger";
}

function getPerfBacklogClass(value) {
  if (value <= 10) {
    return "perf-badge--ok";
  }
  if (value <= 25) {
    return "perf-badge--warn";
  }
  return "perf-badge--danger";
}

function getPerfCriticalClass(value) {
  if (!value) {
    return "perf-badge--ok";
  }
  if (value <= 2) {
    return "perf-badge--warn";
  }
  return "perf-badge--danger";
}

function clampPercent(value) {
  if (!Number.isFinite(value)) {
    return 0;
  }
  return Math.max(0, Math.min(100, Math.round(value)));
}

function setBadgeState(badge, className, label) {
  if (!badge) {
    return;
  }
  badge.classList.remove("badge--ok", "badge--warn", "badge--danger");
  if (className) {
    badge.classList.add(className);
  }
  if (label) {
    badge.textContent = label;
  }
}

function setProgressVariant(progress, variant) {
  if (!progress) {
    return;
  }
  progress.classList.remove("progress--warn", "progress--cool");
  if (variant) {
    progress.classList.add(variant);
  }
}

function getExecucaoDuracaoMin(item) {
  if (item && item.conclusao && Number.isFinite(item.conclusao.duracaoMin)) {
    return item.conclusao.duracaoMin;
  }
  const inicio = getItemInicioExecucaoDate(item);
  const fim = getItemFimExecucaoDate(item);
  if (!inicio || !fim) {
    return null;
  }
  const diff = Math.round((fim - inicio) / 60000);
  if (!Number.isFinite(diff) || diff < 0) {
    return null;
  }
  return diff;
}

function calcularMediaDuracao(items) {
  const duracoes = items
    .map((item) => getExecucaoDuracaoMin(item))
    .filter((value) => Number.isFinite(value));
  if (!duracoes.length) {
    return { media: null, duracoes };
  }
  const total = duracoes.reduce((acc, value) => acc + value, 0);
  return { media: total / duracoes.length, duracoes };
}

function getReopenEvents() {
  if (!auditLog || !auditLog.length) {
    return [];
  }
  const grouped = new Map();
  auditLog.forEach((entry) => {
    if (!entry || !entry.manutencaoId) {
      return;
    }
    const time = parseTimestamp(entry.timestamp);
    if (!time) {
      return;
    }
    if (!grouped.has(entry.manutencaoId)) {
      grouped.set(entry.manutencaoId, []);
    }
    grouped.get(entry.manutencaoId).push({ action: entry.action, time });
  });
  const events = [];
  grouped.forEach((entries) => {
    entries.sort((a, b) => a.time - b.time);
    let lastComplete = null;
    entries.forEach((entry) => {
      if (entry.action === "complete") {
        lastComplete = entry.time;
        return;
      }
      if (entry.action === "execute" && lastComplete && entry.time > lastComplete) {
        events.push(entry.time);
        lastComplete = null;
      }
    });
  });
  return events;
}

function renderDesempenho() {
  if (
    !perfExecProgressValue &&
    !perfSlaProgressValue &&
    !perfReopenProgressValue
  ) {
    return;
  }
  const periodo = getPeriodoFiltro("30");
  const semana = getPeriodoFiltro("7");
  const concluidasPeriodo = manutencoes.filter((item) => {
    if (item.status !== "concluida") {
      return false;
    }
    const concluidaEm = getItemConclusaoDate(item);
    if (!concluidaEm) {
      return false;
    }
    return inRange(startOfDay(concluidaEm), periodo.inicio, periodo.fim);
  });
  const concluidasSemana = manutencoes.filter((item) => {
    if (item.status !== "concluida") {
      return false;
    }
    const concluidaEm = getItemConclusaoDate(item);
    if (!concluidaEm) {
      return false;
    }
    return inRange(startOfDay(concluidaEm), semana.inicio, semana.fim);
  });

  const metaMin = 24 * 60;
  const mediaPeriodo = calcularMediaDuracao(concluidasPeriodo);
  const mediaSemana = calcularMediaDuracao(concluidasSemana);
  const dentroMeta = mediaPeriodo.duracoes.filter((value) => value <= metaMin).length;
  const velocidadePct = clampPercent(calcPercent(dentroMeta, mediaPeriodo.duracoes.length));

  if (perfExecProgressValue) {
    perfExecProgressValue.textContent = `${velocidadePct}%`;
    perfExecProgressValue.style.width = `${velocidadePct}%`;
  }
  if (perfExecTempoMedio) {
    perfExecTempoMedio.textContent = `Tempo médio: ${
      mediaPeriodo.media === null ? "-" : formatDuracaoMin(mediaPeriodo.media)
    }`;
  }
  if (perfExecSemana) {
    perfExecSemana.textContent = `Última semana: ${
      mediaSemana.media === null ? "-" : formatDuracaoMin(mediaSemana.media)
    }`;
  }
  if (perfExecBadge) {
    const badgeClass = velocidadePct >= 90 ? "badge--ok" : velocidadePct >= 75 ? "badge--warn" : "badge--danger";
    setBadgeState(perfExecBadge, badgeClass, "Meta 24h");
  }

  const slaStats = concluidasPeriodo.reduce(
    (acc, item) => {
      const sla = isSlaCompliant(item);
      if (sla === true) {
        acc.noPrazo += 1;
      } else if (sla === false) {
        acc.foraPrazo += 1;
      }
      return acc;
    },
    { noPrazo: 0, foraPrazo: 0 }
  );
  const slaPct = clampPercent(calcPercent(slaStats.noPrazo, slaStats.noPrazo + slaStats.foraPrazo));

  if (perfSlaProgressValue) {
    perfSlaProgressValue.textContent = `${slaPct}%`;
    perfSlaProgressValue.style.width = `${slaPct}%`;
  }
  if (perfSlaNoPrazo) {
    perfSlaNoPrazo.textContent = `No prazo: ${slaStats.noPrazo}`;
  }
  if (perfSlaForaPrazo) {
    perfSlaForaPrazo.textContent = `Fora do prazo: ${slaStats.foraPrazo}`;
  }
  if (perfSlaBadge) {
    const label = slaPct >= 90 ? "No prazo" : slaPct >= 75 ? "Atenção" : "Crítico";
    const badgeClass = slaPct >= 90 ? "badge--ok" : slaPct >= 75 ? "badge--warn" : "badge--danger";
    setBadgeState(perfSlaBadge, badgeClass, label);
  }
  if (perfSlaProgress) {
    const variant = slaPct >= 90 ? "" : "progress--warn";
    setProgressVariant(perfSlaProgress, variant);
  }

  const reopenEvents = getReopenEvents();
  const reopensPeriodo = reopenEvents.filter((time) =>
    inRange(startOfDay(time), periodo.inicio, periodo.fim)
  ).length;
  const reopensSemana = reopenEvents.filter((time) =>
    inRange(startOfDay(time), semana.inicio, semana.fim)
  ).length;
  const reopensBase = concluidasPeriodo.length || reopensPeriodo;
  const reopensPct = clampPercent(calcPercent(reopensPeriodo, reopensBase));

  if (perfReopenProgressValue) {
    perfReopenProgressValue.textContent = `${reopensPct}%`;
    perfReopenProgressValue.style.width = `${reopensPct}%`;
  }
  if (perfReopenUltimos) {
    perfReopenUltimos.textContent = `Últimos 7 dias: ${reopensSemana}`;
  }
  if (perfReopenImpacto) {
    const impacto = reopensPct <= 10 ? "baixo" : reopensPct <= 20 ? "moderado" : "alto";
    perfReopenImpacto.textContent = `Impacto: ${impacto}`;
  }
  if (perfReopenBadge) {
    const badgeClass = reopensPct <= 10 ? "badge--ok" : reopensPct <= 20 ? "badge--warn" : "badge--danger";
    const label = reopensPct <= 10 ? "Controlado" : reopensPct <= 20 ? "Atenção" : "Crítico";
    setBadgeState(perfReopenBadge, badgeClass, label);
  }
  if (perfReopenProgress) {
    const variant = reopensPct <= 10 ? "progress--cool" : "progress--warn";
    setProgressVariant(perfReopenProgress, variant);
  }
}

function parseTimeToMinutes(value) {
  if (!value) {
    return null;
  }
  const [hora, minuto] = String(value).split(":").map((item) => Number.parseInt(item, 10));
  if (!Number.isFinite(hora) || !Number.isFinite(minuto)) {
    return null;
  }
  return hora * 60 + minuto;
}

function calcDurationMinutes(inicio, fim) {
  const inicioMin = parseTimeToMinutes(inicio);
  const fimMin = parseTimeToMinutes(fim);
  if (inicioMin === null || fimMin === null) {
    return 0;
  }
  let diff = fimMin - inicioMin;
  if (diff < 0) {
    diff += 24 * 60;
  }
  return diff;
}

function getRdoScheduleFromDate(date) {
  const day = date ? date.getDay() : null;
  const isFriday = day === 5;
  const inicio = 7 * 60;
  const fim = isFriday ? 16 * 60 : 17 * 60;
  const label = isFriday ? "07:00 - 16:00 (sexta)" : "07:00 - 17:00 (seg-qui)";
  return { inicio, fim, label };
}

function calcOverlapMinutes(startA, endA, startB, endB) {
  const inicio = Math.max(startA, startB);
  const fim = Math.min(endA, endB);
  return Math.max(0, fim - inicio);
}

function renderPerformanceProjetos() {
  if (!perfProjetoCards || !perfProjetoTabela) {
    return;
  }
  const periodo = getPeriodoFiltro(perfProjetoPeriodo ? perfProjetoPeriodo.value : "30");
  const filtroProjeto = perfProjetoFiltro ? perfProjetoFiltro.value : "";
  const lista = manutencoes.filter((item) => {
    const dataRef = getRelatorioItemDate(item);
    if (!dataRef) {
      return false;
    }
    const dia = startOfDay(dataRef);
    if (!inRange(dia, periodo.inicio, periodo.fim)) {
      return false;
    }
    if (filtroProjeto && getProjetoLabel(item) !== filtroProjeto) {
      return false;
    }
    return true;
  });

  const projetos = {};
  lista.forEach((item) => {
    const projeto = getProjetoLabel(item);
    if (!projetos[projeto]) {
      projetos[projeto] = {
        concluida: 0,
        noPrazo: 0,
        backlog: 0,
        criticas: 0,
        apr: 0,
        os: 0,
        pte: 0,
        pt: 0,
      };
    }
    const stats = projetos[projeto];
    if (item.status === "concluida") {
      stats.concluida += 1;
      const data = parseDate(item.data);
      const doneAt = parseTimestamp(item.doneAt);
      if (data && doneAt && startOfDay(doneAt) <= startOfDay(data)) {
        stats.noPrazo += 1;
      }
    }
    if (item.status === "backlog") {
      stats.backlog += 1;
    }
    if (isItemCritico(item)) {
      stats.criticas += 1;
    }
    const docs = contarDocsItem(item);
    stats.apr += docs.apr;
    stats.os += docs.os;
    stats.pte += docs.pte;
    stats.pt += docs.pt;
  });

  const projetosOrdenados = Object.keys(projetos).sort((a, b) => {
    const diff = projetos[b].concluida - projetos[a].concluida;
    if (diff !== 0) {
      return diff;
    }
    return a.localeCompare(b);
  });
  const total = projetosOrdenados.reduce(
    (acc, key) => {
      const stats = projetos[key];
      acc.concluida += stats.concluida;
      acc.noPrazo += stats.noPrazo;
      acc.backlog += stats.backlog;
      acc.criticas += stats.criticas;
      acc.apr += stats.apr;
      acc.os += stats.os;
      acc.pte += stats.pte;
      acc.pt += stats.pt;
      return acc;
    },
    { concluida: 0, noPrazo: 0, backlog: 0, criticas: 0, apr: 0, os: 0, pte: 0, pt: 0 }
  );
  const totalAtividades = total.concluida + total.backlog;
  const totalSla = calcPercent(total.noPrazo, total.concluida);
  const totalBacklogRate = calcPercent(total.backlog, totalAtividades);
  const totalDocs = total.apr + total.os + total.pte + total.pt;

  perfProjetoCards.innerHTML = `
    <div class="perf-card">
      <span>Projetos ativos</span>
      <strong>${projetosOrdenados.length}</strong>
      <small>Período selecionado</small>
    </div>
    <div class="perf-card">
      <span>Concluídas</span>
      <strong>${total.concluida}</strong>
      <small>${total.noPrazo} no prazo</small>
    </div>
    <div class="perf-card">
      <span>SLA no prazo</span>
      <strong>${totalSla}%</strong>
      <small>Índice mensal</small>
    </div>
    <div class="perf-card">
      <span>Backlog</span>
      <strong>${total.backlog}</strong>
      <small>${totalBacklogRate}% do volume</small>
    </div>
    <div class="perf-card">
      <span>Críticas</span>
      <strong>${total.criticas}</strong>
      <small>Riscos no período</small>
    </div>
    <div class="perf-card">
      <span>Docs de segurança</span>
      <strong>${totalDocs}</strong>
      <small>APR, OS, PTE, PT</small>
    </div>
  `;

  const tbody = perfProjetoTabela.querySelector("tbody");
  tbody.innerHTML = "";
  projetosOrdenados.forEach((key) => {
    const stats = projetos[key];
    const totalItem = stats.concluida + stats.backlog;
    const sla = calcPercent(stats.noPrazo, stats.concluida);
    const backlogRate = calcPercent(stats.backlog, totalItem);
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${escapeHtml(key)}</td>
      <td>${stats.concluida}</td>
      <td>${stats.noPrazo}</td>
      <td><span class="perf-badge ${getPerfSlaClass(sla)}">${sla}%</span></td>
      <td><span class="perf-badge ${getPerfBacklogClass(backlogRate)}">${stats.backlog}</span></td>
      <td><span class="perf-badge ${getPerfCriticalClass(stats.criticas)}">${stats.criticas}</span></td>
      <td>${stats.apr}</td>
      <td>${stats.os}</td>
      <td>${stats.pte}</td>
      <td>${stats.pt}</td>
    `;
    tbody.append(tr);
  });
  if (perfProjetoTotalConcluidas) perfProjetoTotalConcluidas.textContent = String(total.concluida);
  if (perfProjetoTotalPrazo) perfProjetoTotalPrazo.textContent = String(total.noPrazo);
  if (perfProjetoTotalSla) perfProjetoTotalSla.textContent = `${totalSla}%`;
  if (perfProjetoTotalBacklog) perfProjetoTotalBacklog.textContent = String(total.backlog);
  if (perfProjetoTotalCriticas) perfProjetoTotalCriticas.textContent = String(total.criticas);
  if (perfProjetoTotalApr) perfProjetoTotalApr.textContent = String(total.apr);
  if (perfProjetoTotalOs) perfProjetoTotalOs.textContent = String(total.os);
  if (perfProjetoTotalPte) perfProjetoTotalPte.textContent = String(total.pte);
  if (perfProjetoTotalPt) perfProjetoTotalPt.textContent = String(total.pt);

  if (perfProjetoInsights) {
    const rankingSla = projetosOrdenados
      .map((key) => {
        const stats = projetos[key];
        return { key, sla: calcPercent(stats.noPrazo, stats.concluida) };
      })
      .sort((a, b) => b.sla - a.sla)
      .slice(0, 3);
    const rankingBacklog = projetosOrdenados
      .map((key) => {
        const stats = projetos[key];
        const totalItem = stats.concluida + stats.backlog;
        return {
          key,
          backlogRate: calcPercent(stats.backlog, totalItem),
          backlog: stats.backlog,
        };
      })
      .sort((a, b) => b.backlogRate - a.backlogRate)
      .slice(0, 3);
    perfProjetoInsights.innerHTML = `
      <div class="performance-insight">
        <h3>Destaques de SLA</h3>
        <ul>
          ${rankingSla
            .map(
              (item) =>
                `<li><strong>${escapeHtml(item.key)}</strong><span>${item.sla}% no prazo</span></li>`
            )
            .join("")}
        </ul>
      </div>
      <div class="performance-insight">
        <h3>Risco de backlog</h3>
        <ul>
          ${rankingBacklog
            .map(
              (item) =>
                `<li><strong>${escapeHtml(item.key)}</strong><span>${item.backlog} pendências</span></li>`
            )
            .join("")}
        </ul>
      </div>
    `;
  }

  if (perfProjetoFiltro) {
    const atual = perfProjetoFiltro.value;
    perfProjetoFiltro.innerHTML = `<option value="">Todos os projetos</option>`;
    projetosOrdenados.forEach((key) => {
      const opt = document.createElement("option");
      opt.value = key;
      opt.textContent = key;
      perfProjetoFiltro.append(opt);
    });
    if (atual && projetosOrdenados.includes(atual)) {
      perfProjetoFiltro.value = atual;
    }
  }
}

function renderPerformancePessoas() {
  if (!perfPessoaCards || !perfPessoaTabela) {
    return;
  }
  const periodo = getPeriodoFiltro(perfPessoaPeriodo ? perfPessoaPeriodo.value : "30");
  const filtroPessoa = perfPessoaFiltro ? perfPessoaFiltro.value : "";
  const lista = manutencoes.filter((item) => {
    const dataRef = getRelatorioItemDate(item);
    if (!dataRef) {
      return false;
    }
    const dia = startOfDay(dataRef);
    if (!inRange(dia, periodo.inicio, periodo.fim)) {
      return false;
    }
    if (filtroPessoa && getResponsavelLabel(item) !== filtroPessoa) {
      return false;
    }
    return true;
  });

  const pessoas = {};
  const usuariosBase = filtroPessoa
    ? [filtroPessoa]
    : users
        .filter((user) => user && (user.name || user.username))
        .map((user) => getUserLabel(user.id))
        .filter(Boolean);
  usuariosBase.forEach((label) => {
    if (!pessoas[label]) {
      pessoas[label] = {
        abertas: 0,
        concluida: 0,
        noPrazo: 0,
        backlog: 0,
        criticas: 0,
        apr: 0,
        os: 0,
        pte: 0,
        pt: 0,
      };
    }
  });
  lista.forEach((item) => {
    const responsavel = getResponsavelLabel(item);
    if (!pessoas[responsavel]) {
      pessoas[responsavel] = {
        abertas: 0,
        concluida: 0,
        noPrazo: 0,
        backlog: 0,
        criticas: 0,
        apr: 0,
        os: 0,
        pte: 0,
        pt: 0,
      };
    }
    const stats = pessoas[responsavel];
    if (item.createdBy && getUserLabel(item.createdBy) === responsavel) {
      stats.abertas += 1;
    }
    if (item.status === "concluida") {
      stats.concluida += 1;
      const data = parseDate(item.data);
      const doneAt = parseTimestamp(item.doneAt);
      if (data && doneAt && startOfDay(doneAt) <= startOfDay(data)) {
        stats.noPrazo += 1;
      }
    }
    if (item.status === "backlog") {
      stats.backlog += 1;
    }
    if (isItemCritico(item)) {
      stats.criticas += 1;
    }
    const docs = contarDocsItem(item);
    stats.apr += docs.apr;
    stats.os += docs.os;
    stats.pte += docs.pte;
    stats.pt += docs.pt;
  });

  const pessoasOrdenadas = Object.keys(pessoas).sort((a, b) => {
    const diff = pessoas[b].concluida - pessoas[a].concluida;
    if (diff !== 0) {
      return diff;
    }
    return a.localeCompare(b);
  });
  const total = pessoasOrdenadas.reduce(
    (acc, key) => {
      const stats = pessoas[key];
      acc.abertas += stats.abertas;
      acc.concluida += stats.concluida;
      acc.noPrazo += stats.noPrazo;
      acc.backlog += stats.backlog;
      acc.criticas += stats.criticas;
      acc.apr += stats.apr;
      acc.os += stats.os;
      acc.pte += stats.pte;
      acc.pt += stats.pt;
      return acc;
    },
    { abertas: 0, concluida: 0, noPrazo: 0, backlog: 0, criticas: 0, apr: 0, os: 0, pte: 0, pt: 0 }
  );
  const totalAtividades = total.concluida + total.backlog;
  const totalSla = calcPercent(total.noPrazo, total.concluida);
  const totalBacklogRate = calcPercent(total.backlog, totalAtividades);
  const totalDocs = total.apr + total.os + total.pte + total.pt;
  const mediaConcluida = pessoasOrdenadas.length
    ? Math.round(total.concluida / pessoasOrdenadas.length)
    : 0;

  perfPessoaCards.innerHTML = `
    <div class="perf-card">
      <span>Colaboradores ativos</span>
      <strong>${pessoasOrdenadas.length}</strong>
      <small>Período selecionado</small>
    </div>
    <div class="perf-card">
      <span>Concluídas</span>
      <strong>${total.concluida}</strong>
      <small>${total.noPrazo} no prazo</small>
    </div>
    <div class="perf-card">
      <span>SLA no prazo</span>
      <strong>${totalSla}%</strong>
      <small>Índice mensal</small>
    </div>
    <div class="perf-card">
      <span>Backlog</span>
      <strong>${total.backlog}</strong>
      <small>${totalBacklogRate}% do volume</small>
    </div>
    <div class="perf-card">
      <span>Críticas</span>
      <strong>${total.criticas}</strong>
      <small>Riscos no período</small>
    </div>
    <div class="perf-card">
      <span>Docs de segurança</span>
      <strong>${totalDocs}</strong>
      <small>APR, OS, PTE, PT</small>
    </div>
    <div class="perf-card">
      <span>Média concluída</span>
      <strong>${mediaConcluida}</strong>
      <small>Por colaborador</small>
    </div>
  `;

  const tbody = perfPessoaTabela.querySelector("tbody");
  tbody.innerHTML = "";
  pessoasOrdenadas.forEach((key) => {
    const stats = pessoas[key];
    const totalItem = stats.concluida + stats.backlog;
    const sla = calcPercent(stats.noPrazo, stats.concluida);
    const backlogRate = calcPercent(stats.backlog, totalItem);
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${escapeHtml(key)}</td>
      <td>${stats.abertas}</td>
      <td>${stats.concluida}</td>
      <td>${stats.noPrazo}</td>
      <td><span class="perf-badge ${getPerfSlaClass(sla)}">${sla}%</span></td>
      <td><span class="perf-badge ${getPerfBacklogClass(backlogRate)}">${stats.backlog}</span></td>
      <td><span class="perf-badge ${getPerfCriticalClass(stats.criticas)}">${stats.criticas}</span></td>
      <td>${stats.apr}</td>
      <td>${stats.os}</td>
      <td>${stats.pte}</td>
      <td>${stats.pt}</td>
    `;
    tbody.append(tr);
  });
  if (perfPessoaTotalAbertas) perfPessoaTotalAbertas.textContent = String(total.abertas);
  if (perfPessoaTotalConcluidas) perfPessoaTotalConcluidas.textContent = String(total.concluida);
  if (perfPessoaTotalPrazo) perfPessoaTotalPrazo.textContent = String(total.noPrazo);
  if (perfPessoaTotalSla) perfPessoaTotalSla.textContent = `${totalSla}%`;
  if (perfPessoaTotalBacklog) perfPessoaTotalBacklog.textContent = String(total.backlog);
  if (perfPessoaTotalCriticas) perfPessoaTotalCriticas.textContent = String(total.criticas);
  if (perfPessoaTotalApr) perfPessoaTotalApr.textContent = String(total.apr);
  if (perfPessoaTotalOs) perfPessoaTotalOs.textContent = String(total.os);
  if (perfPessoaTotalPte) perfPessoaTotalPte.textContent = String(total.pte);
  if (perfPessoaTotalPt) perfPessoaTotalPt.textContent = String(total.pt);

  if (perfPessoaInsights) {
    const rankingEntrega = pessoasOrdenadas
      .map((key) => ({ key, concluida: pessoas[key].concluida }))
      .sort((a, b) => b.concluida - a.concluida)
      .slice(0, 3);
    const rankingBacklog = pessoasOrdenadas
      .map((key) => ({ key, backlog: pessoas[key].backlog }))
      .sort((a, b) => b.backlog - a.backlog)
      .slice(0, 3);
    perfPessoaInsights.innerHTML = `
      <div class="performance-insight">
        <h3>Top entregas</h3>
        <ul>
          ${rankingEntrega
            .map(
              (item) =>
                `<li><strong>${escapeHtml(item.key)}</strong><span>${item.concluida} concluídas</span></li>`
            )
            .join("")}
        </ul>
      </div>
      <div class="performance-insight">
        <h3>Maior backlog</h3>
        <ul>
          ${rankingBacklog
            .map(
              (item) =>
                `<li><strong>${escapeHtml(item.key)}</strong><span>${item.backlog} pendências</span></li>`
            )
            .join("")}
        </ul>
      </div>
    `;
  }

  if (perfPessoaFiltro) {
    const atual = perfPessoaFiltro.value;
    perfPessoaFiltro.innerHTML = `<option value="">Todos os colaboradores</option>`;
    pessoasOrdenadas.forEach((key) => {
      const opt = document.createElement("option");
      opt.value = key;
      opt.textContent = key;
      perfPessoaFiltro.append(opt);
    });
    if (atual && pessoasOrdenadas.includes(atual)) {
      perfPessoaFiltro.value = atual;
    }
  }
}

function normalizeFeedbackRecord(record) {
  if (!record || typeof record !== "object") {
    return null;
  }
  const projectId = String(record.projectId || activeProjectId || "").trim();
  const from = String(record.from || record.fromId || record.senderId || "").trim();
  const to = String(record.to || record.toId || record.receiverId || "").trim();
  const message = String(record.message || record.text || "").trim();
  if (!from || !to || !message) {
    return null;
  }
  const createdAt = record.createdAt || toIsoUtc(new Date());
  return {
    id: record.id || criarId(),
    projectId,
    from,
    to,
    score: Number(record.score) || 0,
    message,
    createdAt,
    readAt: record.readAt || "",
    fromName: String(record.fromName || record.senderName || "").trim(),
    toName: String(record.toName || record.receiverName || "").trim(),
  };
}

function normalizeFeedbackList(list) {
  const map = new Map();
  (Array.isArray(list) ? list : [])
    .map((item) => normalizeFeedbackRecord(item))
    .filter(Boolean)
    .forEach((item) => {
      map.set(String(item.id), item);
    });
  return Array.from(map.values()).sort((a, b) => {
    const ta = getTimeValue(parseTimestamp(a.createdAt)) || 0;
    const tb = getTimeValue(parseTimestamp(b.createdAt)) || 0;
    return tb - ta;
  });
}

async function carregarFeedbacks(force = false) {
  if (!currentUser) {
    feedbacks = [];
    feedbacksLastFetch = 0;
    feedbacksLastProjectId = "";
    atualizarFeedbackBadge();
    renderFeedbackInbox();
    renderFeedbackList();
    return;
  }
  if (activeProjectId !== feedbacksLastProjectId) {
    feedbacksLastProjectId = activeProjectId || "";
    force = true;
  }
  if (!USE_AUTH_API) {
    feedbacks = readJson(getProjectStorageKey(FEEDBACK_KEY), []);
    atualizarFeedbackBadge();
    renderFeedbackInbox();
    renderFeedbackList();
    return;
  }
  const agora = Date.now();
  if (!force && feedbacksLastFetch && agora - feedbacksLastFetch < FEEDBACK_TTL_MS) {
    atualizarFeedbackBadge();
    renderFeedbackInbox();
    renderFeedbackList();
    return;
  }
  try {
    const data = await apiFeedbackList(activeProjectId);
    const list = data && (data.items || data.feedbacks || data.list);
    feedbacks = normalizeFeedbackList(list);
    feedbacksLastFetch = Date.now();
    salvarFeedbacks(feedbacks);
  } catch (error) {
    feedbacks = readJson(getProjectStorageKey(FEEDBACK_KEY), []);
  }
  atualizarFeedbackBadge();
  renderFeedbackInbox();
  renderFeedbackList();
}

function salvarFeedbacks(lista) {
  writeJson(getProjectStorageKey(FEEDBACK_KEY), lista);
  feedbacks = lista;
}

function getFeedbacksRecebidos(userId) {
  return feedbacks.filter((item) => item.to === userId);
}

function getFeedbacksEnviados(userId) {
  return feedbacks.filter((item) => item.from === userId);
}

function getFeedbackUserLabel(userId, fallbackName) {
  const label = getUserLabel(userId);
  const normalized = String(label || "").trim();
  if (normalized && normalized !== String(userId) && normalized !== "Desconhecido") {
    return normalized;
  }
  const fallback = String(fallbackName || "").trim();
  return fallback || normalized || String(userId || "-");
}

function renderFeedbackStats() {
  if (!currentUser) {
    return;
  }
  const userId = currentUser.id;
  const recebidos = getFeedbacksRecebidos(userId);
  const enviados = getFeedbacksEnviados(userId);
  const unread = recebidos.filter((item) => !item.readAt).length;
  const media =
    recebidos.length > 0
      ? (
          recebidos.reduce((acc, item) => acc + (Number(item.score) || 0), 0) /
          recebidos.length
        ).toFixed(1)
      : "-";

  if (feedbackStatReceived) feedbackStatReceived.textContent = String(recebidos.length);
  if (feedbackStatSent) feedbackStatSent.textContent = String(enviados.length);
  if (feedbackStatAvg) feedbackStatAvg.textContent = media === "-" ? "-" : media;
  if (feedbackStatUnread) feedbackStatUnread.textContent = String(unread);
}

function renderFeedbackList() {
  if (!feedbackList || !feedbackEmpty) {
    return;
  }
  renderFeedbackStats();
  const activeTab = feedbackTabButtons.find((btn) => btn.classList.contains("is-active"));
  const mode = activeTab ? activeTab.dataset.feedbackTab : "recebidos";
  const userId = currentUser ? currentUser.id : "";
  const searchQuery = feedbackSearch ? normalizeSearchValue(feedbackSearch.value) : "";
  const sortMode = feedbackSort ? feedbackSort.value : "recent";
  const listaBase = mode === "enviados" ? getFeedbacksEnviados(userId) : getFeedbacksRecebidos(userId);
  const lista = listaBase.filter((item) => {
    if (!searchQuery) {
      return true;
    }
    const peerId = mode === "enviados" ? item.to : item.from;
    const peerName = mode === "enviados" ? item.toName : item.fromName;
    const peer = getFeedbackUserLabel(peerId, peerName);
    const content = normalizeSearchValue(`${peer} ${item.message || ""}`);
    return content.includes(searchQuery);
  });
  feedbackList.innerHTML = "";

  if (!lista.length) {
    feedbackEmpty.hidden = false;
    return;
  }
  feedbackEmpty.hidden = true;

  lista
    .slice()
    .sort((a, b) => {
      if (sortMode === "score") {
        return (Number(b.score) || 0) - (Number(a.score) || 0);
      }
      return (
        (getTimeValue(parseTimestamp(b.createdAt)) || 0) -
        (getTimeValue(parseTimestamp(a.createdAt)) || 0)
      );
    })
    .forEach((item) => {
      const card = document.createElement("div");
      card.className = `feedback-item ${item.readAt ? "" : "is-unread"}`;
      const createdAt = item.createdAt ? formatDateTime(parseTimestamp(item.createdAt)) : "-";
      const peerId = mode === "enviados" ? item.to : item.from;
      const peerName = mode === "enviados" ? item.toName : item.fromName;
      const peer = getFeedbackUserLabel(peerId, peerName);
      card.innerHTML = `
        <div class="feedback-item__head">
          <strong>${escapeHtml(peer || "-")}</strong>
          <span class="feedback-score">Nota ${item.score}</span>
        </div>
        <p>${escapeHtml(item.message || "")}</p>
        <small>${escapeHtml(createdAt)}</small>
      `;
      feedbackList.append(card);
    });

  if (mode === "recebidos") {
    marcarFeedbacksComoLidos(userId);
  }
}

function marcarFeedbacksComoLidos(userId) {
  let mudou = false;
  const ids = [];
  const agora = toIsoUtc(new Date());
  const atualizados = feedbacks.map((item) => {
    if (item.to === userId && !item.readAt) {
      mudou = true;
      if (item.id) {
        ids.push(item.id);
      }
      return { ...item, readAt: agora };
    }
    return item;
  });
  if (mudou) {
    salvarFeedbacks(atualizados);
    if (USE_AUTH_API && ids.length) {
      apiFeedbackRead(ids).catch(() => null);
    }
  }
  atualizarFeedbackBadge();
  renderFeedbackInbox();
  renderFeedbackStats();
}

function atualizarFeedbackBadge() {
  const userId = currentUser ? currentUser.id : "";
  const unread = feedbacks.filter((item) => item.to === userId && !item.readAt).length;
  if (feedbackBadge) {
    feedbackBadge.textContent = String(unread);
    feedbackBadge.hidden = unread === 0;
  }
  if (feedbackInboxDot) {
    feedbackInboxDot.textContent = unread ? String(unread) : "";
    feedbackInboxDot.hidden = unread === 0;
    if (unread > 0) {
      setBadgeSeverity(feedbackInboxDot, "media");
    } else {
      setBadgeSeverity(feedbackInboxDot, null);
    }
  }
}

function renderFeedbackInbox() {
  if (!feedbackInboxList || !feedbackInboxEmpty) {
    return;
  }
  const userId = currentUser ? currentUser.id : "";
  const recebidos = getFeedbacksRecebidos(userId)
    .slice()
    .sort((a, b) => (getTimeValue(parseTimestamp(b.createdAt)) || 0) - (getTimeValue(parseTimestamp(a.createdAt)) || 0))
    .slice(0, 4);
  feedbackInboxList.innerHTML = "";
  if (!recebidos.length) {
    feedbackInboxEmpty.hidden = false;
    return;
  }
  feedbackInboxEmpty.hidden = true;
  recebidos.forEach((item) => {
    const row = document.createElement("div");
    row.className = `feedback-inbox-item${item.readAt ? "" : " is-unread"}`;
    const createdAt = item.createdAt ? formatDateTime(parseTimestamp(item.createdAt)) : "-";
    const author = getFeedbackUserLabel(item.from, item.fromName);
    row.innerHTML = `
      <strong>${escapeHtml(author || "-")}</strong>
      <span>${escapeHtml(item.message || "").slice(0, 60)}${item.message && item.message.length > 60 ? "..." : ""}</span>
      <small>${escapeHtml(createdAt)}</small>
    `;
    feedbackInboxList.append(row);
  });
  renderFeedbackStats();
}

async function enviarFeedback() {
  if (!currentUser) {
    return;
  }
  const to = feedbackTo ? feedbackTo.value : "";
  const score = feedbackScore ? Number(feedbackScore.value) : 0;
  const message = feedbackMessage ? feedbackMessage.value.trim() : "";
  if (!to || !message || !score) {
    if (feedbackSendMsg) {
      feedbackSendMsg.textContent = "Preencha destinatário, avaliação e mensagem.";
      feedbackSendMsg.classList.add("mensagem--erro");
    }
    return;
  }
  if (btnEnviarFeedback) {
    btnEnviarFeedback.disabled = true;
  }
  const payload = {
    projectId: activeProjectId || "",
    from: currentUser.id,
    fromName: getFeedbackUserLabel(currentUser.id, currentUser.name || currentUser.nome),
    to,
    toName: getFeedbackUserLabel(to),
    score,
    message,
    createdAt: toIsoUtc(new Date()),
    readAt: null,
  };
  try {
    const data = await apiFeedbackCreate(payload);
    const item = normalizeFeedbackRecord(data.item || data.feedback || payload);
    const list = Array.isArray(data.items || data.list)
      ? normalizeFeedbackList(data.items || data.list)
      : item
        ? normalizeFeedbackList([item].concat(feedbacks))
        : feedbacks;
    salvarFeedbacks(list);
    feedbacksLastFetch = Date.now();
    if (feedbackMessage) {
      feedbackMessage.value = "";
    }
    if (feedbackSendMsg) {
      feedbackSendMsg.textContent = "Feedback enviado com sucesso.";
      feedbackSendMsg.classList.remove("mensagem--erro");
    }
    atualizarFeedbackBadge();
    renderFeedbackInbox();
    renderFeedbackList();
    renderFeedbackStats();
  } catch (error) {
    if (feedbackSendMsg) {
      feedbackSendMsg.textContent = error.message || "Falha ao enviar feedback.";
      feedbackSendMsg.classList.add("mensagem--erro");
    }
  } finally {
    if (btnEnviarFeedback) {
      btnEnviarFeedback.disabled = false;
    }
  }
}

function renderFeedbackRecipients() {
  if (!feedbackTo) {
    return;
  }
  feedbackTo.innerHTML = `<option value="">Selecione um colaborador</option>`;
  users.forEach((user) => {
    if (currentUser && user.id === currentUser.id) {
      return;
    }
    const option = document.createElement("option");
    option.value = user.id;
    option.textContent = getUserLabel(user.id) || user.nome || user.email || user.id;
    feedbackTo.append(option);
  });
}

function buildRelatorioResumoHtml(titulo, periodoLabel, lista) {
  const concluidas = lista.filter((item) => item.status === "concluida");
  const criticos = lista.filter(
    (item) => item.critico || (item.prioridade || "").toLowerCase() === "critica"
  );
  const evidencias = lista.reduce((acc, item) => acc + contarEvidencias(item), 0);
  const pontuais = concluidas.filter((item) => {
    const data = parseDate(item.data);
    const doneAt = parseTimestamp(item.doneAt);
    if (!data || !doneAt) {
      return false;
    }
    return startOfDay(doneAt) <= startOfDay(data);
  });
  const sla = concluidas.length ? Math.round((pontuais.length / concluidas.length) * 100) : 0;
  const linhas = lista
    .map((item) => {
      const data = parseDate(item.data);
      const doneAt = parseTimestamp(item.doneAt);
      const referencia = doneAt ? formatDate(doneAt) : data ? formatDate(data) : "-";
      const responsavel = getRelatorioResponsavel(item);
      return `<tr>
        <td>${escapeHtml(item.titulo || "-")}</td>
        <td>${escapeHtml(item.local || "-")}</td>
        <td>${escapeHtml(referencia)}</td>
        <td>${escapeHtml(item.status || "-")}</td>
        <td>${escapeHtml(responsavel || "-")}</td>
      </tr>`;
    })
    .join("");

  return `
    <div class="report">
      <header class="report__header">
        <div class="report__brand">
          <strong>OPSCOPE</strong>
          <span>${escapeHtml(titulo)}</span>
        </div>
        <div class="report__meta">
          <div>Período: ${escapeHtml(periodoLabel)}</div>
          <div>Gerado em: ${escapeHtml(formatDateTime(new Date()))}</div>
        </div>
      </header>
      <section class="report__grid">
        <div><span>Manutenções</span><strong>${lista.length}</strong></div>
        <div><span>Concluídas</span><strong>${concluidas.length}</strong></div>
        <div><span>Críticos</span><strong>${criticos.length}</strong></div>
        <div><span>Evidências</span><strong>${evidencias}</strong></div>
        <div><span>SLA no prazo</span><strong>${sla}%</strong></div>
      </section>
      <section class="report__body">
        <h4>Resumo do período</h4>
        <table class="report__table">
          <thead>
            <tr>
              <th>Manutenção</th>
              <th>Local</th>
              <th>Data</th>
              <th>Status</th>
              <th>Responsável</th>
            </tr>
          </thead>
          <tbody>
            ${linhas || `<tr><td colspan="5">Nenhum registro no período.</td></tr>`}
          </tbody>
        </table>
      </section>
    </div>
  `;
}

function abrirJanelaRelatorio(html, titulo, imprimir) {
  const nova = window.open("", "_blank");
  if (!nova) {
    return false;
  }
  nova.document.write(`
    <html>
      <head>
        <title>${escapeHtml(titulo)}</title>
        <style>
          body { font-family: "Segoe UI", sans-serif; margin: 24px; color: #16202a; }
          .report__header { display: flex; justify-content: space-between; gap: 16px; border-bottom: 2px solid #d9d4c8; padding-bottom: 12px; }
          .report__brand strong { font-size: 1.1rem; letter-spacing: 0.2em; display: block; }
          .report__brand span { font-size: 0.9rem; color: #5c6772; }
          .report__meta { font-size: 0.85rem; color: #5c6772; display: grid; gap: 6px; text-align: right; }
          .report__grid { display: grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap: 8px; margin: 18px 0; }
          .report__grid div { border: 1px solid #d9d4c8; border-radius: 10px; padding: 10px; }
          .report__grid span { font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.12em; color: #5c6772; }
          .report__grid strong { font-size: 1rem; }
          .report__table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
          .report__table th, .report__table td { border-bottom: 1px solid #e2ddd2; padding: 8px; text-align: left; }
          .report__table th { text-transform: uppercase; letter-spacing: 0.12em; font-size: 0.65rem; background: #f6f2ea; }
          .rdo-doc { display: grid; gap: 18px; }
          .rdo-header { display: flex; justify-content: space-between; gap: 16px; padding-bottom: 10px; border-bottom: 2px solid #d9d4c8; }
          .rdo-brand { display: grid; gap: 4px; }
          .rdo-brand__row { display: flex; align-items: center; gap: 12px; }
          .rdo-logo { width: 72px; height: auto; object-fit: contain; }
          .rdo-eyebrow { font-size: 0.6rem; letter-spacing: 0.2em; text-transform: uppercase; color: #5c6772; }
          .rdo-title { font-size: 1.5rem; letter-spacing: 0.08em; text-transform: uppercase; margin: 0; }
          .rdo-subtitle { font-size: 0.9rem; color: #5c6772; margin: 0; }
          .rdo-meta { font-size: 0.8rem; display: grid; gap: 4px; color: #5c6772; text-align: right; }
          .rdo-header-info { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 8px; font-size: 0.72rem; color: #425363; }
          .rdo-header-info span { display: block; text-transform: uppercase; letter-spacing: 0.12em; font-size: 0.55rem; }
          .rdo-header-info strong { font-size: 0.78rem; color: #1f2a33; }
          .rdo-section { display: grid; gap: 10px; }
          .rdo-summary { background: #f8f6f1; border: 1px solid #d9d4c8; padding: 12px 14px; border-radius: 12px; }
          .rdo-block { border: 1px solid #d9d4c8; border-radius: 12px; padding: 10px 12px; background: #fff; }
          .rdo-summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 8px; margin-top: 8px; }
          .rdo-summary-item { border: 1px solid #d9d4c8; border-radius: 10px; padding: 6px 8px; display: grid; gap: 2px; background: #fff; }
          .rdo-summary-item span { font-size: 0.6rem; letter-spacing: 0.12em; text-transform: uppercase; color: #425363; }
          .rdo-summary-item strong { font-size: 0.9rem; }
          .rdo-summary-grid--cards .rdo-summary-item { background: #fff; box-shadow: 0 6px 10px rgba(0,0,0,0.06); }
          .rdo-kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 10px; }
          .rdo-kpi-card { border: 1px solid #d9d4c8; border-radius: 12px; padding: 10px 10px 10px 30px; background: #fff; display: grid; gap: 6px; position: relative; }
          .rdo-kpi-card span { font-size: 0.6rem; letter-spacing: 0.12em; text-transform: uppercase; color: #5c6772; }
          .rdo-kpi-card strong { font-size: 1rem; }
          .rdo-kpi-card--ok { border-left: 4px solid #4bd28f; }
          .rdo-kpi-card--warn { border-left: 4px solid #f6c453; }
          .rdo-kpi-card--danger { border-left: 4px solid #e2595c; }
          .rdo-kpi-card--info { border-left: 4px solid #5b8def; }
          .rdo-kpi-card--neutral { border-left: 4px solid #9aa4af; }
          .rdo-kpi-card::before { content: ""; width: 10px; height: 10px; border-radius: 50%; background: #9aa4af; position: absolute; left: 10px; top: 12px; }
          .rdo-kpi-card--ok::before { background: #4bd28f; }
          .rdo-kpi-card--warn::before { background: #f6c453; }
          .rdo-kpi-card--danger::before { background: #e2595c; }
          .rdo-kpi-card--info::before { background: #5b8def; }
          .rdo-kpi-card--neutral::before { background: #9aa4af; }
          .rdo-month__sla { display: grid; gap: 6px; }
          .rdo-month__sla-bar { height: 16px; background: #e5e1d6; border-radius: 999px; overflow: hidden; }
          .rdo-month__sla-bar span { display: block; height: 100%; background: linear-gradient(90deg, #4bd28f, #9bf7c7); color: #1f2a33; font-size: 0.7rem; text-align: right; padding-right: 8px; line-height: 16px; }
          .rdo-month__sla small { font-size: 0.75rem; color: #5c6772; }
          .rdo-note { border: 1px dashed #d9d4c8; border-radius: 12px; padding: 12px 14px; background: #fff; }
          .rdo-note h3 { margin: 0 0 6px; font-size: 0.95rem; }
          .report-table__wrap { border: 1px solid #e2ddd2; border-radius: 10px; overflow: hidden; }
          .report__table tbody tr:nth-child(even) { background: #fbf9f4; }
          .report__table tfoot td { font-weight: 600; background: #f6f2ea; }
          .status-badge { display: inline-flex; align-items: center; justify-content: center; padding: 3px 6px; border-radius: 999px; font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.1em; }
          .status-badge--concluida { background: rgba(43, 122, 120, 0.18); color: #1f5759; }
          .status-badge--em_execucao { background: rgba(91, 141, 239, 0.18); color: #2b4e7a; }
          .status-badge--backlog { background: rgba(226, 89, 92, 0.18); color: #7a2b1e; }
          .status-badge--agendada { background: rgba(246, 196, 83, 0.18); color: #7a5b1e; }
          .status-badge--liberada { background: rgba(91, 141, 239, 0.16); color: #2b4e7a; }
          .priority-badge { display: inline-flex; align-items: center; justify-content: center; padding: 3px 6px; border-radius: 999px; font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.1em; border: 1px solid #d9d4c8; }
          .priority-badge--baixa { background: rgba(91, 141, 239, 0.12); color: #2b4e7a; }
          .priority-badge--media { background: rgba(246, 196, 83, 0.18); color: #7a5b1e; }
          .priority-badge--alta { background: rgba(226, 89, 92, 0.18); color: #7a2b1e; }
          .priority-badge--critica { background: rgba(226, 89, 92, 0.28); color: #7a2b1e; }
          .rdo-month__day summary { cursor: pointer; list-style: none; }
          .rdo-month__day summary::-webkit-details-marker { display: none; }
          @media screen {
            .report-table__wrap { max-height: 260px; overflow: auto; }
            .report__table thead th { position: sticky; top: 0; z-index: 1; }
          }
          @media print {
            body { margin: 16mm; }
            .rdo-month__charts { grid-template-columns: 1fr; }
            .rdo-month__charts > div { break-inside: avoid; page-break-inside: avoid; }
            .rdo-month__donut { grid-template-columns: 1fr; justify-items: center; }
            .rdo-legend { margin-top: 6px; }
            .rdo-chart, .rdo-donut { max-width: 100%; height: auto; }
            h3, h4 { break-after: avoid; page-break-after: avoid; }
            .report-table__wrap { max-height: none; overflow: visible; }
            table { page-break-inside: avoid; }
          }
          .rdo-items { display: grid; gap: 10px; }
          .rdo-item { border: 1px solid #d9d4c8; border-radius: 12px; padding: 10px 12px; display: grid; gap: 8px; }
          .rdo-item__head { display: flex; justify-content: space-between; gap: 12px; font-size: 0.8rem; color: #425363; }
          .rdo-month__day { border: 1px solid #d9d4c8; border-radius: 12px; padding: 12px; display: grid; gap: 12px; }
          .rdo-month__day-head { display: flex; justify-content: space-between; gap: 12px; align-items: center; }
          .rdo-month__day-head span { font-size: 0.8rem; color: #5c6772; }
          .rdo-badge { border: 1px solid #d9d4c8; border-radius: 999px; padding: 6px 10px; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.12em; background: #f6f2ea; color: #5c6772; }
          .rdo-month__grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 8px; }
          .rdo-month__grid div { border: 1px solid #e2ddd2; border-radius: 10px; padding: 8px; }
          .rdo-month__grid span { font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.12em; color: #5c6772; }
          .rdo-month__grid strong { font-size: 0.85rem; }
          .rdo-month__notes { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; }
          .rdo-month__notes h4 { margin: 0 0 6px; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.12em; color: #5c6772; }
          .rdo-month__notes p { margin: 0; font-size: 0.85rem; color: #1f2a33; }
          .rdo-month { display: grid; gap: 18px; }
          .rdo-month__charts { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 16px; }
          .rdo-month__charts h4 { margin: 0 0 8px; font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.12em; color: #5c6772; }
          .rdo-chart { width: 100%; height: auto; display: block; }
          .rdo-month__donut { display: grid; grid-template-columns: auto 1fr; gap: 12px; align-items: center; }
          .rdo-donut { width: 120px; height: 120px; display: block; }
          .rdo-legend { display: grid; gap: 6px; font-size: 0.75rem; color: #425363; }
          .legend-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; }
          .legend-dot--ok { background: #4bd28f; }
          .legend-dot--info { background: #5b8def; }
          .legend-dot--warn { background: #f6c453; }
          .legend-dot--danger { background: #e2595c; }
        </style>
      </head>
      <body>${html}</body>
    </html>
  `);
  nova.document.close();
  if (imprimir) {
    nova.focus();
    nova.print();
  }
  return true;
}

function updateMonthlyRangeFromMonth() {
  if (!relatorioMes || !relatorioInicioMensal || !relatorioFimMensal) {
    return;
  }
  if (!relatorioMes.value) {
    return;
  }
  const [anoStr, mesStr] = relatorioMes.value.split("-");
  const ano = Number(anoStr);
  const mes = Number(mesStr);
  if (!ano || !mes) {
    return;
  }
  const inicio = new Date(ano, mes - 1, 1);
  const fim = new Date(ano, mes, 0);
  relatorioInicioMensal.value = formatDateISO(inicio);
  relatorioFimMensal.value = formatDateISO(fim);
}

function getMonthlyRange() {
  if (relatorioInicioMensal && relatorioFimMensal && relatorioInicioMensal.value && relatorioFimMensal.value) {
    const inicio = parseDate(relatorioInicioMensal.value);
    const fim = parseDate(relatorioFimMensal.value);
    if (inicio && fim) {
      return { start: startOfDay(inicio), end: startOfDay(fim) };
    }
  }
  if (relatorioMes && relatorioMes.value) {
    updateMonthlyRangeFromMonth();
    const inicio = parseDate(relatorioInicioMensal ? relatorioInicioMensal.value : "");
    const fim = parseDate(relatorioFimMensal ? relatorioFimMensal.value : "");
    if (inicio && fim) {
      return { start: startOfDay(inicio), end: startOfDay(fim) };
    }
  }
  const hoje = startOfDay(new Date());
  return { start: hoje, end: hoje };
}

function gerarRelatorioMensalHtml(range) {
  const periodoLabel = `${formatDate(range.start)} - ${formatDate(range.end)}`;
  const filtrados = filtrarRelatorioLista(manutencoes, { start: range.start, end: range.end });
  const clienteProjeto = getActiveProjectClient();
  const titulo = `Relatório mensal (${relatorioCliente ? relatorioCliente.value || clienteProjeto : clienteProjeto})`;
  return buildRelatorioResumoHtml(titulo, periodoLabel, filtrados);
}

function exportarRelatoriosPdf() {
  const filtros = getRelatorioFiltros();
  const filtrados = filtrarRelatorioLista(manutencoes, filtros);
  const periodoLabel = `${formatDate(filtros.start)} - ${formatDate(filtros.end)}`;
  const html = buildRelatorioResumoHtml("Central de relatórios", periodoLabel, filtrados);
  return abrirJanelaRelatorio(html, "Relatório - OPSCOPE", true);
}

function gerarResumoMensal() {
  const range = getMonthlyRange();
  const filtrados = filtrarRelatorioLista(manutencoes, { start: range.start, end: range.end });
  atualizarResumoRelatorios(filtrados);
  const periodoLabel = `${formatDate(range.start)} - ${formatDate(range.end)}`;
  const html = buildRelatorioResumoHtml("Resumo mensal", periodoLabel, filtrados);
  return abrirJanelaRelatorio(html, "Resumo mensal - OPSCOPE", false);
}

function previewRelatorioMensal() {
  const range = getMonthlyRange();
  const html = gerarRelatorioMensalHtml(range);
  return abrirJanelaRelatorio(html, "Relatório mensal - OPSCOPE", false);
}

function exportarRelatorioMensal() {
  const range = getMonthlyRange();
  const html = gerarRelatorioMensalHtml(range);
  return abrirJanelaRelatorio(html, "Relatório mensal - OPSCOPE", true);
}

function gerarRdoMensal(imprimir = false, returnHtml = false) {
  const range = getMonthlyRange();
  const periodoLabel = `${formatDate(range.start)} - ${formatDate(range.end)}`;
  const rdos = rdoSnapshots
    .filter((item) => {
      const data = item.rdoDate ? parseDate(item.rdoDate) : null;
      return data ? inRange(startOfDay(data), range.start, range.end) : false;
    })
    .sort((a, b) => (getTimeValue(parseDate(b.rdoDate)) || 0) - (getTimeValue(parseDate(a.rdoDate)) || 0));

  const manutencoesPeriodo = filtrarRelatorioLista(manutencoes, {
    start: range.start,
    end: range.end,
  });
  const acumulado = rdos.reduce(
    (acc, item) => {
      const metricas = item.metricas || {};
      acc.totalRdos += 1;
      acc.atividades += metricas.total || 0;
      acc.concluidas += metricas.concluidas || 0;
      acc.emExecucao += metricas.emExecucao || 0;
      acc.criticas += metricas.criticas || 0;
      acc.overdue += metricas.overdue || 0;
      acc.docsOk += metricas.docsOk || 0;
      acc.docsTotal += metricas.docsTotal || 0;
      acc.tempoTotal += metricas.tempoTotalMin || 0;
      acc.evidencias += item.evidenciasTotal || (Array.isArray(item.evidencias) ? item.evidencias.length : 0);
      return acc;
    },
    {
      totalRdos: 0,
      atividades: 0,
      concluidas: 0,
      emExecucao: 0,
      criticas: 0,
      overdue: 0,
      abertas: 0,
      docsOk: 0,
      docsTotal: 0,
      tempoTotal: 0,
      evidencias: 0,
    }
  );
  acumulado.abertas = rdos.reduce((acc, item) => acc + ((item.metricas && item.metricas.abertas) || 0), 0);

  const docsPercent = acumulado.docsTotal
    ? Math.round((acumulado.docsOk / acumulado.docsTotal) * 100)
    : 0;
  const slaPercent = acumulado.atividades
    ? Math.round(((acumulado.atividades - acumulado.overdue) / acumulado.atividades) * 100)
    : 0;
  const tempoTotalLabel = acumulado.tempoTotal
    ? formatDuracaoMin(acumulado.tempoTotal)
    : "-";
  const cliente = relatorioCliente ? relatorioCliente.value || clienteProjeto : clienteProjeto;
  const projetoAtivo = getActiveProject();
  const projetoLabel = projetoAtivo ? getProjectLabel(projetoAtivo) : RDO_PROJETO;
  const hashMensal = hashString(`${periodoLabel}|${acumulado.totalRdos}|${cliente}`).slice(0, 8).toUpperCase();
  const emissor = currentUser ? getUserLabel(currentUser.id) : "Sistema";
  const topSubestacoes = rdos.reduce((acc, item) => {
    const sub = item.filtros && item.filtros.subestacao ? item.filtros.subestacao : "";
    if (!sub) {
      return acc;
    }
    acc[sub] = (acc[sub] || 0) + ((item.metricas && item.metricas.total) || 0);
    return acc;
  }, {});
  const topSubResumo = Object.keys(topSubestacoes)
    .map((key) => ({ key, total: topSubestacoes[key] }))
    .sort((a, b) => b.total - a.total)
    .slice(0, 3)
    .map((item) => `${item.key} (${item.total})`)
    .join(", ");
  const resumoExec = acumulado.totalRdos
    ? `No período foram consolidados ${acumulado.totalRdos} RDOs, com ${acumulado.atividades} atividades, ${acumulado.concluidas} concluídas e ${acumulado.overdue} overdue. ${
        topSubResumo ? `Subestacoes com maior volume: ${topSubResumo}.` : ""
      }`
    : "Nenhum RDO encontrado no período selecionado.";

  const segurancaResumo = rdos.reduce(
    (acc, item) => {
      const manual = item.manual || {};
      const incidente = String(manual.incidente || "").toUpperCase();
      const bloqueio = String(manual.bloqueio || "").toUpperCase();
      if (incidente && incidente !== "NAO" && incidente !== "N/A") {
        acc.incidentes += 1;
      }
      if (bloqueio && bloqueio !== "N/A" && bloqueio !== "NAO") {
        acc.bloqueios += 1;
      }
      const clima = (manual.clima || "").trim();
      if (clima) {
        acc.climas[clima] = (acc.climas[clima] || 0) + 1;
      }
      const kmInicial = Number.parseFloat(manual.kmInicial || "");
      const kmFinal = Number.parseFloat(manual.kmFinal || "");
      if (Number.isFinite(kmInicial) && Number.isFinite(kmFinal) && kmFinal >= kmInicial) {
        acc.kmTotal += kmFinal - kmInicial;
      }
      const qtPessoas = Number.parseFloat(manual.qtPessoas || "");
      if (Number.isFinite(qtPessoas) && qtPessoas > 0) {
        acc.qtPessoasTotal += qtPessoas;
        acc.qtPessoasCount += 1;
      }
      const condutor = manual.condutor ? String(manual.condutor).trim() : "";
      if (condutor) {
        acc.condutores.add(condutor);
      }
      return acc;
    },
    {
      incidentes: 0,
      bloqueios: 0,
      climas: {},
      kmTotal: 0,
      qtPessoasTotal: 0,
      qtPessoasCount: 0,
      condutores: new Set(),
    }
  );
  const climaTop = Object.keys(segurancaResumo.climas)
    .map((key) => ({ key, total: segurancaResumo.climas[key] }))
    .sort((a, b) => b.total - a.total)[0];
  const pessoasMedia = segurancaResumo.qtPessoasCount
    ? Math.round(segurancaResumo.qtPessoasTotal / segurancaResumo.qtPessoasCount)
    : 0;

  const docsMensais = manutencoesPeriodo.reduce(
    (acc, item) => {
      const docs = getItemDocs(item) || {};
      DOC_KEYS.forEach((key) => {
        if (key === "pt" && !isItemCritico(item)) {
          return;
        }
        if (docs[key]) {
          acc[key] += 1;
        }
      });
      return acc;
    },
    { apr: 0, os: 0, pte: 0, pt: 0 }
  );
  const equipesAtivas = new Set(
    manutencoesPeriodo.map((item) => getRelatorioResponsavel(item)).filter(Boolean)
  );
  const concluidasPeriodo = manutencoesPeriodo.filter((item) => item.status === "concluida");
  const pontuaisPeriodo = concluidasPeriodo.filter((item) => {
    const data = parseDate(item.data);
    const doneAt = parseTimestamp(item.doneAt);
    if (!data || !doneAt) {
      return false;
    }
    return startOfDay(doneAt) <= startOfDay(data);
  });
  const pontualidadeEquipe = concluidasPeriodo.length
    ? Math.round((pontuaisPeriodo.length / concluidasPeriodo.length) * 100)
    : 0;
  const criticasCount = manutencoesPeriodo.filter(
    (item) => item.critico || (item.prioridade || "").toLowerCase() === "critica"
  ).length;

  const daysTotal = Math.max(1, diffInDays(range.start, range.end) + 1);
  const dailySeries = Array.from({ length: daysTotal }, (_, index) => {
    const dia = addDays(range.start, index);
    return {
      date: dia,
      label: formatDate(dia),
      total: 0,
      backlog: 0,
      concluidas: 0,
      overdue: 0,
    };
  });
  manutencoesPeriodo.forEach((item) => {
    const dataRef = getRelatorioItemDate(item);
    if (!dataRef) {
      return;
    }
    const dia = startOfDay(dataRef);
    const diff = diffInDays(range.start, dia);
    if (diff < 0 || diff >= dailySeries.length) {
      return;
    }
    dailySeries[diff].total += 1;
    if (item.status === "concluida") {
      dailySeries[diff].concluidas += 1;
    }
    if (item.status === "backlog") {
      dailySeries[diff].backlog += 1;
    }
    if (isItemOverdue(item, range.end)) {
      dailySeries[diff].overdue += 1;
    }
  });
  const maxDaily = dailySeries.reduce((max, item) => Math.max(max, item.total), 1);
  const chartWidth = 560;
  const chartHeight = 140;
  const barWidth = dailySeries.length ? Math.max(12, Math.floor(chartWidth / dailySeries.length) - 6) : 12;
  const barGap = 6;
  const bars = dailySeries
    .map((item, index) => {
      const height = Math.round((item.total / maxDaily) * (chartHeight - 40));
      const x = index * (barWidth + barGap);
      const y = chartHeight - height - 20;
      return `<g>
        <rect x="${x}" y="${y}" width="${barWidth}" height="${height}" fill="#5b8def" rx="4" />
      </g>`;
    })
    .join("");
  const chartSvg = `
    <svg class="rdo-chart" viewBox="0 0 ${chartWidth} ${chartHeight}" role="img" aria-label="Volume diário">
      <rect x="0" y="0" width="${chartWidth}" height="${chartHeight}" fill="#f8f6f1" rx="12" />
      <line x1="0" y1="${chartHeight - 20}" x2="${chartWidth}" y2="${chartHeight - 20}" stroke="#d9d4c8" />
      ${bars}
    </svg>
  `;
  const statusTotals = manutencoesPeriodo.reduce(
    (acc, item) => {
      acc.total += 1;
      acc[item.status] = (acc[item.status] || 0) + 1;
      return acc;
    },
    { total: 0 }
  );
  const totalDistribuicao = Math.max(1, manutencoesPeriodo.length);
  const statusConcluidas = statusTotals.concluida || 0;
  const statusExecucao = statusTotals.em_execucao || 0;
  const statusAbertas = (statusTotals.agendada || 0) + (statusTotals.liberada || 0);
  const statusBacklog = statusTotals.backlog || 0;
  const percConclusao = Math.round((statusConcluidas / totalDistribuicao) * 100);
  const percExecucao = Math.round((statusExecucao / totalDistribuicao) * 100);
  const percAbertas = Math.round((statusAbertas / totalDistribuicao) * 100);
  const percOverdue = Math.round((statusBacklog / totalDistribuicao) * 100);
  const donutSvg = `
    <svg class="rdo-donut" viewBox="0 0 120 120" role="img" aria-label="Distribuição de status">
      <circle cx="60" cy="60" r="46" fill="none" stroke="#e5e1d6" stroke-width="16" />
      <circle cx="60" cy="60" r="46" fill="none" stroke="#4bd28f" stroke-width="16"
        stroke-dasharray="${percConclusao} ${100 - percConclusao}" stroke-dashoffset="25" />
      <circle cx="60" cy="60" r="46" fill="none" stroke="#5b8def" stroke-width="16"
        stroke-dasharray="${percExecucao} ${100 - percExecucao}" stroke-dashoffset="${25 - percConclusao}" />
      <circle cx="60" cy="60" r="46" fill="none" stroke="#f6c453" stroke-width="16"
        stroke-dasharray="${percAbertas} ${100 - percAbertas}" stroke-dashoffset="${25 - percConclusao - percExecucao}" />
      <circle cx="60" cy="60" r="46" fill="none" stroke="#e2595c" stroke-width="16"
        stroke-dasharray="${percOverdue} ${100 - percOverdue}" stroke-dashoffset="${25 - percConclusao - percExecucao - percAbertas}" />
    </svg>
  `;

  const statusItems = [
    { key: "concluida", label: "Concluídas", color: "#4bd28f" },
    { key: "em_execucao", label: "Em execução", color: "#5b8def" },
    { key: "liberada", label: "Liberadas", color: "#9aa4af" },
    { key: "agendada", label: "Agendadas", color: "#f6c453" },
    { key: "backlog", label: "Backlog", color: "#e2595c" },
  ];
  const statusMax = statusItems.reduce((max, item) => Math.max(max, statusTotals[item.key] || 0), 1);
  const statusBars = statusItems
    .map((item, index) => {
      const height = Math.round(((statusTotals[item.key] || 0) / statusMax) * 90);
      const x = index * 52;
      const y = 110 - height;
      return `<g>
        <rect x="${x}" y="${y}" width="40" height="${height}" fill="${item.color}" rx="6" />
        <text x="${x + 20}" y="125" text-anchor="middle" font-size="9" fill="#5c6772">${escapeHtml(
          String(statusTotals[item.key] || 0)
        )}</text>
      </g>`;
    })
    .join("");
  const statusChart = `
    <svg class="rdo-chart" viewBox="0 0 260 140" role="img" aria-label="Manutenções por status">
      <rect x="0" y="0" width="260" height="140" fill="#f8f6f1" rx="12" />
      ${statusBars}
    </svg>
  `;

  const backlogLineMax = dailySeries.reduce((max, item) => Math.max(max, item.backlog), 1);
  const linePoints = dailySeries
    .map((item, index) => {
      const x = (index / Math.max(1, dailySeries.length - 1)) * 520 + 20;
      const y = 120 - Math.round((item.backlog / backlogLineMax) * 80);
      return `${x},${y}`;
    })
    .join(" ");
  const backlogChart = `
    <svg class="rdo-chart" viewBox="0 0 560 140" role="img" aria-label="Evolução diária do backlog">
      <rect x="0" y="0" width="560" height="140" fill="#f8f6f1" rx="12" />
      <polyline fill="none" stroke="#e2595c" stroke-width="3" points="${linePoints}" />
    </svg>
  `;

  const tipoDistribuicao = manutencoesPeriodo.reduce((acc, item) => {
    const tipo = (item.categoria || "N\u00e3o informado").toLowerCase();
    acc[tipo] = (acc[tipo] || 0) + 1;
    return acc;
  }, {});
  const tiposOrdenados = Object.keys(tipoDistribuicao)
    .map((key, index) => ({
      key,
      total: tipoDistribuicao[key],
      color: ["#4bd28f", "#5b8def", "#f6c453", "#e2595c", "#9a6bff"][index % 5],
    }))
    .sort((a, b) => b.total - a.total)
    .slice(0, 5);
  const totalTipos = tiposOrdenados.reduce((acc, item) => acc + item.total, 0) || 1;
  let offset = 25;
  const pieSlices = tiposOrdenados
    .map((item) => {
      const percent = Math.round((item.total / totalTipos) * 100);
      const slice = `
        <circle cx="60" cy="60" r="46" fill="none" stroke="${item.color}" stroke-width="16"
          stroke-dasharray="${percent} ${100 - percent}" stroke-dashoffset="${offset}" />
      `;
      offset -= percent;
      return slice;
    })
    .join("");
  const pieChart = `
    <svg class="rdo-donut" viewBox="0 0 120 120" role="img" aria-label="Distribuição por tipo">
      <circle cx="60" cy="60" r="46" fill="none" stroke="#e5e1d6" stroke-width="16" />
      ${pieSlices}
    </svg>
  `;
  const pieLegend = tiposOrdenados
    .map(
      (item) =>
        `<span><i class="legend-dot" style="background:${item.color}"></i>${escapeHtml(
          item.key
        )} (${item.total})</span>`
    )
    .join("");

  const slaMensal = manutencoesPeriodo.filter((item) => item.status === "concluida");
  const slaNoPrazo = slaMensal.filter((item) => {
    const data = parseDate(item.data);
    const doneAt = parseTimestamp(item.doneAt);
    if (!data || !doneAt) {
      return false;
    }
    return startOfDay(doneAt) <= startOfDay(data);
  });
  const slaMensalPercent = slaMensal.length
    ? Math.round((slaNoPrazo.length / slaMensal.length) * 100)
    : 0;
  const slaChart = `
    <div class="rdo-month__sla">
      <div class="rdo-month__sla-bar">
        <span style="width:${slaMensalPercent}%">${slaMensalPercent}% no prazo</span>
      </div>
      <small>${100 - slaMensalPercent}% fora do SLA</small>
    </div>
  `;

  const backlogRate = manutencoesPeriodo.length
    ? Math.round(((statusTotals.backlog || 0) / manutencoesPeriodo.length) * 100)
    : 0;
  const criticasRate = manutencoesPeriodo.length
    ? Math.round(
        manutencoesPeriodo.filter(
          (item) => item.critico || (item.prioridade || "").toLowerCase() === "critica"
        ).length /
          manutencoesPeriodo.length *
          100
      )
    : 0;
  const tempoMedioExec = slaMensal.length
    ? formatDuracaoMin(
        Math.round(
          manutencoesPeriodo.reduce((acc, item) => {
            const duracao = item.conclusao && Number.isFinite(item.conclusao.duracaoMin)
              ? item.conclusao.duracaoMin
              : 0;
            return acc + duracao;
          }, 0) / Math.max(1, slaMensal.length)
        )
      )
    : "-";
  const prevMonthStart = new Date(range.start.getFullYear(), range.start.getMonth() - 1, 1);
  const prevMonthEnd = new Date(range.start.getFullYear(), range.start.getMonth(), 0);
  const prevRdos = rdoSnapshots.filter((item) => {
    const data = item.rdoDate ? parseDate(item.rdoDate) : null;
    return data ? inRange(startOfDay(data), startOfDay(prevMonthStart), startOfDay(prevMonthEnd)) : false;
  });
  const prevTotal = prevRdos.reduce((acc, item) => acc + ((item.metricas && item.metricas.total) || 0), 0);
  const tendencia = prevTotal
    ? manutencoesPeriodo.length > prevTotal
      ? "↑"
      : manutencoesPeriodo.length < prevTotal
        ? "↓"
        : "→"
    : "→";

  const linhas = rdos
    .map((item) => {
      const dataLabel = item.rdoDate ? formatDate(parseDate(item.rdoDate)) : "-";
      const filtros = item.filtros || {};
      const metricas = item.metricas || {};
      return `<tr>
        <td>${escapeHtml(dataLabel)}</td>
        <td>${escapeHtml(filtros.subestacao || "-")}</td>
        <td>${escapeHtml(filtros.categoria || "-")}</td>
        <td>${escapeHtml(filtros.prioridade || "-")}</td>
        <td>${escapeHtml(filtros.usuario || "-")}</td>
        <td>${escapeHtml(String(metricas.total || 0))}</td>
        <td>${escapeHtml(String(metricas.concluidas || 0))}</td>
        <td>${escapeHtml(String(metricas.criticas || 0))}</td>
      </tr>`;
    })
    .join("");
  const resumoDiaTotals = rdos.reduce(
    (acc, item) => {
      const metricas = item.metricas || {};
      acc.total += metricas.total || 0;
      acc.concluidas += metricas.concluidas || 0;
      acc.criticas += metricas.criticas || 0;
      return acc;
    },
    { total: 0, concluidas: 0, criticas: 0 }
  );

  const blocos = rdos
    .map((item) => {
      const dataLabel = item.rdoDate ? formatDate(parseDate(item.rdoDate)) : "-";
      const emitidoEm = item.createdAt ? formatDateTime(parseTimestamp(item.createdAt)) : "-";
      const emitidoPor = item.createdBy ? getUserLabel(item.createdBy) : "Sistema";
      const filtros = item.filtros || {};
      const manual = item.manual || {};
      const metricas = item.metricas || {};
      const resumo = item.resumoDia || "-";
      const narrativa = item.narrativaDia || "-";
      const docsPercentDia =
        metricas.docsTotal && metricas.docsPercent !== null
          ? `${metricas.docsPercent}%`
          : metricas.docsTotal
            ? `${Math.round((metricas.docsOk / metricas.docsTotal) * 100)}%`
            : "-";
      const isEmpty = !metricas.total;
      return `
        <details class="rdo-month__day" ${isEmpty ? "" : "open"}>
          <summary class="rdo-month__day-head">
            <div>
              <strong>RDO ${escapeHtml(dataLabel)}</strong>
              <span>Emitido em ${escapeHtml(emitidoEm)} por ${escapeHtml(emitidoPor)}</span>
            </div>
            <span class="rdo-badge">Atividades: ${escapeHtml(String(metricas.total || 0))}</span>
          </summary>
          ${isEmpty ? "<p>Sem atividades registradas neste dia.</p>" : ""}
          <div class="rdo-month__grid">
            <div>
              <span>Subestação</span>
              <strong>${escapeHtml(filtros.subestacao || "-")}</strong>
            </div>
            <div>
              <span>Categoria</span>
              <strong>${escapeHtml(filtros.categoria || "-")}</strong>
            </div>
            <div>
              <span>Prioridade</span>
              <strong>${escapeHtml(filtros.prioridade || "-")}</strong>
            </div>
            <div>
              <span>Usuário</span>
              <strong>${escapeHtml(filtros.usuario || "-")}</strong>
            </div>
            <div>
              <span>Local</span>
              <strong>${escapeHtml(manual.local || "-")}</strong>
            </div>
            <div>
              <span>Condutor</span>
              <strong>${escapeHtml(manual.condutor || "-")}</strong>
            </div>
            <div>
              <span>KM inicial/final</span>
              <strong>${escapeHtml(manual.kmInicial || "-")} / ${escapeHtml(manual.kmFinal || "-")}</strong>
            </div>
            <div>
              <span>Qt. pessoas</span>
              <strong>${escapeHtml(manual.qtPessoas || "-")}</strong>
            </div>
            <div>
              <span>Clima</span>
              <strong>${escapeHtml(
                manual.clima === "OUTRO" && manual.climaOutro ? `OUTRO - ${manual.climaOutro}` : manual.clima || "-"
              )}</strong>
            </div>
            <div>
              <span>Incidente</span>
              <strong>${escapeHtml(manual.incidente || "-")}</strong>
            </div>
            <div>
              <span>Bloqueio elétrico</span>
              <strong>${escapeHtml(manual.bloqueio || "-")}</strong>
            </div>
            <div>
              <span>SI / SGI</span>
              <strong>${escapeHtml(manual.numeroSi || "-")} / ${escapeHtml(manual.numeroSgi || "-")}</strong>
            </div>
            <div>
              <span>Concluídas</span>
              <strong>${escapeHtml(String(metricas.concluidas || 0))}</strong>
            </div>
            <div>
              <span>Em execução</span>
              <strong>${escapeHtml(String(metricas.emExecucao || 0))}</strong>
            </div>
            <div>
              <span>Críticas</span>
              <strong>${escapeHtml(String(metricas.criticas || 0))}</strong>
            </div>
            <div>
              <span>Overdue</span>
              <strong>${escapeHtml(String(metricas.overdue || 0))}</strong>
            </div>
            <div>
              <span>Docs</span>
              <strong>${escapeHtml(docsPercentDia)}</strong>
            </div>
            <div>
              <span>Tempo total</span>
              <strong>${escapeHtml(
                metricas.tempoTotalMin && metricas.tempoTotalMin > 0
                  ? formatDuracaoMin(metricas.tempoTotalMin)
                  : "-"
              )}</strong>
            </div>
          </div>
          <div class="rdo-month__notes">
            <div>
              <h4>Resumo do dia</h4>
              <p>${escapeHtml(resumo)}</p>
            </div>
            <div>
              <h4>Narrativa técnica</h4>
              <p>${escapeHtml(narrativa)}</p>
            </div>
          </div>
        </details>
      `;
    })
    .join("");

  const html = `
    <div class="rdo-month rdo-doc">
      <header class="rdo-header">
          <div class="rdo-brand">
            <div class="rdo-brand__row">
              <img class="rdo-logo" src="./assets/engelmig-logo.png" alt="ENGELMIG" width="110" height="40" />
              <div>
                <span class="rdo-eyebrow">OPSCOPE</span>
                <h2 class="rdo-title">RELATÓRIO MENSAL DE OPERAÇÃO</h2>
                <p class="rdo-subtitle">Consolidado executivo do período</p>
              </div>
            </div>
          </div>
        <div class="rdo-meta">
          <span>RDO-M: ${escapeHtml(hashMensal)}</span>
          <span>Período: ${escapeHtml(periodoLabel)}</span>
          <span>Cliente: ${escapeHtml(cliente)}</span>
          <span>Emitido por: ${escapeHtml(emissor)}</span>
          <span>Emitido em: ${escapeHtml(formatDateTime(new Date()))}</span>
        </div>
      </header>
      <div class="rdo-header-info">
        <div>
          <span>Projeto/Planta</span>
          <strong>${escapeHtml(projetoLabel)}</strong>
        </div>
        <div>
          <span>Cliente</span>
          <strong>${escapeHtml(cliente)}</strong>
        </div>
        <div>
          <span>Setor</span>
          <strong>${escapeHtml(RDO_SETOR)}</strong>
        </div>
        <div>
          <span>Local</span>
          <strong>Consolidado</strong>
        </div>
      </div>
      <section class="rdo-section rdo-summary">
        <h3>Resumo Executivo</h3>
        <p>${escapeHtml(resumoExec)}</p>
        <div class="rdo-summary-grid rdo-summary-grid--cards">
          <div class="rdo-summary-item"><span>RDOs</span><strong>${acumulado.totalRdos}</strong></div>
          <div class="rdo-summary-item"><span>Atividades</span><strong>${manutencoesPeriodo.length}</strong></div>
          <div class="rdo-summary-item"><span>Concluídas</span><strong>${statusConcluidas}</strong></div>
          <div class="rdo-summary-item"><span>Em execução</span><strong>${statusExecucao}</strong></div>
          <div class="rdo-summary-item"><span>Críticas</span><strong>${criticasCount}</strong></div>
          <div class="rdo-summary-item"><span>Backlog</span><strong>${statusBacklog}</strong></div>
          <div class="rdo-summary-item"><span>Docs OK</span><strong>${docsPercent}%</strong></div>
          <div class="rdo-summary-item"><span>SLA no prazo</span><strong>${slaPercent}%</strong></div>
          <div class="rdo-summary-item"><span>Evidências</span><strong>${acumulado.evidencias}</strong></div>
          <div class="rdo-summary-item"><span>Tempo total</span><strong>${tempoTotalLabel}</strong></div>
        </div>
      </section>
      <section class="rdo-section rdo-block">
        <h3>KPIs Gerenciais</h3>
        <div class="rdo-kpi-grid">
          <div class="rdo-kpi-card rdo-kpi-card--ok"><span>SLA mensal</span><strong>${slaPercent}%</strong></div>
          <div class="rdo-kpi-card rdo-kpi-card--warn"><span>Taxa de backlog</span><strong>${backlogRate}%</strong></div>
          <div class="rdo-kpi-card rdo-kpi-card--danger"><span>Taxa de críticas</span><strong>${criticasRate}%</strong></div>
          <div class="rdo-kpi-card rdo-kpi-card--info"><span>Tempo médio de execução</span><strong>${tempoMedioExec}</strong></div>
          <div class="rdo-kpi-card rdo-kpi-card--neutral"><span>Tendência</span><strong>${tendencia}</strong></div>
        </div>
      </section>
      <section class="rdo-section rdo-block rdo-month__charts">
        <div>
          <h4>Volume diário de atividades</h4>
          ${chartSvg}
          <small>Conta de manutenções registradas por dia no período.</small>
        </div>
        <div>
          <h4>Manutenções por status</h4>
          ${statusChart}
          <small>Distribuição de status (concluídas, backlog, agendadas).</small>
        </div>
        <div>
          <h4>Distribuição de status</h4>
          <div class="rdo-month__donut">
            ${donutSvg}
            <div class="rdo-legend">
              <span><i class="legend-dot legend-dot--ok"></i>Concluídas (${percConclusao}%)</span>
              <span><i class="legend-dot legend-dot--info"></i>Em execução (${percExecucao}%)</span>
              <span><i class="legend-dot legend-dot--warn"></i>Abertas (${percAbertas}%)</span>
              <span><i class="legend-dot legend-dot--danger"></i>Backlog (${percOverdue}%)</span>
            </div>
          </div>
          <small>Percentual consolidado do mês por status operacional.</small>
        </div>
        <div>
          <h4>Evolução diária do backlog</h4>
          ${backlogChart}
          <small>Backlog diário com base nas OS atrasadas.</small>
        </div>
        <div>
          <h4>Distribuição por tipo</h4>
          <div class="rdo-month__donut">
            ${pieChart}
            <div class="rdo-legend">
              ${pieLegend}
            </div>
          </div>
          <small>Tipos de manutenção predominantes no período.</small>
        </div>
        <div>
          <h4>SLA mensal</h4>
          ${slaChart}
          <small>Percentual de concluída no prazo vs fora do SLA.</small>
        </div>
      </section>
      <section class="rdo-section rdo-block">
        <h3>Segurança e logística</h3>
        <div class="rdo-month__grid">
          <div><span>Incidentes</span><strong>${segurancaResumo.incidentes}</strong></div>
          <div><span>Bloqueios elétricos</span><strong>${segurancaResumo.bloqueios}</strong></div>
          <div><span>Clima dominante</span><strong>${escapeHtml(climaTop ? climaTop.key : "-")}</strong></div>
          <div><span>KM total</span><strong>${segurancaResumo.kmTotal.toFixed(1)}</strong></div>
          <div><span>Qt. pessoas (média)</span><strong>${pessoasMedia}</strong></div>
          <div><span>Condutores</span><strong>${segurancaResumo.condutores.size}</strong></div>
          <div><span>APR abertas</span><strong>${docsMensais.apr}</strong></div>
          <div><span>OS abertas</span><strong>${docsMensais.os}</strong></div>
          <div><span>PTE abertas</span><strong>${docsMensais.pte}</strong></div>
          <div><span>PT abertas</span><strong>${docsMensais.pt}</strong></div>
        </div>
      </section>
      <section class="rdo-section rdo-block">
        <h3>Desenvolvimento da equipe ENGELMIG</h3>
        <div class="rdo-month__grid">
          <div><span>Projeto</span><strong>${escapeHtml(projetoLabel)}</strong></div>
          <div><span>Equipes ativas</span><strong>${equipesAtivas.size}</strong></div>
          <div><span>Execuções concluídas</span><strong>${concluidasPeriodo.length}</strong></div>
          <div><span>Pontualidade</span><strong>${pontualidadeEquipe}%</strong></div>
          <div><span>Backlog</span><strong>${backlogRate}%</strong></div>
          <div><span>Evolução mensal</span><strong>${tendencia}</strong></div>
        </div>
        <p>
          Evolução técnica do time com foco em disciplina operacional, entrega no prazo e maturidade de processos.
        </p>
      </section>
      <section class="rdo-section rdo-block">
        <h3>Resumo operacional por dia</h3>
        <div class="report-table__wrap">
          <table class="report__table">
            <thead>
              <tr>
                <th>Data</th>
                <th>Subestação</th>
              <th>Categoria</th>
              <th>Prioridade</th>
              <th>Usuário</th>
              <th>Atividades</th>
              <th>Concluídas</th>
              <th>Críticas</th>
            </tr>
          </thead>
          <tbody>
            ${linhas || `<tr><td colspan="8">Nenhum RDO no período.</td></tr>`}
          </tbody>
          <tfoot>
            <tr>
              <td colspan="5">Total do período</td>
              <td>${resumoDiaTotals.total}</td>
              <td>${resumoDiaTotals.concluidas}</td>
              <td>${resumoDiaTotals.criticas}</td>
            </tr>
          </tfoot>
          </table>
        </div>
      </section>
      <section class="rdo-section rdo-block">
        <h3>Tabela consolidada</h3>
        <div class="report-table__wrap">
          <table class="report__table">
          <thead>
            <tr>
              <th>Manutenção</th>
              <th>Local</th>
              <th>Data</th>
              <th>Status</th>
              <th>Responsável</th>
              <th>Prioridade</th>
            </tr>
          </thead>
          <tbody>
            ${
              manutencoesPeriodo.length
                ? manutencoesPeriodo
                    .slice(0, 200)
                    .map((item) => {
                      const data = getRelatorioItemDate(item);
                      const label = data ? formatDate(data) : "-";
                      const responsavel = getRelatorioResponsavel(item) || "-";
                      const status = item.status || "-";
                      const statusKey = String(status).toLowerCase();
                      const prioridade = item.prioridade || "-";
                      const prioridadeKey = String(prioridade).toLowerCase();
                      return `<tr>
                        <td>${escapeHtml(item.titulo || "-")}</td>
                        <td>${escapeHtml(item.local || "-")}</td>
                        <td>${escapeHtml(label)}</td>
                        <td><span class="status-badge status-badge--${escapeHtml(
                          statusKey
                        )}">${escapeHtml(status)}</span></td>
                        <td>${escapeHtml(responsavel)}</td>
                        <td><span class="priority-badge priority-badge--${escapeHtml(
                          prioridadeKey
                        )}">${escapeHtml(prioridade)}</span></td>
                      </tr>`;
                    })
                    .join("")
                : `<tr><td colspan="6">Nenhuma manutenção no período.</td></tr>`
            }
          </tbody>
          <tfoot>
            <tr>
              <td colspan="5">Total de manutenções</td>
              <td>${manutencoesPeriodo.length}</td>
            </tr>
          </tfoot>
          </table>
        </div>
      </section>
      <section class="rdo-section rdo-note">
        <h3>Análise técnica do período</h3>
        <p>
          ${escapeHtml(
            acumulado.overdue
              ? `Foram identificadas ${acumulado.overdue} atividades overdue, indicando gargalos no fluxo de execução e necessidade de ajustes na programação.`
              : "Não foram identificadas atividades overdue no período."
          )}
        </p>
        <p>
          ${escapeHtml(
            acumulado.criticas
              ? `Houve ${acumulado.criticas} manutenções críticas; recomenda-se priorizar recursos e revisar planos de contingência.`
              : "Sem manutenções críticas registradas."
          )}
        </p>
        <p>
          ${escapeHtml(
            docsPercent < 90
              ? "O compliance documental ficou abaixo da meta; reforçar captura de evidências e checklists operacionais."
              : "Compliance documental dentro do esperado."
          )}
        </p>
      </section>
      <section class="rdo-section rdo-note">
        <h3>Conclusão gerencial</h3>
        <p>
          ${escapeHtml(
            acumulado.totalRdos
              ? `O período apresentou ${slaPercent}% de SLA no prazo, com ${acumulado.concluidas} concluídas e ${backlogRate}% de backlog. Recomenda-se manter o foco nas frentes críticas e sustentar a disciplina operacional.`
              : "Não houve movimentação operacional no período. Sem impactos registrados."
          )}
        </p>
      </section>
      <section class="rdo-section">
        <h3>Detalhamento diário</h3>
        <div class="rdo-items">
          ${blocos || `<div class="rdo-item">Nenhum RDO no período.</div>`}
        </div>
      </section>
    </div>
  `;
  if (returnHtml) {
    return html;
  }
  return abrirJanelaRelatorio(html, "RDO mensal - OPSCOPE", imprimir);
}

function abrirRdoMensalPreview() {
  if (!rdoMensalPreviewModal || !rdoMensalPreviewBody) {
    return false;
  }
  const html = gerarRdoMensal(false, true);
  rdoMensalPreviewBody.innerHTML = html;
  rdoMensalPreviewModal.hidden = false;
  return true;
}

function fecharRdoMensalPreview() {
  if (!rdoMensalPreviewModal) {
    return;
  }
  rdoMensalPreviewModal.hidden = true;
}


function montarRdoUI() {
  const painel = document.getElementById("relatorios");
  if (!painel || document.getElementById("rdoCard")) {
    return;
  }
  const card = document.createElement("section");
  card.className = "card rdo-card";
  card.id = "rdoCard";
  card.innerHTML = `
    <div class="rdo-head">
      <div>
        <h2>Relatórios Diários (RDO)</h2>
        <p class="hint">Consolide a operação do dia com texto técnico e evidências.</p>
      </div>
      <button id="btnGerarRdo" class="btn btn--primary" type="button">Gerar RDO do dia</button>
    </div>
    <div class="rdo-actions">
      <label class="rdo-toggle">
        <input id="rdoShowDeleted" type="checkbox" />
        <span>Exibir excluídos</span>
      </label>
      <button id="btnRdoExcluir" class="btn btn--danger btn--small" type="button" disabled>
        Excluir selecionados
      </button>
    </div>
    <div id="rdoList" class="rdo-list"></div>
    <p id="rdoEmpty" class="empty-state">Nenhum RDO gerado.</p>
  `;
  painel.append(card);

  const modal = document.createElement("div");
  modal.id = "modalRdo";
  modal.className = "modal";
  modal.hidden = true;
  modal.innerHTML = `
    <div class="modal__content modal__content--wide">
      <div class="modal__header">
        <div>
          <h3>Relatório Diário de Operação</h3>
          <p class="hint">Geração automática baseada na execução do dia.</p>
        </div>
        <button class="btn btn--ghost btn--small" type="button" data-rdo-close>Fechar</button>
      </div>
      <form class="modal__form">
        <div class="rdo-guide">
          <strong>Guia rápido de preenchimento</strong>
          <ul>
            <li>Use a data da execução e filtre subestação/categoria quando necessário.</li>
            <li>Informe condutor, KM e quantidade de pessoas conforme diário do veículo/equipe.</li>
            <li>Marque Acionamento/Hora extra apenas quando ocorreu e informe a janela correta.</li>
            <li>Registro gerencial é opcional; use para decisões, desvios, riscos e pendências.</li>
          </ul>
        </div>
        <div class="form-grid">
          <div class="field">
            <label for="rdoData">Data do RDO</label>
            <input id="rdoData" type="date" />
            <small class="hint hint--compact">Use a data da execução do serviço.</small>
          </div>
          <div class="field">
            <label for="rdoSubestacao">Subestação</label>
            <select id="rdoSubestacao">
              <option value="">Todas</option>
            </select>
          </div>
          <div class="field">
            <label for="rdoCategoria">Categoria</label>
            <select id="rdoCategoria">
              <option value="">Todas</option>
            </select>
          </div>
          <div class="field">
            <label for="rdoPrioridade">Prioridade</label>
            <select id="rdoPrioridade">
              <option value="">Todas</option>
            </select>
          </div>
          <div class="field">
            <label for="rdoUsuario">Usuário</label>
            <select id="rdoUsuario">
              <option value="">Todos</option>
            </select>
          </div>
          <div class="field">
            <label for="rdoLimite">Limite de evidências no PDF</label>
            <select id="rdoLimite">
              <option value="8">8</option>
              <option value="16" selected>16</option>
              <option value="32">32</option>
            </select>
            <small class="hint hint--compact">Define o número máximo de fotos no PDF.</small>
          </div>
          <div class="field">
            <label for="rdoCondutor">Condutor do veículo</label>
            <input id="rdoCondutor" type="text" />
            <small class="hint hint--compact">Nome de quem conduziu o veículo no dia.</small>
          </div>
          <div class="field">
            <label for="rdoKmInicial">KM inicial do dia</label>
            <input id="rdoKmInicial" type="number" min="0" step="0.1" />
            <small class="hint hint--compact">Informe o odômetro no início do turno.</small>
          </div>
          <div class="field">
            <label for="rdoKmFinal">KM final do dia</label>
            <input id="rdoKmFinal" type="number" min="0" step="0.1" />
            <small class="hint hint--compact">Informe o odômetro ao final do turno.</small>
          </div>
          <div class="field">
            <label for="rdoQtPessoas">Qt. pessoas na atividade</label>
            <input id="rdoQtPessoas" type="number" min="0" step="1" />
            <small class="hint hint--compact">Quantidade total de pessoas no campo.</small>
          </div>
          <div class="field">
            <label for="rdoClima">Clima</label>
            <select id="rdoClima">
              <option value="SOL">SOL</option>
              <option value="NUBLADO">NUBLADO</option>
              <option value="CHUVA">CHUVA</option>
              <option value="VENTO FORTE">VENTO FORTE</option>
              <option value="NEBLINA">NEBLINA</option>
              <option value="OUTRO">OUTRO</option>
            </select>
          </div>
          <div class="field">
            <label for="rdoLocal">Local</label>
            <select id="rdoLocal">
              <option value="">Sem locais</option>
            </select>
          </div>
          <div class="field" id="rdoClimaOutroField" hidden>
            <label for="rdoClimaOutro">Clima (outro)</label>
            <input id="rdoClimaOutro" type="text" />
          </div>
          <div class="field">
            <label for="rdoIncidente">Incidente/Acidente</label>
            <select id="rdoIncidente">
              <option value="NÃO">NAO</option>
              <option value="SIM">SIM</option>
              <option value="N/A">N/A</option>
            </select>
            <small class="hint hint--compact">Use SIM apenas se houve ocorrência.</small>
          </div>
          <div class="field">
            <label for="rdoBloqueio">Bloqueio elétrico</label>
            <select id="rdoBloqueio">
              <option value="NAO">NAO</option>
              <option value="SIM">SIM</option>
              <option value="N/A">N/A</option>
            </select>
            <small class="hint hint--compact">Use SIM apenas se houve bloqueio/LOTO.</small>
          </div>
          <div class="field">
            <label for="rdoSi">N de SI</label>
            <input id="rdoSi" type="text" />
            <small class="hint hint--compact">Número do registro de SI, se houver.</small>
          </div>
          <div class="field">
            <label for="rdoSgi">N de SGI</label>
            <input id="rdoSgi" type="text" />
            <small class="hint hint--compact">Número do registro de SGI, se houver.</small>
          </div>
        </div>
        <div class="field rdo-shift-block" data-full>
          <label id="rdoShiftLabel">Horas e acionamentos</label>
          <div class="rdo-shift-toggles">
            <label class="checkbox-field">
              <input id="rdoAcionamentoToggle" type="checkbox" />
              <span>Acionamento</span>
            </label>
            <div class="rdo-shift-time">
              <input id="rdoAcionamentoInicio" type="time" disabled />
              <input id="rdoAcionamentoFim" type="time" disabled />
            </div>
            <label class="checkbox-field">
              <input id="rdoHoraExtraToggle" type="checkbox" />
              <span>Hora extra</span>
            </label>
            <div class="rdo-shift-time">
              <input id="rdoHoraExtraInicio" type="time" disabled />
              <input id="rdoHoraExtraFim" type="time" disabled />
            </div>
          </div>
          <div class="rdo-shift-list" id="rdoJornadaList"></div>
          <small class="hint hint--compact" id="rdoShiftHint">
            Preencha entrada e saída por colaborador. Marque acionamento/hora extra apenas quando
            ocorrer e informe a janela. Expediente: 07:00-17:00 (seg-qui) e 07:00-16:00 (sex).
          </small>
        </div>
        <div class="field" data-full>
          <label for="rdoRegistro">Registro gerencial do dia</label>
          <textarea
            id="rdoRegistro"
            rows="2"
            placeholder="Opcional. Ex.: decisões, desvios, riscos e pendências."
          ></textarea>
          <small class="hint hint--compact">
            Use este espaço para decisões, desvios relevantes, riscos e pendências do dia.
          </small>
        </div>
        <p id="rdoMensagem" class="mensagem" aria-live="polite"></p>
        <div class="modal__actions">
          <button id="btnRdoPreview" class="btn btn--ghost btn--small" type="button">Preview</button>
          <button id="btnRdoExportar" class="btn btn--primary btn--small" type="button">Exportar PDF</button>
          <button id="btnRdoExportarCliente" class="btn btn--ghost btn--small" type="button">
            Exportar PDF cliente
          </button>
          <button id="btnRdoVoltar" class="btn btn--ghost btn--small" type="button">Voltar</button>
        </div>
        <div id="rdoPreview" class="rdo-preview" hidden>
          <div class="rdo-preview__head">
            <strong>Preview do RDO</strong>
            <small class="hint">Somente leitura.</small>
          </div>
          <div id="rdoPreviewBody"></div>
        </div>
      </form>
    </div>
  `;
  document.body.append(modal);

  const modalDelete = document.createElement("div");
  modalDelete.id = "modalRdoDelete";
  modalDelete.className = "modal";
  modalDelete.hidden = true;
  modalDelete.innerHTML = `
    <div class="modal__content">
      <div class="modal__header">
        <div>
          <h3>Excluir RDOs selecionados</h3>
          <p class="hint">Informe o motivo da exclusao.</p>
        </div>
        <button class="btn btn--ghost btn--small" type="button" data-rdo-delete-close>Fechar</button>
      </div>
      <form class="modal__form">
        <div class="field">
          <label for="rdoDeleteReason">Justificativa (obrigatoria)</label>
          <textarea id="rdoDeleteReason" rows="3" placeholder="Descreva o motivo"></textarea>
        </div>
        <p id="rdoDeleteMensagem" class="mensagem" aria-live="polite"></p>
        <div class="modal__actions">
          <button id="btnRdoDeleteConfirm" class="btn btn--danger btn--small" type="button">
            Confirmar exclusao
          </button>
          <button id="btnRdoDeleteCancel" class="btn btn--ghost btn--small" type="button">
            Cancelar
          </button>
        </div>
      </form>
    </div>
  `;
  document.body.append(modalDelete);

  rdoUI.card = card;
  rdoUI.list = card.querySelector("#rdoList");
  rdoUI.empty = card.querySelector("#rdoEmpty");
  rdoUI.showDeleted = card.querySelector("#rdoShowDeleted");
  rdoUI.btnExcluir = card.querySelector("#btnRdoExcluir");
  rdoUI.btnGerar = card.querySelector("#btnGerarRdo");
  rdoUI.modal = modal;
  rdoUI.data = modal.querySelector("#rdoData");
  rdoUI.subestacao = modal.querySelector("#rdoSubestacao");
  rdoUI.categoria = modal.querySelector("#rdoCategoria");
  rdoUI.prioridade = modal.querySelector("#rdoPrioridade");
  rdoUI.usuario = modal.querySelector("#rdoUsuario");
  rdoUI.registro = modal.querySelector("#rdoRegistro");
  rdoUI.limite = modal.querySelector("#rdoLimite");
  rdoUI.condutor = modal.querySelector("#rdoCondutor");
  rdoUI.kmInicial = modal.querySelector("#rdoKmInicial");
  rdoUI.kmFinal = modal.querySelector("#rdoKmFinal");
  rdoUI.qtPessoas = modal.querySelector("#rdoQtPessoas");
  rdoUI.acionamentoToggle = modal.querySelector("#rdoAcionamentoToggle");
  rdoUI.acionamentoInicio = modal.querySelector("#rdoAcionamentoInicio");
  rdoUI.acionamentoFim = modal.querySelector("#rdoAcionamentoFim");
  rdoUI.horaExtraToggle = modal.querySelector("#rdoHoraExtraToggle");
  rdoUI.horaExtraInicio = modal.querySelector("#rdoHoraExtraInicio");
  rdoUI.horaExtraFim = modal.querySelector("#rdoHoraExtraFim");
  rdoUI.jornadaList = modal.querySelector("#rdoJornadaList");
  rdoUI.clima = modal.querySelector("#rdoClima");
  rdoUI.climaOutroField = modal.querySelector("#rdoClimaOutroField");
  rdoUI.climaOutro = modal.querySelector("#rdoClimaOutro");
  rdoUI.incidente = modal.querySelector("#rdoIncidente");
  rdoUI.bloqueio = modal.querySelector("#rdoBloqueio");
  rdoUI.local = modal.querySelector("#rdoLocal");
  rdoUI.numeroSi = modal.querySelector("#rdoSi");
  rdoUI.numeroSgi = modal.querySelector("#rdoSgi");
  rdoUI.shiftLabel = modal.querySelector("#rdoShiftLabel");
  rdoUI.shiftHint = modal.querySelector("#rdoShiftHint");
  rdoUI.preview = modal.querySelector("#rdoPreview");
  rdoUI.previewBody = modal.querySelector("#rdoPreviewBody");
  rdoUI.mensagem = modal.querySelector("#rdoMensagem");
  rdoUI.btnPreview = modal.querySelector("#btnRdoPreview");
  rdoUI.btnExportar = modal.querySelector("#btnRdoExportar");
  rdoUI.btnExportarCliente = modal.querySelector("#btnRdoExportarCliente");
  rdoUI.btnFechar = modal.querySelector("[data-rdo-close]");
  rdoUI.btnVoltar = modal.querySelector("#btnRdoVoltar");
  rdoUI.deleteModal = modalDelete;
  rdoUI.deleteReason = modalDelete.querySelector("#rdoDeleteReason");
  rdoUI.deleteMensagem = modalDelete.querySelector("#rdoDeleteMensagem");
  rdoUI.btnDeleteConfirm = modalDelete.querySelector("#btnRdoDeleteConfirm");
  rdoUI.btnDeleteCancel = modalDelete.querySelector("#btnRdoDeleteCancel");

  renderRdoLocaisOptions();
  updateRdoShiftLabels();

  if (rdoUI.btnGerar) {
    rdoUI.btnGerar.addEventListener("click", () => abrirRdoModal());
  }
  if (rdoUI.btnFechar) {
    rdoUI.btnFechar.addEventListener("click", fecharRdoModal);
  }
  if (rdoUI.btnVoltar) {
    rdoUI.btnVoltar.addEventListener("click", fecharRdoModal);
  }
  if (rdoUI.btnPreview) {
    rdoUI.btnPreview.addEventListener("click", async () => {
      const snapshot = await gerarSnapshotRdo(false);
      if (snapshot) {
        renderRdoPreview(snapshot);
      }
    });
  }
  if (rdoUI.btnExportar) {
    rdoUI.btnExportar.addEventListener("click", async () => {
      const isReadOnly = rdoUI.modal && rdoUI.modal.dataset.readonly === "true";
      const snapshot = isReadOnly ? rdoPreviewSnapshot : await gerarSnapshotRdo(true);
      if (snapshot) {
        await exportarRdoPdf(snapshot);
      }
    });
  }
  if (rdoUI.btnExportarCliente) {
    rdoUI.btnExportarCliente.addEventListener("click", async () => {
      const isReadOnly = rdoUI.modal && rdoUI.modal.dataset.readonly === "true";
      const snapshot = isReadOnly ? rdoPreviewSnapshot : await gerarSnapshotRdo(true);
      if (snapshot) {
        await exportarRdoPdf(snapshot, { cliente: true });
      }
    });
  }
  if (rdoUI.showDeleted) {
    rdoUI.showDeleted.addEventListener("change", renderRdoList);
  }
  if (rdoUI.btnExcluir) {
    rdoUI.btnExcluir.addEventListener("click", abrirRdoDeleteModal);
  }
  if (rdoUI.btnDeleteCancel) {
    rdoUI.btnDeleteCancel.addEventListener("click", fecharRdoDeleteModal);
  }
  if (rdoUI.btnDeleteConfirm) {
    rdoUI.btnDeleteConfirm.addEventListener("click", confirmarDeleteRdo);
  }
  if (rdoUI.deleteModal) {
    const btnClose = rdoUI.deleteModal.querySelector("[data-rdo-delete-close]");
    if (btnClose) {
      btnClose.addEventListener("click", fecharRdoDeleteModal);
    }
  }
  if (rdoUI.clima) {
    rdoUI.clima.addEventListener("change", atualizarClimaOutroRdo);
  }
  if (rdoUI.acionamentoToggle) {
    rdoUI.acionamentoToggle.addEventListener("change", () => {
      toggleRdoHorarioFields(
        rdoUI.acionamentoToggle,
        rdoUI.acionamentoInicio,
        rdoUI.acionamentoFim
      );
    });
  }
  if (rdoUI.horaExtraToggle) {
    rdoUI.horaExtraToggle.addEventListener("change", () => {
      toggleRdoHorarioFields(
        rdoUI.horaExtraToggle,
        rdoUI.horaExtraInicio,
        rdoUI.horaExtraFim
      );
    });
  }
  if (rdoUI.qtPessoas) {
    rdoUI.qtPessoas.addEventListener("input", () => {
      rdoUI.qtPessoas.dataset.auto = "manual";
    });
  }
  const atualizarSugestao = () => atualizarSugestaoQtPessoas();
  if (rdoUI.data) {
    rdoUI.data.addEventListener("change", atualizarSugestao);
  }
  if (rdoUI.subestacao) {
    rdoUI.subestacao.addEventListener("change", atualizarSugestao);
  }
  if (rdoUI.categoria) {
    rdoUI.categoria.addEventListener("change", atualizarSugestao);
  }
  if (rdoUI.prioridade) {
    rdoUI.prioridade.addEventListener("change", atualizarSugestao);
  }
  if (rdoUI.usuario) {
    rdoUI.usuario.addEventListener("change", atualizarSugestao);
  }
  if (rdoUI.list) {
    rdoUI.list.addEventListener("click", async (event) => {
      const botao = event.target.closest("button[data-action]");
      if (!botao) {
        return;
      }
      const item = botao.closest("[data-rdo-id]");
      if (!item) {
        return;
      }
      const snapshot = rdoSnapshots.find((registro) => registro.id === item.dataset.rdoId);
      if (!snapshot) {
        return;
      }
      if (botao.dataset.action === "rdo-open") {
        abrirRdoModal(snapshot);
      }
      if (botao.dataset.action === "rdo-pdf") {
        await exportarRdoPdf(snapshot);
      }
      if (botao.dataset.action === "rdo-pdf-cliente") {
        await exportarRdoPdf(snapshot, { cliente: true });
      }
    });
    rdoUI.list.addEventListener("change", (event) => {
      const checkbox = event.target.closest("input[data-rdo-select]");
      if (!checkbox) {
        return;
      }
      const id = checkbox.dataset.rdoSelect;
      if (!id) {
        return;
      }
      if (checkbox.checked) {
        rdoSelection.add(id);
      } else {
        rdoSelection.delete(id);
      }
      atualizarRdoExcluirState();
    });
  }

  aplicarPermissoesRdo();
}

function aplicarPermissoesRdo() {
  if (!rdoUI.card) {
    return;
  }
  const podeVer = Boolean(currentUser && canViewRdo(currentUser));
  const podeGerar = Boolean(currentUser && canGerarRelatorio(currentUser));
  const podeExcluir = Boolean(currentUser && canExcluirRdo(currentUser));
  rdoUI.card.hidden = !podeVer;
  if (!podeVer) {
    return;
  }
  if (rdoUI.btnGerar) {
    rdoUI.btnGerar.disabled = !podeGerar;
    rdoUI.btnGerar.classList.toggle("is-disabled", !podeGerar);
  }
  if (rdoUI.btnExcluir) {
    rdoUI.btnExcluir.disabled = !podeExcluir;
  }
}

function renderRdoList() {
  if (!rdoUI.list || !rdoUI.empty) {
    return;
  }
  rdoUI.list.innerHTML = "";
  const showDeleted = rdoUI.showDeleted ? rdoUI.showDeleted.checked : false;
  const lista = Array.isArray(rdoSnapshots)
    ? rdoSnapshots.filter((item) => showDeleted || !item.deletedAt)
    : [];
  lista.sort((a, b) => (getTimeValue(b.createdAt) || 0) - (getTimeValue(a.createdAt) || 0));
  rdoSelection.forEach((id) => {
    if (!lista.some((item) => item.id === id)) {
      rdoSelection.delete(id);
    }
  });
  if (!lista.length) {
    rdoUI.empty.hidden = false;
    atualizarRdoExcluirState();
    return;
  }
  rdoUI.empty.hidden = true;
  lista.forEach((snapshot) => {
    const card = document.createElement("div");
    card.className = "report-item rdo-item";
    card.dataset.rdoId = snapshot.id;
    if (snapshot.deletedAt) {
      card.classList.add("rdo-item--deleted");
    }

    const selectWrap = document.createElement("div");
    selectWrap.className = "rdo-select";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.dataset.rdoSelect = snapshot.id;
    checkbox.checked = rdoSelection.has(snapshot.id);
    checkbox.disabled = Boolean(snapshot.deletedAt);
    selectWrap.append(checkbox);

    const info = document.createElement("div");
    const titulo = document.createElement("strong");
    const dataParsed = snapshot.rdoDate ? parseDate(snapshot.rdoDate) : null;
    const dataLabel = dataParsed ? formatDate(dataParsed) : "-";
    titulo.textContent = `RDO ${dataLabel}`;
    const meta = document.createElement("p");
    meta.className = "meta";
    const emitidoDate = snapshot.createdAt ? parseTimestamp(snapshot.createdAt) : null;
    const emitidoEm = emitidoDate ? formatDateTime(emitidoDate) : "-";
    const emitidoPor = snapshot.createdBy ? getUserLabel(snapshot.createdBy) : "Sistema";
    const itensCount = snapshot.itens ? snapshot.itens.length : 0;
    const deletedInfo = snapshot.deletedAt
      ? " | Excluido"
      : "";
    meta.textContent = `Emitido por ${emitidoPor} em ${emitidoEm} | Itens: ${itensCount}${deletedInfo}`;
    info.append(titulo, meta);

    const actions = document.createElement("div");
    actions.className = "report-actions";
    const btnAbrir = document.createElement("button");
    btnAbrir.type = "button";
    btnAbrir.className = "btn btn--ghost btn--small";
    btnAbrir.dataset.action = "rdo-open";
    btnAbrir.textContent = "Abrir";
    const btnPdf = document.createElement("button");
    btnPdf.type = "button";
    btnPdf.className = "btn btn--primary btn--small";
    btnPdf.dataset.action = "rdo-pdf";
    btnPdf.textContent = "Exportar PDF";
    const btnPdfCliente = document.createElement("button");
    btnPdfCliente.type = "button";
    btnPdfCliente.className = "btn btn--ghost btn--small";
    btnPdfCliente.dataset.action = "rdo-pdf-cliente";
    btnPdfCliente.textContent = "PDF cliente";
    if (snapshot.deletedAt) {
      btnPdf.disabled = true;
      btnPdfCliente.disabled = true;
    }
    actions.append(btnAbrir, btnPdf, btnPdfCliente);

    card.append(selectWrap, info, actions);
    rdoUI.list.append(card);
  });
  atualizarRdoExcluirState();
}

function atualizarRdoExcluirState() {
  if (!rdoUI.btnExcluir) {
    return;
  }
  rdoUI.btnExcluir.disabled = rdoSelection.size === 0;
}

function abrirRdoDeleteModal() {
  if (!rdoUI.deleteModal) {
    return;
  }
  if (rdoSelection.size === 0) {
    return;
  }
  if (rdoUI.deleteReason) {
    rdoUI.deleteReason.value = "";
  }
  if (rdoUI.deleteMensagem) {
    rdoUI.deleteMensagem.textContent = "";
    rdoUI.deleteMensagem.classList.remove("mensagem--erro");
  }
  rdoUI.deleteModal.hidden = false;
}

function fecharRdoDeleteModal() {
  if (!rdoUI.deleteModal) {
    return;
  }
  rdoUI.deleteModal.hidden = true;
}

function confirmarDeleteRdo() {
  if (!rdoUI.deleteReason) {
    return;
  }
  if (!currentUser || !canExcluirRdo(currentUser)) {
    mostrarMensagemRdo("Sem permissão para excluir RDO.", true);
    return;
  }
  const motivo = rdoUI.deleteReason.value.trim();
  if (!motivo) {
    if (rdoUI.deleteMensagem) {
      rdoUI.deleteMensagem.textContent = "Informe a justificativa.";
      rdoUI.deleteMensagem.classList.add("mensagem--erro");
    }
    return;
  }
  const agoraIso = toIsoUtc(new Date());
  const userId = currentUser ? currentUser.id : SYSTEM_USER_ID;
  const selecionados = new Set(rdoSelection);
  rdoSnapshots = rdoSnapshots.map((snapshot) => {
    if (!selecionados.has(snapshot.id)) {
      return snapshot;
    }
    const atualizado = {
      ...snapshot,
      deletedAt: agoraIso,
      deletedBy: userId,
      deleteReason: motivo,
    };
    logAction(
      "rdo_delete",
      { id: `rdo:${snapshot.id}`, titulo: `RDO ${snapshot.rdoDate || ""}` },
      {
        rdoId: snapshot.id,
        rdoDate: snapshot.rdoDate || "",
        motivo,
        resumo: "RDO excluido.",
      },
      userId
    );
    return atualizado;
  });
  salvarRdoSnapshots(rdoSnapshots);
  rdoSelection.clear();
  fecharRdoDeleteModal();
  renderRdoList();
}

function abrirRdoModal(snapshot) {
  if (!rdoUI.modal) {
    return;
  }
  if (!currentUser || !canViewRdo(currentUser)) {
    mostrarMensagemRdo("Sem permissão para acessar RDO.", true);
    return;
  }
  if (!snapshot && !canGerarRelatorio(currentUser)) {
    mostrarMensagemRdo("Sem permissão para gerar RDO.", true);
    return;
  }
  atualizarFiltrosRdo(manutencoes);
  const hoje = formatDateISO(new Date());
  const isReadOnly = Boolean(snapshot);
  rdoUI.modal.dataset.readonly = isReadOnly ? "true" : "false";
  rdoPreviewSnapshot = snapshot || null;
  if (rdoUI.data) {
    rdoUI.data.value = snapshot && snapshot.rdoDate ? snapshot.rdoDate : hoje;
  }
  if (rdoUI.subestacao) {
    rdoUI.subestacao.value = snapshot && snapshot.filtros ? snapshot.filtros.subestacao || "" : "";
  }
  if (rdoUI.categoria) {
    rdoUI.categoria.value = snapshot && snapshot.filtros ? snapshot.filtros.categoria || "" : "";
  }
  if (rdoUI.prioridade) {
    rdoUI.prioridade.value = snapshot && snapshot.filtros ? snapshot.filtros.prioridade || "" : "";
  }
  if (rdoUI.usuario) {
    rdoUI.usuario.value = snapshot && snapshot.filtros ? snapshot.filtros.usuario || "" : "";
  }
  if (rdoUI.registro) {
    rdoUI.registro.value = snapshot && snapshot.registroGerencial ? snapshot.registroGerencial : "";
  }
  if (rdoUI.limite) {
    rdoUI.limite.value =
      snapshot && snapshot.limiteEvidencias ? String(snapshot.limiteEvidencias) : "16";
  }
  const manual = snapshot && snapshot.manual ? snapshot.manual : {};
  if (rdoUI.condutor) {
    rdoUI.condutor.value = manual.condutor || "";
  }
  if (rdoUI.kmInicial) {
    rdoUI.kmInicial.value = manual.kmInicial || "";
  }
  if (rdoUI.kmFinal) {
    rdoUI.kmFinal.value = manual.kmFinal || "";
  }
  if (rdoUI.qtPessoas) {
    rdoUI.qtPessoas.value = manual.qtPessoas || "";
    rdoUI.qtPessoas.dataset.auto = manual.qtPessoas ? "manual" : "auto";
  }
  if (rdoUI.acionamentoToggle) {
    rdoUI.acionamentoToggle.checked = Boolean(manual.acionamento && manual.acionamento.ativo);
  }
  if (rdoUI.acionamentoInicio) {
    rdoUI.acionamentoInicio.value =
      manual.acionamento && manual.acionamento.inicio ? manual.acionamento.inicio : "";
  }
  if (rdoUI.acionamentoFim) {
    rdoUI.acionamentoFim.value =
      manual.acionamento && manual.acionamento.fim ? manual.acionamento.fim : "";
  }
  if (rdoUI.horaExtraToggle) {
    rdoUI.horaExtraToggle.checked = Boolean(manual.horaExtra && manual.horaExtra.ativo);
  }
  if (rdoUI.horaExtraInicio) {
    rdoUI.horaExtraInicio.value =
      manual.horaExtra && manual.horaExtra.inicio ? manual.horaExtra.inicio : "";
  }
  if (rdoUI.horaExtraFim) {
    rdoUI.horaExtraFim.value =
      manual.horaExtra && manual.horaExtra.fim ? manual.horaExtra.fim : "";
  }
  if (rdoUI.clima) {
    rdoUI.clima.value = manual.clima || "SOL";
  }
  if (rdoUI.climaOutro) {
    rdoUI.climaOutro.value = manual.climaOutro || "";
  }
  if (rdoUI.incidente) {
    rdoUI.incidente.value = manual.incidente || "NAO";
  }
  if (rdoUI.bloqueio) {
    rdoUI.bloqueio.value = manual.bloqueio || "N/A";
  }
  if (rdoUI.local) {
    renderRdoLocaisOptions(manual.local || "");
  }
  if (rdoUI.numeroSi) {
    rdoUI.numeroSi.value = manual.numeroSi || "";
  }
  if (rdoUI.numeroSgi) {
    rdoUI.numeroSgi.value = manual.numeroSgi || "";
  }
  renderRdoJornadas(manual);
  toggleRdoHorarioFields(rdoUI.acionamentoToggle, rdoUI.acionamentoInicio, rdoUI.acionamentoFim);
  toggleRdoHorarioFields(rdoUI.horaExtraToggle, rdoUI.horaExtraInicio, rdoUI.horaExtraFim);
  atualizarClimaOutroRdo();
  atualizarSugestaoQtPessoas();
  setRdoReadOnly(isReadOnly);
  if (rdoUI.previewBody) {
    rdoUI.previewBody.innerHTML = "";
  }
  if (snapshot) {
    renderRdoPreview(snapshot);
  } else if (rdoUI.preview) {
    rdoUI.preview.hidden = true;
  }
  if (rdoUI.btnExportar) {
    rdoUI.btnExportar.disabled = Boolean(snapshot && snapshot.deletedAt);
  }
  if (rdoUI.btnExportarCliente) {
    rdoUI.btnExportarCliente.disabled = Boolean(snapshot && snapshot.deletedAt);
  }
  mostrarMensagemRdo(isReadOnly ? "Snapshot somente leitura." : "");
  rdoUI.modal.hidden = false;
}

function fecharRdoModal() {
  if (!rdoUI.modal) {
    return;
  }
  rdoUI.modal.hidden = true;
  rdoPreviewSnapshot = null;
}

function mostrarMensagemRdo(texto, erro = false) {
  if (!rdoUI.mensagem) {
    return;
  }
  rdoUI.mensagem.textContent = texto;
  rdoUI.mensagem.classList.toggle("mensagem--erro", erro);
}

function setRdoReadOnly(readOnly) {
  const campos = [
    rdoUI.data,
    rdoUI.subestacao,
    rdoUI.categoria,
    rdoUI.prioridade,
    rdoUI.usuario,
    rdoUI.registro,
    rdoUI.limite,
    rdoUI.condutor,
    rdoUI.kmInicial,
    rdoUI.kmFinal,
    rdoUI.qtPessoas,
    rdoUI.acionamentoToggle,
    rdoUI.acionamentoInicio,
    rdoUI.acionamentoFim,
    rdoUI.horaExtraToggle,
    rdoUI.horaExtraInicio,
    rdoUI.horaExtraFim,
    rdoUI.clima,
    rdoUI.climaOutro,
    rdoUI.incidente,
    rdoUI.bloqueio,
    rdoUI.local,
    rdoUI.numeroSi,
    rdoUI.numeroSgi,
  ];
  campos.forEach((campo) => {
    if (campo) {
      campo.disabled = readOnly;
    }
  });
  if (rdoUI.btnPreview) {
    rdoUI.btnPreview.hidden = readOnly;
  }
  setRdoJornadaReadOnly(readOnly);
}

function atualizarClimaOutroRdo() {
  if (!rdoUI.clima || !rdoUI.climaOutroField) {
    return;
  }
  const isOutro = rdoUI.clima.value === "OUTRO";
  rdoUI.climaOutroField.hidden = !isOutro;
  if (!isOutro && rdoUI.climaOutro) {
    rdoUI.climaOutro.value = "";
  }
}

function renderRdoLocaisOptions(selected) {
  if (!rdoUI.local) {
    return;
  }
  const locais = getActiveProjectLocais();
  rdoUI.local.innerHTML = "";
  const selectedValue = selected ? String(selected).trim() : "";
  if (selectedValue && !locais.includes(selectedValue)) {
    const opt = document.createElement("option");
    opt.value = selectedValue;
    opt.textContent = selectedValue;
    rdoUI.local.append(opt);
  }
  if (!locais.length) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "Sem locais";
    rdoUI.local.append(opt);
    rdoUI.local.disabled = true;
    return;
  }
  rdoUI.local.disabled = false;
  locais.forEach((local) => {
    const opt = document.createElement("option");
    opt.value = local;
    opt.textContent = local;
    rdoUI.local.append(opt);
  });
  const safeSelected = selectedValue && locais.includes(selectedValue) ? selectedValue : locais[0];
  if (safeSelected) {
    rdoUI.local.value = safeSelected;
  }
}

function updateRdoShiftLabels() {
  const label = getActiveProjectShortLabel();
  if (rdoUI.shiftLabel) {
    rdoUI.shiftLabel.textContent = `Horas e acionamentos (${label})`;
  }
  if (rdoUI.shiftHint) {
    rdoUI.shiftHint.textContent = `Informe entrada e saida dos colaboradores do ${label}. Expediente: 07:00-17:00 (seg-qui) e 07:00-16:00 (sex).`;
  }
}

function getActiveProjectEquipeIds() {
  const ids = Array.isArray(projectEquipe)
    ? projectEquipe.map((entry) => entry && entry.userId).filter(Boolean)
    : [];
  return new Set(ids);
}

function hasUserProjectInfo(user) {
  if (!user) {
    return false;
  }
  const tokens = [
    user.projectId,
    user.projetoId,
    user.project_id,
    user.project,
    user.projectKey,
    user.projectCode,
    user.projectName,
    user.projectLabel,
    user.projeto,
    user.localizacao,
  ];
  if (user.project && typeof user.project === "object") {
    tokens.push(user.project.id, user.project.codigo, user.project.nome, user.project.label);
  }
  if (Array.isArray(user.projects)) {
    user.projects.forEach((entry) => {
      if (!entry) {
        return;
      }
      if (typeof entry === "string") {
        tokens.push(entry);
        return;
      }
      if (typeof entry === "object") {
        tokens.push(entry.id, entry.codigo, entry.nome, entry.label);
      }
    });
  }
  const hasToken = tokens.some((value) => {
    if (!value) {
      return false;
    }
    if (typeof value === "object") {
      return Object.values(value).some((item) =>
        /[a-z0-9]/i.test(normalizeSearchValue(item))
      );
    }
    return /[a-z0-9]/i.test(normalizeSearchValue(value));
  });
  if (hasToken) {
    return true;
  }
  return /[a-z0-9]/i.test(normalizeSearchValue(getUserProjectLabel(user)));
}

function collectActiveProjectMembers(jornadas = [], options = {}) {
  const includeAdmins = Boolean(options && options.includeAdmins);
  const requireProjectInfo = Boolean(options && options.requireProjectInfo);
  const members = new Map();
  const addUser = (user, labelOverride = "") => {
    if (!user) {
      return;
    }
    const id = String(user.id || "").trim();
    if (!id || isSystemUserId(id)) {
      return;
    }
    if (normalizeAccessUserStatus(user.status, user.active) === "INATIVO") {
      return;
    }
    if (!includeAdmins && isAdminUser(user)) {
      return;
    }
    if (requireProjectInfo && !hasUserProjectInfo(user)) {
      return;
    }
    if (members.has(id)) {
      return;
    }
    const label = String(
      labelOverride || user.name || user.username || user.matricula || ""
    ).trim();
    members.set(id, { ...user, id, label: label || user.name || id });
  };

  if (Array.isArray(projectEquipe) && projectEquipe.length) {
    projectEquipe.forEach((entry) => {
      if (!entry) {
        return;
      }
      const entryUserId = entry.userId || (entry.user && entry.user.id) || "";
      const entryUser =
        entry.user || getUserById(entryUserId) || users.find((item) => item.id === entryUserId);
      if (entryUser) {
        addUser(entryUser);
        return;
      }
      const fallbackLabel = String(entry.nome || entry.label || "").trim();
      if (entryUserId) {
        addUser({ id: entryUserId, name: fallbackLabel }, fallbackLabel);
      }
    });
  }

  const baseUsers = includeAdmins ? users : getOperationalUsers();
  baseUsers.filter(isUserFromActiveProject).forEach((user) => addUser(user));

  if (currentUser && isUserFromActiveProject(currentUser)) {
    if (includeAdmins || isRealUser(currentUser)) {
      addUser(currentUser);
    }
  }

  if (Array.isArray(jornadas) && jornadas.length) {
    jornadas.forEach((item) => {
      if (!item) {
        return;
      }
      const entryId = String(item.userId || "").trim();
      const entryLabel = String(item.nome || item.label || "").trim();
      if (entryId && !members.has(entryId)) {
        addUser({ id: entryId, name: entryLabel }, entryLabel);
      } else if (!entryId && entryLabel) {
        const syntheticId = `label:${normalizeSearchValue(entryLabel)}`;
        if (!members.has(syntheticId)) {
          addUser({ id: syntheticId, name: entryLabel }, entryLabel);
        }
      }
    });
  }

  return Array.from(members.values()).sort((a, b) =>
    String(a.label || a.name || "").localeCompare(String(b.label || b.name || ""), "pt-BR")
  );
}

function isUserFromActiveProject(user) {
  if (!user) {
    return false;
  }
  const activeProject = getActiveProject();
  const activeId = String(activeProjectId || "").trim();
  const userProjectId = String(
    user.projectId || user.projetoId || user.project_id || ""
  ).trim();
  if (activeId && userProjectId && userProjectId === activeId) {
    return true;
  }
  const equipeIds = getActiveProjectEquipeIds();
  if (equipeIds.size && user.id && equipeIds.has(user.id)) {
    return true;
  }
  const targetTokens = [
    activeId,
    activeProject ? getProjectLabel(activeProject) : "",
    activeProject ? activeProject.codigo || "" : "",
    activeProject ? activeProject.nome || "" : "",
  ]
    .map((value) => normalizeSearchValue(value))
    .filter(Boolean);
  const userTokens = [
    userProjectId,
    user.project,
    user.projectKey,
    user.projectCode,
    user.projectName,
    user.projectLabel,
    user.projeto,
    user.localizacao,
    getUserProjectLabel(user),
  ];
  if (user.project && typeof user.project === "object") {
    userTokens.push(user.project.id, user.project.codigo, user.project.nome, user.project.label);
  }
  if (Array.isArray(user.projects)) {
    user.projects.forEach((entry) => {
      if (!entry) {
        return;
      }
      if (typeof entry === "string") {
        userTokens.push(entry);
        return;
      }
      if (typeof entry === "object") {
        userTokens.push(entry.id, entry.codigo, entry.nome, entry.label);
      }
    });
  }
  const normalizedUserTokens = userTokens
    .map((value) => normalizeSearchValue(value))
    .filter(Boolean)
    .filter((token) => /[a-z0-9]/i.test(token));
  if (!targetTokens.length || !normalizedUserTokens.length) {
    return false;
  }
  return targetTokens.some((target) =>
    normalizedUserTokens.some(
      (token) => token === target || token.includes(target) || target.includes(token)
    )
  );
}

function renderRdoJornadas(manual = {}) {
  if (!rdoUI.jornadaList) {
    return;
  }
  const dataStr = rdoUI.data ? rdoUI.data.value : "";
  const dataBase = dataStr ? parseDate(dataStr) : null;
  const schedule = getRdoScheduleFromDate(dataBase || new Date());
  const jornadas = Array.isArray(manual.jornadas) ? manual.jornadas : [];
  const jornadasValidas = jornadas.filter((item) => {
    const nome = String(item && (item.nome || item.label || "")).toLowerCase();
    if (!nome) {
      return isRealUserId(item && item.userId ? item.userId : "");
    }
    if (nome.includes("administrador") || nome.includes("sistema")) {
      return false;
    }
    return true;
  });
  const jornadasMap = new Map(
    jornadasValidas.map((item) => [String(item.userId || item.nome || item.label || ""), item])
  );
  const colaboradores = collectActiveProjectMembers(jornadasValidas, {
    includeAdmins: true,
    requireProjectInfo: true,
  });

  if (!colaboradores.length && !jornadasValidas.length) {
    const label = getActiveProjectShortLabel();
    rdoUI.jornadaList.innerHTML = `<p class="empty-state">Nenhum colaborador do ${escapeHtml(label)} cadastrado.</p>`;
    return;
  }

  if (!colaboradores.length && jornadasValidas.length) {
    rdoUI.jornadaList.innerHTML = jornadasValidas
      .map((item) => {
        const label = item.nome || item.label || "Colaborador";
        return `
          <div class="rdo-shift-row" data-user-id="${escapeHtml(item.userId || "")}">
            <div class="rdo-shift-name">${escapeHtml(label)}</div>
            <div class="rdo-shift-inputs">
              <label>Entrada</label>
              <input type="time" data-shift="entrada" value="${escapeHtml(item.entrada || "")}" />
              <label>Saida</label>
              <input type="time" data-shift="saida" value="${escapeHtml(item.saida || "")}" />
            </div>
          </div>
        `;
      })
      .join("");
    return;
  }

  rdoUI.jornadaList.innerHTML = colaboradores
    .map((user) => {
      const label = user.label || getUserLabel(user.id);
      const ref =
        jornadasMap.get(String(user.id)) || jornadasMap.get(label) || jornadasMap.get(user.label) || {};
      return `
        <div class="rdo-shift-row" data-user-id="${escapeHtml(user.id)}">
          <div class="rdo-shift-name">${escapeHtml(label)}</div>
          <div class="rdo-shift-inputs">
            <label>Entrada</label>
            <input type="time" data-shift="entrada" value="${escapeHtml(
              ref.entrada || ""
            )}" placeholder="07:00" />
            <label>Saida</label>
            <input type="time" data-shift="saida" value="${escapeHtml(
              ref.saida || ""
            )}" placeholder="${schedule.fim === 16 * 60 ? "16:00" : "17:00"}" />
          </div>
        </div>
      `;
    })
    .join("");
}

function toggleRdoHorarioFields(toggle, inicio, fim) {
  if (!toggle || !inicio || !fim) {
    return;
  }
  const ativo = toggle.checked;
  inicio.disabled = !ativo;
  fim.disabled = !ativo;
  if (!ativo) {
    inicio.value = "";
    fim.value = "";
  }
}

function setRdoJornadaReadOnly(readOnly) {
  if (!rdoUI.jornadaList) {
    return;
  }
  rdoUI.jornadaList
    .querySelectorAll("input")
    .forEach((input) => (input.disabled = readOnly));
}

function coletarFiltrosRdo() {
  return {
    subestacao: rdoUI.subestacao ? rdoUI.subestacao.value : "",
    categoria: rdoUI.categoria ? rdoUI.categoria.value : "",
    prioridade: rdoUI.prioridade ? rdoUI.prioridade.value : "",
    usuario: rdoUI.usuario ? rdoUI.usuario.value : "",
  };
}

function coletarManualRdo() {
  const clima = rdoUI.clima ? rdoUI.clima.value : "";
  const jornadas = rdoUI.jornadaList
    ? Array.from(rdoUI.jornadaList.querySelectorAll(".rdo-shift-row"))
        .map((row) => {
          const entradaInput = row.querySelector("input[data-shift='entrada']");
          const saidaInput = row.querySelector("input[data-shift='saida']");
          return {
            userId: row.dataset.userId || "",
            nome: row.querySelector(".rdo-shift-name")
              ? row.querySelector(".rdo-shift-name").textContent.trim()
              : "",
            entrada: entradaInput ? entradaInput.value : "",
            saida: saidaInput ? saidaInput.value : "",
          };
        })
        .filter((item) => item.entrada || item.saida)
    : [];
  return {
    condutor: rdoUI.condutor ? rdoUI.condutor.value.trim() : "",
    kmInicial: rdoUI.kmInicial ? rdoUI.kmInicial.value.trim() : "",
    kmFinal: rdoUI.kmFinal ? rdoUI.kmFinal.value.trim() : "",
    qtPessoas: rdoUI.qtPessoas ? rdoUI.qtPessoas.value.trim() : "",
    clima,
    climaOutro: rdoUI.climaOutro ? rdoUI.climaOutro.value.trim() : "",
    incidente: rdoUI.incidente ? rdoUI.incidente.value : "",
    bloqueio: rdoUI.bloqueio ? rdoUI.bloqueio.value : "",
    local: rdoUI.local ? rdoUI.local.value : "",
    numeroSi: rdoUI.numeroSi ? rdoUI.numeroSi.value.trim() : "",
    numeroSgi: rdoUI.numeroSgi ? rdoUI.numeroSgi.value.trim() : "",
    acionamento: {
      ativo: rdoUI.acionamentoToggle ? rdoUI.acionamentoToggle.checked : false,
      inicio: rdoUI.acionamentoInicio ? rdoUI.acionamentoInicio.value : "",
      fim: rdoUI.acionamentoFim ? rdoUI.acionamentoFim.value : "",
    },
    horaExtra: {
      ativo: rdoUI.horaExtraToggle ? rdoUI.horaExtraToggle.checked : false,
      inicio: rdoUI.horaExtraInicio ? rdoUI.horaExtraInicio.value : "",
      fim: rdoUI.horaExtraFim ? rdoUI.horaExtraFim.value : "",
    },
    jornadas,
  };
}

function calcularSugestaoQtPessoas(itens) {
  const participantes = new Set();
  itens.forEach((item) => {
    const liberacao = getLiberacao(item) || {};
    const ids = Array.isArray(liberacao.participantes) ? liberacao.participantes : [];
    ids.forEach((id) => {
      const label = getUserLabel(id) || id;
      if (label) {
        participantes.add(label);
      }
    });
    if (!ids.length && item.participantes) {
      if (Array.isArray(item.participantes)) {
        item.participantes.forEach((p) => participantes.add(p));
      } else if (typeof item.participantes === "string") {
        item.participantes
          .split(/[;,]/)
          .map((p) => p.trim())
          .filter(Boolean)
          .forEach((p) => participantes.add(p));
      }
    }
  });
  return participantes.size;
}

function atualizarSugestaoQtPessoas() {
  if (!rdoUI.qtPessoas || !rdoUI.data) {
    return;
  }
  const dataStr = rdoUI.data.value || formatDateISO(new Date());
  const filtros = coletarFiltrosRdo();
  const itensBase = filtrarItensRdo(dataStr, filtros);
  const sugestao = calcularSugestaoQtPessoas(itensBase);
  const auto = rdoUI.qtPessoas.dataset.auto !== "manual";
  if (!rdoUI.qtPessoas.value || auto) {
    rdoUI.qtPessoas.value = sugestao ? String(sugestao) : "";
    rdoUI.qtPessoas.dataset.auto = "auto";
  }
}

function atualizarFiltrosRdo(baseItems) {
  if (!rdoUI.subestacao && !rdoUI.categoria && !rdoUI.prioridade && !rdoUI.usuario) {
    return;
  }
  const subestacoes = Array.from(
    new Set(
      baseItems
        .map((item) => getItemSubestacao(item))
        .filter(Boolean)
        .concat(getSubestacoesBase())
    )
  ).sort((a, b) => a.localeCompare(b, "pt-BR"));
  const categorias = Array.from(
    new Set(baseItems.map((item) => getItemCategoria(item)).filter(Boolean))
  ).sort((a, b) => a.localeCompare(b, "pt-BR"));
  const prioridades = Array.from(
    new Set(baseItems.map((item) => getItemPrioridade(item)).filter(Boolean))
  ).sort((a, b) => a.localeCompare(b, "pt-BR"));

  atualizarSelectKpi(rdoUI.subestacao, subestacoes, "Todas");
  atualizarSelectKpi(rdoUI.categoria, categorias, "Todas");
  atualizarSelectKpi(rdoUI.prioridade, prioridades, "Todas");

  if (rdoUI.usuario) {
    const atual = rdoUI.usuario.value;
    const usuariosBase = baseItems
      .map((item) => getExecutadoPorId(item))
      .filter((id) => isRealUserId(id))
      .concat(getOperationalUsers().map((user) => user.id));
    const usuarios = Array.from(new Set(usuariosBase)).sort((a, b) =>
      getUserLabel(a).localeCompare(getUserLabel(b), "pt-BR")
    );
    rdoUI.usuario.innerHTML = "";
    const optionAll = document.createElement("option");
    optionAll.value = "";
    optionAll.textContent = "Todos";
    rdoUI.usuario.append(optionAll);
    usuarios.forEach((id) => {
      const option = document.createElement("option");
      option.value = id;
      option.textContent = getUserLabel(id) || id;
      rdoUI.usuario.append(option);
    });
    if (atual && Array.from(rdoUI.usuario.options).some((opt) => opt.value === atual)) {
      rdoUI.usuario.value = atual;
    }
  }
}

function getRdoDateRange(dataStr) {
  const base = dataStr ? parseDate(dataStr) : null;
  const inicio = startOfDay(base || new Date());
  const fim = addDays(inicio, 1);
  return { inicio, fim };
}

function isDateInRange(date, inicio, fim) {
  if (!date) {
    return false;
  }
  const time = date.getTime();
  return time >= inicio.getTime() && time < fim.getTime();
}

function filtrarItensRdo(dataStr, filtros) {
  const range = getRdoDateRange(dataStr);
  return manutencoes.filter((item) => {
    const inicio = getItemInicioExecucaoDate(item);
    const fim = getItemFimExecucaoDate(item);
    const conclusao = getItemConclusaoDate(item);
    const agendada = parseAnyDate(item && item.data ? item.data : "") || getItemCriacaoDate(item);
    const entrouExec =
      isDateInRange(inicio, range.inicio, range.fim) ||
      isDateInRange(fim, range.inicio, range.fim) ||
      isDateInRange(conclusao, range.inicio, range.fim);
    const entrouAgenda =
      !inicio && !fim && !conclusao && isDateInRange(agendada, range.inicio, range.fim);
    const entrou = entrouExec || entrouAgenda;
    if (!entrou) {
      return false;
    }
    if (filtros.subestacao && getItemSubestacao(item) !== filtros.subestacao) {
      return false;
    }
    if (filtros.categoria && getItemCategoria(item) !== filtros.categoria) {
      return false;
    }
    if (filtros.prioridade && getItemPrioridade(item) !== filtros.prioridade) {
      return false;
    }
    if (filtros.usuario && getExecutadoPorId(item) !== filtros.usuario) {
      return false;
    }
    return true;
  });
}

function normalizarStatusRdo(valor) {
  if (!valor) {
    return { key: "indefinido", label: "-" };
  }
  const key = String(valor).toLowerCase();
  const label = STATUS_LABELS[key] || (key === "cancelada" ? "Cancelada" : String(valor));
  return { key, label };
}

function getItemDescricaoRdo(item) {
  const conclusaoBreve =
    item && item.conclusao ? item.conclusao.descricaoBreve || "" : "";
  const registro = item && item.registroExecucao ? item.registroExecucao.comentario : "";
  const conclusao = item && item.conclusao ? item.conclusao.comentario : "";
  return conclusaoBreve || registro || conclusao || item.observacao || "";
}

function getItemObsExecucaoRdo(item) {
  const registro = item && item.registroExecucao ? item.registroExecucao.observacaoExecucao : "";
  const conclusao = item && item.conclusao ? item.conclusao.observacaoExecucao : "";
  return registro || conclusao || "";
}

function getResultadoLabelRdo(item) {
  const registro = item && item.registroExecucao ? item.registroExecucao.resultado : "";
  const conclusao = item && item.conclusao ? item.conclusao.resultado : "";
  const resultado = conclusao || registro;
  return resultado ? RESULTADO_LABELS[resultado] || resultado : "";
}

function getResponsavelRdo(item) {
  const id = getExecutadoPorId(item) || item.doneBy || item.createdBy || "";
  if (!id || !isRealUserId(id)) {
    return "";
  }
  return getUserLabel(id);
}

function getDocsStatusRdo(item) {
  const docs = getItemDocs(item);
  const critico = isItemCritico(item);
  const status = {};
  DOC_KEYS.forEach((key) => {
    if (key === "pt" && !critico) {
      status[key] = "N/A";
      return;
    }
    status[key] = docs && docs[key] ? "OK" : "Pendente";
  });
  return status;
}

function buildDocsResumoRdo(status) {
  return DOC_KEYS.map((key) => {
    const label = DOC_LABELS[key] || key.toUpperCase();
    const valor = status[key] || "Pendente";
    return `${label} ${valor}`;
  }).join(" | ");
}

function buildDocsChipsHtml(status) {
  if (!status) {
    return `<span class="doc-chip doc-chip--na">Docs N/A</span>`;
  }
  return DOC_KEYS.map((key) => {
    const label = DOC_LABELS[key] || key.toUpperCase();
    const valor = status[key] || "Pendente";
    const classe =
      valor === "OK" ? "doc-chip--ok" : valor === "N/A" ? "doc-chip--na" : "doc-chip--pendente";
    return `<span class="doc-chip ${classe}">${escapeHtml(`${label} ${valor}`)}</span>`;
  }).join("");
}

function isImageEvidence(evidencia) {
  if (!evidencia) {
    return false;
  }
  const type = evidencia.type || evidencia.mime || "";
  if (type && type.startsWith("image/")) {
    return true;
  }
  const dataUrl = evidencia.dataUrl || evidencia.url || "";
  return dataUrl.startsWith("data:image/");
}

function blobToDataUrl(blob) {
  return new Promise((resolve) => {
    if (!blob) {
      resolve("");
      return;
    }
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result || "");
    reader.onerror = () => resolve("");
    reader.readAsDataURL(blob);
  });
}

async function getEvidenceDataUrl(evidencia) {
  if (!evidencia) {
    return "";
  }
  const rawUrl = evidencia.dataUrl || evidencia.url || "";
  if (rawUrl.startsWith("data:")) {
    return rawUrl;
  }
  if (!rawUrl) {
    return "";
  }
  const dataUrl = resolvePublicUrl(rawUrl);
  try {
    const response = await fetch(dataUrl);
    const blob = await response.blob();
    return await blobToDataUrl(blob);
  } catch (error) {
    return "";
  }
}

async function montarEvidenciasRdo(itens, limite) {
  const lista = [];
  const naoImagem = [];
  let total = 0;
  for (const item of itens) {
    const evidencias =
      item && item.conclusao && Array.isArray(item.conclusao.evidencias)
        ? item.conclusao.evidencias
        : [];
    const dataRef =
      getItemFimExecucaoDate(item) ||
      getItemInicioExecucaoDate(item) ||
      getItemConclusaoDate(item);
    const dataHora = dataRef ? formatDateTime(dataRef) : "-";
    const responsavel = getResponsavelRdo(item) || "-";
    for (const evidencia of evidencias) {
      const nome = evidencia.nome || evidencia.name || "Arquivo";
      if (!isImageEvidence(evidencia)) {
        naoImagem.push({
          nome,
          itemTitulo: item.titulo || "-",
        });
        continue;
      }
      total += 1;
      if (lista.length >= limite) {
        continue;
      }
      const dataUrl = await getEvidenceDataUrl(evidencia);
      if (!dataUrl) {
        continue;
      }
      lista.push({
        dataUrl,
        nome,
        itemId: item.id,
        itemTitulo: item.titulo || "-",
        dataHora,
        responsavel,
      });
    }
  }
  return { lista, total, naoImagem };
}

async function buscarLogoRdo(itens) {
  const regex = /ENGELMIG|LOGO/i;
  for (const item of itens) {
    const evidencias =
      item && item.conclusao && Array.isArray(item.conclusao.evidencias)
        ? item.conclusao.evidencias
        : [];
    for (const evidencia of evidencias) {
      const nome = evidencia.nome || evidencia.name || "";
      if (!regex.test(nome)) {
        continue;
      }
      const dataUrl = await getEvidenceDataUrl(evidencia);
      if (dataUrl) {
        return dataUrl;
      }
    }
  }
  return "";
}

function mapItemRdo(item) {
  const statusInfo = normalizarStatusRdo(item.status);
  const inicio = getItemInicioExecucaoDate(item);
  const fim = getItemFimExecucaoDate(item) || getItemConclusaoDate(item);
  const liberacao = getLiberacao(item) || {};
  const equipamento = getMaintenanceEquipamentoLabel(item);
  const osReferencia = getMaintenanceOsReferencia(item);
  const participantes = Array.isArray(liberacao.participantes)
    ? liberacao.participantes
    : Array.isArray(item.participantes)
      ? item.participantes
      : [];
  const docsStatus = getDocsStatusRdo(item);
  const duracaoMin = Number.isFinite(item.conclusao && item.conclusao.duracaoMin)
    ? item.conclusao.duracaoMin
    : inicio && fim
      ? Math.max(0, Math.round((fim - inicio) / 60000))
      : null;
  const evidencias =
    item && item.conclusao && Array.isArray(item.conclusao.evidencias)
      ? item.conclusao.evidencias
      : [];
  const evidenciasCount = evidencias.filter((evidencia) => isImageEvidence(evidencia)).length;
  const evidenciasNaoImagem = evidencias
    .filter((evidencia) => !isImageEvidence(evidencia))
    .map((evidencia) => evidencia.nome || evidencia.name || "Arquivo");
  return {
    id: item.id,
    titulo: item.titulo || "-",
    subestacao: getItemSubestacao(item) || "-",
    categoria: getItemCategoria(item) || "",
    prioridade: getItemPrioridade(item) || "",
    equipamento,
    osReferencia,
    statusKey: statusInfo.key,
    statusLabel: statusInfo.label,
    inicio: inicio ? toIsoUtc(inicio) : "",
    fim: fim ? toIsoUtc(fim) : "",
    duracaoMin,
    responsavel: getResponsavelRdo(item),
    participantes: getParticipantesLabel(participantes),
    descricao: getItemDescricaoRdo(item),
    observacaoExecucao: getItemObsExecucaoRdo(item),
    evidenciasCount,
    evidenciasNaoImagem,
    docsStatus,
    docsResumo: buildDocsResumoRdo(docsStatus),
    docsCompliance: getDocCompliance(item),
    resultadoLabel: getResultadoLabelRdo(item),
    critico: isItemCritico(item),
  };
}

function calcularMetricasRdo(itensBase, itensRdo, dataStr) {
  const baseDate = dataStr ? parseDate(dataStr) : null;
  const referencia = startOfDay(baseDate || new Date());
  const concluidas = itensRdo.filter((item) => item.statusKey === "concluida").length;
  const abertas = itensRdo.filter(
    (item) => item.statusKey !== "concluida" && item.statusKey !== "cancelada"
  ).length;
  const emExecucao = itensRdo.filter((item) =>
    ["em_execucao", "encerramento"].includes(item.statusKey)
  ).length;
  const overdue = itensBase.filter((item) => isItemOverdue(item, referencia)).length;
  const criticas = itensRdo.filter((item) => item.critico).length;
  const docsOk = itensRdo.filter((item) => item.docsCompliance === true).length;
  const docsTotal = itensRdo.filter((item) => item.docsCompliance !== null).length;
  const docsPercent = docsTotal ? Math.round((docsOk / docsTotal) * 100) : null;
  const tempoTotalMin = itensRdo.reduce(
    (acc, item) => acc + (Number.isFinite(item.duracaoMin) ? item.duracaoMin : 0),
    0
  );
  return {
    total: itensRdo.length,
    concluidas,
    abertas,
    emExecucao,
    overdue,
    criticas,
    docsOk,
    docsTotal,
    docsPercent,
    tempoTotalMin,
  };
}

function formatJanelaExecucaoRdo(inicioIso, fimIso) {
  const inicioDate = inicioIso ? parseTimestamp(inicioIso) : null;
  const fimDate = fimIso ? parseTimestamp(fimIso) : null;
  const inicio = inicioDate ? formatDateTime(inicioDate) : "";
  const fim = fimDate ? formatDateTime(fimDate) : "";
  if (inicio && fim) {
    return `A execução ocorreu entre ${inicio} e ${fim}.`;
  }
  if (inicio) {
    return `Início registrado em ${inicio}. Fim sem registro no período.`;
  }
  if (fim) {
    return `Fim registrado em ${fim}. Início sem registro no período.`;
  }
  return "Sem registro de início e fim no período.";
}

function gerarTextoItemRdo(item) {
  const tipo = (item.categoria || "").trim().toLowerCase();
  const tipoLabel = tipo ? `manutenção ${tipo}` : "manutenção";
  const chave = item.id || item.titulo || "";
  const variante = Number.parseInt(hashString(chave).slice(0, 2), 16) % 3;
  const titulo = item.titulo || "atividade";
  const subestacao = item.subestacao || "subestação não informada";
  let abertura = `Durante o período, foi executada ${tipoLabel} em ${subestacao}.`;
  if (variante === 1) {
    abertura = `No período, a equipe realizou ${tipoLabel} em ${subestacao}, vinculada a ${titulo}.`;
  }
  if (variante === 2) {
    abertura = `Foi registrada ${tipoLabel} em ${subestacao} durante o período, referente a ${titulo}.`;
  }
  const descricao = item.descricao
    ? `Descrição técnica: ${item.descricao}.`
    : "Sem registro de descrição técnica no período.";
  const diagnostico = item.descricao
    ? `Diagnóstico: ${item.descricao}.`
    : "Sem registro de diagnóstico no período.";
  const acao = item.observacaoExecucao
    ? `Ação executada: ${item.observacaoExecucao}.`
    : "Sem registro de ação detalhada no período.";
  const janela = formatJanelaExecucaoRdo(item.inicio, item.fim);
  const responsavel = item.responsavel
    ? `Responsável: ${item.responsavel}.`
    : "Sem registro de responsável no período.";
  const participantes =
    item.participantes && item.participantes !== "-"
      ? `Participantes: ${item.participantes}.`
      : "Sem registro de participantes no período.";
  const evidencias = item.evidenciasCount
    ? `Foram registradas ${item.evidenciasCount} evidências fotográficas.`
    : "Sem evidências fotográficas registradas no período.";
  const docs = item.docsResumo
    ? `Documentação registrada no sistema: ${item.docsResumo}.`
    : "Sem registro de documentação no período.";
  const resultado = item.resultadoLabel ? `Resultado: ${item.resultadoLabel}.` : "";
  const status = item.statusLabel ? `Status final: ${item.statusLabel}.` : "Status final: -.";
  const criticidade = item.critico ? "Classificação: crítica." : "";
  const duracao =
    Number.isFinite(item.duracaoMin) && item.duracaoMin > 0
      ? `Tempo total de execução: ${formatDuracaoMin(item.duracaoMin)}.`
      : "";

  if (["corretiva", "preditiva"].includes(tipo)) {
    return [
      abertura,
      diagnostico,
      acao,
      janela,
      responsavel,
      participantes,
      duracao,
      evidencias,
      docs,
      resultado,
      status,
      criticidade,
    ]
      .filter(Boolean)
      .join(" ");
  }

  const observacao = item.observacaoExecucao
    ? `Observação de execução: ${item.observacaoExecucao}.`
    : "Sem registro de observações adicionais no período.";
  return [
    abertura,
    descricao,
    janela,
    responsavel,
    participantes,
    duracao,
    evidencias,
    docs,
    resultado,
    status,
    criticidade,
    observacao,
  ]
    .filter(Boolean)
    .join(" ");
}

function gerarResumoDiaRdo(itensRdo, metricas) {
  if (!itensRdo.length) {
    return "Sem registro de atividades no período.";
  }
  const parts = [];
  parts.push(
    `Foram registradas ${metricas.total} atividades no período, com ${metricas.concluidas} concluídas e ${metricas.abertas} em andamento.`
  );
  const subestacoes = itensRdo.reduce((acc, item) => {
    const chave = item.subestacao || "";
    if (!chave || chave === "-") {
      return acc;
    }
    acc[chave] = (acc[chave] || 0) + 1;
    return acc;
  }, {});
  const topSubs = Object.keys(subestacoes)
    .map((key) => ({ key, total: subestacoes[key] }))
    .sort((a, b) => b.total - a.total)
    .slice(0, 2);
  if (topSubs.length) {
    parts.push(
      `Subestações com maior volume: ${topSubs
        .map((item) => `${item.key} (${item.total})`)
        .join(", ")}.`
    );
  }
  const corretivas = itensRdo.filter(
    (item) => (item.categoria || "").toLowerCase() === "corretiva"
  ).length;
  if (corretivas || metricas.criticas) {
    parts.push(
      `Destaques: ${corretivas} corretivas e ${metricas.criticas} críticas no período.`
    );
  }
  const docsPendentes = metricas.docsTotal - metricas.docsOk;
  if (metricas.overdue || docsPendentes > 0) {
    parts.push(
      `Pendências: ${metricas.overdue} overdue e ${docsPendentes} atividades com documentação pendente.`
    );
  } else {
    parts.push("Sem pendências críticas no período.");
  }
  return parts.join(" ");
}

function gerarNarrativaDiaRdo(itensRdo, metricas) {
  if (!itensRdo.length) {
    return "Sem registro de execuções no período.";
  }
  const parts = [];
  const tempoTotal =
    metricas.tempoTotalMin && metricas.tempoTotalMin > 0
      ? formatDuracaoMin(metricas.tempoTotalMin)
      : "sem registro";
  parts.push(`Tempo total de execução no período: ${tempoTotal}.`);
  const corretivas = itensRdo.filter(
    (item) => (item.categoria || "").toLowerCase() === "corretiva"
  ).length;
  const preditivas = itensRdo.filter(
    (item) => (item.categoria || "").toLowerCase() === "preditiva"
  ).length;
  if (corretivas || preditivas || metricas.criticas) {
    parts.push(
      `Atividades críticas: ${metricas.criticas}. Corretivas: ${corretivas}. Preditivas: ${preditivas}.`
    );
  }
  if (metricas.docsTotal) {
    parts.push(
      `Compliance documental: ${metricas.docsPercent}% (${metricas.docsOk}/${metricas.docsTotal}).`
    );
  } else {
    parts.push("Sem base documental consolidada no período.");
  }
  const ocorrencias = itensRdo.filter(
    (item) => item.descricao || item.observacaoExecucao
  );
  if (ocorrencias.length) {
    const destaques = ocorrencias.slice(0, 2).map((item) => item.titulo).join(", ");
    parts.push(
      `Observações técnicas registradas em ${ocorrencias.length} atividades${destaques ? `, destaque para: ${destaques}` : ""}.`
    );
  }
  if (metricas.overdue) {
    parts.push(`Permanecem ${metricas.overdue} itens overdue com necessidade de tratativa.`);
  } else {
    parts.push("Sem itens overdue registrados no período.");
  }
  return parts.join(" ");
}

function normalizeResumoRdoTexto(texto) {
  return String(texto || "").replace(/\s+/g, " ").trim();
}

function isResumoRdoValido(texto) {
  return normalizeResumoRdoTexto(texto).length >= MIN_RESUMO_RDO_CHARS;
}

function getMensagemResumoRdo(texto) {
  const normalizado = normalizeResumoRdoTexto(texto);
  if (!normalizado) {
    return `Descrição técnica obrigatória (mínimo ${MIN_RESUMO_RDO_CHARS} caracteres).`;
  }
  if (normalizado.length < MIN_RESUMO_RDO_CHARS) {
    return `Descrição técnica muito curta. Use no mínimo ${MIN_RESUMO_RDO_CHARS} caracteres.`;
  }
  return "";
}

function ensureSentence(texto) {
  const normalizado = normalizeResumoRdoTexto(texto);
  if (!normalizado) {
    return "";
  }
  return /[.!?]$/.test(normalizado) ? normalizado : `${normalizado}.`;
}

function formatListLimited(lista, limite = 3) {
  const unicos = Array.from(new Set((lista || []).filter(Boolean)));
  if (!unicos.length) {
    return "";
  }
  const exibidos = unicos.slice(0, limite);
  const restante = unicos.length - exibidos.length;
  return restante > 0 ? `${exibidos.join(", ")} +${restante}` : exibidos.join(", ");
}

function parseParticipantesLabel(label) {
  if (!label || label === "-") {
    return [];
  }
  return String(label)
    .split(/[;,|]/)
    .map((item) => item.trim())
    .filter(Boolean);
}

function buildResumoItemRdo(item) {
  const resumoBase = normalizeResumoRdoTexto(item.descricao || item.observacaoExecucao || "");
  if (!resumoBase) {
    return "";
  }
  const titulo = item.titulo || "Atividade";
  const local = item.subestacao && item.subestacao !== "-" ? item.subestacao : "";
  const equipamento = item.equipamento && item.equipamento !== "-" ? item.equipamento : "";
  const contexto = [local, equipamento].filter(Boolean).join(" • ");
  const prefix = contexto ? `${titulo} (${contexto})` : titulo;
  return `${prefix}: ${resumoBase}`;
}

function gerarDescricaoConsolidadaRdo(itensRdo, metricas) {
  if (!itensRdo.length) {
    return "Sem registro de execuções no período.";
  }
  const resumo = `Foram registradas ${metricas.total} atividades no período, com ${metricas.concluidas} concluídas, ${metricas.emExecucao} em execução e ${metricas.overdue} pendentes.`;
  const resumos = itensRdo
    .map((item) => buildResumoItemRdo(item))
    .filter(Boolean)
    .map((texto) => ensureSentence(truncarTexto(texto, 220)))
    .filter(Boolean);
  let sintese = "Sem descrição técnica detalhada registrada.";
  if (resumos.length) {
    const limite = 4;
    const frases = resumos.slice(0, limite);
    const restante = resumos.length - limite;
    if (restante > 0) {
      frases.push(`Outras ${restante} atividade(s) seguiram o escopo programado.`);
    }
    sintese = `Síntese técnica: ${frases.join(" ")}`.trim();
  }
  return `${resumo} ${sintese}`.trim();
}

function gerarDetalhamentoConsolidadoRdo(itensRdo, metricas) {
  if (!itensRdo.length) {
    return { texto: "Sem itens no período.", cards: [] };
  }
  const subestacoes = itensRdo
    .map((item) => (item.subestacao && item.subestacao !== "-" ? item.subestacao : ""))
    .filter(Boolean);
  const equipamentos = itensRdo
    .map((item) => (item.equipamento && item.equipamento !== "-" ? item.equipamento : ""))
    .filter(Boolean);
  const responsaveis = itensRdo
    .map((item) => item.responsavel || "")
    .filter(Boolean);
  const participantes = itensRdo
    .flatMap((item) => parseParticipantesLabel(item.participantes))
    .filter(Boolean);
  const docsPendentes = itensRdo.filter((item) => item.docsCompliance === false).length;
  const partes = [];
  if (metricas.tempoTotalMin && metricas.tempoTotalMin > 0) {
    partes.push(`Tempo total de execução: ${formatDuracaoMin(metricas.tempoTotalMin)}.`);
  }
  if (metricas.criticas) {
    partes.push(`Atividades críticas: ${metricas.criticas}.`);
  }
  if (docsPendentes) {
    partes.push(`Documentação pendente em ${docsPendentes} atividade(s).`);
  } else if (metricas.docsTotal) {
    partes.push("Documentação operacional dentro do esperado.");
  }
  if (!partes.length) {
    partes.push("Sem detalhes adicionais no período.");
  }
  const cards = [];
  const subestacoesLabel = formatListLimited(subestacoes);
  if (subestacoesLabel) {
    cards.push({ label: "Subestações", value: subestacoesLabel });
  }
  const equipamentosLabel = formatListLimited(equipamentos);
  if (equipamentosLabel) {
    cards.push({ label: "Equipamentos", value: equipamentosLabel });
  }
  const responsaveisLabel = formatListLimited(responsaveis);
  if (responsaveisLabel) {
    cards.push({ label: "Responsáveis", value: responsaveisLabel });
  }
  const participantesLabel = formatListLimited(participantes);
  if (participantesLabel) {
    cards.push({ label: "Participantes", value: participantesLabel });
  }
  return { texto: partes.join(" "), cards };
}

function getStatusGeralConsolidado(itensRdo) {
  if (!itensRdo.length) {
    return "não informado";
  }
  const statusKeys = itensRdo.map((item) => item.statusKey || "");
  const allConcluida = statusKeys.every((status) => status === "concluida");
  if (allConcluida) {
    return "Concluída";
  }
  if (statusKeys.some((status) => status === "em_execucao" || status === "encerramento")) {
    return "Em execução";
  }
  if (statusKeys.some((status) => status === "backlog")) {
    return "Pendentes";
  }
  return "Em andamento";
}

function normalizeForMatch(texto) {
  if (!texto) {
    return "";
  }
  return String(texto)
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toUpperCase();
}

function getEquipmentGroupLabel(nome) {
  const base = normalizeForMatch(nome);
  if (!base) {
    return "";
  }
  if (base.includes("SERVICOS AUXILIARES") || /\bTSA-\d+\b/.test(base)) {
    return "transformadores de serviços auxiliares";
  }
  if (base.includes("POTENCIA") || /\bT-\d+\b/.test(base)) {
    return "transformadores de potência";
  }
  if (base.includes("TRANSFORMADOR")) {
    return "transformadores";
  }
  return "equipamentos";
}

function buildAtividadesConsolidadoFallback(itensRdo) {
  const projetoAtivo = getActiveProject();
  const projetoLabel = projetoAtivo ? getProjectLabel(projetoAtivo) : "não informado";
  const subestacoes = Array.from(
    new Set(
      itensRdo
        .map((item) => (item.subestacao && item.subestacao !== "-" ? item.subestacao : ""))
        .filter(Boolean)
    )
  );
  const subestacao = projetoLabel || (subestacoes[0] || "não informado");
  const titulos = Array.from(
    new Set(itensRdo.map((item) => item.titulo || "").filter(Boolean))
  );
  const categorias = Array.from(
    new Set(itensRdo.map((item) => item.categoria || "").filter(Boolean))
  );
  const equipamentosNomes = itensRdo
    .map((item) => (item.equipamento && item.equipamento !== "-" ? item.equipamento : ""))
    .filter(Boolean);
  const gruposEquip = Array.from(
    new Set(equipamentosNomes.map((nome) => getEquipmentGroupLabel(nome)).filter(Boolean))
  );
  let atividadeDoDia = "Atividades de manutenção";
  if (titulos.length === 1) {
    atividadeDoDia = titulos[0];
  } else if (titulos.length > 1 && titulos.length <= 3) {
    atividadeDoDia = titulos.join(" / ");
  } else if (categorias.length === 1) {
    atividadeDoDia = `Manutenção ${categorias[0]}`;
  }
  if (gruposEquip.length === 1) {
    atividadeDoDia = `${atividadeDoDia} em ${gruposEquip[0]}`;
  } else if (gruposEquip.length > 1) {
    atividadeDoDia = `${atividadeDoDia} em ${gruposEquip.join(" e ")}`;
  }
  const statusGeral = getStatusGeralConsolidado(itensRdo);
  const equipamentos = itensRdo.map((item) => ({
    nome: item.equipamento && item.equipamento !== "-" ? item.equipamento : "não informado",
    tipo: item.categoria || item.titulo || "não informado",
    status: item.statusLabel || "não informado",
  }));
  const equipamentosUnicos = Array.from(
    new Map(
      equipamentos.map((equip) => [
        `${equip.nome}|${equip.tipo}|${equip.status}`,
        equip,
      ])
    ).values()
  );
  return {
    local: projetoLabel,
    subestacao,
    atividade_do_dia: atividadeDoDia,
    status_geral: statusGeral,
    equipamentos: equipamentosUnicos.length
      ? equipamentosUnicos
      : [{ nome: "não informado", tipo: "não informado", status: "não informado" }],
  };
}

function buildAtividadesConsolidadoHtml(data, meta = {}) {
  const dash = "\u2014";
  const normalizeValue = (value) => {
    if (value === null || value === undefined) {
      return dash;
    }
    const text = String(value).trim();
    if (!text || text === "-" || /^(nao|n\u00e3o) informado$/i.test(text)) {
      return dash;
    }
    return text;
  };
  const local = normalizeValue(meta.local || (data && data.local));
  const subestacao = normalizeValue(meta.subestacao || (data && data.subestacao));
  const atividadeRaw = normalizeValue(data && data.atividade_do_dia);
  const status = normalizeValue(meta.status || (data && data.status_geral));
  const statusClass = status === dash ? "neutral" : meta.statusClass || "neutral";
  const tempoLabel = meta.tempoTotal || "-";
  const docsLabel = meta.docsBadge || dash;
  const equipamentos = data && Array.isArray(data.equipamentos) ? data.equipamentos : [];
  const tiposUnicos = Array.from(
    new Set(equipamentos.map((equip) => (equip.tipo || "").trim()).filter(Boolean))
  );
  const statusUnicos = Array.from(
    new Set(equipamentos.map((equip) => (equip.status || "").trim()).filter(Boolean))
  );
  const tipoResumo = tiposUnicos.length === 1 ? tiposUnicos[0] : "";
  const statusResumo = statusUnicos.length === 1 ? statusUnicos[0] : status;
  let atividadeTitulo = atividadeRaw;
  let atividadeSubtitulo = "";
  if (atividadeRaw !== dash) {
    const separadores = [" - ", " \u2014 ", " | ", ": "];
    for (const sep of separadores) {
      if (atividadeRaw.includes(sep)) {
        const partes = atividadeRaw.split(sep);
        atividadeTitulo = (partes.shift() || "").trim() || atividadeRaw;
        atividadeSubtitulo = partes.join(sep).trim();
        break;
      }
    }
    if (!atividadeSubtitulo && atividadeRaw.includes(" em ")) {
      const partes = atividadeRaw.split(" em ");
      if (partes.length > 1) {
        atividadeTitulo = (partes.shift() || "").trim() || atividadeRaw;
        atividadeSubtitulo = `em ${partes.join(" em ").trim()}`;
      }
    }
  }
  const grupos = equipamentos.reduce((acc, equip) => {
    const base = normalizeForMatch(`${equip.nome || ""} ${equip.tipo || ""}`);
    let grupo = "Outros";
    if (base.includes("SERVICOS AUXILIARES") || /\bTSA-\d+\b/.test(base)) {
      grupo = "Servicos auxiliares";
    } else if (base.includes("POTENCIA") || /\bT-\d+\b/.test(base)) {
      grupo = "Potencia";
    }
    if (!acc[grupo]) {
      acc[grupo] = [];
    }
    acc[grupo].push(equip);
    return acc;
  }, {});
  const gruposOrdenados = ["Servicos auxiliares", "Potencia", "Outros"].filter(
    (key) => grupos[key] && grupos[key].length
  );
  const equipamentosHtml = equipamentos.length
    ? gruposOrdenados.length > 1
      ? gruposOrdenados
          .map((grupo) => {
            const lista = grupos[grupo]
              .map((equip) => {
                const nome = normalizeValue(equip.nome);
                const tipo = normalizeValue(equip.tipo);
                const statusItem = normalizeValue(equip.status);
                const tipoLabel = tiposUnicos.length === 1 ? "" : ` \u2014 ${escapeHtml(tipo)}`;
                const statusLabel =
                  statusUnicos.length === 1 ? "" : ` \u2014 ${escapeHtml(statusItem)}`;
                return `<li>${escapeHtml(nome)}${tipoLabel}${statusLabel}</li>`;
              })
              .join("");
            const grupoLabel =
              grupo === "Servicos auxiliares"
                ? "Servi\u00e7os auxiliares"
                : grupo === "Potencia"
                  ? "Pot\u00eancia"
                  : "Outros";
            return `
              <div class="rdo-equip-group">
                <h5>${escapeHtml(grupoLabel)}</h5>
                <ul class="rdo-lista">${lista}</ul>
              </div>
            `;
          })
          .join("")
      : `
          <ul class="rdo-lista">
            ${gruposOrdenados
              .flatMap((grupo) =>
                grupos[grupo].map((equip) => {
                  const nome = normalizeValue(equip.nome);
                  const tipo = normalizeValue(equip.tipo);
                  const statusItem = normalizeValue(equip.status);
                  const tipoLabel = tiposUnicos.length === 1 ? "" : ` \u2014 ${escapeHtml(tipo)}`;
                  const statusLabel =
                    statusUnicos.length === 1 ? "" : ` \u2014 ${escapeHtml(statusItem)}`;
                  return `<li>${escapeHtml(nome)}${tipoLabel}${statusLabel}</li>`;
                })
              )
              .join("")}
          </ul>
        `
    : `<p class="rdo-muted">\u2014 (sem registros no per\u00edodo)</p>`;
  const resumoChips = [
    `Equipamentos: ${equipamentos.length ? equipamentos.length : dash}`,
    `Tipo: ${tipoResumo ? tipoResumo : dash}`,
  ];
  const statusMetaParts = [docsLabel ? `Docs: ${docsLabel}` : ""].filter(Boolean);
  const statusMeta = statusMetaParts.length ? statusMetaParts.join(" \u2022 ") : dash;
  return `
    <div class="rdo-consolidado-grid">
      <div>
        <span>Local/Empreendimento</span>
        <strong>${escapeHtml(local)}</strong>
      </div>
      <div>
        <span>Subesta\u00e7\u00e3o</span>
        <strong>${escapeHtml(subestacao)}</strong>
      </div>
      <div class="rdo-consolidado-activity">
        <span>Atividade do dia</span>
        <strong>${escapeHtml(atividadeTitulo)}</strong>
        ${atividadeSubtitulo ? `<small>${escapeHtml(atividadeSubtitulo)}</small>` : ""}
      </div>
      <div class="rdo-consolidado-status">
        <span>Status geral + Docs</span>
        <strong class="rdo-status rdo-status--${escapeHtml(statusClass)}">${escapeHtml(
          status || dash
        )}</strong>
        <small>${escapeHtml(statusMeta)}</small>
      </div>
    </div>
    <div class="rdo-consolidado-chips">
      ${resumoChips
        .map((chip) => `<span class="rdo-chip rdo-chip--plain">${escapeHtml(chip)}</span>`)
        .join("")}
    </div>
    <div class="rdo-item__section rdo-consolidado-equip">
      <h4>Equipamentos atendidos</h4>
      ${equipamentosHtml}
    </div>
  `;
}

function truncarTexto(texto, limite) {
  if (!texto || texto.length <= limite) {
    return texto || "";
  }
  return `${texto.slice(0, limite - 1)}...`;
}

function escapeHtml(valor) {
  return String(valor || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function stripHtml(html) {
  const container = document.createElement("div");
  container.innerHTML = html || "";
  return container.textContent || "";
}

function sanitizeRichText(html) {
  const allowedTags = new Set([
    "B",
    "STRONG",
    "I",
    "EM",
    "U",
    "P",
    "BR",
    "UL",
    "OL",
    "LI",
    "BLOCKQUOTE",
    "H3",
    "DIV",
    "SPAN",
    "FONT",
  ]);
  const allowedFonts = new Set(["Segoe UI", "Arial", "Georgia", "Courier New"]);
  const allowedSizes = new Set(["2", "3", "4", "5", "6"]);
  const allowedStyleProps = new Set([
    "font-family",
    "font-size",
    "font-weight",
    "font-style",
    "text-decoration",
  ]);

  const root = document.createElement("div");
  root.innerHTML = html || "";

  const cleanNode = (node) => {
    Array.from(node.childNodes).forEach((child) => {
      if (child.nodeType === Node.COMMENT_NODE) {
        child.remove();
        return;
      }
      if (child.nodeType === Node.TEXT_NODE) {
        return;
      }
      if (child.nodeType !== Node.ELEMENT_NODE) {
        child.remove();
        return;
      }
      const tag = child.tagName.toUpperCase();
      if (!allowedTags.has(tag)) {
        const fragment = document.createDocumentFragment();
        while (child.firstChild) {
          fragment.append(child.firstChild);
        }
        child.replaceWith(fragment);
        return;
      }

      if (tag === "FONT") {
        const face = child.getAttribute("face") || "";
        const size = child.getAttribute("size") || "";
        Array.from(child.attributes).forEach((attr) => {
          if (!["face", "size"].includes(attr.name)) {
            child.removeAttribute(attr.name);
          }
        });
        if (face && !allowedFonts.has(face)) {
          child.removeAttribute("face");
        }
        if (size && !allowedSizes.has(size)) {
          child.removeAttribute("size");
        }
      } else if (tag === "SPAN") {
        const style = child.getAttribute("style") || "";
        if (style) {
          const safeStyles = [];
          style.split(";").forEach((rule) => {
            const [rawProp, rawValue] = rule.split(":");
            if (!rawProp || !rawValue) {
              return;
            }
            const prop = rawProp.trim().toLowerCase();
            const value = rawValue.trim();
            if (!allowedStyleProps.has(prop)) {
              return;
            }
            if (prop === "font-family") {
              const font = value.replace(/['\"]/g, "");
              if (!allowedFonts.has(font)) {
                return;
              }
              safeStyles.push(`font-family:${font}`);
              return;
            }
            if (prop === "font-size") {
              const px = value.replace("px", "");
              const pxVal = Number(px);
              if (!Number.isFinite(pxVal) || pxVal < 10 || pxVal > 22) {
                return;
              }
              safeStyles.push(`font-size:${pxVal}px`);
              return;
            }
            if (prop === "text-decoration") {
              if (value.toLowerCase().includes("underline")) {
                safeStyles.push("text-decoration: underline");
              }
              return;
            }
            safeStyles.push(`${prop}:${value}`);
          });
          if (safeStyles.length) {
            child.setAttribute("style", safeStyles.join("; "));
          } else {
            child.removeAttribute("style");
          }
        }
        Array.from(child.attributes).forEach((attr) => {
          if (attr.name !== "style") {
            child.removeAttribute(attr.name);
          }
        });
      } else {
        Array.from(child.attributes).forEach((attr) => child.removeAttribute(attr.name));
      }

      cleanNode(child);
    });
  };

  cleanNode(root);
  return root.innerHTML;
}

function hashString(valor) {
  const texto = String(valor || "");
  let hash = 0;
  for (let i = 0; i < texto.length; i += 1) {
    hash = (hash << 5) - hash + texto.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash).toString(16).padStart(8, "0");
}

function salvarSnapshotRdo(snapshot) {
  if (!snapshot) {
    return;
  }
  const index = rdoSnapshots.findIndex((item) => item.id === snapshot.id);
  if (index >= 0) {
    rdoSnapshots[index] = snapshot;
  } else {
    rdoSnapshots = [snapshot, ...rdoSnapshots];
  }
  salvarRdoSnapshots(rdoSnapshots);
  renderRdoList();
}

async function fetchRdoAiText(dateStr) {
  if (!USE_AUTH_API || !currentUser || !canGerarRelatorio(currentUser)) {
    return null;
  }
  try {
    const response = await apiRdoGenerateText({
      date: dateStr,
      projectId: activeProjectId,
    });
    const result = response && (response.result || response.data || response);
    if (
      result &&
      typeof result.descricao_consolidada === "string" &&
      result.atividades_consolidado
    ) {
      return result;
    }
  } catch (error) {
    // fallback handled by caller
  }
  return null;
}

async function gerarSnapshotRdo(persistir = false) {
  if (!rdoUI.data) {
    return null;
  }
  const dataStr = rdoUI.data.value || formatDateISO(new Date());
  const dataBase = parseDate(dataStr);
  if (!dataBase) {
    mostrarMensagemRdo("Data inválida.", true);
    return null;
  }
  const filtros = coletarFiltrosRdo();
  const manual = coletarManualRdo();
  const limite = rdoUI.limite ? Number(rdoUI.limite.value) || 8 : 8;
  const registroGerencial = rdoUI.registro ? rdoUI.registro.value.trim() : "";
  mostrarMensagemRdo("Gerando RDO...");
  const itensBase = filtrarItensRdo(dataStr, filtros);
  const itensOrdenados = itensBase.slice().sort((a, b) => {
    const dataA = getItemInicioExecucaoDate(a) || getItemConclusaoDate(a) || parseAnyDate(a.data);
    const dataB = getItemInicioExecucaoDate(b) || getItemConclusaoDate(b) || parseAnyDate(b.data);
    return (getTimeValue(dataB) || 0) - (getTimeValue(dataA) || 0);
  });
  const itensRdo = itensOrdenados.map((item) => mapItemRdo(item));
  itensRdo.forEach((item) => {
    item.texto = gerarTextoItemRdo(item);
  });
  const evidenciasInfo = await montarEvidenciasRdo(itensOrdenados, limite);
  const logoDataUrl = await buscarLogoRdo(itensOrdenados);
  const metricas = calcularMetricasRdo(itensOrdenados, itensRdo, dataStr);
  const resumoDia = gerarResumoDiaRdo(itensRdo, metricas);
  const narrativaDia = gerarNarrativaDiaRdo(itensRdo, metricas);
  const aiFallback = {
    descricao_consolidada: gerarDescricaoConsolidadaRdo(itensRdo, metricas),
    atividades_consolidado: buildAtividadesConsolidadoFallback(itensRdo),
  };
  const aiTextRaw = await fetchRdoAiText(dataStr);
  const aiText = aiTextRaw
    ? { ...aiTextRaw, atividades_consolidado: aiFallback.atividades_consolidado }
    : aiFallback;
  const agora = new Date();
  const snapshot = {
    id: criarId(),
    hash: "",
    rdoDate: dataStr,
    filtros,
    manual,
    registroGerencial,
    limiteEvidencias: limite,
    projectId: activeProjectId,
    projectLabel: getActiveProject() ? getActiveProject().nome : "",
    projectCode: getActiveProject() ? getActiveProject().codigo : "",
    projectClient: getActiveProject() ? getActiveProject().cliente : "",
    createdAt: toIsoUtc(agora),
    createdBy: currentUser ? currentUser.id : "",
    itens: itensRdo,
    metricas,
    evidencias: evidenciasInfo.lista,
    evidenciasTotal: evidenciasInfo.total,
    evidenciasNaoImagem: evidenciasInfo.naoImagem,
    logoDataUrl,
    resumoDia,
    narrativaDia,
    aiText,
  };
  snapshot.hash = hashString(
    `${snapshot.id}|${snapshot.rdoDate}|${snapshot.itens.length}|${snapshot.createdAt}`
  );
  if (persistir) {
    salvarSnapshotRdo(snapshot);
  }
  mostrarMensagemRdo("");
  rdoPreviewSnapshot = snapshot;
  return snapshot;
}

function renderRdoPreview(snapshot) {
  if (!rdoUI.preview || !rdoUI.previewBody) {
    return;
  }
  try {
    rdoUI.previewBody.innerHTML = buildRdoHtml(snapshot);
    rdoUI.preview.hidden = false;
    rdoUI.preview.scrollIntoView({ behavior: "smooth", block: "start" });
  } catch (error) {
    console.error("[rdo] erro ao montar preview", error);
    mostrarMensagemRdo("Não foi possível montar o preview do RDO.", true);
    rdoUI.preview.hidden = false;
    rdoUI.previewBody.innerHTML = `<p class="empty-state">Preview indisponível.</p>`;
  }
}

function normalizeRdoSnapshot(snapshot) {
  const metricasDefault = {
    total: 0,
    concluidas: 0,
    abertas: 0,
    emExecucao: 0,
    overdue: 0,
    criticas: 0,
    docsOk: 0,
    docsTotal: 0,
    docsPercent: null,
    tempoTotalMin: 0,
  };
  const metricasRaw = snapshot && snapshot.metricas ? snapshot.metricas : null;
  const metricas =
    metricasRaw && typeof metricasRaw === "object"
      ? { ...metricasDefault, ...metricasRaw }
      : metricasDefault;
  const itens = Array.isArray(snapshot && snapshot.itens) ? snapshot.itens : [];
  const evidencias = Array.isArray(snapshot && snapshot.evidencias)
    ? snapshot.evidencias
    : [];
  const evidenciasNaoImagem = Array.isArray(snapshot && snapshot.evidenciasNaoImagem)
    ? snapshot.evidenciasNaoImagem
    : [];
  const evidenciasTotal = Number.isFinite(snapshot && snapshot.evidenciasTotal)
    ? snapshot.evidenciasTotal
    : evidencias.length;
  return {
    ...snapshot,
    metricas,
    itens,
    evidencias,
    evidenciasNaoImagem,
    evidenciasTotal,
  };
}

function buildRdoHtml(snapshot, options = {}) {
  if (!snapshot || typeof snapshot !== "object") {
    return `<div class="rdo-doc"><p class="empty-state">RDO indisponível.</p></div>`;
  }
  snapshot = normalizeRdoSnapshot(snapshot);
  const dash = "\u2014";
  const isCliente = Boolean(options.cliente);
  const dataParsed = snapshot.rdoDate ? parseDate(snapshot.rdoDate) : null;
  const dataLabel = dataParsed ? formatDate(dataParsed) : "-";
  const emitidoDate = snapshot.createdAt ? parseTimestamp(snapshot.createdAt) : null;
  const emitidoEm = emitidoDate ? formatDateTime(emitidoDate) : "-";
  const emitidoPor = snapshot.createdBy ? getUserLabel(snapshot.createdBy) : "Sistema";
  const hashShort = snapshot.hash ? snapshot.hash.slice(0, 8).toUpperCase() : "-";
  const tempoTotal =
    snapshot.metricas.tempoTotalMin && snapshot.metricas.tempoTotalMin > 0
      ? formatDuracaoMin(snapshot.metricas.tempoTotalMin)
      : "-";
  const docsPercent =
    snapshot.metricas.docsTotal && snapshot.metricas.docsPercent !== null
      ? `${snapshot.metricas.docsPercent}%`
      : dash;
  const docsMeta = snapshot.metricas.docsTotal
    ? `${snapshot.metricas.docsOk}/${snapshot.metricas.docsTotal}`
    : dash;
  const evidenciasLimitadas =
    snapshot.evidenciasTotal > snapshot.evidencias.length
      ? `Evidências limitadas a ${snapshot.limiteEvidencias} no PDF.`
      : "";
  const logoHtml = `
    <img
      id="rdoEngelmigLogo"
      class="rdo-logo"
      src="./assets/engelmig-logo.png"
      alt="ENGELMIG"
      width="110"
      height="40"
      loading="eager"
    />
    <span id="rdoEngelmigFallback" class="rdo-logo-fallback">ENGELMIG</span>
  `;
  const manual = snapshot.manual || {};
  const projeto =
    snapshot.projectLabel ||
    snapshot.projectCode ||
    (snapshot.filtros && snapshot.filtros.subestacao ? snapshot.filtros.subestacao : RDO_PROJETO);
  const cliente = snapshot.projectClient || getActiveProjectClient();
  const local = manual.local || getDefaultRdoLocal();
  const climaValor = manual.clima === "OUTRO" && manual.climaOutro
    ? `OUTRO - ${manual.climaOutro}`
    : manual.clima || "-";
  const jornadas = Array.isArray(manual.jornadas) ? manual.jornadas : [];
  const schedule = getRdoScheduleFromDate(dataParsed || new Date());
  const jornadasRows = jornadas.map((item) => {
    const entrada = item.entrada || "";
    const saida = item.saida || "";
    const duracaoBrutaMin = calcDurationMinutes(entrada, saida);
    const entradaMin = parseTimeToMinutes(entrada);
    const saidaMin = parseTimeToMinutes(saida);
    const expedienteBrutoMin =
      entradaMin === null || saidaMin === null || saidaMin < entradaMin
        ? 0
        : calcOverlapMinutes(entradaMin, saidaMin, schedule.inicio, schedule.fim);
    const almocoMin = duracaoBrutaMin > 0 ? ALMOCO_MIN : 0;
    const duracaoMin = Math.max(0, duracaoBrutaMin - almocoMin);
    const expedienteMin = Math.max(0, expedienteBrutoMin - almocoMin);
    const extraMin = Math.max(0, duracaoMin - expedienteMin);
    return {
      nome: item.nome || item.label || item.userLabel || "Colaborador",
      entrada: entrada || "-",
      saida: saida || "-",
      duracaoMin,
      expedienteMin,
      extraMin,
      almocoMin,
    };
  });
  const totalJornadaMin = jornadasRows.reduce((acc, row) => acc + (row.duracaoMin || 0), 0);
  const totalExpedienteMin = jornadasRows.reduce((acc, row) => acc + (row.expedienteMin || 0), 0);
  const totalExtraCalcMin = jornadasRows.reduce((acc, row) => acc + (row.extraMin || 0), 0);
  const hasAcionamento = Boolean(manual.acionamento && manual.acionamento.ativo);
  const acionamentoMin = hasAcionamento
    ? calcDurationMinutes(manual.acionamento.inicio, manual.acionamento.fim)
    : 0;
  const hasHoraExtra = Boolean(manual.horaExtra && manual.horaExtra.ativo);
  const horaExtraMin = hasHoraExtra
    ? calcDurationMinutes(manual.horaExtra.inicio, manual.horaExtra.fim)
    : 0;
  const aiText = snapshot.aiText || null;
  const descricaoConsolidada =
    (aiText && aiText.descricao_consolidada) ||
    gerarDescricaoConsolidadaRdo(snapshot.itens || [], snapshot.metricas);
  const atividadesConsolidado =
    (aiText && aiText.atividades_consolidado) ||
    buildAtividadesConsolidadoFallback(snapshot.itens || []);
  const formatValue = (value) => {
    if (value === 0) {
      return { text: "0", muted: false };
    }
    if (value === null || value === undefined) {
      return { text: dash, muted: true };
    }
    const text = String(value).trim();
    if (!text || text === "-" || text === dash) {
      return { text: dash, muted: true };
    }
    return { text, muted: false };
  };
  const buildField = (label, value, options = {}) => {
    const val = formatValue(value);
    const extraClass = options.className ? ` ${options.className}` : "";
    return `
      <div class="rdo-field${extraClass}">
        <span>${escapeHtml(label)}</span>
        <strong${val.muted ? ' class="rdo-muted"' : ""}>${escapeHtml(val.text)}</strong>
      </div>
    `;
  };
  const rdoNumero = snapshot.id ? snapshot.id.slice(0, 6).toUpperCase() : "-";
  const resumoItensBase = [
    { label: "Atividades", value: snapshot.metricas.total },
    { label: "Concluídas", value: snapshot.metricas.concluidas },
    { label: "Em execução", value: snapshot.metricas.emExecucao },
    { label: "Críticas", value: snapshot.metricas.criticas },
    { label: "Overdue", value: snapshot.metricas.overdue },
    { label: "Docs", value: docsPercent, meta: docsMeta },
    { label: "Tempo total", value: tempoTotal },
  ];
  const resumoItens = resumoItensBase.filter((item) => {
    const value = item.value;
    if (value === null || value === undefined) {
      return false;
    }
    if (typeof value === "number") {
      return value > 0;
    }
    const text = String(value || "").trim();
    if (!text || text === "-" || text === "0" || text === "0%") {
      return false;
    }
    return true;
  });
  const resumoOperacionalHtml = resumoItens.length
    ? `
      <div class="rdo-summary-grid">
        ${resumoItens
          .map(
            (item) => `
          <div class="rdo-summary-item">
            <span>${escapeHtml(item.label)}</span>
            <strong>${escapeHtml(item.value)}</strong>
            ${item.meta ? `<small>${escapeHtml(item.meta)}</small>` : ""}
          </div>
        `
          )
          .join("")}
      </div>
    `
    : `<p class="empty-state">Sem indicadores relevantes no período.</p>`;
  const jornadaRowsHtml = `
      <table class="rdo-table rdo-table--compact rdo-table--center">
        <thead>
          <tr>
            <th>Colaborador</th>
            <th>Entrada</th>
            <th>Saída</th>
            <th>Horas líquidas</th>
            <th>Expediente líquido</th>
            <th>Extra calc.</th>
          </tr>
        </thead>
        <tbody>
          ${
            jornadasRows.length
              ? jornadasRows
                  .map(
                    (row) => `
              <tr>
                <td>${escapeHtml(row.nome)}</td>
                <td>${escapeHtml(row.entrada)}</td>
                <td>${escapeHtml(row.saida)}</td>
                <td>${row.duracaoMin ? escapeHtml(formatDuracaoMin(row.duracaoMin)) : "—"}</td>
                <td>${row.expedienteMin ? escapeHtml(formatDuracaoMin(row.expedienteMin)) : "—"}</td>
                <td>${row.extraMin ? escapeHtml(formatDuracaoMin(row.extraMin)) : "—"}</td>
              </tr>
            `
                  )
                  .join("")
              : `<tr><td colspan="6" class="rdo-muted">— (sem apontamentos no período)</td></tr>`
          }
        </tbody>
      </table>
      ${
        jornadasRows.length
          ? ""
          : `<p class="rdo-note-muted">Sem apontamentos de jornada no período.</p>`
      }
    `;
  const acionamentoLabel = hasAcionamento
    ? `${manual.acionamento.inicio || "-"} - ${manual.acionamento.fim || "-"}`
    : "N\u00e3o houve acionamento neste dia.";
  const horaExtraLabel = hasHoraExtra
    ? `${manual.horaExtra.inicio || "-"} - ${manual.horaExtra.fim || "-"}`
    : "N\u00e3o houve horas extras neste dia.";
  const jornadaResumoHtml = `
    <div class="rdo-summary-grid rdo-summary-grid--cards rdo-summary-grid--tight">
      <div class="rdo-summary-item">
        <span>Jornada líquida</span>
        <strong>${totalJornadaMin ? formatDuracaoMin(totalJornadaMin) : "-"}</strong>
        <small>${jornadasRows.length} colaboradores • -1h almoço</small>
      </div>
      <div class="rdo-summary-item">
        <span>Expediente líquido</span>
        <strong>${totalExpedienteMin ? formatDuracaoMin(totalExpedienteMin) : "-"}</strong>
        <small>Base ${schedule.label} • -1h almoço</small>
      </div>
      <div class="rdo-summary-item">
        <span>Extra calculada</span>
        <strong>${totalExtraCalcMin ? formatDuracaoMin(totalExtraCalcMin) : "-"}</strong>
        <small>Acima do expediente</small>
      </div>
      <div class="rdo-summary-item">
        <span>Hora extra</span>
        <strong>${horaExtraMin ? formatDuracaoMin(horaExtraMin) : "-"}</strong>
        <small>${escapeHtml(horaExtraLabel)}</small>
      </div>
      <div class="rdo-summary-item">
        <span>Acionamento</span>
        <strong>${acionamentoMin ? formatDuracaoMin(acionamentoMin) : "-"}</strong>
        <small>${escapeHtml(acionamentoLabel)}</small>
      </div>
    </div>
  `;

  const jornadaCards = [
    {
      label: "Jornada líquida",
      value: totalJornadaMin ? formatDuracaoMin(totalJornadaMin) : dash,
      meta: `${jornadasRows.length} colaboradores • -1h almoço`,
    },
    {
      label: "Expediente líquido",
      value: totalExpedienteMin ? formatDuracaoMin(totalExpedienteMin) : dash,
      meta: `Base ${schedule.label} • -1h almoço`,
    },
    {
      label: "Extra calculada",
      value: totalExtraCalcMin ? formatDuracaoMin(totalExtraCalcMin) : dash,
      meta: "Acima do expediente",
    },
    {
      label: "Hora extra",
      value: horaExtraMin ? formatDuracaoMin(horaExtraMin) : dash,
      meta: horaExtraLabel,
    },
  ];
  const jornadaCardsHtml = `
    <div class="rdo-journey-grid">
      ${jornadaCards
        .map((card) => {
          const val = formatValue(card.value);
          return `
          <div class="rdo-journey-card">
            <span>${escapeHtml(card.label)}</span>
            <strong${val.muted ? ' class="rdo-muted"' : ""}>${escapeHtml(val.text)}</strong>
            <small>${escapeHtml(card.meta || dash)}</small>
          </div>
        `;
        })
        .join("")}
    </div>
  `;
  const acionamentoDuracao = acionamentoMin ? formatDuracaoMin(acionamentoMin) : dash;
  const acionamentoHtml = `
    <div class="rdo-journey-row">
      ${buildField("Acionamento", acionamentoDuracao)}
      ${buildField("Janela acionamento", acionamentoLabel)}
    </div>
  `;

  const rows = snapshot.itens
    .map((item) => {
      const statusClass = item.statusKey
        ? item.statusKey.replace(/[^a-z0-9]+/g, "_")
        : "default";
      const inicioDate = item.inicio ? parseTimestamp(item.inicio) : null;
      const fimDate = item.fim ? parseTimestamp(item.fim) : null;
      const inicio = inicioDate ? formatDateTime(inicioDate) : "-";
      const fim = fimDate ? formatDateTime(fimDate) : "-";
      const osReferencia = item.osReferencia ? String(item.osReferencia).trim() : "";
      const meta = [];
      if (item.subestacao && item.subestacao !== "-") {
        meta.push(`Subestacao: ${item.subestacao}`);
      }
      if (item.equipamento && item.equipamento !== "-") {
        meta.push(`Equipamento: ${item.equipamento}`);
      }
      if (osReferencia) {
        meta.push(`OS: ${osReferencia}`);
      }
      if (item.categoria) {
        meta.push(`Categoria: ${item.categoria}`);
      }
      if (item.prioridade) {
        meta.push(`Prioridade: ${item.prioridade}`);
      }
      const metaHtml = meta.length
        ? `<div class="rdo-activity__meta">${meta
            .map((texto) => `<span>${escapeHtml(texto)}</span>`)
            .join("")}</div>`
        : `<div class="rdo-activity__meta"><span>Sem detalhes adicionais.</span></div>`;
      const janelaHtml = `
        <div class="rdo-janela">
          <span>Inicio: ${escapeHtml(inicio)}</span>
          <span>Fim: ${escapeHtml(fim)}</span>
        </div>
      `;
      return `
        <tr>
          <td>
            <div class="rdo-activity">
              <div class="rdo-activity__title">${escapeHtml(item.titulo)}</div>
              ${metaHtml}
            </div>
          </td>
          <td class="rdo-table__status">
            <span class="status-badge status-badge--${statusClass}">${escapeHtml(item.statusLabel)}</span>
          </td>
          <td>${janelaHtml}</td>
          <td>${escapeHtml(item.responsavel || "-")}</td>
        </tr>
      `;
    })
    .join("");

  const itensById = new Map((snapshot.itens || []).map((item) => [item.id, item]));
  const evidenciasHtml = snapshot.evidencias.length
    ? snapshot.evidencias
        .map((evidencia) => {
          const dataHora = evidencia.dataHora || "-";
          const responsavel = evidencia.responsavel || "-";
          const itemRef = itensById.get(evidencia.itemId) || {};
          const equipamentoRef = itemRef.equipamento || "-";
          const osRef = itemRef.osReferencia || "-";
          const legenda = `${evidencia.itemTitulo} • ${equipamentoRef} • OS ${osRef} • ${dataHora} • ${responsavel}`;
          return `
            <figure class="rdo-evidencia">
              <img src="${evidencia.dataUrl}" alt="${escapeHtml(legenda)}" />
              <figcaption>${escapeHtml(legenda)}</figcaption>
            </figure>
          `;
        })
        .join("")
    : `<p class="rdo-muted">— (sem registros no período)</p>`;

  const naoImagemHtml = snapshot.evidenciasNaoImagem.length
    ? `
      <div class="rdo-naoimagem">
        <strong>Evidências não-imagem</strong>
        <ul>
          ${snapshot.evidenciasNaoImagem
            .map(
              (item) =>
                `<li>${escapeHtml(item.itemTitulo)} - ${escapeHtml(item.nome)}</li>`
            )
            .join("")}
        </ul>
      </div>
    `
    : "";

  const responsaveisHeader = formatListLimited(
    (snapshot.itens || []).map((item) => item.responsavel).filter(Boolean),
    2
  ) || "-";
  const equipeHeader = formatListLimited(
    (snapshot.itens || [])
      .flatMap((item) => parseParticipantesLabel(item.participantes))
      .filter(Boolean),
    3
  ) || "-";
  const osList = Array.from(
    new Set((snapshot.itens || []).map((item) => item.osReferencia).filter(Boolean))
  );
  const osLabel = osList.length ? formatListLimited(osList, 3) : "-";
  const subestacoesHeader = Array.from(
    new Set(
      (snapshot.itens || [])
        .map((item) => item.subestacao)
        .filter((item) => item && item !== "-")
    )
  );
  const subestacaoHeader =
    subestacoesHeader.length === 1
      ? subestacoesHeader[0]
      : subestacoesHeader.length > 1
        ? "M\u00faltiplas"
        : "-";
  const statusDiaLabel =
    snapshot.metricas.total && snapshot.metricas.concluidas === snapshot.metricas.total
      ? "Conclu\u00edda"
      : snapshot.metricas.emExecucao > 0
        ? "Em execu\u00e7\u00e3o"
        : snapshot.metricas.overdue > 0
          ? "Pendente"
          : "Em andamento";
  const statusDiaFinal = snapshot.metricas.total === 0 ? "—" : statusDiaLabel;
  const statusDiaClass =
    statusDiaFinal === "Conclu\u00edda"
      ? "ok"
      : statusDiaFinal === "Em execu\u00e7\u00e3o"
        ? "warn"
        : statusDiaFinal === "Pendente"
          ? "danger"
          : "neutral";
  const statusField = formatValue(statusDiaFinal);
  const statusBadge = `<span class="rdo-badge rdo-badge--${escapeHtml(
    statusDiaClass
  )}${statusField.muted ? " rdo-badge--muted" : ""}">${escapeHtml(
    statusField.text
  )}</span>`;
  const docsBadge = snapshot.metricas.docsTotal ? `${docsPercent} \u2022 ${docsMeta}` : dash;
  const atividadesConsolidadoHtml = buildAtividadesConsolidadoHtml(atividadesConsolidado, {
    local: projeto,
    subestacao: subestacaoHeader,
    status: statusDiaFinal,
    statusClass: statusDiaClass,
    total: snapshot.metricas.total,
    concluidas: snapshot.metricas.concluidas,
    tempoTotal,
    docsBadge,
  });
  const themeRaw = options.theme || "enterprise";
  const theme = ["enterprise", "industrial", "minimal"].includes(themeRaw)
    ? themeRaw
    : "enterprise";

  
  const descricaoValue = formatValue(descricaoConsolidada || "");
  const descricaoText = descricaoValue.text;
  const descricaoMuted = descricaoValue.muted;
  const descricaoHtml = `
    <p class="rdo-paragraph rdo-paragraph--narrow${descricaoMuted ? " rdo-muted" : ""}">${escapeHtml(
      descricaoText
    )}</p>
  `;
  const registroTexto = String(snapshot.registroGerencial || "").trim();
  const registroNormalizado =
    registroTexto && registroTexto !== "-" && registroTexto !== "\u2014" ? registroTexto : "";
  const registroHtml = registroNormalizado
    ? `
      <section class="rdo-section rdo-note">
        <h3>Registro Gerencial do Dia</h3>
        <p>${escapeHtml(registroNormalizado)}</p>
      </section>
    `
    : "";

  const atividadesCardsHtml = (snapshot.itens || [])
    .map((item) => {
      const statusKey = item.statusKey || "";
      const statusClass =
        statusKey === "concluida"
          ? "ok"
          : statusKey === "em_execucao" || statusKey === "encerramento"
            ? "warn"
            : statusKey === "backlog"
              ? "danger"
              : "neutral";
      const inicioDate = item.inicio ? parseTimestamp(item.inicio) : null;
      const fimDate = item.fim ? parseTimestamp(item.fim) : null;
      const inicio = inicioDate ? formatDateTime(inicioDate) : "-";
      const fim = fimDate ? formatDateTime(fimDate) : "-";
      const duracaoMin =
        Number.isFinite(item.duracaoMin)
          ? item.duracaoMin
          : item.conclusao && Number.isFinite(item.conclusao.duracaoMin)
            ? item.conclusao.duracaoMin
            : inicioDate && fimDate
              ? Math.max(0, Math.round((fimDate.getTime() - inicioDate.getTime()) / 60000))
              : null;
      const duracaoLabel =
        Number.isFinite(duracaoMin) && duracaoMin > 0 ? formatDuracaoMin(duracaoMin) : dash;
      const gridItems = [
        { label: "Subesta\u00e7\u00e3o", value: item.subestacao },
        { label: "Equipamento", value: item.equipamento },
        { label: "OS", value: item.osReferencia },
        { label: "Janela", value: `${inicio} - ${fim}` },
        { label: "Dura\u00e7\u00e3o", value: duracaoLabel },
        { label: "Respons\u00e1vel", value: item.responsavel },
      ];
      const chips = [
        item.categoria ? `<span class="rdo-chip">${escapeHtml(item.categoria)}</span>` : "",
        item.prioridade
          ? `<span class="rdo-chip rdo-chip--priority">${escapeHtml(item.prioridade)}</span>`
          : "",
      ]
        .filter(Boolean)
        .join("");
      return `
        <article class="rdo-activity-card">
          <div class="rdo-activity-card__head">
            <div class="rdo-activity-card__title">${escapeHtml(item.titulo || "-")}</div>
            <span class="rdo-status rdo-status--${statusClass}">${escapeHtml(
              item.statusLabel || "-"
            )}</span>
          </div>
          <div class="rdo-activity-grid">
            ${gridItems
              .map((info) => {
                const val = formatValue(info.value);
                return `
                  <div>
                    <span>${escapeHtml(info.label)}</span>
                    <strong${val.muted ? ' class="rdo-muted"' : ""}>${escapeHtml(
                  val.text
                )}</strong>
                  </div>
                `;
              })
              .join("")}
          </div>
          ${chips ? `<div class="rdo-chip-row">${chips}</div>` : ""}
        </article>
      `;
    })
    .join("");
  const atividadesHtml = atividadesCardsHtml
    ? `<div class="rdo-activities">${atividadesCardsHtml}</div>`
    : `
      <div class="rdo-activities">
        <div class="rdo-activity-card rdo-activity-card--empty">
          <strong class="rdo-muted">— (sem registros no per\u00edodo)</strong>
        </div>
      </div>
    `;


  const totalAtividades = snapshot.metricas.total ?? 0;
  const totalConcluidas = snapshot.metricas.concluidas ?? 0;
  const totalExecucao = snapshot.metricas.emExecucao ?? 0;
  const totalPendentes = snapshot.metricas.overdue ?? 0;
  const totalCriticas = snapshot.metricas.criticas ?? 0;
  const panoramaDetail = totalAtividades
    ? `${totalAtividades} atividades — ${totalConcluidas} conclu\u00eddas, ${totalExecucao} em andamento, ${totalPendentes} pendentes.`
    : "—";
  const subCounts = (snapshot.itens || []).reduce((acc, item) => {
    const sub = item.subestacao && item.subestacao !== "-" ? item.subestacao : "";
    if (!sub) {
      return acc;
    }
    acc[sub] = (acc[sub] || 0) + 1;
    return acc;
  }, {});
  const topSub = Object.keys(subCounts)
    .map((key) => ({ key, total: subCounts[key] }))
    .sort((a, b) => b.total - a.total)[0];
  const volumeDetail = topSub
    ? `${topSub.key}: ${topSub.total} atividade${topSub.total === 1 ? "" : "s"}.`
    : totalAtividades
      ? `${projeto || dash}: ${totalAtividades} atividade${totalAtividades === 1 ? "" : "s"}.`
      : "—";
  const destaquesDetail = totalAtividades
    ? totalCriticas || totalPendentes
      ? `${totalCriticas} cr\u00edticas; ${totalPendentes} pend\u00eancias.`
      : "Sem pend\u00eancias cr\u00edticas."
    : "—";
  const resumoTexto = `
    <ul class="rdo-summary-lines">
      <li><strong>Panorama:</strong> ${escapeHtml(panoramaDetail)}</li>
      <li><strong>Volume/Local:</strong> ${escapeHtml(volumeDetail)}</li>
      <li><strong>Destaques/Pend\u00eancias:</strong> ${escapeHtml(destaquesDetail)}</li>
    </ul>
  `;
  const docsPercentLabel = snapshot.metricas.docsTotal ? `${docsPercent}` : dash;
  const docsMetaLabel = snapshot.metricas.docsTotal ? docsMeta : dash;
  const kpiCards = [
    { label: "Atividades", value: totalAtividades },
    { label: "Conclu\u00eddas", value: totalConcluidas },
    { label: "Cr\u00edticas", value: totalCriticas },
    { label: "Docs", value: docsPercentLabel, meta: docsMetaLabel },
    { label: "Tempo total", value: tempoTotal !== "-" ? tempoTotal : dash },
  ];
  const kpiCardsHtml = kpiCards
    .map(
      (item) => `
        <div class="rdo-kpi-card">
          <span>${escapeHtml(item.label)}</span>
          <strong>${escapeHtml(formatValue(item.value).text)}</strong>
          ${item.meta ? `<small>${escapeHtml(formatValue(item.meta).text)}</small>` : ""}
        </div>
      `
    )
    .join("");
  const itensCount = (snapshot.itens || []).length;
  const subtitleLabel = isCliente
    ? "Relat\u00f3rio Di\u00e1rio de Opera\u00e7\u00e3o - HV (Cliente)"
    : "Relat\u00f3rio Di\u00e1rio de Opera\u00e7\u00e3o - HV";

  return `
    <div class="rdo-doc rdo-template-a" data-theme="${escapeHtml(theme)}">
      <header class="rdo-header rdo-header--compact">
        <div class="rdo-header-line">
          <div class="rdo-logo-wrap">${logoHtml}</div>
          <div class="rdo-header-title">
            <span class="rdo-eyebrow">OPSCOPE</span>
            <h2 class="rdo-title">RDO ${escapeHtml(dataLabel)}</h2>
            <p class="rdo-subtitle">${escapeHtml(subtitleLabel)}</p>
          </div>
          <div class="rdo-header-meta">
            <div>
              <span>RDO/Hash</span>
              <strong>${escapeHtml(rdoNumero)} • ${escapeHtml(hashShort)}</strong>
            </div>
            <div>
              <span>Emitido por</span>
              <strong>${escapeHtml(emitidoPor)}</strong>
            </div>
            <div>
              <span>Emitido em</span>
              <strong>${escapeHtml(emitidoEm)}</strong>
            </div>
          </div>
        </div>
      </header>

      <section class="rdo-section rdo-tech-sheet">
        <div class="rdo-tech-grid">
          ${buildField("Local/Empreendimento", projeto, { className: "rdo-field--span-5" })}
          ${buildField("Cliente", cliente, { className: "rdo-field--span-3" })}
          ${buildField("Setor", RDO_SETOR, { className: "rdo-field--span-2" })}
          <div class="rdo-field rdo-field--status rdo-field--span-2">
            <span>Status do dia</span>
            ${statusBadge}
          </div>
          ${buildField("Subesta\u00e7\u00e3o", subestacaoHeader, { className: "rdo-field--span-4" })}
          ${buildField("OS/Ordem", osLabel, { className: "rdo-field--span-2" })}
          ${buildField("Respons\u00e1vel", responsaveisHeader, { className: "rdo-field--span-3" })}
          ${buildField("Equipe", equipeHeader, { className: "rdo-field--span-3" })}
        </div>
      </section>

      <section class="rdo-section rdo-summary rdo-summary--executive">
        <div class="rdo-section-head">
          <h3>Resumo Executivo</h3>
        </div>
        ${resumoTexto}
        <div class="rdo-kpi-row">
          ${kpiCardsHtml}
        </div>
      </section>

      <section class="rdo-section rdo-editorial">
        <div class="rdo-section-head">
          <h3>Descri\u00e7\u00e3o Consolidada do Dia</h3>
        </div>
        ${descricaoHtml}
      </section>

      <section class="rdo-section rdo-premium">
        <h3>Consolidado do Dia</h3>
        ${atividadesConsolidadoHtml}
      </section>

      <section class="rdo-section rdo-grid-2 rdo-grid-2--compact">
        <div class="rdo-block rdo-block--compact">
          <h3>Seguran\u00e7a</h3>
          <div class="rdo-info-grid rdo-info-grid--compact rdo-info-grid--safety">
            ${buildField("Incidente/Acidente", manual.incidente)}
            ${buildField("Bloqueio el\u00e9trico", manual.bloqueio)}
            ${buildField("Clima", climaValor)}
          </div>
        </div>
        <div class="rdo-block rdo-block--compact">
          <h3>Dados Operacionais</h3>
          <div class="rdo-info-grid rdo-info-grid--compact">
            ${buildField("Condutor", manual.condutor)}
            ${buildField("KM inicial", manual.kmInicial)}
            ${buildField("KM final", manual.kmFinal)}
            ${buildField("Qt. pessoas", manual.qtPessoas)}
            ${buildField("N\u00ba de SI", manual.numeroSi)}
            ${buildField("N\u00ba de SGI", manual.numeroSgi)}
            ${buildField("Local (manual)", local)}
          </div>
        </div>
      </section>

      <section class="rdo-section rdo-block rdo-header-shifts">
        <h3>Controle de jornada</h3>
        ${jornadaCardsHtml}
        ${acionamentoHtml}
        ${jornadaRowsHtml}
      </section>

      ${registroHtml}

      <section class="rdo-section">
        <div class="rdo-section-head">
          <h3>Atividades do Dia</h3>
          <span class="rdo-count">${escapeHtml(`${itensCount} itens`)}</span>
        </div>
        ${atividadesHtml}
      </section>

      <section class="rdo-section">
        <h3>Evid\u00eancias</h3>
        ${evidenciasLimitadas ? `<p class="hint">${escapeHtml(evidenciasLimitadas)}</p>` : ""}
        <div class="rdo-evidencias-grid">
          ${evidenciasHtml}
        </div>
        ${naoImagemHtml}
      </section>
    </div>
  `;
}

function buildRdoPrintHtml(snapshot, logoDataUrl = "", options = {}) {
  const baseHref = window.location.href.split("#")[0];
  const estilos = `
    @page { size: A4; margin: 12mm; }
    * { box-sizing: border-box; }
    body { font-family: "Trebuchet MS", Arial, sans-serif; color: #1f2933; margin: 0; background: #fff; }
    h2, h3, h4 { font-family: "Trebuchet MS", Arial, sans-serif; margin: 0 0 6px; }
    .rdo-doc { max-width: 860px; margin: 0 auto; display: block; }
    .rdo-doc.rdo-template-a {
      --rdo-bg: #ffffff;
      --rdo-card: #ffffff;
      --rdo-ink: #1f2933;
      --rdo-ink-soft: #4b5b68;
      --rdo-line: #d7dee5;
      --rdo-accent: #1f5f74;
      --rdo-accent-soft: rgba(31, 95, 116, 0.12);
      --rdo-ok: #15803d;
      --rdo-warn: #d97706;
      --rdo-danger: #b91c1c;
      --rdo-chip: #eef2f6;
      --rdo-chip-ink: #2f3b46;
    }
    .rdo-doc.rdo-template-a[data-theme="industrial"] {
      --rdo-bg: #0f1419;
      --rdo-card: #1b242d;
      --rdo-ink: #f2f5f9;
      --rdo-ink-soft: #b2beca;
      --rdo-line: #2b3540;
      --rdo-accent: #f59e0b;
      --rdo-accent-soft: rgba(245, 158, 11, 0.18);
      --rdo-ok: #22c55e;
      --rdo-warn: #f59e0b;
      --rdo-danger: #ef4444;
      --rdo-chip: rgba(255, 255, 255, 0.08);
      --rdo-chip-ink: #e7edf4;
    }
    .rdo-doc.rdo-template-a[data-theme="minimal"] {
      --rdo-bg: #f6f8fb;
      --rdo-card: #ffffff;
      --rdo-ink: #1e293b;
      --rdo-ink-soft: #556275;
      --rdo-line: #dbe2ea;
      --rdo-accent: #2563eb;
      --rdo-accent-soft: rgba(37, 99, 235, 0.12);
      --rdo-ok: #16a34a;
      --rdo-warn: #eab308;
      --rdo-danger: #dc2626;
      --rdo-chip: #edf2ff;
      --rdo-chip-ink: #243b6b;
    }
    .rdo-template-a { background: var(--rdo-bg); color: var(--rdo-ink); }
    .rdo-header { display: grid; gap: 12px; padding-bottom: 10px; border-bottom: 1px solid var(--rdo-line); }
    .rdo-header-main { display: flex; flex-wrap: wrap; justify-content: space-between; gap: 16px; align-items: flex-start; }
    .rdo-brand { display: flex; align-items: center; gap: 12px; }
    .rdo-logo { width: 70px; height: auto; object-fit: contain; }
    .rdo-logo-fallback { font-weight: 700; letter-spacing: 0.2em; text-transform: uppercase; display: none; }
    .rdo-eyebrow { font-size: 0.6rem; letter-spacing: 0.2em; text-transform: uppercase; color: var(--rdo-ink-soft); }
    .rdo-title { font-size: 1.3rem; letter-spacing: 0.08em; text-transform: uppercase; margin: 0; }
    .rdo-subtitle { font-size: 0.85rem; color: var(--rdo-ink-soft); margin: 0; }
    .rdo-meta { font-size: 0.78rem; display: grid; gap: 4px; color: var(--rdo-ink-soft); }
    .rdo-header-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 8px; }
    .rdo-header-grid > div { border: 1px solid var(--rdo-line); border-radius: 10px; padding: 6px 8px; background: var(--rdo-card); }
    .rdo-header-grid span { display: block; text-transform: uppercase; letter-spacing: 0.12em; font-size: 0.55rem; color: var(--rdo-ink-soft); }
    .rdo-header-grid strong { font-size: 0.8rem; color: var(--rdo-ink); }
    .rdo-section { display: grid; gap: 8px; margin: 0 0 10px; }
    .rdo-section-head { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .rdo-summary { border: 1px solid var(--rdo-line); border-radius: 12px; padding: 10px; background: var(--rdo-card); }
    .rdo-summary-lines { margin: 0 0 8px; padding-left: 18px; display: grid; gap: 4px; font-size: 0.82rem; line-height: 1.55; color: var(--rdo-ink); }
    .rdo-summary-lines li { margin: 0; }
    .rdo-summary-lines strong { font-weight: 600; color: var(--rdo-ink); }
    .rdo-kpi-row { display: grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap: 8px; }
    .rdo-kpi-card { border: 1px solid var(--rdo-line); border-radius: 10px; padding: 6px; background: #fff; display: grid; gap: 4px; }
    .rdo-kpi-card span { font-size: 0.6rem; letter-spacing: 0.12em; text-transform: uppercase; color: var(--rdo-ink-soft); }
    .rdo-kpi-card strong { font-size: 0.95rem; color: var(--rdo-ink); }
    .rdo-kpi-card small { font-size: 0.7rem; color: var(--rdo-ink-soft); }
    .rdo-kpi-card--primary { border-color: var(--rdo-accent); background: var(--rdo-accent-soft); }
    .rdo-kpi-card--primary strong { font-size: 1.05rem; }
    .rdo-editorial { border-left: 4px solid var(--rdo-accent); border-radius: 12px; padding: 10px; border: 1px solid var(--rdo-line); background: var(--rdo-card); }
    .rdo-premium { border: 1px solid var(--rdo-line); border-radius: 12px; padding: 10px; background: var(--rdo-card); }
    .rdo-consolidado-grid { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 8px; }
    .rdo-consolidado-grid span { display: block; text-transform: uppercase; letter-spacing: 0.12em; font-size: 0.55rem; color: var(--rdo-ink-soft); }
    .rdo-consolidado-grid strong { font-size: 0.82rem; color: var(--rdo-ink); }
    .rdo-consolidado-status small { font-size: 0.7rem; color: var(--rdo-ink-soft); }
    .rdo-consolidado-activity { display: grid; gap: 4px; padding: 6px 0; }
    .rdo-consolidado-activity span { font-size: 0.6rem; letter-spacing: 0.12em; text-transform: uppercase; color: var(--rdo-ink-soft); }
    .rdo-consolidado-activity strong { font-size: 0.9rem; color: var(--rdo-ink); }
    .rdo-consolidado-activity small { display: block; margin-top: 2px; font-size: 0.7rem; color: var(--rdo-ink-soft); }
    .rdo-consolidado-chips { display: flex; flex-wrap: wrap; gap: 6px; margin: 6px 0 2px; }
    .rdo-equip-group { border: 1px solid var(--rdo-line); border-radius: 10px; padding: 8px; background: rgba(0, 0, 0, 0.02); }
    .rdo-equip-group h5 { margin: 0 0 6px; font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--rdo-ink-soft); }
    .rdo-mini { display: flex; flex-wrap: wrap; gap: 6px; font-size: 0.72rem; color: var(--rdo-ink-soft); }
    .rdo-info-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 8px; font-size: 0.75rem; color: var(--rdo-ink-soft); }
    .rdo-info-grid span { display: block; text-transform: uppercase; letter-spacing: 0.1em; font-size: 0.55rem; }
    .rdo-info-grid strong { font-size: 0.8rem; color: var(--rdo-ink); }
    .rdo-info-grid--compact { grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 6px; }
    .rdo-info-grid--safety { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    .rdo-info-grid--compact .rdo-field { padding: 6px 8px; border-radius: 8px; gap: 2px; }
    .rdo-info-grid--compact .rdo-field span { font-size: 0.55rem; }
    .rdo-info-grid--compact .rdo-field strong { font-size: 0.82rem; }
    .rdo-grid-2 { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 12px; }
    .rdo-grid-2--compact { gap: 8px; align-items: start; }
    .rdo-block { border: 1px solid var(--rdo-line); border-radius: 12px; padding: 10px; background: var(--rdo-card); }
    .rdo-block--compact { padding: 8px; }
    .rdo-summary,
    .rdo-editorial,
    .rdo-premium,
    .rdo-block,
    .rdo-tech-sheet,
    .rdo-journey-card,
    .rdo-activity-card,
    .rdo-evidencia,
    .rdo-note { break-inside: avoid; page-break-inside: avoid; }
    .rdo-paragraph { margin: 0; line-height: 1.55; font-size: 0.82rem; color: var(--rdo-ink); }
    .rdo-pill { border-radius: 999px; padding: 2px 8px; font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.12em; border: 1px solid var(--rdo-line); color: var(--rdo-ink-soft); }
    .rdo-pill--accent { border-color: var(--rdo-accent); color: var(--rdo-accent); }
    .rdo-status { display: inline-flex; align-items: center; justify-content: center; padding: 3px 8px; border-radius: 999px; font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.12em; border: 1px solid transparent; }
    .rdo-status--ok { color: var(--rdo-ok); background: rgba(21, 128, 61, 0.12); border-color: rgba(21, 128, 61, 0.25); }
    .rdo-status--warn { color: var(--rdo-warn); background: rgba(217, 119, 6, 0.12); border-color: rgba(217, 119, 6, 0.25); }
    .rdo-status--danger { color: var(--rdo-danger); background: rgba(185, 28, 28, 0.12); border-color: rgba(185, 28, 28, 0.25); }
    .rdo-status--neutral { color: var(--rdo-ink-soft); background: rgba(100, 116, 139, 0.12); border-color: rgba(100, 116, 139, 0.25); }
    .rdo-activities { display: grid; gap: 8px; }
    .rdo-activity-card { border: 1px solid var(--rdo-line); border-radius: 12px; padding: 8px; background: var(--rdo-card); display: grid; gap: 6px; }
    .rdo-activity-card__head { display: flex; justify-content: space-between; gap: 10px; align-items: center; }
    .rdo-activity-card__title { font-size: 0.82rem; font-weight: 600; color: var(--rdo-ink); }
    .rdo-activity-grid { display: grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap: 6px; font-size: 0.72rem; color: var(--rdo-ink-soft); }
    .rdo-activity-grid span { display: block; font-size: 0.55rem; text-transform: uppercase; letter-spacing: 0.1em; }
    .rdo-activity-grid strong { font-size: 0.78rem; color: var(--rdo-ink); }
    .rdo-chip-row { display: flex; flex-wrap: wrap; gap: 6px; }
    .rdo-chip { border-radius: 999px; padding: 2px 8px; background: var(--rdo-chip); color: var(--rdo-chip-ink); font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.08em; }
    .rdo-chip--plain { text-transform: none; letter-spacing: 0.02em; font-size: 0.72rem; }
    .rdo-chip--priority { background: rgba(245, 158, 11, 0.18); color: #8a5302; }
    .rdo-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
    .rdo-table th, .rdo-table td { border-bottom: 1px solid var(--rdo-line); padding: 6px 8px; text-align: left; }
    .rdo-table th { font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.12em; color: var(--rdo-ink-soft); background: #f6f7f9; }
    .rdo-evidencias-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .rdo-evidencia { border: 1px solid var(--rdo-line); border-radius: 10px; overflow: hidden; }
    .rdo-evidencia img { width: 100%; height: auto; display: block; }
    .rdo-evidencia figcaption { padding: 6px 8px; font-size: 0.7rem; color: var(--rdo-ink-soft); background: #f6f7f9; }
    .rdo-note { border: 1px dashed var(--rdo-line); border-radius: 12px; padding: 10px 12px; background: #fff; }
    .rdo-count { font-size: 0.7rem; color: var(--rdo-ink-soft); }
    .empty-state { font-size: 0.75rem; color: var(--rdo-ink-soft); }
    .hint { font-size: 0.72rem; color: var(--rdo-ink-soft); }
    .rdo-lista { margin: 0; padding-left: 18px; font-size: 0.75rem; color: var(--rdo-ink-soft); }
    .rdo-header-line { display: grid; grid-template-columns: auto 1fr auto; gap: 16px; align-items: center; }
    .rdo-logo-wrap { display: flex; align-items: center; }
    .rdo-header-title { display: grid; gap: 2px; }
    .rdo-header-meta { display: grid; gap: 6px; text-align: right; font-size: 0.78rem; color: var(--rdo-ink-soft); }
    .rdo-header-meta span { display: block; font-size: 0.55rem; text-transform: uppercase; letter-spacing: 0.12em; }
    .rdo-tech-sheet { border: 1px solid var(--rdo-line); border-radius: 12px; padding: 12px; background: var(--rdo-card); }
    .rdo-tech-grid { display: grid; grid-template-columns: repeat(12, minmax(0, 1fr)); gap: 10px; }
    .rdo-tech-sheet .rdo-field { padding: 7px 9px; }
    .rdo-field { border: 1px solid var(--rdo-line); border-radius: 10px; padding: 8px 10px; background: var(--rdo-card); display: grid; gap: 4px; }
    .rdo-field span { font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.12em; color: var(--rdo-ink-soft); }
    .rdo-field strong { font-size: 0.86rem; color: var(--rdo-ink); }
    .rdo-field--status { align-content: center; }
    .rdo-field--span-2 { grid-column: span 2; }
    .rdo-field--span-3 { grid-column: span 3; }
    .rdo-field--span-4 { grid-column: span 4; }
    .rdo-field--span-5 { grid-column: span 5; }
    .rdo-field--span-6 { grid-column: span 6; }
    .rdo-badge { display: inline-flex; align-items: center; justify-content: center; padding: 6px 10px; border-radius: 999px; font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.12em; border: 1px solid transparent; }
    .rdo-badge--ok { color: var(--rdo-ok); background: rgba(21, 128, 61, 0.12); border-color: rgba(21, 128, 61, 0.25); }
    .rdo-badge--warn { color: var(--rdo-warn); background: rgba(217, 119, 6, 0.12); border-color: rgba(217, 119, 6, 0.25); }
    .rdo-badge--danger { color: var(--rdo-danger); background: rgba(185, 28, 28, 0.12); border-color: rgba(185, 28, 28, 0.25); }
    .rdo-badge--neutral { color: var(--rdo-ink-soft); background: rgba(100, 116, 139, 0.12); border-color: rgba(100, 116, 139, 0.25); }
    .rdo-badge--muted { color: var(--rdo-ink-soft); border-color: var(--rdo-line); background: rgba(120, 130, 145, 0.08); }
    .rdo-paragraph--narrow { max-width: 720px; }
    .rdo-kpi-row { display: grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap: 8px; }
    .rdo-kpi-card strong { font-size: 1.1rem; line-height: 1.2; }
    .rdo-consolidado-line { margin: 6px 0 2px; display: flex; flex-wrap: wrap; gap: 8px; font-size: 0.8rem; color: var(--rdo-ink-soft); }
    .rdo-consolidado-line span { font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.12em; }
    .rdo-journey-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .rdo-journey-card { border: 1px solid var(--rdo-line); border-radius: 12px; padding: 10px; background: var(--rdo-card); display: grid; gap: 4px; }
    .rdo-journey-card span { font-size: 0.6rem; text-transform: uppercase; letter-spacing: 0.12em; color: var(--rdo-ink-soft); }
    .rdo-journey-card strong { font-size: 1rem; color: var(--rdo-ink); }
    .rdo-journey-card small { font-size: 0.72rem; color: var(--rdo-ink-soft); }
    .rdo-journey-row { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .rdo-note-muted { font-size: 0.75rem; color: var(--rdo-ink-soft); }
    .rdo-activity-card--empty { text-align: center; }
    .rdo-muted { color: var(--rdo-ink-soft); }
  `;
  let body = buildRdoHtml(snapshot, { ...options, print: true });
  if (logoDataUrl) {
    body = body.replace('src="./assets/engelmig-logo.png"', `src="${logoDataUrl}"`);
  }
  const titleLabel = options.cliente ? "RDO cliente" : "RDO";
  return `
    <!doctype html>
    <html lang="pt-BR">
      <head>
        <meta charset="utf-8" />
        <title>${titleLabel} ${escapeHtml(snapshot.rdoDate || "")}</title>
        <base href="${baseHref}" />
        <style>${estilos}</style>
      </head>
      <body>${body}</body>
    </html>
  `;
}

function waitForImages(doc) {
  const imagens = Array.from(doc.images || []);
  const pendentes = imagens.filter((img) => !img.complete);
  if (!pendentes.length) {
    return Promise.resolve();
  }
  return Promise.all(
    pendentes.map(
      (img) =>
        new Promise((resolve) => {
          img.onload = resolve;
          img.onerror = resolve;
        })
    )
  );
}

function waitForRdoLogo(doc) {
  const img = doc.getElementById("rdoEngelmigLogo");
  const fallback = doc.getElementById("rdoEngelmigFallback");
  if (!img) {
    if (fallback) {
      fallback.style.display = "block";
    }
    return Promise.resolve(false);
  }
  if (img.complete && img.naturalWidth > 0) {
    if (fallback) {
      fallback.style.display = "none";
    }
    return Promise.resolve(true);
  }
  return new Promise((resolve) => {
    let done = false;
    const finalizar = (ok) => {
      if (done) {
        return;
      }
      done = true;
      img.onload = null;
      img.onerror = null;
      clearTimeout(timer);
      if (!ok && fallback) {
        fallback.style.display = "block";
      }
      resolve(ok);
    };
    const timer = setTimeout(() => finalizar(false), 1500);
    img.onload = () => finalizar(true);
    img.onerror = () => finalizar(false);
  });
}

async function carregarLogoRdoDataUrl() {
  const logoPath = "./assets/engelmig-logo.png";
  const timeoutMs = 1500;
  try {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    const response = await fetch(logoPath, { cache: "no-cache", signal: controller.signal });
    clearTimeout(timer);
    if (!response.ok) {
      return "";
    }
    const blob = await response.blob();
    return await blobToDataUrl(blob);
  } catch (error) {
    return "";
  }
}

async function exportarRdoPdf(snapshot, options = {}) {
  if (!snapshot) {
    return;
  }
  const logoDataUrl = await carregarLogoRdoDataUrl();
  const html = buildRdoPrintHtml(snapshot, logoDataUrl, options);
  const popup = window.open("", "_blank");
  if (!popup) {
    mostrarMensagemRdo("Popup bloqueado. Permita a abertura para exportar o PDF.", true);
    return;
  }
  popup.document.open();
  popup.document.write(html);
  popup.document.close();
  let printed = false;
  const tentarImprimir = async () => {
    if (printed) {
      return;
    }
    printed = true;
    await waitForRdoLogo(popup.document);
    await waitForImages(popup.document);
    popup.focus();
    popup.print();
  };
  popup.addEventListener("load", () => {
    tentarImprimir();
  });
  setTimeout(() => {
    tentarImprimir();
  }, 600);
}

function renderAuditoria() {
  if (!listaAuditoria || !auditVazio) {
    return;
  }
  listaAuditoria.innerHTML = "";
  const ordenadas = [...auditLog]
    .sort((a, b) => (getTimeValue(b.timestamp) || 0) - (getTimeValue(a.timestamp) || 0))
    .slice(0, 20);
  if (ordenadas.length === 0) {
    auditVazio.hidden = false;
    return;
  }
  auditVazio.hidden = true;
  ordenadas.forEach((entry) => {
    const item = document.createElement("div");
    item.className = "audit-item";

    const titulo = document.createElement("strong");
    const label = ACTION_LABELS[entry.action] || entry.action;
    const detalhe = entry.title ? ` - ${entry.title}` : "";
    titulo.textContent = `${label}${detalhe}`;

    const meta = document.createElement("small");
    const autor = getUserLabel(entry.userId);
    const dataEvento = parseTimestamp(entry.timestamp);
    meta.textContent = `${autor} - ${dataEvento ? formatDateTime(dataEvento) : "-"}`;

    item.append(titulo, meta);
    if (entry.detalhes && entry.detalhes.resumo) {
      const extra = document.createElement("small");
      extra.textContent = entry.detalhes.resumo;
      item.append(extra);
    }
    listaAuditoria.append(item);
  });
}

function renderKPIs() {
  if (!kpiTotal || !kpiConclusao || !kpiConcluidas || !kpiBacklog || !kpiPontual || !kpiAtraso) {
    return;
  }
  const total = manutencoes.length;
  const concluidas = manutencoes.filter((item) => item.status === "concluida");
  const backlog = manutencoes.filter((item) => item.status === "backlog");
  const hoje = startOfDay(new Date());

  const taxaConclusao = total ? Math.round((concluidas.length / total) * 100) : 0;
  const pontuais = concluidas.filter((item) => {
    const data = parseDate(item.data);
    const doneAt = parseTimestamp(item.doneAt);
    if (!data || !doneAt) {
      return false;
    }
    return startOfDay(doneAt) <= startOfDay(data);
  });
  const taxaPontual = concluidas.length
    ? Math.round((pontuais.length / concluidas.length) * 100)
    : 0;

  const atrasos = [];
  manutencoes.forEach((item) => {
    const data = parseDate(item.data);
    if (!data) {
      return;
    }
    if (item.status === "backlog") {
      const diff = diffInDays(data, hoje);
      if (diff > 0) {
        atrasos.push(diff);
      }
    }
    if (item.status === "concluida" && item.doneAt) {
      const doneAt = parseTimestamp(item.doneAt);
      const diff = doneAt ? diffInDays(data, startOfDay(doneAt)) : null;
      if (diff > 0) {
        atrasos.push(diff);
      }
    }
  });
  const mediaAtraso = atrasos.length
    ? Math.round(atrasos.reduce((acc, val) => acc + val, 0) / atrasos.length)
    : 0;

  kpiTotal.textContent = total;
  kpiConclusao.textContent = `${taxaConclusao}%`;
  kpiConcluidas.textContent = `${concluidas.length} concluídas`;
  kpiBacklog.textContent = backlog.length;
  kpiPontual.textContent = `${taxaPontual}%`;
  kpiAtraso.textContent = mediaAtraso;
}

function startOfWeek(date) {
  const inicio = startOfDay(date);
  const day = inicio.getDay();
  const diff = (day + 6) % 7;
  inicio.setDate(inicio.getDate() - diff);
  return inicio;
}

function addDays(date, days) {
  const copia = new Date(date);
  copia.setDate(copia.getDate() + days);
  return copia;
}

function inRange(date, start, end) {
  return date >= start && date <= end;
}

// KPI: tooltips
function buildKpiTooltip(titulo, formula, periodo) {
  return `O que é: ${titulo}\nComo calcula: ${formula}\nPeríodo: ${periodo}`;
}

function parseAnyDate(value) {
  if (!value && value !== 0) {
    return null;
  }
  if (value instanceof Date || typeof value === "number") {
    return parseTimestamp(value);
  }
  if (typeof value === "string") {
    const text = value.trim();
    if (!text) {
      return null;
    }
    if (/^\d{4}-\d{2}-\d{2}$/.test(text)) {
      const byDate = parseDate(text);
      if (byDate) {
        return byDate;
      }
    }
    const parsed = parseTimestamp(text);
    if (parsed) {
      return parsed;
    }
    const byDateTime = parseDateTimeInput(text);
    if (byDateTime) {
      return byDateTime;
    }
  }
  return null;
}

function pickItemValue(item, keys) {
  if (!item) {
    return null;
  }
  for (const key of keys) {
    const value = item[key];
    if (value !== undefined && value !== null && value !== "") {
      return value;
    }
  }
  return null;
}

function getItemCriacaoDate(item) {
  return parseAnyDate(pickItemValue(item, ["createdAt", "abertaEm", "criadaEm"]));
}

function getItemInicioExecucaoDate(item) {
  const direto = pickItemValue(item, ["executionStartedAt", "inicioExecucao", "inicio"]);
  const registro = item && item.registroExecucao ? item.registroExecucao.inicio : null;
  const conclusao = item && item.conclusao ? item.conclusao.inicio : null;
  return parseAnyDate(direto || registro || conclusao);
}

function getItemFimExecucaoDate(item) {
  const direto = pickItemValue(item, ["executionFinishedAt", "fimExecucao", "fim"]);
  const conclusao = item && item.conclusao ? item.conclusao.fim : null;
  return parseAnyDate(direto || conclusao);
}

function getItemConclusaoDate(item) {
  const direto = pickItemValue(item, ["doneAt", "concluidaEm", "executionFinishedAt"]);
  const conclusao = item && item.conclusao ? item.conclusao.fim : null;
  return parseAnyDate(direto || conclusao);
}

function getExecutadoPorId(item) {
  const direto = pickItemValue(item, ["executadaPor", "executionStartedBy", "doneBy"]);
  const registro = item && item.registroExecucao ? item.registroExecucao.executadoPor : null;
  const conclusao = item && item.conclusao ? item.conclusao.executadoPor : null;
  return direto || registro || conclusao || "";
}

function getItemSubestacao(item) {
  return pickItemValue(item, ["local", "subestacao"]) || "";
}

function getItemCategoria(item) {
  return (
    pickItemValue(item, ["categoria", "tipo", "tipoManutencao"]) ||
    (item && item.conclusao ? pickItemValue(item.conclusao, ["categoria", "tipo"]) : "") ||
    (item && item.registroExecucao
      ? pickItemValue(item.registroExecucao, ["categoria", "tipo"])
      : "") ||
    ""
  );
}

function getItemPrioridade(item) {
  return (
    pickItemValue(item, ["prioridade", "prioridadeNivel"]) ||
    (item && item.conclusao ? pickItemValue(item.conclusao, ["prioridade"]) : "") ||
    (item && item.registroExecucao
      ? pickItemValue(item.registroExecucao, ["prioridade"])
      : "") ||
    ""
  );
}

function getRdoItemSnapshot(manutencaoId) {
  if (!manutencaoId || !Array.isArray(rdoSnapshots) || !rdoSnapshots.length) {
    return null;
  }
  let found = null;
  let foundDate = null;
  rdoSnapshots.forEach((snapshot) => {
    if (!snapshot || !Array.isArray(snapshot.itens)) {
      return;
    }
    const match = snapshot.itens.find(
      (item) => item && String(item.id || "") === String(manutencaoId)
    );
    if (!match) {
      return;
    }
    const candidateDate = snapshot.createdAt || snapshot.rdoDate || "";
    if (!found || (candidateDate && candidateDate > (foundDate || ""))) {
      found = match;
      foundDate = candidateDate;
    }
  });
  return found;
}

function findSimilarMaintenance(item) {
  if (!item || !Array.isArray(manutencoes)) {
    return null;
  }
  const templateId = item.templateId || "";
  const titulo = normalizeSearchValue(item.titulo || item.nome || "");
  let best = null;
  let bestScore = -1;
  manutencoes.forEach((candidate) => {
    if (!candidate || candidate.id === item.id) {
      return;
    }
    const sameTemplate = templateId && candidate.templateId === templateId;
    const sameTitle =
      titulo &&
      normalizeSearchValue(candidate.titulo || candidate.nome || "") === titulo;
    if (!sameTemplate && !sameTitle) {
      return;
    }
    const score =
      (getItemCategoria(candidate) ? 1 : 0) +
      (getItemPrioridade(candidate) ? 1 : 0) +
      (pickItemValue(candidate, ["equipamentoId", "equipamento"]) ? 1 : 0) +
      (getItemSubestacao(candidate) ? 1 : 0) +
      (getItemDescricaoRdo(candidate) ? 1 : 0);
    if (score > bestScore) {
      best = candidate;
      bestScore = score;
    }
  });
  return best;
}

function isCriticoValor(valor) {
  if (valor === true) {
    return true;
  }
  if (valor === false || valor === null || valor === undefined) {
    return false;
  }
  if (typeof valor === "string") {
    const normalizado = valor.trim().toLowerCase();
    return ["sim", "s", "true", "critico"].includes(normalizado);
  }
  return false;
}

function isItemCritico(item) {
  if (item && item.liberacao && item.liberacao.critico !== undefined) {
    return isCriticoValor(item.liberacao.critico);
  }
  const valor = pickItemValue(item, ["criticidade", "trabalhoCritico", "critico"]);
  return isCriticoValor(valor);
}

function getItemDocs(item) {
  if (!item) {
    return null;
  }
  if (item.liberacao && item.liberacao.documentos) {
    return item.liberacao.documentos;
  }
  return item.documentos || item.docs || null;
}

function getDocCompliance(item) {
  const docs = getItemDocs(item);
  if (!docs) {
    return null;
  }
  const obrigatorios = ["apr", "os", "pte"];
  if (isItemCritico(item)) {
    obrigatorios.push("pt");
  }
  return obrigatorios.every((key) => docs[key]);
}

function getItemReferenciaDate(item) {
  return (
    getItemConclusaoDate(item) ||
    getItemCriacaoDate(item) ||
    parseAnyDate(item ? item.data : null)
  );
}

function buildPeriodoJanela(periodoDias) {
  const hoje = startOfDay(new Date());
  const inicio = addDays(hoje, -(periodoDias - 1));
  const anteriorFim = addDays(inicio, -1);
  const anteriorInicio = addDays(anteriorFim, -(periodoDias - 1));
  return { inicio, fim: hoje, anteriorInicio, anteriorFim };
}

function aplicarFiltrosBase(items, filtros) {
  return items.filter((item) => {
    if (filtros.subestacao && getItemSubestacao(item) !== filtros.subestacao) {
      return false;
    }
    if (filtros.categoria && getItemCategoria(item) !== filtros.categoria) {
      return false;
    }
    if (filtros.prioridade && getItemPrioridade(item) !== filtros.prioridade) {
      return false;
    }
    return true;
  });
}

function aplicarFiltroPeriodo(items, janela) {
  return items.filter((item) => {
    const referencia = getItemReferenciaDate(item);
    if (!referencia) {
      return false;
    }
    const dia = startOfDay(referencia);
    return inRange(dia, janela.inicio, janela.fim);
  });
}

function isItemOverdue(item, hoje) {
  if (!item || item.status === "concluida") {
    return false;
  }
  const data = parseDate(item.data);
  if (!data) {
    return false;
  }
  return startOfDay(data) < hoje;
}

function isSlaCompliant(item) {
  const data = parseDate(item.data);
  const concluidaEm = getItemConclusaoDate(item);
  if (!data || !concluidaEm) {
    return null;
  }
  return startOfDay(concluidaEm) <= startOfDay(data);
}

// KPI: filtros globais
function getKpiFiltros() {
  const periodo = kpiPeriodo ? Number(kpiPeriodo.value) || 30 : 30;
  return {
    periodo,
    subestacao: kpiSubestacao ? kpiSubestacao.value : "",
    categoria: kpiCategoria ? kpiCategoria.value : "",
    prioridade: kpiPrioridade ? kpiPrioridade.value : "",
    usuario: kpiUsuarioFiltro ? kpiUsuarioFiltro.value : "",
  };
}

function atualizarSelectKpi(select, valores, labelPadrao) {
  if (!select) {
    return;
  }
  const atual = select.value;
  select.innerHTML = "";
  const optionAll = document.createElement("option");
  optionAll.value = "";
  optionAll.textContent = labelPadrao;
  select.append(optionAll);
  valores.forEach((valor) => {
    const option = document.createElement("option");
    option.value = valor;
    option.textContent = valor;
    select.append(option);
  });
  if (atual && Array.from(select.options).some((opt) => opt.value === atual)) {
    select.value = atual;
  }
}

function atualizarFiltrosKpi(baseItems) {
  const subestacoes = Array.from(
    new Set(
      baseItems
        .map((item) => getItemSubestacao(item))
        .filter(Boolean)
        .concat(getSubestacoesBase())
    )
  ).sort((a, b) => a.localeCompare(b, "pt-BR"));
  const categorias = Array.from(
    new Set(baseItems.map((item) => getItemCategoria(item)).filter(Boolean))
  ).sort((a, b) => a.localeCompare(b, "pt-BR"));
  const prioridades = Array.from(
    new Set(baseItems.map((item) => getItemPrioridade(item)).filter(Boolean))
  ).sort((a, b) => a.localeCompare(b, "pt-BR"));

  atualizarSelectKpi(kpiSubestacao, subestacoes, "Todas");
  atualizarSelectKpi(kpiCategoria, categorias, "Todas");
  atualizarSelectKpi(kpiPrioridade, prioridades, "Todas");

  if (kpiUsuarioFiltro) {
    const atual = kpiUsuarioFiltro.value;
    const usuarios = Array.from(
      new Set(
        baseItems
          .map((item) => getExecutadoPorId(item))
          .filter(Boolean)
          .concat(users.map((user) => user.id))
      )
    )
      .map((id) => ({ id, label: getUserLabel(id) }))
      .sort((a, b) => a.label.localeCompare(b.label, "pt-BR"));
    kpiUsuarioFiltro.innerHTML = "";
    const optionAll = document.createElement("option");
    optionAll.value = "";
    optionAll.textContent = "Todos";
    kpiUsuarioFiltro.append(optionAll);
    usuarios.forEach((user) => {
      const option = document.createElement("option");
      option.value = user.id;
      option.textContent = user.label;
      kpiUsuarioFiltro.append(option);
    });
    if (atual && Array.from(kpiUsuarioFiltro.options).some((opt) => opt.value === atual)) {
      kpiUsuarioFiltro.value = atual;
    }
  }
}

// KPI: calculo base
function calcularKpisBase(items) {
  const hoje = startOfDay(new Date());
  const concluidas = items.filter((item) => item.status === "concluida");
  const backlog = items.filter((item) => item.status === "backlog");
  const overdue = items.filter((item) => isItemOverdue(item, hoje));
  const criticosAbertos = items.filter(
    (item) => item.status !== "concluida" && isItemCritico(item)
  );

  const slaResultados = [];
  concluidas.forEach((item) => {
    const ok = isSlaCompliant(item);
    if (ok === null) {
      return;
    }
    slaResultados.push(ok);
  });
  const slaCompliance = slaResultados.length
    ? Math.round((slaResultados.filter(Boolean).length / slaResultados.length) * 100)
    : null;

  const leadTimes = concluidas
    .map((item) => {
      const criadoEm = getItemCriacaoDate(item);
      const concluidoEm = getItemConclusaoDate(item);
      if (!criadoEm || !concluidoEm) {
        return null;
      }
      return (concluidoEm - criadoEm) / DAY_MS;
    })
    .filter((valor) => Number.isFinite(valor));
  const leadTimeMedio = leadTimes.length
    ? leadTimes.reduce((acc, val) => acc + val, 0) / leadTimes.length
    : null;

  const mttrMinutos = concluidas
    .map((item) => {
      const inicio = getItemInicioExecucaoDate(item);
      const fim = getItemFimExecucaoDate(item);
      if (!inicio || !fim) {
        return null;
      }
      return (fim - inicio) / 60000;
    })
    .filter((valor) => Number.isFinite(valor));
  const mttrMedio = mttrMinutos.length
    ? mttrMinutos.reduce((acc, val) => acc + val, 0) / mttrMinutos.length
    : null;

  return {
    backlogTotal: backlog.length,
    overdueTotal: overdue.length,
    slaCompliance,
    leadTimeMedio,
    mttrMedio,
    criticosAbertos: criticosAbertos.length,
  };
}

function formatDuracaoKpi(minutos) {
  if (minutos === null || minutos === undefined || Number.isNaN(minutos)) {
    return "N/A";
  }
  const total = Math.max(0, Math.round(minutos));
  const horas = Math.floor(total / 60);
  const mins = total % 60;
  return `${horas}h ${mins}m`;
}

function formatKpiValor(valor, tipo) {
  if (valor === null || valor === undefined || Number.isNaN(valor)) {
    return "N/A";
  }
  if (tipo === "percent") {
    return `${Math.round(valor)}%`;
  }
  if (tipo === "days") {
    return `${valor.toFixed(1)} dias`;
  }
  if (tipo === "duration") {
    return formatDuracaoKpi(valor);
  }
  return String(Math.round(valor));
}

function formatKpiDelta(atual, anterior, tipo, periodoDias) {
  if (atual === null || anterior === null) {
    return "\u2014";
  }
  const diff = atual - anterior;
  if (tipo === "duration") {
    const texto = formatDuracaoKpi(Math.abs(diff));
    const sinal = diff > 0 ? "+" : diff < 0 ? "-" : "";
    return `${sinal}${texto} vs ${periodoDias}d`;
  }
  const textoBase = diff > 0 ? `+${diff}` : `${diff}`;
  if (tipo === "percent") {
    const texto = diff > 0 ? `+${Math.round(diff)}` : `${Math.round(diff)}`;
    return `${texto}pp vs ${periodoDias}d`;
  }
  if (tipo === "days") {
    const texto = diff > 0 ? `+${diff.toFixed(1)}` : `${diff.toFixed(1)}`;
    return `${texto}d vs ${periodoDias}d`;
  }
  return `${textoBase} vs ${periodoDias}d`;
}

// KPI: renderizacao cards
function renderKpiCards(itens, itensAnterior, filtros) {
  if (!kpiCards) {
    return;
  }
  kpiCards.innerHTML = "";
  const atual = calcularKpisBase(itens);
  const anterior = calcularKpisBase(itensAnterior);
  const periodoLabel = `últimos ${filtros.periodo} dias`;
  const cards = [
    {
      key: "backlog_total",
      label: "Backlog total",
      valor: atual.backlogTotal,
      delta: formatKpiDelta(
        atual.backlogTotal,
        anterior.backlogTotal,
        "count",
        filtros.periodo
      ),
      formato: "count",
      tooltip: buildKpiTooltip(
        "Backlog total",
        "Manutenções com status backlog.",
        periodoLabel
      ),
    },
    {
      key: "overdue_total",
      label: "Overdue / Vencidas",
      valor: atual.overdueTotal,
      delta: formatKpiDelta(
        atual.overdueTotal,
        anterior.overdueTotal,
        "count",
        filtros.periodo
      ),
      formato: "count",
      tooltip: buildKpiTooltip(
        "Overdue",
        "Manutenções abertas com data programada menor que hoje.",
        periodoLabel
      ),
    },
    {
      key: "sla_compliance",
      label: "SLA compliance",
      valor: atual.slaCompliance,
      delta: formatKpiDelta(
        atual.slaCompliance,
        anterior.slaCompliance,
        "percent",
        filtros.periodo
      ),
      formato: "percent",
      tooltip: buildKpiTooltip(
        "SLA compliance",
        "Concluídas no prazo / concluídas no período.",
        periodoLabel
      ),
    },
    {
      key: "lead_time",
      label: "Lead time médio",
      valor: atual.leadTimeMedio,
      delta: formatKpiDelta(
        atual.leadTimeMedio,
        anterior.leadTimeMedio,
        "days",
        filtros.periodo
      ),
      formato: "days",
      tooltip: buildKpiTooltip(
        "Lead time",
        "Conclusão - criação (dias).",
        periodoLabel
      ),
    },
    {
      key: "mttr",
      label: "MTTR médio",
      valor: atual.mttrMedio,
      delta: formatKpiDelta(atual.mttrMedio, anterior.mttrMedio, "duration", filtros.periodo),
      formato: "duration",
      tooltip: buildKpiTooltip(
        "MTTR médio",
        "Fim da execução - início da execução.",
        periodoLabel
      ),
    },
    {
      key: "criticos_abertos",
      label: "Críticos em aberto",
      valor: atual.criticosAbertos,
      delta: formatKpiDelta(
        atual.criticosAbertos,
        anterior.criticosAbertos,
        "count",
        filtros.periodo
      ),
      formato: "count",
      tooltip: buildKpiTooltip(
        "Críticos em aberto",
        "Manutenções críticas não concluídas.",
        periodoLabel
      ),
    },
  ];

  cards.forEach((card) => {
    const item = document.createElement("div");
    item.className = "kpi-card kpi-card--metric";
    item.dataset.drilldown = card.key;
    item.style.cursor = "pointer";
    const head = document.createElement("div");
    head.className = "kpi-card__head";
    const label = document.createElement("span");
    label.className = "kpi-card__label";
    label.textContent = card.label;
    const info = document.createElement("span");
    info.className = "kpi-info";
    info.textContent = "\u24D8";
    info.setAttribute("aria-label", "Detalhes do KPI");
    info.dataset.tooltip = card.tooltip;
    head.append(label, info);
    const valor = document.createElement("strong");
    valor.className = "kpi-card__value";
    valor.textContent = formatKpiValor(card.valor, card.formato);
    const delta = document.createElement("small");
    delta.className = "kpi-card__delta";
    delta.textContent = card.delta;
    item.append(head, valor, delta);
    kpiCards.append(item);
  });
}

function buildLineChart(container, labels, series, maxValor, tooltipLabels) {
  if (!container) {
    return;
  }
  container.innerHTML = "";
  const width = 600;
  const height = 160;
  const padX = 24;
  const padY = 18;
  const plotWidth = width - padX * 2;
  const plotHeight = height - padY * 2;
  const baseline = padY + plotHeight;
  const step = labels.length > 1 ? plotWidth / (labels.length - 1) : plotWidth;
  const pulse = Math.max(6, step * 0.14);

  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  svg.classList.add("chart__svg");

  const baselineLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
  baselineLine.setAttribute("x1", padX);
  baselineLine.setAttribute("x2", width - padX);
  baselineLine.setAttribute("y1", baseline);
  baselineLine.setAttribute("y2", baseline);
  baselineLine.classList.add("chart__baseline");
  svg.append(baselineLine);

  const max = Math.max(1, maxValor || 1);

  series.forEach((serie) => {
    const points = serie.values.map((valor, index) => {
      const safeValor = Number.isFinite(valor) ? valor : 0;
      const x = padX + index * step;
      const y = padY + plotHeight - (safeValor / max) * plotHeight;
      return { x, y, valor: safeValor };
    });
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    const d = points
      .map((point, index) => `${index === 0 ? "M" : "L"} ${point.x} ${point.y}`)
      .join(" ");
    path.setAttribute("d", d);
    path.classList.add("chart__line");
    if (serie.lineClass) {
      path.classList.add(serie.lineClass);
    }
    if (serie.stroke) {
      path.setAttribute("stroke", serie.stroke);
    }
    svg.append(path);

    points.forEach((point, index) => {
      const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      dot.setAttribute("cx", point.x);
      dot.setAttribute("cy", point.y);
      dot.setAttribute("r", pulse * 0.35);
      dot.classList.add("chart__dot");
      if (serie.dotClass) {
        dot.classList.add(serie.dotClass);
      }
      if (serie.drilldown) {
        dot.dataset.drilldown = serie.drilldown;
        dot.dataset.week = serie.weekKeys[index];
        dot.style.cursor = "pointer";
      }
      if (tooltipLabels && tooltipLabels[index]) {
        dot.setAttribute("title", tooltipLabels[index]);
      }
      svg.append(dot);
    });
  });

  const legend = document.createElement("div");
  legend.className = "chart__legend";
  series.forEach((serie) => {
    const item = document.createElement("span");
    item.className = "chart__legend-item";
    if (serie.legendClass) {
      item.classList.add(serie.legendClass);
    }
    item.textContent = serie.label;
    if (serie.tooltip) {
      item.title = serie.tooltip;
    }
    legend.append(item);
  });

  const labelsRow = document.createElement("div");
  labelsRow.className = "chart__labels";
  labels.forEach((label) => {
    const span = document.createElement("span");
    span.textContent = label;
    labelsRow.append(span);
  });

  container.append(svg, legend, labelsRow);
}

// KPI: graficos
function renderKpiGraficos(itens, filtros) {
  if (!kpiTrendChart || !kpiAgingChart || !kpiSlaChart) {
    return;
  }
  const semanasCount = 6;
  const ultimaSemana = startOfWeek(new Date());
  const semanas = [];
  for (let i = semanasCount - 1; i >= 0; i -= 1) {
    const inicio = addDays(ultimaSemana, -7 * i);
    const fim = addDays(inicio, 6);
    semanas.push({ inicio, fim });
  }

  const weekLabels = semanas.map((semana) => weekLabelFormatter.format(semana.inicio));
  const weekKeys = semanas.map((semana) => formatDateISO(semana.inicio));

  const concluidasSeries = semanas.map((semana) => {
    return itens.filter((item) => {
      if (item.status !== "concluida") {
        return false;
      }
      const feito = getItemConclusaoDate(item);
      if (!feito) {
        return false;
      }
      return inRange(startOfDay(feito), semana.inicio, semana.fim);
    }).length;
  });

  const backlogSeries = semanas.map((semana) => {
    return itens.filter((item) => {
      if (item.status !== "backlog") {
        return false;
      }
      const data = parseDate(item.data);
      if (!data) {
        return false;
      }
      return inRange(startOfDay(data), semana.inicio, semana.fim);
    }).length;
  });

  const maxTrend = Math.max(1, ...concluidasSeries, ...backlogSeries);
  const trendPeriodo = `últimas ${semanasCount} semanas`;
  buildLineChart(
    kpiTrendChart,
    weekLabels,
    [
      {
        label: "Concluidas",
        values: concluidasSeries,
        lineClass: "chart__line--done",
        dotClass: "chart__dot--done",
        legendClass: "chart__legend-item--done",
        drilldown: "trend_concluidas",
        weekKeys,
        tooltip: buildKpiTooltip(
          "Concluidas",
          "Manutenções concluídas por semana.",
          trendPeriodo
        ),
      },
      {
        label: "Backlog",
        values: backlogSeries,
        lineClass: "chart__line--backlog",
        dotClass: "chart__dot--backlog",
        legendClass: "chart__legend-item--backlog",
        drilldown: "trend_backlog",
        weekKeys,
        tooltip: buildKpiTooltip(
          "Backlog",
          "Manutenções em backlog por semana.",
          trendPeriodo
        ),
      },
    ],
    maxTrend
  );

  const agingBuckets = [
    { label: "0-2d", min: 0, max: 2 },
    { label: "3-7d", min: 3, max: 7 },
    { label: "8-14d", min: 8, max: 14 },
    { label: "15-30d", min: 15, max: 30 },
    { label: ">30d", min: 31, max: null },
  ];
  const hoje = startOfDay(new Date());
  const agingCounts = agingBuckets.map((bucket) => {
    return itens.filter((item) => {
      if (item.status !== "backlog") {
        return false;
      }
      const data = parseDate(item.data);
      if (!data) {
        return false;
      }
      const atraso = diffInDays(startOfDay(data), hoje);
      if (bucket.max === null) {
        return atraso >= bucket.min;
      }
      return atraso >= bucket.min && atraso <= bucket.max;
    }).length;
  });
  const maxAging = Math.max(1, ...agingCounts);
  kpiAgingChart.innerHTML = "";
  const agingContainer = document.createElement("div");
  agingContainer.style.display = "grid";
  agingContainer.style.gap = "10px";
  agingBuckets.forEach((bucket, index) => {
    const linha = document.createElement("div");
    linha.style.display = "grid";
    linha.style.gridTemplateColumns = "80px 1fr 40px";
    linha.style.alignItems = "center";
    linha.dataset.drilldown = "aging";
    linha.dataset.range = bucket.label;
    linha.style.cursor = "pointer";
    linha.title = buildKpiTooltip(
      `Backlog aging ${bucket.label}`,
      "Dias em atraso desde a data programada.",
      "Status backlog atual"
    );
    const label = document.createElement("span");
    label.textContent = bucket.label;
    const bar = document.createElement("div");
    bar.style.height = "10px";
    bar.style.borderRadius = "999px";
    bar.style.background = "rgba(192, 84, 47, 0.7)";
    bar.style.width = `${Math.round((agingCounts[index] / maxAging) * 100)}%`;
    const valor = document.createElement("strong");
    valor.textContent = agingCounts[index];
    linha.append(label, bar, valor);
    agingContainer.append(linha);
  });
  kpiAgingChart.append(agingContainer);

  const slaSeries = semanas.map((semana) => {
    const concluidasSemana = itens.filter((item) => {
      if (item.status !== "concluida") {
        return false;
      }
      const feito = getItemConclusaoDate(item);
      if (!feito) {
        return false;
      }
      return inRange(startOfDay(feito), semana.inicio, semana.fim);
    });
    const resultados = concluidasSemana
      .map((item) => isSlaCompliant(item))
      .filter((valor) => valor !== null);
    if (!resultados.length) {
      return null;
    }
    return Math.round(
      (resultados.filter(Boolean).length / resultados.length) * 100
    );
  });
  const slaTooltip = buildKpiTooltip(
    "SLA compliance",
    "Concluídas no prazo / concluídas na semana.",
    trendPeriodo
  );
  const slaLabels = slaSeries.map((valor) =>
    valor === null ? "Sem dados" : `${valor}%`
  );
  buildLineChart(
    kpiSlaChart,
    weekLabels,
    [
      {
        label: "SLA",
        values: slaSeries.map((valor) => (valor === null ? 0 : valor)),
        lineClass: "chart__line--done",
        dotClass: "chart__dot--done",
        legendClass: "chart__legend-item--done",
        drilldown: "sla_semana",
        weekKeys,
        tooltip: slaTooltip,
      },
    ],
    100,
    slaLabels
  );
}

// KPI: ranking por usuario
function renderKpiRanking(itens, filtros) {
  if (!kpiRanking || !kpiRankingVazio) {
    return;
  }
  kpiRanking.innerHTML = "";
  const agrupado = new Map();
  itens.forEach((item) => {
    const userId = getExecutadoPorId(item) || "sem_responsavel";
    if (!agrupado.has(userId)) {
      agrupado.set(userId, {
        userId,
        concluidas: 0,
        overdue: 0,
        leadTimes: [],
        mttr: [],
        docsOk: 0,
        docsTotal: 0,
      });
    }
    const registro = agrupado.get(userId);
    if (item.status === "concluida") {
      registro.concluidas += 1;
      const criadoEm = getItemCriacaoDate(item);
      const concluidoEm = getItemConclusaoDate(item);
      if (criadoEm && concluidoEm) {
        registro.leadTimes.push((concluidoEm - criadoEm) / DAY_MS);
      }
      const inicio = getItemInicioExecucaoDate(item);
      const fim = getItemFimExecucaoDate(item);
      if (inicio && fim) {
        registro.mttr.push((fim - inicio) / 60000);
      }
    } else if (isItemOverdue(item, startOfDay(new Date()))) {
      registro.overdue += 1;
    }
    const compliance = getDocCompliance(item);
    if (compliance !== null) {
      registro.docsTotal += 1;
      if (compliance) {
        registro.docsOk += 1;
      }
    }
  });

  let linhas = Array.from(agrupado.values());
  if (filtros.usuario) {
    linhas = linhas.filter((linha) => linha.userId === filtros.usuario);
  }
  const linhasCalculadas = linhas.map((linha) => {
    const leadMedio = linha.leadTimes.length
      ? linha.leadTimes.reduce((acc, val) => acc + val, 0) / linha.leadTimes.length
      : null;
    const mttrMedio = linha.mttr.length
      ? linha.mttr.reduce((acc, val) => acc + val, 0) / linha.mttr.length
      : null;
    const docsPercent =
      linha.docsTotal > 0 ? Math.round((linha.docsOk / linha.docsTotal) * 100) : null;
    return { ...linha, leadMedio, mttrMedio, docsPercent };
  });
  // ordenacao ranking usuario
  const sortKey = kpiRankingSort ? kpiRankingSort.key : "concluidas";
  const sortDir = kpiRankingSort ? kpiRankingSort.dir : "desc";
  const sortDirFactor = sortDir === "asc" ? 1 : -1;
  const getSortValue = (linha) => {
    if (sortKey === "overdue") {
      return linha.overdue;
    }
    if (sortKey === "lead") {
      return linha.leadMedio;
    }
    if (sortKey === "mttr") {
      return linha.mttrMedio;
    }
    if (sortKey === "docs") {
      return linha.docsPercent;
    }
    return linha.concluidas;
  };
  linhasCalculadas.sort((a, b) => {
    const aVal = getSortValue(a);
    const bVal = getSortValue(b);
    const aEmpty = aVal === null || aVal === undefined || Number.isNaN(aVal);
    const bEmpty = bVal === null || bVal === undefined || Number.isNaN(bVal);
    if (aEmpty && bEmpty) {
      return 0;
    }
    if (aEmpty) {
      return 1;
    }
    if (bEmpty) {
      return -1;
    }
    return (aVal - bVal) * sortDirFactor;
  });

  if (!linhasCalculadas.length) {
    kpiRankingVazio.hidden = false;
    return;
  }
  kpiRankingVazio.hidden = true;

  const table = document.createElement("table");
  table.className = "kpi-table";
  const thead = document.createElement("thead");
  const headRow = document.createElement("tr");
  const headers = [
    {
      label: "Usuário",
      tooltip: buildKpiTooltip(
        "Usuário",
        "Responsável pela execução.",
        "Filtro atual"
      ),
    },
    {
      label: "Concluídas",
      sortKey: "concluidas",
      tooltip: buildKpiTooltip(
        "Concluídas",
        "Total de manutenções concluídas.",
        `últimos ${filtros.periodo} dias`
      ),
    },
    {
      label: "Overdue aberto",
      sortKey: "overdue",
      tooltip: buildKpiTooltip(
        "Overdue aberto",
        "Manutenções em aberto com data atrasada.",
        `últimos ${filtros.periodo} dias`
      ),
    },
    {
      label: "Lead time médio",
      sortKey: "lead",
      tooltip: buildKpiTooltip(
        "Lead time médio",
        "Conclusão - criação (dias).",
        `últimos ${filtros.periodo} dias`
      ),
    },
    {
      label: "MTTR médio",
      sortKey: "mttr",
      tooltip: buildKpiTooltip(
        "MTTR médio",
        "Fim - início da execução.",
        `últimos ${filtros.periodo} dias`
      ),
    },
    {
      label: "% docs OK",
      sortKey: "docs",
      tooltip: buildKpiTooltip(
        "Compliance docs",
        "APR/OS/PTE e PT quando crítico.",
        `últimos ${filtros.periodo} dias`
      ),
    },
  ];
  headers.forEach((header, index) => {
    const th = document.createElement("th");
    th.textContent = header.label;
    th.title = header.tooltip;
    if (header.sortKey) {
      th.dataset.sortKey = header.sortKey;
      th.classList.add("is-sortable");
    }
    if (index > 0) {
      th.classList.add("is-num");
    }
    headRow.append(th);
  });
  thead.append(headRow);
  table.append(thead);

  const tbody = document.createElement("tbody");
  linhasCalculadas.forEach((linha) => {
    const lead = linha.leadMedio;
    const mttr = linha.mttrMedio;
    const docsPercent = linha.docsPercent;
    const tr = document.createElement("tr");
    tr.dataset.drilldown = "user";
    tr.dataset.userId = linha.userId;
    if (filtros.usuario && linha.userId === filtros.usuario) {
      tr.classList.add("is-selected");
    }
    tr.style.cursor = "pointer";
    // formatação valores ranking
    const cols = [
      { value: getUserLabel(linha.userId) },
      { value: linha.concluidas },
      { value: linha.overdue },
      {
        value: lead === null ? "\u2014" : `${lead.toFixed(1)}d`,
        tooltip: lead === null ? "Sem base de cálculo" : "",
      },
      {
        value: mttr === null ? "\u2014" : formatDuracaoKpi(mttr),
        tooltip: mttr === null ? "Sem base de cálculo" : "",
      },
      {
        value: docsPercent === null ? "\u2014" : `${docsPercent}%`,
        tooltip: docsPercent === null ? "Sem documentos no período" : "",
      },
    ];
    cols.forEach((col, index) => {
      const td = document.createElement("td");
      const valor = col && Object.prototype.hasOwnProperty.call(col, "value") ? col.value : col;
      td.textContent = valor;
      if (col && col.tooltip) {
        td.title = col.tooltip;
        td.classList.add("is-empty");
      }
      if (index > 0) {
        td.classList.add("is-num");
      }
      tr.append(td);
    });
    tbody.append(tr);
  });
  table.append(tbody);
  kpiRanking.append(table);
}

// KPI: drilldown
function renderKpiDrilldown() {
  if (!kpiDrilldownTabela || !kpiDrilldownVazio || !kpiDrilldownTitulo) {
    return;
  }
  kpiDrilldownTabela.innerHTML = "";
  if (!kpiDrilldown || !kpiDrilldown.items.length) {
    kpiDrilldownTitulo.textContent = "Clique em um KPI ou gráfico para listar.";
    kpiDrilldownVazio.hidden = false;
    return;
  }
  kpiDrilldownVazio.hidden = true;
  const filtros = kpiSnapshot ? kpiSnapshot.filtros || {} : {};
  const periodoLabel = filtros.periodo ? `${filtros.periodo}d` : "-";
  const subestacaoLabel = filtros.subestacao || "Todas";
  const categoriaLabel = filtros.categoria || "Todas";
  const prioridadeLabel = filtros.prioridade || "Todas";
  const usuarioLabel = filtros.usuario ? getUserLabel(filtros.usuario) : "Todos";
  const limite = kpiDrilldownLimite ? Number(kpiDrilldownLimite.value) || 25 : 25;
  const itensVisiveis = kpiDrilldown.items.slice(0, limite);
  // header drill-down
  kpiDrilldownTitulo.textContent = `Métrica: ${kpiDrilldown.titulo} | Itens: ${itensVisiveis.length} | Período: ${periodoLabel} | Subestação: ${subestacaoLabel} | Categoria: ${categoriaLabel} | Prioridade: ${prioridadeLabel} | Usuário: ${usuarioLabel}`;

  const table = document.createElement("table");
  table.className = "kpi-table kpi-table--compact";
  const thead = document.createElement("thead");
  const headRow = document.createElement("tr");
  const colunas = [
    { label: "Manutenção", className: "is-wide" },
    { label: "Subestação" },
    { label: "Status", className: "is-center" },
    { label: "Programada", className: "is-date" },
    { label: "Início", className: "is-date" },
    { label: "Fim", className: "is-date" },
    { label: "Responsável" },
  ];
  colunas.forEach((coluna) => {
    const th = document.createElement("th");
    th.textContent = coluna.label;
    if (coluna.className) {
      th.classList.add(coluna.className);
    }
    headRow.append(th);
  });
  thead.append(headRow);
  table.append(thead);
  const tbody = document.createElement("tbody");
  itensVisiveis.forEach((item) => {
    const tr = document.createElement("tr");
    const programadaDate = item.data ? parseDate(item.data) : null;
    const programada = programadaDate ? formatDate(programadaDate) : "-";
    const inicio = getItemInicioExecucaoDate(item);
    const fim = getItemFimExecucaoDate(item) || getItemConclusaoDate(item);
    const statusKeyRaw = item.status ? String(item.status).toLowerCase() : "";
    const statusLabel =
      STATUS_LABELS[statusKeyRaw] || (statusKeyRaw === "cancelada" ? "Cancelada" : item.status) || "-";
    const statusClass = statusKeyRaw ? statusKeyRaw.replace(/[^a-z0-9]+/g, "_") : "default";
    const statusBadge = document.createElement("span");
    statusBadge.className = `status-badge status-badge--${statusClass}`;
    statusBadge.textContent = statusLabel;
    const cols = [
      { value: item.titulo || "-", title: item.titulo || "" },
      { value: getItemSubestacao(item) || "-" },
      { node: statusBadge },
      { value: programada || "-" },
      { value: inicio ? formatDateTime(inicio) : "-" },
      { value: fim ? formatDateTime(fim) : "-" },
      { value: getUserLabel(getExecutadoPorId(item)) },
    ];
    cols.forEach((col, index) => {
      const td = document.createElement("td");
      if (col && col.node) {
        td.append(col.node);
      } else {
        const valor = col && Object.prototype.hasOwnProperty.call(col, "value") ? col.value : col;
        td.textContent = valor;
      }
      if (col && col.title) {
        td.title = col.title;
      }
      const coluna = colunas[index];
      if (coluna && coluna.className) {
        td.classList.add(coluna.className);
      }
      tr.append(td);
    });
    tbody.append(tr);
  });
  table.append(tbody);
  kpiDrilldownTabela.append(table);
}

function atualizarKpiDrilldown(tipo, itens, titulo) {
  kpiDrilldown = { tipo, items: itens, titulo };
  renderKpiDrilldown();
}

function handleKpiRankingSort(event) {
  const th = event.target.closest("th[data-sort-key]");
  if (!th || !kpiSnapshot) {
    return;
  }
  const key = th.dataset.sortKey;
  if (kpiRankingSort.key === key) {
    kpiRankingSort.dir = kpiRankingSort.dir === "asc" ? "desc" : "asc";
  } else {
    kpiRankingSort.key = key;
    kpiRankingSort.dir = key === "lead" || key === "mttr" ? "asc" : "desc";
  }
  renderKpiRanking(kpiSnapshot.itensPeriodo || [], kpiSnapshot.filtros || {});
}

// KPI: renderizacao principal
function renderPainelKpiGerencial() {
  if (!kpiCards || !kpiTrendChart || !kpiAgingChart || !kpiSlaChart) {
    return;
  }
  const filtros = getKpiFiltros();
  const base = aplicarFiltrosBase(manutencoes, filtros);
  atualizarFiltrosKpi(base);
  const janela = buildPeriodoJanela(filtros.periodo);
  const itensPeriodo = aplicarFiltroPeriodo(base, janela);
  const itensAnterior = aplicarFiltroPeriodo(base, {
    inicio: janela.anteriorInicio,
    fim: janela.anteriorFim,
  });
  kpiSnapshot = { itensPeriodo, filtros };
  renderKpiCards(itensPeriodo, itensAnterior, filtros);
  renderKpiGraficos(itensPeriodo, filtros);
  renderKpiRanking(itensPeriodo, filtros);
  renderKpiDrilldown();
}

function handleKpiDrilldownClick(event) {
  const alvo = event.target.closest("[data-drilldown]");
  if (!alvo || !kpiSnapshot) {
    return;
  }
  const itens = kpiSnapshot.itensPeriodo || [];
  const hoje = startOfDay(new Date());
  const tipo = alvo.dataset.drilldown;
  let filtrados = [];
  let titulo = "";

  if (tipo === "backlog_total") {
    filtrados = itens.filter((item) => item.status === "backlog");
    titulo = "Backlog total";
  } else if (tipo === "overdue_total") {
    filtrados = itens.filter((item) => isItemOverdue(item, hoje));
    titulo = "Overdue / Vencidas";
  } else if (tipo === "sla_compliance") {
    filtrados = itens.filter((item) => item.status === "concluida");
    titulo = "SLA compliance";
  } else if (tipo === "lead_time") {
    filtrados = itens.filter(
      (item) => item.status === "concluida" && getItemCriacaoDate(item) && getItemConclusaoDate(item)
    );
    titulo = "Lead time médio";
  } else if (tipo === "mttr") {
    filtrados = itens.filter(
      (item) => item.status === "concluida" && getItemInicioExecucaoDate(item) && getItemFimExecucaoDate(item)
    );
    titulo = "MTTR médio";
  } else if (tipo === "criticos_abertos") {
    filtrados = itens.filter((item) => item.status !== "concluida" && isItemCritico(item));
    titulo = "Criticos em aberto";
  } else if (tipo === "trend_concluidas" || tipo === "trend_backlog" || tipo === "sla_semana") {
    const weekStart = parseDate(alvo.dataset.week);
    if (weekStart) {
      const weekEnd = addDays(weekStart, 6);
      if (tipo === "trend_concluidas") {
        filtrados = itens.filter((item) => {
          if (item.status !== "concluida") {
            return false;
          }
          const feito = getItemConclusaoDate(item);
          return feito ? inRange(startOfDay(feito), weekStart, weekEnd) : false;
        });
        titulo = `Concluidas - semana ${formatDate(weekStart)}`;
      } else if (tipo === "trend_backlog") {
        filtrados = itens.filter((item) => {
          if (item.status !== "backlog") {
            return false;
          }
          const data = parseDate(item.data);
          return data ? inRange(startOfDay(data), weekStart, weekEnd) : false;
        });
        titulo = `Backlog - semana ${formatDate(weekStart)}`;
      } else {
        filtrados = itens.filter((item) => {
          if (item.status !== "concluida") {
            return false;
          }
          const feito = getItemConclusaoDate(item);
          return feito ? inRange(startOfDay(feito), weekStart, weekEnd) : false;
        });
        titulo = `SLA compliance - semana ${formatDate(weekStart)}`;
      }
    }
  } else if (tipo === "aging") {
    const range = alvo.dataset.range || "";
    const ranges = {
      "0-2d": { min: 0, max: 2 },
      "3-7d": { min: 3, max: 7 },
      "8-14d": { min: 8, max: 14 },
      "15-30d": { min: 15, max: 30 },
      ">30d": { min: 31, max: null },
    };
    const bucket = ranges[range];
    if (bucket) {
      filtrados = itens.filter((item) => {
        if (item.status !== "backlog") {
          return false;
        }
        const data = parseDate(item.data);
        if (!data) {
          return false;
        }
        const atraso = diffInDays(startOfDay(data), hoje);
        if (bucket.max === null) {
          return atraso >= bucket.min;
        }
        return atraso >= bucket.min && atraso <= bucket.max;
      });
      titulo = `Backlog aging ${range}`;
    }
  } else if (tipo === "user") {
    const userId = alvo.dataset.userId;
    if (userId) {
      filtrados = itens.filter((item) => getExecutadoPorId(item) === userId);
      titulo = `Usuário ${getUserLabel(userId)}`;
    }
  }

  const ordenados = filtrados.slice().sort((a, b) => {
    const dataA = getItemConclusaoDate(a) || parseAnyDate(a.data) || getItemCriacaoDate(a);
    const dataB = getItemConclusaoDate(b) || parseAnyDate(b.data) || getItemCriacaoDate(b);
    return (getTimeValue(dataB) || 0) - (getTimeValue(dataA) || 0);
  });
  atualizarKpiDrilldown(tipo, ordenados, titulo || "Detalhamento");
}

function renderGrafico() {
  if (kpiCards || kpiTrendChart || kpiAgingChart || kpiSlaChart) {
    renderPainelKpiGerencial();
    return;
  }
  if (!graficoKpi) {
    return;
  }
  graficoKpi.innerHTML = "";
  const hoje = new Date();
  const ultimaSemana = startOfWeek(hoje);
  const semanas = [];
  for (let i = 5; i >= 0; i -= 1) {
    const inicio = addDays(ultimaSemana, -7 * i);
    const fim = addDays(inicio, 6);
    semanas.push({ inicio, fim });
  }

  const dados = semanas.map((semana) => {
    const concluidas = manutencoes.filter((item) => {
      if (item.status !== "concluida" || !item.doneAt) {
        return false;
      }
      const feito = parseTimestamp(item.doneAt);
      if (!feito) {
        return false;
      }
      const feitoDia = startOfDay(feito);
      return inRange(feitoDia, semana.inicio, semana.fim);
    }).length;

    const backlog = manutencoes.filter((item) => {
      if (item.status !== "backlog") {
        return false;
      }
      const data = parseDate(item.data);
      if (!data) {
        return false;
      }
      return inRange(data, semana.inicio, semana.fim);
    }).length;

    return { concluidas, backlog, inicio: semana.inicio };
  });

  const labels = dados.map((item) => weekLabelFormatter.format(item.inicio));
  const concluidasSeries = dados.map((item) => item.concluidas);
  const backlogSeries = dados.map((item) => item.backlog);
  const maxValor = Math.max(1, ...concluidasSeries, ...backlogSeries);

  const width = 600;
  const height = 160;
  const padX = 24;
  const padY = 18;
  const plotWidth = width - padX * 2;
  const plotHeight = height - padY * 2;
  const baseline = padY + plotHeight;
  const step = concluidasSeries.length > 1 ? plotWidth / (concluidasSeries.length - 1) : plotWidth;
  const pulse = Math.max(6, step * 0.14);

  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.classList.add("chart__svg");
  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
  svg.setAttribute("role", "img");
  svg.setAttribute("aria-label", "Grafico de desempenho");

  const baselineLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
  baselineLine.setAttribute("x1", padX);
  baselineLine.setAttribute("y1", baseline);
  baselineLine.setAttribute("x2", padX + plotWidth);
  baselineLine.setAttribute("y2", baseline);
  baselineLine.setAttribute("class", "chart__baseline");
  svg.append(baselineLine);

  const buildPulsePath = (values) => {
    let d = `M ${padX} ${baseline}`;
    values.forEach((value, index) => {
      const x = padX + step * index;
      const y = baseline - (value / maxValor) * plotHeight;
      const left = Math.max(padX, x - pulse);
      const right = Math.min(padX + plotWidth, x + pulse);
      d += ` L ${left} ${baseline} L ${x} ${y} L ${right} ${baseline}`;
    });
    d += ` L ${padX + plotWidth} ${baseline}`;
    return d;
  };

  const backlogPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  backlogPath.setAttribute("d", buildPulsePath(backlogSeries));
  backlogPath.setAttribute("class", "chart__line chart__line--backlog");
  svg.append(backlogPath);

  const donePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  donePath.setAttribute("d", buildPulsePath(concluidasSeries));
  donePath.setAttribute("class", "chart__line chart__line--done");
  svg.append(donePath);

  const addDots = (values, className) => {
    values.forEach((value, index) => {
      const x = padX + step * index;
      const y = baseline - (value / maxValor) * plotHeight;
      const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      dot.setAttribute("cx", x);
      dot.setAttribute("cy", y);
      dot.setAttribute("r", 3.4);
      dot.setAttribute("class", className);
      svg.append(dot);
    });
  };

  addDots(backlogSeries, "chart__dot chart__dot--backlog");
  addDots(concluidasSeries, "chart__dot chart__dot--done");

  const legend = document.createElement("div");
  legend.className = "chart__legend";
  const legendDone = document.createElement("span");
  legendDone.className = "chart__legend-item chart__legend-item--done";
  legendDone.textContent = "Concluidas";
  const legendBacklog = document.createElement("span");
  legendBacklog.className = "chart__legend-item chart__legend-item--backlog";
  legendBacklog.textContent = "Backlog";
  legend.append(legendDone, legendBacklog);

  const labelsRow = document.createElement("div");
  labelsRow.className = "chart__labels";
  labels.forEach((label) => {
    const span = document.createElement("span");
    span.textContent = label;
    labelsRow.append(span);
  });

  graficoKpi.append(svg, legend, labelsRow);
}

function normalizeNumberList(list, min, max) {
  const values = Array.isArray(list) ? list : [];
  const limpos = values
    .map((value) => Number(value))
    .filter((value) => Number.isFinite(value) && value >= min && value <= max);
  return Array.from(new Set(limpos)).sort((a, b) => a - b);
}

function normalizeDailyDays(list) {
  const dias = normalizeNumberList(list, 0, 6);
  return dias.length ? dias : [...DEFAULT_DAILY_DAYS];
}

function normalizeMonthlyDays(list) {
  return normalizeNumberList(list, 1, 31);
}

function validateMonthlyDaysInput(value) {
  const raw = String(value || "").trim();
  if (!raw) {
    return { valid: true, dias: [] };
  }
  if (!/^[0-9\s,]+$/.test(raw)) {
    return { valid: false, dias: [] };
  }
  const parts = raw.split(/[\s,]+/).filter(Boolean);
  const numbers = parts.map((item) => Number(item));
  const invalid = numbers.some((num) => !Number.isFinite(num) || num < 1 || num > 31);
  if (invalid) {
    return { valid: false, dias: [] };
  }
  return { valid: true, dias: normalizeMonthlyDays(numbers) };
}

function parseMonthlyDaysInputValue(value) {
  const result = validateMonthlyDaysInput(value);
  return result.valid ? result.dias : [];
}

function updateMonthlyDaysChips() {
  if (!templateMonthlyDaysChips || !templateMonthlyDaysInput) {
    return;
  }
  const dias = parseMonthlyDaysInputValue(templateMonthlyDaysInput.value);
  templateMonthlyDaysChips.innerHTML = "";
  if (!dias.length) {
    const empty = document.createElement("span");
    empty.className = "chip-pill chip-pill--muted";
    empty.textContent = "Nenhum dia selecionado";
    templateMonthlyDaysChips.append(empty);
    return;
  }
  dias.forEach((dia) => {
    const chip = document.createElement("span");
    chip.className = "chip-pill";
    chip.textContent = String(dia);
    templateMonthlyDaysChips.append(chip);
  });
}

function getDailyDaysFromForm() {
  const dias = Array.from(templateDailyDays || [])
    .filter((checkbox) => checkbox.checked)
    .map((checkbox) => Number(checkbox.value));
  return normalizeNumberList(dias, 0, 6);
}

function updateTemplateResumo() {
  if (!templateResumoLinhas) {
    return;
  }
  const nome = templateNome ? templateNome.value.trim() : "";
  const subestacao = templateSubestacao ? templateSubestacao.value : "";
  const subestacaoLabel = subestacao || "Subestação não definida";
  const tipo = templateFrequencia ? templateFrequencia.value : "none";
  const inicioStr = templateInicio ? templateInicio.value : "";
  const inicioDate = parseDate(inicioStr);
  const inicioLabel = inicioDate ? formatDate(inicioDate) : "-";

  const linhas = [];
  const linhaTitulo = `${nome || "Nome do modelo"} - ${subestacaoLabel}`;
  linhas.push(linhaTitulo);

  if (tipo === "none") {
    linhas.push(
      `Este modelo NÃO possui recorrência automática. Uso apenas como modelo manual. Início: ${inicioLabel}.`
    );
  } else if (tipo === "daily") {
    const dias = getDailyDaysFromForm();
    const lista = dias.length ? dias.map(getWeekdayShort).filter(Boolean).join(", ") : "a definir";
    linhas.push(
      `Este modelo irá gerar manutenções DIÁRIAS nos dias: [${lista}], a partir de ${inicioLabel}, para: ${subestacaoLabel}.`
    );
  } else if (tipo === "weekly") {
    const diaSemana = templateWeeklyDay ? getWeekdayLabel(templateWeeklyDay.value) : "";
    const intervaloRaw = templateWeeklyInterval ? Number(templateWeeklyInterval.value) : 1;
    const intervalo = Math.max(1, Math.round(intervaloRaw || 1));
    const diaLabel = diaSemana || "Dia não definido";
    linhas.push(
      `Este modelo irá gerar manutenções SEMANAIS toda(o) ${diaLabel}, a cada ${intervalo} semana(s), a partir de ${inicioLabel}, para: ${subestacaoLabel}.`
    );
  } else if (tipo === "monthly") {
    const modo = templateMonthlyMulti && templateMonthlyMulti.checked ? "multi" : "fixed";
    if (modo === "multi") {
      const dias = parseMonthlyDaysInputValue(templateMonthlyDaysInput ? templateMonthlyDaysInput.value : "");
      const lista = dias.length ? dias.join(", ") : "a definir";
      linhas.push(
        `Este modelo irá gerar manutenções MENSAIS nos dias ${lista} de cada mês, a partir de ${inicioLabel}, para: ${subestacaoLabel}.`
      );
    } else {
      const dia = templateMonthlyDay ? templateMonthlyDay.value : "";
      const diaLabel = dia || "-";
      linhas.push(
        `Este modelo irá gerar manutenções MENSAIS no dia ${diaLabel} de cada mês, a partir de ${inicioLabel}, para: ${subestacaoLabel}.`
      );
    }
    linhas.push(
      "Obs.: quando o mês não possuir o dia configurado, a ocorrência será IGNORADA."
    );
  }

  templateResumoLinhas.innerHTML = "";
  linhas.forEach((linha) => {
    const span = document.createElement("span");
    span.textContent = linha;
    templateResumoLinhas.append(span);
  });
}

function handleTemplateFormChange(event) {
  if (event) {
    clearTemplateFieldError(event.target);
    mostrarMensagemTemplate("");
  }
  if (event && event.target === templateMonthlyDaysInput) {
    const validacao = validateMonthlyDaysInput(templateMonthlyDaysInput.value);
    if (
      templateFrequencia &&
      templateFrequencia.value === "monthly" &&
      templateMonthlyMulti &&
      templateMonthlyMulti.checked &&
      !validacao.valid
    ) {
      setFieldError(
        templateMonthlyDaysErro,
        "Informe dias válidos entre 1 e 31 (ex.: 10, 25)."
      );
    } else {
      setFieldError(templateMonthlyDaysErro, "");
    }
    if (event.type === "change" && validacao.valid) {
      templateMonthlyDaysInput.value = validacao.dias.length ? validacao.dias.join(", ") : "";
    }
  }
  updateMonthlyDaysChips();
  updateTemplateResumo();
}

function normalizarTemplate(template) {
  if (!template || typeof template !== "object") {
    return { template, mudou: false };
  }
  let mudou = false;
  const resultado = { ...template };

  if (!resultado.frequencia) {
    resultado.frequencia = "none";
    mudou = true;
  }

  if (resultado.frequencia === "biweekly") {
    resultado.frequencia = "weekly";
    if (!Number.isFinite(Number(resultado.weeklyInterval))) {
      resultado.weeklyInterval = 2;
    }
    mudou = true;
  }

  if (resultado.frequencia === "custom") {
    const intervalo = Number(resultado.intervaloDias || 0);
    if (intervalo >= 7 && intervalo % 7 === 0) {
      resultado.frequencia = "weekly";
      resultado.weeklyInterval = Math.max(1, Math.round(intervalo / 7));
    } else if (intervalo >= 28) {
      resultado.frequencia = "monthly";
    } else if (intervalo === 1) {
      resultado.frequencia = "daily";
    } else {
      resultado.frequencia = "none";
    }
    mudou = true;
  }

  if (!resultado.inicio || !parseDate(resultado.inicio)) {
    resultado.inicio = formatDateISO(new Date());
    mudou = true;
  }

  if (resultado.frequencia === "daily") {
    const dias = normalizeNumberList(resultado.dailyDays || resultado.diasSemana, 0, 6);
    resultado.dailyDays = dias.length ? dias : [...DEFAULT_DAILY_DAYS];
    if (!dias.length) {
      mudou = true;
    }
  } else {
    resultado.dailyDays = normalizeNumberList(resultado.dailyDays, 0, 6);
  }

  if (resultado.frequencia === "weekly") {
    const inicio = parseDate(resultado.inicio);
    const fallbackDay = Number.isFinite(Number(resultado.weekday))
      ? Number(resultado.weekday)
      : inicio
        ? inicio.getDay()
        : 1;
    const weeklyDayValue = Number(resultado.weeklyDay);
    const weeklyDay =
      Number.isFinite(weeklyDayValue) && weeklyDayValue >= 0 && weeklyDayValue <= 6
        ? weeklyDayValue
        : fallbackDay;
    let weeklyInterval = Number(resultado.weeklyInterval || 0);
    if (!Number.isFinite(weeklyInterval) || weeklyInterval < 1) {
      const dias = Number(resultado.intervaloDias || 0);
      if (Number.isFinite(dias) && dias >= 7 && dias % 7 === 0) {
        weeklyInterval = Math.max(1, Math.round(dias / 7));
      } else {
        weeklyInterval = 1;
      }
    }
    resultado.weeklyDay = weeklyDay;
    resultado.weeklyInterval = weeklyInterval;
  }

  if (resultado.frequencia === "monthly") {
    const diasMes = normalizeMonthlyDays(resultado.monthlyDays);
    let mode = resultado.monthlyMode;
    if (mode !== "multi" && mode !== "fixed") {
      mode = diasMes.length ? "multi" : "fixed";
    }
    resultado.monthlyMode = mode;

    if (mode === "multi") {
      let diasSelecionados = diasMes;
      if (diasSelecionados.length === 0) {
        const inicio = parseDate(resultado.inicio);
        const fallbackDay = Number(resultado.monthlyDay) || (inicio ? inicio.getDate() : 1);
        diasSelecionados = normalizeMonthlyDays([fallbackDay]);
        mudou = true;
      }
      resultado.monthlyDays = diasSelecionados;
    } else {
      let dia = Number(resultado.monthlyDay);
      if (!Number.isFinite(dia) || dia < 1 || dia > 31) {
        const inicio = parseDate(resultado.inicio);
        dia = inicio ? inicio.getDate() : 1;
        mudou = true;
      }
      resultado.monthlyDay = dia;
      resultado.monthlyDays = diasMes;
    }
  } else {
    resultado.monthlyDays = normalizeMonthlyDays(resultado.monthlyDays);
    resultado.monthlyMode = resultado.monthlyMode || "fixed";
  }

  const participantesRaw = Array.isArray(resultado.participantes)
    ? resultado.participantes
    : typeof resultado.participantes === "string"
      ? resultado.participantes.split(/[;,]/)
      : [];
  const participantesNormalizados = participantesRaw
    .map((item) => normalizeParticipantName(item))
    .filter(Boolean);
  const participantesAtuais = Array.isArray(resultado.participantes)
    ? resultado.participantes
    : [];
  const participantesMudaram =
    !Array.isArray(resultado.participantes) ||
    participantesNormalizados.length !== participantesAtuais.length ||
    participantesNormalizados.some((item, index) => item !== participantesAtuais[index]);
  if (participantesMudaram) {
    resultado.participantes = participantesNormalizados;
    mudou = true;
  }

  const equipamentoId = resolveEquipamentoIdFromValue(
    resultado.equipamentoId || resultado.equipamento
  );
  if (equipamentoId !== String(resultado.equipamentoId || "")) {
    resultado.equipamentoId = equipamentoId;
    mudou = true;
  }

  const equipeRaw = String(resultado.equipeResponsavel || "").trim();
  const equipeNormalizada = equipeRaw ? normalizeTeamName(equipeRaw) : "";
  if (equipeNormalizada !== equipeRaw) {
    resultado.equipeResponsavel = equipeNormalizada;
    mudou = true;
  }

  return { template: resultado, mudou };
}

function normalizarTemplates(lista) {
  let mudou = false;
  const normalizadas = lista.map((template) => {
    const resultado = normalizarTemplate(template);
    if (resultado.mudou) {
      mudou = true;
    }
    return resultado.template;
  });
  return { normalizadas, mudou };
}

function getWeekdayLabel(weekday) {
  const value = Number(weekday);
  if (!Number.isFinite(value)) {
    return "";
  }
  return WEEKDAYS[value] || "";
}

function getWeekdayShort(weekday) {
  const value = Number(weekday);
  if (!Number.isFinite(value)) {
    return "";
  }
  return WEEKDAYS_SHORT[value] || "";
}

function ajustarParaDiaSemana(base, weekday) {
  const data = startOfDay(base);
  const diff = (weekday - data.getDay() + 7) % 7;
  data.setDate(data.getDate() + diff);
  return data;
}

function formatIntervalo(template) {
  if (!template || !template.frequencia || template.frequencia === "none") {
    return "Sem recorrência";
  }

  if (template.frequencia === "daily") {
    const dias = normalizeDailyDays(template.dailyDays);
    const lista = dias.map(getWeekdayLabel).filter(Boolean).join(", ");
    return lista ? `Diaria (${lista})` : "Diaria";
  }

  if (template.frequencia === "weekly") {
    const dia = getWeekdayLabel(template.weeklyDay);
    const intervalo = Number(template.weeklyInterval || 1);
    if (intervalo > 1) {
      return dia ? `Semanal (${dia}, a cada ${intervalo} semanas)` : `Semanal (a cada ${intervalo} semanas)`;
    }
    return dia ? `Semanal (${dia})` : "Semanal";
  }

  if (template.frequencia === "monthly") {
    if (template.monthlyMode === "multi") {
      const dias = normalizeMonthlyDays(template.monthlyDays);
      return dias.length ? `Mensal (dias ${dias.join(", ")})` : "Mensal (dias)";
    }
    const dia = Number(template.monthlyDay);
    return Number.isFinite(dia) ? `Mensal (dia ${dia})` : "Mensal";
  }

  return "Sem recorrência";
}

function matchesRecorrencia(template, data) {
  if (!template || template.frequencia === "none") {
    return false;
  }

  const dia = startOfDay(data);
  const inicio = parseDate(template.inicio);
  const base = inicio ? startOfDay(inicio) : null;
  if (base && dia < base) {
    return false;
  }

  if (template.frequencia === "daily") {
    const dias = normalizeDailyDays(template.dailyDays);
    return dias.includes(dia.getDay());
  }

  if (template.frequencia === "weekly") {
    const day = Number.isFinite(Number(template.weeklyDay)) ? Number(template.weeklyDay) : 1;
    if (dia.getDay() !== day) {
      return false;
    }
    const intervalo = Math.max(1, Math.round(Number(template.weeklyInterval || 1)));
    const baseWeek = startOfWeek(base || dia);
    const currentWeek = startOfWeek(dia);
    const diffWeeks = Math.floor((currentWeek - baseWeek) / (7 * DAY_MS));
    return diffWeeks % intervalo === 0;
  }

  if (template.frequencia === "monthly") {
    const day = dia.getDate();
    if (template.monthlyMode === "multi") {
      const dias = normalizeMonthlyDays(template.monthlyDays);
      return dias.includes(day);
    }
    const fixo = Number(template.monthlyDay);
    return Number.isFinite(fixo) ? day === fixo : false;
  }

  return false;
}

function getNextOccurrenceDate(template, fromDate = new Date()) {
  if (!template || template.frequencia === "none") {
    return null;
  }
  const normalizado = normalizarTemplate(template).template;
  const inicio = parseDate(normalizado.inicio);
  let base = startOfDay(fromDate);
  if (inicio && inicio > base) {
    base = startOfDay(inicio);
  }
  const limite = addDays(base, 370);
  for (let atual = base; atual <= limite; atual = addDays(atual, 1)) {
    if (matchesRecorrencia(normalizado, atual)) {
      return atual;
    }
  }
  return null;
}

function calcularProximaData(template) {
  const proxima = getNextOccurrenceDate(template, new Date());
  return proxima ? formatDateISO(proxima) : "";
}

function resetTemplateFieldsForTipo(tipo) {
  if (templateDailyDays.length) {
    templateDailyDays.forEach((checkbox) => {
      const valor = Number(checkbox.value);
      checkbox.checked = tipo === "daily" && DEFAULT_DAILY_DAYS.includes(valor);
    });
  }

  if (templateWeeklyDay) {
    templateWeeklyDay.value = "1";
  }
  if (templateWeeklyInterval) {
    templateWeeklyInterval.value = "1";
  }

  if (templateMonthlyFixed) {
    templateMonthlyFixed.checked = true;
  }
  if (templateMonthlyMulti) {
    templateMonthlyMulti.checked = false;
  }
  if (templateMonthlyDay) {
    templateMonthlyDay.value = "10";
  }
  if (templateMonthlyDaysInput) {
    templateMonthlyDaysInput.value = "";
  }
}

function resetTemplateMonthlyModeFields(mode) {
  if (mode === "fixed") {
    if (templateMonthlyDaysInput) {
      templateMonthlyDaysInput.value = "";
    }
    if (templateMonthlyDay && (!templateMonthlyDay.value || Number(templateMonthlyDay.value) < 1)) {
      templateMonthlyDay.value = "10";
    }
  } else {
    if (templateMonthlyDay) {
      templateMonthlyDay.value = "";
    }
  }
}

function aplicarPresetDiasUteis() {
  if (!templateDailyDays.length) {
    return;
  }
  templateDailyDays.forEach((checkbox) => {
    const valor = Number(checkbox.value);
    checkbox.checked = DEFAULT_DAILY_DAYS.includes(valor);
  });
  setFieldError(templateDailyErro, "");
  updateTemplateResumo();
}

function aplicarPresetModelo(tipo) {
  if (!templateFrequencia) {
    return;
  }
  if (templateInicio && !templateInicio.value) {
    templateInicio.value = formatDateISO(new Date());
  }
  if (tipo === "hv-daily") {
    templateFrequencia.value = "daily";
    atualizarTemplateFrequenciaUI(true);
    aplicarPresetDiasUteis();
    return;
  }
  if (tipo === "weekly") {
    templateFrequencia.value = "weekly";
    atualizarTemplateFrequenciaUI(true);
    if (templateWeeklyDay) {
      templateWeeklyDay.value = "1";
    }
    if (templateWeeklyInterval) {
      templateWeeklyInterval.value = "1";
    }
    updateTemplateResumo();
    return;
  }
  if (tipo === "monthly") {
    templateFrequencia.value = "monthly";
    atualizarTemplateFrequenciaUI(true);
    if (templateMonthlyFixed) {
      templateMonthlyFixed.checked = true;
    }
    if (templateMonthlyMulti) {
      templateMonthlyMulti.checked = false;
    }
    if (templateMonthlyDay) {
      templateMonthlyDay.value = "10";
    }
    if (templateMonthlyDaysInput) {
      templateMonthlyDaysInput.value = "";
    }
    atualizarTemplateMonthlyUI(true);
  }
}

function atualizarTemplateMonthlyUI(limparCampos = false) {
  if (!templateMonthlyModeField) {
    return;
  }
  const isMonthly = templateFrequencia && templateFrequencia.value === "monthly";
  const isFixed = templateMonthlyFixed ? templateMonthlyFixed.checked : true;
  if (limparCampos && isMonthly) {
    resetTemplateMonthlyModeFields(isFixed ? "fixed" : "multi");
    clearTemplateErrors();
    mostrarMensagemTemplate("");
  }
  templateMonthlyModeField.hidden = !isMonthly;
  if (templateMonthlyDayField) {
    templateMonthlyDayField.hidden = !isMonthly || !isFixed;
  }
  if (templateMonthlyDaysField) {
    templateMonthlyDaysField.hidden = !isMonthly || isFixed;
  }
  updateMonthlyDaysChips();
  updateTemplateResumo();
}

function atualizarTemplateFrequenciaUI(limparCampos = false) {
  if (!templateFrequencia) {
    return;
  }
  const tipo = templateFrequencia.value;
  if (limparCampos) {
    resetTemplateFieldsForTipo(tipo);
    clearTemplateErrors();
    mostrarMensagemTemplate("");
  }
  if (templateDailyField) {
    templateDailyField.hidden = tipo !== "daily";
  }
  if (templateWeeklyDayField) {
    templateWeeklyDayField.hidden = tipo !== "weekly";
  }
  if (templateWeeklyIntervalField) {
    templateWeeklyIntervalField.hidden = tipo !== "weekly";
  }
  if (templateInicioField) {
    templateInicioField.hidden = false;
  }
  atualizarTemplateMonthlyUI();
  updateTemplateResumo();
}

function limparTemplateForm() {
  if (!templateForm) {
    return;
  }
  templateForm.reset();
  templateForm.dataset.templateId = "";
  clearTemplateErrors();
  mostrarMensagemTemplate("");
  renderProjectSelectOptions(templateProjeto, activeProjectId);
  if (templateEquipamento) {
    templateEquipamento.value = "";
  }
  renderTemplateEquipeOptions();
  setTemplateParticipantes([]);
  if (templateParticipanteExterno) {
    templateParticipanteExterno.value = "";
  }
  if (templateInicio) {
    templateInicio.value = formatDateISO(new Date());
  }
  if (templateDailyDays.length) {
    templateDailyDays.forEach((checkbox) => {
      const valor = Number(checkbox.value);
      checkbox.checked = DEFAULT_DAILY_DAYS.includes(valor);
    });
  }
  if (templateWeeklyDay) {
    templateWeeklyDay.value = "1";
  }
  if (templateWeeklyInterval) {
    templateWeeklyInterval.value = "1";
  }
  if (templateMonthlyFixed) {
    templateMonthlyFixed.checked = true;
  }
  if (templateMonthlyMulti) {
    templateMonthlyMulti.checked = false;
  }
  if (templateMonthlyDay) {
    templateMonthlyDay.value = "10";
  }
  if (templateMonthlyDaysInput) {
    templateMonthlyDaysInput.value = "";
  }
  updateMonthlyDaysChips();
  atualizarTemplateFrequenciaUI();
  updateTemplateResumo();
}

function preencherTemplateForm(template) {
  if (!templateForm || !template) {
    return;
  }
  templateForm.dataset.templateId = template.id;
  clearTemplateErrors();
  mostrarMensagemTemplate("");
  if (templateNome) {
    templateNome.value = template.nome || "";
  }
  if (templateSubestacao && template.subestacao) {
    templateSubestacao.value = template.subestacao;
  }
  if (templateEquipamento) {
    setEquipamentoSelectValue(
      templateEquipamento,
      template.equipamentoId || template.equipamento || ""
    );
  }
  renderTemplateEquipeOptions(template.equipeResponsavel || "");
  const participantesTemplate = Array.isArray(template.participantes)
    ? template.participantes
    : typeof template.participantes === "string"
      ? template.participantes
          .split(";")
          .map((item) => normalizeParticipantName(item))
          .filter(Boolean)
      : [];
  setTemplateParticipantes(participantesTemplate);
  if (templateParticipanteExterno) {
    templateParticipanteExterno.value = "";
  }
  if (templateFrequencia) {
    templateFrequencia.value = template.frequencia || "none";
  }
  if (templateDailyDays.length) {
    const dias = normalizeDailyDays(template.dailyDays);
    templateDailyDays.forEach((checkbox) => {
      const valor = Number(checkbox.value);
      checkbox.checked = dias.includes(valor);
    });
  }
  if (templateWeeklyDay) {
    const weekdayValue = Number(template.weeklyDay);
    templateWeeklyDay.value =
      Number.isFinite(weekdayValue) && weekdayValue >= 0 ? String(weekdayValue) : "1";
  }
  if (templateWeeklyInterval) {
    templateWeeklyInterval.value = template.weeklyInterval || 1;
  }
  if (templateMonthlyFixed && templateMonthlyMulti) {
    const modo = template.monthlyMode === "multi" ? "multi" : "fixed";
    templateMonthlyFixed.checked = modo === "fixed";
    templateMonthlyMulti.checked = modo === "multi";
  }
  if (templateMonthlyDay) {
    templateMonthlyDay.value = template.monthlyDay || 10;
  }
  if (templateMonthlyDaysInput) {
    const diasMes = normalizeMonthlyDays(template.monthlyDays);
    templateMonthlyDaysInput.value = diasMes.length ? diasMes.join(", ") : "";
  }
  if (templateInicio) {
    templateInicio.value = template.inicio || formatDateISO(new Date());
  }
  if (templateObs) {
    templateObs.value = template.observacao || "";
  }
  if (templateAtivo) {
    templateAtivo.checked = template.ativo !== false;
  }
  updateMonthlyDaysChips();
  atualizarTemplateFrequenciaUI();
  updateTemplateResumo();
}

function salvarModelo(event) {
  event.preventDefault();
  if (!activeProjectId) {
    mostrarMensagemTemplate("Selecione um projeto ativo antes de salvar.", true);
    return;
  }
  const templateIdAtual = templateForm ? templateForm.dataset.templateId || "" : "";
  const existente = templateIdAtual
    ? templates.find((item) => item && item.id === templateIdAtual)
    : null;
  const podeSalvar = existente ? can("edit") : can("create");
  if (!podeSalvar) {
    mostrarMensagemTemplate("Sem permissão para salvar modelos.", true);
    return;
  }
  if (templateProjeto && templateProjeto.value && templateProjeto.value !== activeProjectId) {
    mostrarMensagemTemplate("O projeto selecionado e diferente do ativo. Troque o projeto e tente novamente.", true);
    return;
  }
  clearTemplateErrors();
  mostrarMensagemTemplate("");
  const nome = templateNome ? templateNome.value.trim() : "";
  if (!nome) {
    setFieldError(templateNomeErro, "Informe o nome do modelo.");
    return;
  }
  const subestacao =
    (templateSubestacao ? templateSubestacao.value.trim() : "") ||
    getSubestacoesBase()[0] ||
    "";
  const equipamentoId = templateEquipamento ? templateEquipamento.value.trim() : "";
  const equipeResponsavel = getTemplateEquipeSelecionada();
  const participantes = getTemplateParticipantesFromForm();
  const frequencia = templateFrequencia ? templateFrequencia.value : "none";
  const inicio = templateInicio ? templateInicio.value : formatDateISO(new Date());

  const dailyDays = getDailyDaysFromForm();
  const weeklyDayValue = templateWeeklyDay ? Number(templateWeeklyDay.value) : NaN;
  const weeklyDay = Number.isFinite(weeklyDayValue) ? weeklyDayValue : 1;
  const weeklyIntervalValue = templateWeeklyInterval ? Number(templateWeeklyInterval.value) : 1;
  const weeklyIntervalValid =
    Number.isFinite(weeklyIntervalValue) && weeklyIntervalValue >= 1 && Number.isInteger(weeklyIntervalValue);
  const weeklyInterval = weeklyIntervalValid ? weeklyIntervalValue : 1;

  const monthlyMode =
    templateMonthlyMulti && templateMonthlyMulti.checked ? "multi" : "fixed";
  const monthlyDayValue = templateMonthlyDay ? Number(templateMonthlyDay.value) : NaN;
  const monthlyDayValid =
    Number.isFinite(monthlyDayValue) &&
    Number.isInteger(monthlyDayValue) &&
    monthlyDayValue >= 1 &&
    monthlyDayValue <= 31;
  const monthlyDay = monthlyDayValid ? monthlyDayValue : 1;
  const monthlyValidation = validateMonthlyDaysInput(
    templateMonthlyDaysInput ? templateMonthlyDaysInput.value : ""
  );
  const monthlyDays = monthlyValidation.valid ? monthlyValidation.dias : [];

  if (!parseDate(inicio)) {
    setFieldError(templateInicioErro, "Data de início inválida.");
    return;
  }
  if (frequencia === "daily" && !dailyDays.length) {
    setFieldError(templateDailyErro, "Selecione ao menos um dia.");
    return;
  }
  if (frequencia === "weekly" && (!Number.isFinite(weeklyDay) || !weeklyIntervalValid)) {
    setFieldError(templateWeeklyIntervalErro, "Informe um intervalo semanal válido (>= 1).");
    return;
  }
  if (frequencia === "monthly") {
    if (monthlyMode === "fixed" && !monthlyDayValid) {
      setFieldError(templateMonthlyDayErro, "Informe um dia do mês válido (1 a 31).");
      return;
    }
    if (monthlyMode === "multi") {
      if (!monthlyValidation.valid) {
        setFieldError(
          templateMonthlyDaysErro,
          "Informe dias válidos entre 1 e 31 (ex.: 10, 25)."
        );
        return;
      }
      if (!monthlyDays.length) {
        setFieldError(
          templateMonthlyDaysErro,
          "Informe ao menos um dia do mês para a recorrência."
        );
        return;
      }
      if (templateMonthlyDaysInput) {
        templateMonthlyDaysInput.value = monthlyDays.join(", ");
      }
    }
  }

  const ativo = Boolean(templateAtivo.checked);
  const templateId = templateIdAtual || criarId();

  const modelo = {
    id: templateId,
    nome,
    subestacao,
    equipamentoId,
    equipeResponsavel,
    participantes,
    frequencia,
    dailyDays: frequencia === "daily" ? dailyDays : [],
    weeklyDay: frequencia === "weekly" ? weeklyDay : null,
    weeklyInterval: frequencia === "weekly" ? weeklyInterval : 1,
    monthlyMode: frequencia === "monthly" ? monthlyMode : "fixed",
    monthlyDay: frequencia === "monthly" ? monthlyDay : null,
    monthlyDays: frequencia === "monthly" && monthlyMode === "multi" ? monthlyDays : [],
    inicio,
    proximaData: "",
    observacao: templateObs ? templateObs.value.trim() : "",
    ativo,
    createdAt: existente ? existente.createdAt : toIsoUtc(new Date()),
    createdBy: existente ? existente.createdBy : (currentUser ? currentUser.id : SYSTEM_USER_ID),
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser ? currentUser.id : SYSTEM_USER_ID,
  };
  modelo.proximaData = calcularProximaData(modelo);

  if (existente) {
    templates = templates.map((item) => (item.id === templateId ? modelo : item));
  } else {
    templates = [...templates, modelo];
  }
  salvarTemplates(templates);
  gerarManutencoesRecorrentes();
  renderTudo();
  limparTemplateForm();
  mostrarMensagemTemplate("Modelo salvo.");
}

async function removerModelo(item) {
  if (!can("edit")) {
    mostrarMensagemTemplate("Sem permissão para remover modelos.", true);
    return;
  }
  const templateId = item.dataset.templateId;
  const template = templates.find((registro) => registro.id === templateId);
  if (!template) {
    return;
  }
  const confirmar = await openConfirmModal({
    title: "Remover modelo",
    message: `Remover o modelo \"${template.nome}\"? As ocorrencias ja geradas permanecem.`,
    confirmText: "Remover",
    cancelText: "Cancelar",
  });
  if (!confirmar) {
    return;
  }
  templates = templates.filter((registro) => registro.id !== templateId);
  salvarTemplates(templates);
  removeRecurrenceSuppressionsByTemplate(templateId);
  renderTudo();
  mostrarMensagemTemplate("Modelo removido.");
}

function alternarModelo(item) {
  if (!can("edit")) {
    mostrarMensagemTemplate("Sem permissão para atualizar modelos.", true);
    return;
  }
  const templateId = item.dataset.templateId;
  const template = templates.find((registro) => registro.id === templateId);
  if (!template) {
    return;
  }
  template.ativo = !template.ativo;
  salvarTemplates(templates);
  gerarManutencoesRecorrentes();
  renderTudo();
}

function renderModelos() {
  if (!listaModelos) {
    return;
  }
  listaModelos.innerHTML = "";
  const existentes = templates.filter((item) => item && item.nome);
  if (existentes.length === 0) {
    if (modelosVazio) {
      modelosVazio.textContent = "Nenhum modelo cadastrado.";
      modelosVazio.hidden = false;
    }
    return;
  }

  if (templateFilterSubestacao) {
    const atual = templateFilterSubestacao.value;
    const subestacoes = Array.from(
      new Set([...getSubestacoesBase(), ...existentes.map((item) => item.subestacao).filter(Boolean)])
    ).sort((a, b) => a.localeCompare(b, "pt-BR"));
    templateFilterSubestacao.innerHTML = "";
    const optionAll = document.createElement("option");
    optionAll.value = "";
    optionAll.textContent = "Todas";
    templateFilterSubestacao.append(optionAll);
    subestacoes.forEach((nome) => {
      const option = document.createElement("option");
      option.value = nome;
      option.textContent = nome;
      templateFilterSubestacao.append(option);
    });
    if (atual && subestacoes.includes(atual)) {
      templateFilterSubestacao.value = atual;
    }
  }

  const termo = templateSearch ? templateSearch.value.trim().toLowerCase() : "";
  const filtroSubestacao = templateFilterSubestacao ? templateFilterSubestacao.value : "";
  const ordenacao = templateSort ? templateSort.value : "next";

  const filtrados = existentes.filter((template) => {
    if (filtroSubestacao && template.subestacao !== filtroSubestacao) {
      return false;
    }
    if (!termo) {
      return true;
    }
    const subestacaoLabel = template.subestacao || "";
    const alvo = `${template.nome} ${subestacaoLabel} ${formatIntervalo(template)}`
      .toLowerCase()
      .trim();
    return alvo.includes(termo);
  });

  if (!filtrados.length) {
    if (modelosVazio) {
      modelosVazio.textContent = "Nenhum modelo encontrado.";
      modelosVazio.hidden = false;
    }
    return;
  }
  if (modelosVazio) {
    modelosVazio.textContent = "Nenhum modelo cadastrado.";
    modelosVazio.hidden = true;
  }

  const agora = new Date();
  const ordenados = filtrados
    .map((template) => {
      const proximaDate =
        template.ativo && template.frequencia !== "none"
          ? getNextOccurrenceDate(template, agora)
          : null;
      return { template, proximaDate };
    })
    .sort((a, b) => {
      if (ordenacao === "next") {
        const aTime = a.proximaDate ? a.proximaDate.getTime() : Number.POSITIVE_INFINITY;
        const bTime = b.proximaDate ? b.proximaDate.getTime() : Number.POSITIVE_INFINITY;
        if (aTime !== bTime) {
          return aTime - bTime;
        }
      }
      return a.template.nome.localeCompare(b.template.nome, "pt-BR");
    });

  ordenados.forEach(({ template, proximaDate }) => {
    const item = document.createElement("div");
    item.className = "template-item";
    item.dataset.templateId = template.id;

    const titulo = document.createElement("strong");
    titulo.textContent = template.nome;

    const metaTop = document.createElement("p");
    metaTop.className = "template-meta";
    const subestacaoLabel = template.subestacao || "-";
    metaTop.textContent = `${subestacaoLabel} | ${formatIntervalo(template)}`;

    const proximaLabel = template.ativo
      ? template.frequencia === "none"
        ? "Sem recorrência"
        : proximaDate
          ? formatDate(proximaDate)
          : "Sem proxima"
      : "Desativado";

    const metaBottom = document.createElement("p");
    metaBottom.className = "template-meta";
    metaBottom.textContent = `Proxima: ${proximaLabel}`;

    const status = document.createElement("span");
    status.className = "account-label";
    status.textContent = template.ativo ? "Ativo" : "Desativado";

    const actions = document.createElement("div");
    actions.className = "template-actions";
    const btnEditar = document.createElement("button");
    btnEditar.type = "button";
    btnEditar.className = "btn btn--ghost btn--small";
    btnEditar.dataset.action = "edit-template";
    btnEditar.textContent = "Editar";
    const btnToggle = document.createElement("button");
    btnToggle.type = "button";
    btnToggle.className = "btn btn--ghost btn--small";
    btnToggle.dataset.action = "toggle-template";
    btnToggle.textContent = template.ativo ? "Desativar" : "Ativar";
    const btnRemover = document.createElement("button");
    btnRemover.type = "button";
    btnRemover.className = "btn btn--ghost btn--small btn--danger";
    btnRemover.dataset.action = "delete-template";
    btnRemover.textContent = "Remover";
    actions.append(btnEditar, btnToggle, btnRemover);

    item.append(titulo, metaTop, metaBottom, status, actions);
    listaModelos.append(item);
  });
}

function getPmpFrequency(value) {
  const normalized = normalizeSearchValue(value).replace(/\s+/g, "");
  return PMP_FREQUENCIES.find((item) => item.value === normalized) || null;
}

function getPmpTipoInfo(value) {
  const normalized = normalizeSearchValue(value).replace(/\s+/g, "");
  return PMP_TIPOS.find((item) => item.value === normalized) || null;
}

function isWeekend(date) {
  if (!date) {
    return false;
  }
  const day = date.getDay();
  return day === 0 || day === 6;
}

function shouldSkipWeekend(activity, date) {
  return Boolean(activity && activity.onlyWeekdays) && isWeekend(date);
}

function parseDurationToMinutes(value) {
  if (typeof value === "number" && Number.isFinite(value)) {
    return Math.max(0, Math.round(value));
  }
  const text = String(value || "").trim();
  if (!text) {
    return 0;
  }
  if (text.includes(":")) {
    const [h, m] = text.split(":");
    const horas = Number(h);
    const minutos = Number(m);
    if (Number.isFinite(horas) && Number.isFinite(minutos)) {
      return Math.max(0, Math.round(horas * 60 + minutos));
    }
  }
  const numeric = Number(text);
  if (Number.isFinite(numeric)) {
    return Math.max(0, Math.round(numeric));
  }
  return 0;
}

function normalizePmpChecklistItems(list) {
  if (!Array.isArray(list)) {
    return [];
  }
  return list
    .map((item) => {
      if (!item) {
        return null;
      }
      if (typeof item === "string") {
        const text = item.trim();
        return text ? { descricao: text, link: "" } : null;
      }
      const descricao = String(item.descricao || item.label || "").trim();
      const link = String(item.link || item.url || "").trim();
      if (!descricao && !link) {
        return null;
      }
      return { descricao, link };
    })
    .filter(Boolean);
}

function renderPmpChecklist() {
  if (!pmpChecklistList) {
    return;
  }
  pmpChecklistList.innerHTML = "";
  if (!pmpChecklistItems.length) {
    const vazio = document.createElement("li");
    vazio.textContent = "Nenhum item adicionado.";
    pmpChecklistList.append(vazio);
    return;
  }
  pmpChecklistItems.forEach((item, index) => {
    const li = document.createElement("li");
    const label = document.createElement("span");
    label.textContent = item.descricao || "Item";
    li.append(label);
    if (item.link) {
      const link = document.createElement("a");
      link.href = item.link;
      link.target = "_blank";
      link.rel = "noopener";
      link.textContent = "Abrir";
      li.append(link);
    }
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "btn btn--ghost btn--small";
    btn.dataset.pmpChecklistRemove = String(index);
    btn.textContent = "Remover";
    li.append(btn);
    pmpChecklistList.append(li);
  });
}

function addPmpChecklistItem() {
  const descricao = pmpChecklistItem ? pmpChecklistItem.value.trim() : "";
  const link = pmpChecklistLink ? pmpChecklistLink.value.trim() : "";
  if (!descricao && !link) {
    return;
  }
  pmpChecklistItems = [...pmpChecklistItems, { descricao, link }];
  if (pmpChecklistItem) {
    pmpChecklistItem.value = "";
  }
  if (pmpChecklistLink) {
    pmpChecklistLink.value = "";
  }
  renderPmpChecklist();
}

async function uploadPmpProcedimento(file) {
  if (!file) {
    return;
  }
  if (!currentUser || !canUploadPmpProcedimento(currentUser)) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Somente PCM pode anexar procedimentos.";
    }
    return;
  }
  const isPdf = file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
  if (!isPdf) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Envie um arquivo PDF.";
    }
    return;
  }
  if (file.size > FILE_MAX_BYTES) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Arquivo acima de 10 MB.";
    }
    return;
  }
  if (pmpProcedimentoUpload) {
    pmpProcedimentoUpload.disabled = true;
  }
  if (pmpFormMensagem) {
    pmpFormMensagem.textContent = "Enviando procedimento...";
  }
  try {
    const formData = new FormData();
    formData.append("type", "procedure");
    formData.append("file", file);
    const data = await apiUploadFile(formData);
    if (data && data.file) {
      setPmpProcedimentoDoc(data.file);
      if (pmpFormMensagem) {
        pmpFormMensagem.textContent = "Procedimento anexado. Salve a atividade para vincular.";
      }
    }
  } catch (error) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = error.message || "Falha ao enviar procedimento.";
    }
  } finally {
    if (pmpProcedimentoUpload) {
      pmpProcedimentoUpload.disabled = false;
    }
    if (pmpProcedimentoFile) {
      pmpProcedimentoFile.value = "";
    }
  }
}

function resolvePmpExecutionDate(value) {
  if (value instanceof Date) {
    return value;
  }
  return parseAnyDate(value);
}

function getPmpYearValue() {
  const current = new Date().getFullYear();
  const valor = pmpAno ? Number(pmpAno.value) : current;
  return Number.isFinite(valor) && valor > 0 ? valor : current;
}

function getPmpMonthValue() {
  const current = new Date().getMonth();
  const valor = pmpMes ? Number(pmpMes.value) : current;
  return Number.isFinite(valor) && valor >= 0 && valor <= 11 ? valor : current;
}

function getPmpViewMode() {
  if (pmpView && pmpView.value === "day") {
    return "day";
  }
  return pmpView && pmpView.value === "week" ? "week" : "month";
}

function buildWeeksInYear(year) {
  const weeks = [];
  const startYear = new Date(year, 0, 1);
  let current = startOfWeek(startYear);
  let index = 1;
  const endYear = new Date(year, 11, 31);
  while (current <= endYear || (current.getFullYear() === year && current <= endYear)) {
    const start = new Date(current);
    const end = addDays(start, 6);
    if (end.getFullYear() < year) {
      current = addDays(current, 7);
      continue;
    }
    weeks.push({
      index,
      label: `W${String(index).padStart(2, "0")}`,
      start,
      end,
      key: `W${String(index).padStart(2, "0")}`,
    });
    current = addDays(current, 7);
    index += 1;
    if (index > 54) {
      break;
    }
  }
  return weeks;
}

function getWeekNumber(date) {
  const base = startOfDay(date);
  const start = new Date(base.getFullYear(), 0, 1);
  const diff = Math.floor((base - start) / 86400000);
  const startOffset = (start.getDay() + 6) % 7;
  return Math.floor((diff + startOffset) / 7) + 1;
}

function getPmpPeriods(viewMode, year, monthIndex) {
  if (viewMode === "week") {
    return buildWeeksInYear(year);
  }
  if (viewMode === "day") {
    const month = Number.isFinite(monthIndex) ? monthIndex : new Date().getMonth();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    return Array.from({ length: daysInMonth }, (_, idx) => {
      const day = idx + 1;
      const start = new Date(year, month, day);
      return {
        index: idx,
        label: String(day).padStart(2, "0"),
        start,
        end: start,
        key: `D${String(day).padStart(2, "0")}`,
      };
    });
  }
  return PMP_MONTH_LABELS.map((label, idx) => {
    const start = new Date(year, idx, 1);
    const end = new Date(year, idx + 1, 0);
    return {
      index: idx,
      label,
      start,
      end,
      key: `M${String(idx + 1).padStart(2, "0")}`,
    };
  });
}

function getActivityStartDate(activity, year) {
  const byDate = activity && activity.inicio ? parseDate(activity.inicio) : null;
  const byDateTime = activity && activity.inicio ? parseTimestamp(activity.inicio) : null;
  if (byDate) {
    return byDate;
  }
  if (byDateTime) {
    return byDateTime;
  }
  return new Date(year, 0, 1);
}

function getScheduledDateForMonth(activity, year, monthIndex) {
  const start = getActivityStartDate(activity, year);
  const day = start ? start.getDate() : 1;
  const lastDay = new Date(year, monthIndex + 1, 0).getDate();
  return new Date(year, monthIndex, Math.min(day, lastDay));
}

function getScheduledMonths(activity, year) {
  const freq = getPmpFrequency(activity && activity.frequencia);
  if (!freq) {
    return new Set();
  }
  const allowed = getActivityAllowedMonths(activity);
  const start = getActivityStartDate(activity, year);
  const startYear = start.getFullYear();
  const startMonth = start.getMonth();
  if (year < startYear) {
    return new Set();
  }
  if (freq.unit === "year") {
    if ((year - startYear) % freq.interval !== 0) {
      return new Set();
    }
    const result = new Set([startMonth]);
    if (shouldSkipWeekend(activity, getScheduledDateForMonth(activity, year, startMonth))) {
      return new Set();
    }
    if (allowed) {
      return new Set(Array.from(result).filter((month) => allowed.has(month)));
    }
    return result;
  }
  if (freq.unit === "month") {
    const months = new Set();
    let current = year === startYear ? startMonth : 0;
    for (let m = current; m < 12; m += freq.interval) {
      if (year === startYear && m < startMonth) {
        continue;
      }
      const date = getScheduledDateForMonth(activity, year, m);
      if (shouldSkipWeekend(activity, date)) {
        continue;
      }
      months.add(m);
    }
    if (allowed) {
      return new Set(Array.from(months).filter((month) => allowed.has(month)));
    }
    return months;
  }
  const months = new Set();
  const first = year === startYear ? startMonth : 0;
  for (let m = first; m < 12; m += 1) {
    const date = getScheduledDateForMonth(activity, year, m);
    if (shouldSkipWeekend(activity, date)) {
      continue;
    }
    months.add(m);
  }
  if (allowed) {
    return new Set(Array.from(months).filter((month) => allowed.has(month)));
  }
  return months;
}

function getScheduledDays(activity, year, monthIndex) {
  const freq = getPmpFrequency(activity && activity.frequencia);
  if (!freq || !Number.isFinite(monthIndex)) {
    return new Set();
  }
  if (!isMonthAllowed(activity, monthIndex)) {
    return new Set();
  }
  const start = getActivityStartDate(activity, year);
  const startYear = start.getFullYear();
  const startMonth = start.getMonth();
  if (year < startYear) {
    return new Set();
  }
  if (year === startYear && monthIndex < startMonth) {
    return new Set();
  }
  const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
  const days = new Set();
  const startDay = start.getDate();
  if (freq.unit === "day") {
    for (let day = 1; day <= daysInMonth; day += 1) {
      const date = new Date(year, monthIndex, day);
      if (date < start) {
        continue;
      }
      if (shouldSkipWeekend(activity, date)) {
        continue;
      }
      days.add(day);
    }
    return days;
  }
  if (freq.unit === "week") {
    const startDow = start.getDay();
    for (let day = 1; day <= daysInMonth; day += 1) {
      const date = new Date(year, monthIndex, day);
      if (date < start || date.getDay() !== startDow) {
        continue;
      }
      if (shouldSkipWeekend(activity, date)) {
        continue;
      }
      if (freq.interval > 1) {
        const diffDays = Math.round((startOfDay(date) - startOfDay(start)) / DAY_MS);
        const diffWeeks = Math.floor(diffDays / 7);
        if (diffWeeks < 0 || diffWeeks % freq.interval !== 0) {
          continue;
        }
      }
      days.add(day);
    }
    return days;
  }
  if (freq.unit === "month") {
    const monthDiff = (year - startYear) * 12 + (monthIndex - startMonth);
    if (monthDiff < 0 || monthDiff % freq.interval !== 0) {
      return new Set();
    }
    const day = Math.min(startDay, daysInMonth);
    const date = new Date(year, monthIndex, day);
    if (date < start) {
      return new Set();
    }
    if (shouldSkipWeekend(activity, date)) {
      return new Set();
    }
    days.add(day);
    return days;
  }
  if (freq.unit === "year") {
    const yearDiff = year - startYear;
    if (yearDiff < 0 || yearDiff % freq.interval !== 0) {
      return new Set();
    }
    if (monthIndex !== startMonth) {
      return new Set();
    }
    const day = Math.min(startDay, daysInMonth);
    const date = new Date(year, monthIndex, day);
    if (date < start) {
      return new Set();
    }
    if (shouldSkipWeekend(activity, date)) {
      return new Set();
    }
    days.add(day);
  }
  return days;
}

function getScheduledWeeks(activity, year, weeks) {
  const freq = getPmpFrequency(activity && activity.frequencia);
  if (!freq) {
    return new Set();
  }
  const start = getActivityStartDate(activity, year);
  const startYear = start.getFullYear();
  if (year < startYear) {
    return new Set();
  }
  const allowed = getActivityAllowedMonths(activity);
  const weeksSet = new Set();
  if (freq.unit === "week" || freq.unit === "day") {
    const startWeek = getWeekNumber(start);
    weeks.forEach((week) => {
      if (year === startYear && week.index < startWeek) {
        return;
      }
      if (freq.unit === "week" && freq.interval > 1) {
        const diff = week.index - startWeek;
        if (diff < 0 || diff % freq.interval !== 0) {
          return;
        }
      }
      const startDow = start.getDay();
      const offset = (startDow + 6) % 7;
      const scheduledDate = addDays(week.start, offset);
      if (shouldSkipWeekend(activity, scheduledDate)) {
        return;
      }
      if (allowed && !allowed.has(scheduledDate.getMonth())) {
        return;
      }
      weeksSet.add(week.index);
    });
    return weeksSet;
  }
  if (freq.unit === "month") {
    const months = getScheduledMonths(activity, year);
    months.forEach((monthIndex) => {
      const date = getScheduledDateForMonth(activity, year, monthIndex);
      if (allowed && !allowed.has(date.getMonth())) {
        return;
      }
      weeksSet.add(getWeekNumber(date));
    });
    return weeksSet;
  }
  if (freq.unit === "year") {
    if ((year - startYear) % freq.interval !== 0) {
      return weeksSet;
    }
    const date = getScheduledDateForMonth(activity, year, start.getMonth());
    if (shouldSkipWeekend(activity, date)) {
      return weeksSet;
    }
    if (allowed && !allowed.has(date.getMonth())) {
      return weeksSet;
    }
    weeksSet.add(getWeekNumber(date));
  }
  return weeksSet;
}

function getScheduledPeriodKeys(activity, year, viewMode, periods, monthIndex) {
  if (viewMode === "day") {
    const daysSet = getScheduledDays(activity, year, monthIndex);
    return new Set(Array.from(daysSet).map((value) => `D${String(value).padStart(2, "0")}`));
  }
  if (viewMode === "week") {
    const weeksSet = getScheduledWeeks(activity, year, periods);
    return new Set(Array.from(weeksSet).map((value) => `W${String(value).padStart(2, "0")}`));
  }
  const months = getScheduledMonths(activity, year);
  return new Set(Array.from(months).map((value) => `M${String(value + 1).padStart(2, "0")}`));
}

function getPeriodKeyForDate(viewMode, date, year, monthIndex) {
  if (!date || date.getFullYear() !== year) {
    return "";
  }
  if (viewMode === "day") {
    if (!Number.isFinite(monthIndex) || date.getMonth() !== monthIndex) {
      return "";
    }
    return `D${String(date.getDate()).padStart(2, "0")}`;
  }
  if (viewMode === "week") {
    const week = getWeekNumber(date);
    return `W${String(week).padStart(2, "0")}`;
  }
  return `M${String(date.getMonth() + 1).padStart(2, "0")}`;
}

function getPmpDiffDays(a, b) {
  if (!a || !b) {
    return null;
  }
  const startA = startOfDay(a);
  const startB = startOfDay(b);
  return Math.round((startA - startB) / DAY_MS);
}

function setExecutionMap(map, activityId, periodKey, payload) {
  if (!activityId || !periodKey) {
    return;
  }
  if (!map.has(activityId)) {
    map.set(activityId, new Map());
  }
  map.get(activityId).set(periodKey, payload);
}

function getPmpStatusForPeriod(
  activity,
  period,
  periodKey,
  viewMode,
  manualMap,
  autoMap,
  today,
  isScheduled = true
) {
  const manual = manualMap.get(activity.id) ? manualMap.get(activity.id).get(periodKey) : null;
  const auto = autoMap.get(activity.id) ? autoMap.get(activity.id).get(periodKey) : null;
  const exec = manual || auto;
  const scheduledDate = exec && exec.scheduledFor ? parseAnyDate(exec.scheduledFor) : null;
  const dueDate = scheduledDate || getDueDateForPeriod(activity, period, viewMode);
  if (exec && exec.status === "removida") {
    return { status: "empty", exec, executedAt: null, dueDate };
  }
  if (exec && exec.status === "cancelada") {
    return { status: "cancelled", exec, executedAt: null, dueDate };
  }
  const executedAt = exec ? resolvePmpExecutionDate(exec.executedAt) : null;
  if (executedAt) {
    const diff = dueDate ? getPmpDiffDays(executedAt, dueDate) : 0;
    if (dueDate && diff !== null && Math.abs(diff) > PMP_TOLERANCE_DAYS) {
      return { status: "late", exec, executedAt, dueDate };
    }
    return { status: "on_time", exec, executedAt, dueDate };
  }
  if (!isScheduled && !exec) {
    return { status: "empty", exec: null, executedAt: null, dueDate };
  }
  if (period.end < today) {
    return { status: "missed", exec: null, executedAt: null, dueDate };
  }
  return { status: "scheduled", exec: null, executedAt: null, dueDate };
}

function getExecutionsByActivity() {
  const manual = new Map();
  const year = getPmpYearValue();
  const view = getPmpViewMode();
  const monthIndex = getPmpMonthValue();
  pmpExecutions.forEach((exec) => {
    if (!exec || !exec.activityId) {
      return;
    }
    let periodKey = exec.periodKey;
    if (!periodKey && exec.scheduledFor) {
      const date = parseAnyDate(exec.scheduledFor);
      periodKey = getPeriodKeyForDate(view, date, year, monthIndex);
    }
    if (!periodKey && exec.executedAt) {
      const date = parseAnyDate(exec.executedAt);
      periodKey = getPeriodKeyForDate(view, date, year, monthIndex);
    }
    setExecutionMap(manual, exec.activityId, periodKey, exec);
  });
  return manual;
}

function mapTemplateFrequencyToPmp(template) {
  if (!template || !template.frequencia) {
    return "";
  }
  const freq = String(template.frequencia).toLowerCase();
  if (freq === "daily") {
    return "diaria";
  }
  if (freq === "weekly") {
    return "semanal";
  }
  if (freq === "monthly") {
    return "mensal";
  }
  return "";
}

function getMaintenanceCodigo(item) {
  return String(item && (item.codigo || item.tag || item.subestacao) ? item.codigo || item.tag || item.subestacao : "")
    .trim();
}

function getMaintenanceOsReferencia(item) {
  if (!item) {
    return "";
  }
  if (item.osReferencia) {
    return String(item.osReferencia || "").trim();
  }
  const liberacao = getLiberacao(item);
  if (liberacao && liberacao.osNumero) {
    return String(liberacao.osNumero || "").trim();
  }
  return "";
}

function getMaintenanceParticipantsCount(item) {
  if (!item) {
    return 0;
  }
  const liberacao = getLiberacao(item) || {};
  const participantes = Array.isArray(liberacao.participantes) ? liberacao.participantes : [];
  if (participantes.length) {
    return participantes.length;
  }
  if (Array.isArray(item.participantes)) {
    return item.participantes.length;
  }
  if (typeof item.participantes === "string") {
    return item.participantes.split(/[;,]/).map((p) => p.trim()).filter(Boolean).length;
  }
  if (item.conclusao && Array.isArray(item.conclusao.participantes)) {
    return item.conclusao.participantes.length;
  }
  return 0;
}

function getMaintenanceDurationMinutes(item) {
  if (!item) {
    return 0;
  }
  if (item.conclusao && Number.isFinite(item.conclusao.duracaoMin)) {
    return Math.max(0, Math.round(item.conclusao.duracaoMin));
  }
  if (Number.isFinite(item.duracaoMin)) {
    return Math.max(0, Math.round(item.duracaoMin));
  }
  const inicio = getItemInicioExecucaoDate(item);
  const fim = getItemFimExecucaoDate(item) || getItemConclusaoDate(item);
  if (inicio && fim) {
    return Math.max(0, Math.round((fim - inicio) / 60000));
  }
  return 0;
}

function getMaintenanceEvidencias(item) {
  const evidencias = [];
  if (!item) {
    return evidencias;
  }
  if (Array.isArray(item.evidencias)) {
    evidencias.push(...item.evidencias);
  }
  if (item.registroExecucao && Array.isArray(item.registroExecucao.evidencias)) {
    evidencias.push(...item.registroExecucao.evidencias);
  }
  if (item.conclusao && Array.isArray(item.conclusao.evidencias)) {
    evidencias.push(...item.conclusao.evidencias);
  }
  if (Array.isArray(item.anexos)) {
    evidencias.push(...item.anexos);
  }
  return evidencias;
}

function getPmpMaintenanceList(projectId) {
  if (!projectId) {
    return [];
  }
  if (pmpMaintenanceCache.has(projectId)) {
    return pmpMaintenanceCache.get(projectId);
  }
  if (projectId === activeProjectId && Array.isArray(manutencoes)) {
    return manutencoes;
  }
  return [];
}

async function ensurePmpMaintenanceCache(projectId) {
  if (!projectId) {
    return [];
  }
  if (pmpMaintenanceCache.has(projectId)) {
    return pmpMaintenanceCache.get(projectId);
  }
  try {
    const data = await apiMaintenanceList(projectId);
    if (data && Array.isArray(data.items)) {
      const normalized = normalizarManutencoes(data.items);
      const list = normalized.normalizadas;
      pmpMaintenanceCache.set(projectId, list);
      return list;
    }
  } catch (error) {
    // noop
  }
  pmpMaintenanceCache.set(projectId, []);
  return [];
}

function buildPmpImportItems(projectId, items) {
  const groups = new Map();
  items.forEach((item) => {
    if (!item || item.projectId !== projectId) {
      return;
    }
    const template = item.templateId ? getTemplateById(item.templateId) : null;
    const nomeBase = template && template.nome
      ? template.nome
      : item.titulo || item.nome || item.descricao || "-";
    const key = item.templateId || `${normalizeSearchValue(nomeBase)}|${item.equipamentoId || ""}`;
    if (!groups.has(key)) {
      groups.set(key, {
        id: key,
        projectId,
        templateId: item.templateId || "",
        nome: nomeBase,
        codigo: getMaintenanceCodigo(item),
        equipamentoId: item.equipamentoId || "",
        frequencia: mapTemplateFrequencyToPmp(template),
        status: template && template.ativo === false ? "Inativo" : "Ativo",
        totalDuracao: 0,
        duracaoCount: 0,
        totalTecnicos: 0,
        tecnicosCount: 0,
        ultimaExecucao: null,
      });
    }
    const entry = groups.get(key);
    const duracao = getMaintenanceDurationMinutes(item);
    if (duracao > 0) {
      entry.totalDuracao += duracao;
      entry.duracaoCount += 1;
    }
    const tecnicos = getMaintenanceParticipantsCount(item);
    if (tecnicos > 0) {
      entry.totalTecnicos += tecnicos;
      entry.tecnicosCount += 1;
    }
    const execDate = getItemConclusaoDate(item) || getItemFimExecucaoDate(item);
    if (execDate && (!entry.ultimaExecucao || execDate > entry.ultimaExecucao)) {
      entry.ultimaExecucao = execDate;
    }
  });
  return Array.from(groups.values())
    .map((entry) => ({
      id: entry.id,
      projectId: entry.projectId,
      templateId: entry.templateId,
      nome: entry.nome,
      codigo: entry.codigo,
      equipamentoId: entry.equipamentoId,
      frequencia: entry.frequencia,
      tecnicosEstimados: entry.tecnicosCount
        ? Math.round(entry.totalTecnicos / entry.tecnicosCount)
        : 0,
      duracaoMinutos: entry.duracaoCount
        ? Math.round(entry.totalDuracao / entry.duracaoCount)
        : 0,
      ultimaExecucao: entry.ultimaExecucao,
      status: entry.status,
    }))
    .sort((a, b) => (a.nome || "").localeCompare(b.nome || ""));
}

function buildAutoExecutionMap(activities, periods, viewMode, year, monthIndex) {
  const auto = new Map();
  if (!activities.length) {
    return auto;
  }
  const periodMap = new Map(periods.map((period) => [period.key, period]));
  const byProject = new Map();
  activities.forEach((activity) => {
    if (!activity) {
      return;
    }
    const list = byProject.get(activity.projectId) || [];
    list.push(activity);
    byProject.set(activity.projectId, list);
  });
  byProject.forEach((projectActivities, projectId) => {
    const items = getPmpMaintenanceList(projectId);
    if (!items.length) {
      return;
    }
    const scheduleMeta = new Map();
    projectActivities.forEach((activity) => {
      const scheduledKeys = getScheduledPeriodKeys(activity, year, viewMode, periods, monthIndex);
      const dueDates = new Map();
      scheduledKeys.forEach((key) => {
        const period = periodMap.get(key);
        if (period) {
          dueDates.set(key, getDueDateForPeriod(activity, period, viewMode));
        }
      });
      scheduleMeta.set(activity.id, { scheduledKeys, dueDates });
    });
    items.forEach((item) => {
      if (!item || item.status !== "concluida") {
        return;
      }
      const execDate = getItemConclusaoDate(item) || getItemFimExecucaoDate(item);
      if (!execDate || execDate.getFullYear() !== year) {
        return;
      }
      projectActivities.forEach((activity) => {
        if (!activity || activity.projectId !== projectId) {
          return;
        }
        const equipMatch =
          activity.equipamentoId &&
          item.equipamentoId &&
          activity.equipamentoId === item.equipamentoId;
        const tituloBase = normalizeSearchValue(
          item.titulo || item.nome || item.descricao || ""
        );
        const nomeMatch = activity.nome
          ? tituloBase.includes(normalizeSearchValue(activity.nome))
          : false;
        const codigoMatch = activity.codigo
          ? tituloBase.includes(normalizeSearchValue(activity.codigo))
          : false;
        if (!equipMatch && !nomeMatch && !codigoMatch) {
          return;
        }
        const meta = scheduleMeta.get(activity.id);
        if (!meta) {
          return;
        }
        let bestKey = "";
        let bestDiff = Infinity;
        meta.scheduledKeys.forEach((key) => {
          const dueDate = meta.dueDates.get(key);
          const diff = dueDate ? getPmpDiffDays(execDate, dueDate) : null;
          if (diff === null) {
            return;
          }
          const diffAbs = Math.abs(diff);
          if (diffAbs <= PMP_TOLERANCE_DAYS && diffAbs < bestDiff) {
            bestDiff = diffAbs;
            bestKey = key;
          }
        });
        if (!bestKey) {
          const periodKey = getPeriodKeyForDate(viewMode, execDate, year, monthIndex);
          if (periodKey && meta.scheduledKeys.has(periodKey)) {
            bestKey = periodKey;
          }
        }
        if (!bestKey) {
          return;
        }
        if (auto.get(activity.id)?.get(bestKey)) {
          return;
        }
        const executorId = getExecutadoPorId(item) || item.executadaPor || item.doneBy || "";
        setExecutionMap(auto, activity.id, bestKey, {
          executedAt: execDate,
          executorId,
          source: "auto",
          status: "concluida",
          manutencaoId: item.id,
          osReferencia: getMaintenanceOsReferencia(item),
        });
      });
    });
  });
  return auto;
}

function getDueDateForPeriod(activity, period, viewMode) {
  if (viewMode === "day") {
    return period.start;
  }
  if (viewMode === "month") {
    return getScheduledDateForMonth(activity, period.start.getFullYear(), period.start.getMonth());
  }
  const startDate = getActivityStartDate(activity, period.start.getFullYear());
  const startDow = startDate.getDay();
  const offset = (startDow + 6) % 7;
  return addDays(period.start, offset);
}

function getEquipamentoNomeById(projectId, equipamentoId) {
  if (!equipamentoId) {
    return "-";
  }
  const cached = pmpEquipamentosCache.get(projectId) || [];
  const match = cached.find((item) => item.id === equipamentoId);
  if (match) {
    return `${match.tag ? `${match.tag} - ` : ""}${match.nome || ""}`.trim();
  }
  if (projectId === activeProjectId && Array.isArray(projectEquipamentos)) {
    const local = projectEquipamentos.find((item) => item.id === equipamentoId);
    if (local) {
      return `${local.tag ? `${local.tag} - ` : ""}${local.nome || ""}`.trim();
    }
  }
  return equipamentoId;
}

function getMaintenanceEquipamentoLabel(item) {
  if (!item) {
    return "-";
  }
  const projectId = item.projectId || activeProjectId;
  if (item.equipamento && typeof item.equipamento === "object") {
    const tag = item.equipamento.tag || "";
    const nome = item.equipamento.nome || item.equipamento.name || "";
    if (tag || nome) {
      return `${tag ? `${tag} - ` : ""}${nome}`.trim() || "-";
    }
    if (item.equipamento.id) {
      return getEquipamentoNomeById(projectId, item.equipamento.id);
    }
  }
  if (typeof item.equipamento === "string" && item.equipamento.trim()) {
    return item.equipamento.trim();
  }
  if (item.equipamentoId) {
    return getEquipamentoNomeById(projectId, item.equipamentoId);
  }
  return "-";
}

async function ensurePmpEquipamentos(projectId) {
  if (!projectId) {
    return [];
  }
  if (pmpEquipamentosCache.has(projectId)) {
    return pmpEquipamentosCache.get(projectId);
  }
  try {
    const data = await apiProjetosEquipamentosList(projectId);
    const list = Array.isArray(data.equipamentos) ? data.equipamentos : [];
    pmpEquipamentosCache.set(projectId, list);
    return list;
  } catch (error) {
    pmpEquipamentosCache.set(projectId, []);
    return [];
  }
}

function renderPmpYearOptions() {
  if (!pmpAno) {
    return;
  }
  const current = new Date().getFullYear();
  const years = new Set([current, current + 1, current - 1]);
  pmpActivities.forEach((activity) => {
    if (activity && Number.isFinite(Number(activity.ano))) {
      years.add(Number(activity.ano));
    }
  });
  const sorted = Array.from(years).sort((a, b) => a - b);
  const selected = Number(pmpAno.value) || current;
  pmpAno.innerHTML = "";
  sorted.forEach((year) => {
    const option = document.createElement("option");
    option.value = String(year);
    option.textContent = String(year);
    pmpAno.append(option);
  });
  pmpAno.value = sorted.includes(selected) ? String(selected) : String(current);
}

function renderPmpMonthOptions() {
  if (!pmpMes) {
    return;
  }
  const current = new Date().getMonth();
  const selected = Number(pmpMes.value);
  pmpMes.innerHTML = "";
  PMP_MONTH_LABELS.forEach((label, idx) => {
    const option = document.createElement("option");
    option.value = String(idx);
    option.textContent = label;
    pmpMes.append(option);
  });
  const fallback = Number.isFinite(selected) ? selected : current;
  pmpMes.value = PMP_MONTH_LABELS[fallback] ? String(fallback) : String(current);
}

function renderPmpMesesOptions() {
  if (!pmpMesesWrap) {
    return;
  }
  if (pmpMesesWrap.childElementCount) {
    return;
  }
  pmpMesesWrap.innerHTML = "";
  PMP_MONTH_LABELS.forEach((label, idx) => {
    const id = `pmpMes-${idx}`;
    const wrapper = document.createElement("label");
    wrapper.className = "pmp-month";
    wrapper.setAttribute("for", id);
    const input = document.createElement("input");
    input.type = "checkbox";
    input.id = id;
    input.value = String(idx);
    input.dataset.pmpMonth = String(idx);
    input.checked = true;
    const span = document.createElement("span");
    span.textContent = label;
    wrapper.append(input, span);
    pmpMesesWrap.append(wrapper);
  });
}

function getPmpSelectedMeses() {
  if (!pmpMesesWrap) {
    return [];
  }
  const inputs = Array.from(pmpMesesWrap.querySelectorAll("input[data-pmp-month]"));
  const selecionados = inputs
    .filter((input) => input.checked)
    .map((input) => Number(input.value))
    .filter((value) => Number.isFinite(value));
  return selecionados;
}

function setPmpSelectedMeses(meses) {
  if (!pmpMesesWrap) {
    return;
  }
  const isArray = Array.isArray(meses);
  const normalized = isArray
    ? meses.map((value) => Number(value)).filter((value) => value >= 0 && value <= 11)
    : null;
  const inputs = Array.from(pmpMesesWrap.querySelectorAll("input[data-pmp-month]"));
  if (!inputs.length) {
    return;
  }
  const allowAll = normalized === null;
  inputs.forEach((input) => {
    const value = Number(input.value);
    if (allowAll) {
      input.checked = true;
    } else {
      input.checked = normalized.includes(value);
    }
  });
}

function getActivityAllowedMonths(activity) {
  const mesesRaw = Array.isArray(activity && activity.meses)
    ? activity.meses
    : null;
  if (!mesesRaw) {
    return null;
  }
  const meses = mesesRaw
    ? activity.meses.map((value) => Number(value)).filter((value) => value >= 0 && value <= 11)
    : [];
  if (!meses.length) {
    return new Set();
  }
  return new Set(meses);
}

function isMonthAllowed(activity, monthIndex) {
  const allowed = getActivityAllowedMonths(activity);
  if (!allowed) {
    return true;
  }
  if (!allowed.size) {
    return false;
  }
  return allowed.has(monthIndex);
}

function renderPmpProjetoOptions() {
  if (!pmpProjeto || !pmpFiltroProjeto) {
    return;
  }
  const activeValue = activeProjectId || "";
  const formValue = pmpProjeto.value || "";
  const filtroValue = pmpFiltroProjeto.value || "";
  pmpProjeto.innerHTML = "";
  const optBlank = document.createElement("option");
  optBlank.value = "";
  optBlank.textContent = "Selecione";
  pmpProjeto.append(optBlank);
  pmpFiltroProjeto.innerHTML = "";
  const optAll = document.createElement("option");
  optAll.value = "";
  optAll.textContent = "Todos";
  pmpFiltroProjeto.append(optAll);
  availableProjects.forEach((project) => {
    const label = getProjectLabel(project);
    const optionForm = document.createElement("option");
    optionForm.value = project.id;
    optionForm.textContent = label;
    pmpProjeto.append(optionForm);
    const optionFilter = document.createElement("option");
    optionFilter.value = project.id;
    optionFilter.textContent = label;
    pmpFiltroProjeto.append(optionFilter);
  });
  pmpProjeto.value = formValue || activeValue || "";
  pmpFiltroProjeto.value = activeValue || filtroValue || "";
}

async function renderPmpEquipamentoOptions(targetProjectId) {
  if (!pmpEquipamento || !pmpFiltroEquipamento) {
    return;
  }
  const projectId = targetProjectId || activeProjectId || "";
  const equipamentos = projectId ? await ensurePmpEquipamentos(projectId) : [];
  const formValue = pmpEquipamento.value || "";
  pmpEquipamento.innerHTML = "";
  const optBlank = document.createElement("option");
  optBlank.value = "";
  optBlank.textContent = "Selecione";
  pmpEquipamento.append(optBlank);
  equipamentos.forEach((equip) => {
    const option = document.createElement("option");
    option.value = equip.id;
    option.textContent = `${equip.tag ? `${equip.tag} - ` : ""}${equip.nome || ""}`.trim();
    pmpEquipamento.append(option);
  });
  pmpEquipamento.value = equipamentos.some((item) => item.id === formValue) ? formValue : "";

  const filtroValue = pmpFiltroEquipamento.value || "";
  pmpFiltroEquipamento.innerHTML = "";
  const filtroAll = document.createElement("option");
  filtroAll.value = "";
  filtroAll.textContent = "Todos";
  pmpFiltroEquipamento.append(filtroAll);
  equipamentos.forEach((equip) => {
    const option = document.createElement("option");
    option.value = equip.id;
    option.textContent = `${equip.tag ? `${equip.tag} - ` : ""}${equip.nome || ""}`.trim();
    pmpFiltroEquipamento.append(option);
  });
  pmpFiltroEquipamento.value = equipamentos.some((item) => item.id === filtroValue) ? filtroValue : "";
}

function renderPmpResponsavelOptions(targetProjectId) {
  if (!pmpResponsavel || !pmpFiltroResponsavel) {
    return;
  }
  let lista = Array.isArray(users) ? users.slice() : [];
  if (targetProjectId && targetProjectId === activeProjectId) {
    const equipeIds = getActiveProjectEquipeIds();
    if (equipeIds.size) {
      lista = lista.filter((user) => equipeIds.has(user.id));
    }
  }
  const formValue = pmpResponsavel.value || "";
  const filtroValue = pmpFiltroResponsavel.value || "";
  pmpResponsavel.innerHTML = "";
  const optBlank = document.createElement("option");
  optBlank.value = "";
  optBlank.textContent = "Selecione";
  pmpResponsavel.append(optBlank);
  pmpFiltroResponsavel.innerHTML = "";
  const optAll = document.createElement("option");
  optAll.value = "";
  optAll.textContent = "Todos";
  pmpFiltroResponsavel.append(optAll);
  lista.forEach((user) => {
    const label = user.name || user.username || user.matricula || "-";
    const optionForm = document.createElement("option");
    optionForm.value = user.id;
    optionForm.textContent = label;
    pmpResponsavel.append(optionForm);
    const optionFilter = document.createElement("option");
    optionFilter.value = user.id;
    optionFilter.textContent = label;
    pmpFiltroResponsavel.append(optionFilter);
  });
  pmpResponsavel.value = lista.some((item) => item.id === formValue) ? formValue : "";
  pmpFiltroResponsavel.value = lista.some((item) => item.id === filtroValue) ? filtroValue : "";
}

function getPmpProjectHorasDisponiveis(projectId) {
  if (!projectId) {
    return 0;
  }
  const project = availableProjects.find((item) => item.id === projectId);
  const value = project && Number.isFinite(Number(project.pmpHorasDisponiveis))
    ? Number(project.pmpHorasDisponiveis)
    : 40;
  return Math.max(0, value);
}

function syncPmpHorasDisponiveisInput(projectId) {
  if (!pmpHorasDisponiveis) {
    return;
  }
  if (document.activeElement === pmpHorasDisponiveis) {
    return;
  }
  const resolved = projectId || activeProjectId || "";
  if (!resolved) {
    return;
  }
  const value = getPmpProjectHorasDisponiveis(resolved);
  pmpHorasDisponiveis.value = String(value);
}

let pmpHorasSaveTimer = null;
function schedulePmpHorasDisponiveisSave() {
  if (!pmpHorasDisponiveis) {
    return;
  }
  if (!currentUser || !canManageProjetos(currentUser)) {
    return;
  }
  const projectId = (pmpFiltroProjeto && pmpFiltroProjeto.value) || activeProjectId || "";
  if (!projectId) {
    return;
  }
  if (pmpHorasSaveTimer) {
    clearTimeout(pmpHorasSaveTimer);
  }
  pmpHorasSaveTimer = setTimeout(async () => {
    const valor = Number(pmpHorasDisponiveis.value || 0);
    if (!Number.isFinite(valor)) {
      return;
    }
    try {
      const data = await apiProjetosUpdate(projectId, { pmpHorasDisponiveis: Math.max(0, valor) });
      if (data && data.project) {
        availableProjects = availableProjects.map((item) =>
          item.id === data.project.id ? data.project : item
        );
      }
    } catch (error) {
      if (pmpFormMensagem) {
        pmpFormMensagem.textContent = "Erro ao salvar horas disponiveis do PMP.";
      }
    }
  }, 500);
}

function updatePmpImportButton() {
  if (!pmpImportBtn) {
    return;
  }
  const projectId = (pmpFiltroProjeto && pmpFiltroProjeto.value) || activeProjectId || "";
  const canManage = Boolean(currentUser && canManagePmpActivities(currentUser));
  pmpImportBtn.disabled = !canManage || !projectId;
  pmpImportBtn.hidden = !canManage;
}

function getPmpFilteredActivities() {
  const year = getPmpYearValue();
  const viewMode = getPmpViewMode();
  const monthIndex = getPmpMonthValue();
  const periods = getPmpPeriods(viewMode, year, monthIndex);
  const today = startOfDay(new Date());
  const termo = normalizeSearchValue(pmpBusca ? pmpBusca.value : "");
  const filtroProjeto = (pmpFiltroProjeto && pmpFiltroProjeto.value) || activeProjectId || "";
  const filtroFrequencia = pmpFiltroFrequencia ? pmpFiltroFrequencia.value : "";
  const filtroEquipamento = pmpFiltroEquipamento ? pmpFiltroEquipamento.value : "";
  const filtroResponsavel = pmpFiltroResponsavel ? pmpFiltroResponsavel.value : "";
  const filtroOrigem = pmpFiltroOrigem ? pmpFiltroOrigem.value : "";
  const filtroStatus = pmpFiltroStatus ? pmpFiltroStatus.value : "";
  const manualMap = getExecutionsByActivity();
  const autoMap = buildAutoExecutionMap(pmpActivities, periods, viewMode, year, monthIndex);
  return pmpActivities.filter((activity) => {
    if (filtroProjeto && activity.projectId !== filtroProjeto) {
      return false;
    }
    if (filtroFrequencia && activity.frequencia !== filtroFrequencia) {
      return false;
    }
    if (filtroEquipamento && activity.equipamentoId !== filtroEquipamento) {
      return false;
    }
    if (filtroResponsavel && activity.responsavelId !== filtroResponsavel) {
      return false;
    }
    if (filtroOrigem && (activity.origem || "manual") !== filtroOrigem) {
      return false;
    }
    const activityYear = activity.ano ? Number(activity.ano) : year;
    if (activityYear !== year) {
      return false;
    }
    if (termo) {
      const texto = normalizeSearchValue(
        `${activity.nome} ${activity.codigo} ${activity.descricao}`
      );
      if (!texto.includes(termo)) {
        return false;
      }
    }
    if (filtroStatus) {
      const targetStatus = PMP_STATUS_FILTER_MAP[filtroStatus] || "";
      const scheduledKeys = getScheduledPeriodKeys(activity, year, viewMode, periods, monthIndex);
      const anyMatch = periods.some((period) => {
        const periodKey = period.key;
        const manualEntry = manualMap.get(activity.id)
          ? manualMap.get(activity.id).get(periodKey)
          : null;
        const isScheduled = scheduledKeys.has(periodKey) || Boolean(manualEntry);
        if (!isScheduled) {
          return false;
        }
        const statusInfo = getPmpStatusForPeriod(
          activity,
          period,
          periodKey,
          viewMode,
          manualMap,
          autoMap,
          today,
          isScheduled
        );
        return statusInfo.status === targetStatus;
      });
      if (!anyMatch) {
        return false;
      }
    }
    return true;
  });
}

function resetPmpForm() {
  renderPmpMesesOptions();
  if (pmpFormId) {
    pmpFormId.value = "";
  }
  if (pmpFormTitle) {
    pmpFormTitle.textContent = "Cadastrar atividade PMP";
  }
  if (pmpNome) {
    pmpNome.value = "";
  }
  if (pmpCodigo) {
    pmpCodigo.value = "";
  }
  if (pmpTipo) {
    pmpTipo.value = "";
  }
  if (pmpFrequencia) {
    pmpFrequencia.value = "";
  }
  if (pmpInicio) {
    pmpInicio.value = "";
  }
  if (pmpOnlyWeekdays) {
    pmpOnlyWeekdays.checked = false;
  }
  if (pmpTecnicos) {
    pmpTecnicos.value = "0";
  }
  if (pmpDuracao) {
    pmpDuracao.value = "";
  }
  if (pmpResponsavel) {
    pmpResponsavel.value = "";
  }
  if (pmpDescricao) {
    pmpDescricao.value = "";
  }
  if (pmpObservacoes) {
    pmpObservacoes.value = "";
  }
  if (pmpProcedimentos) {
    pmpProcedimentos.value = "";
  }
  if (pmpChecklistItem) {
    pmpChecklistItem.value = "";
  }
  if (pmpChecklistLink) {
    pmpChecklistLink.value = "";
  }
  if (pmpFormMensagem) {
    pmpFormMensagem.textContent = "";
  }
  pmpChecklistItems = [];
  pmpFormOrigem = "manual";
  setPmpProcedimentoDoc(null);
  setPmpSelectedMeses(null);
  renderPmpChecklist();
}

function preencherPmpForm(activity) {
  if (!activity) {
    return;
  }
  renderPmpMesesOptions();
  if (pmpFormId) {
    pmpFormId.value = activity.id || "";
  }
  if (pmpFormTitle) {
    pmpFormTitle.textContent = "Editar atividade PMP";
  }
  if (pmpNome) {
    pmpNome.value = activity.nome || "";
  }
  if (pmpCodigo) {
    pmpCodigo.value = activity.codigo || "";
  }
  if (pmpTipo) {
    pmpTipo.value = activity.tipoManutencao || activity.tipo || "";
  }
  if (pmpProjeto) {
    pmpProjeto.value = activity.projectId || "";
  }
  if (pmpFrequencia) {
    pmpFrequencia.value = activity.frequencia || "";
  }
  if (pmpInicio) {
    pmpInicio.value = activity.inicio || "";
  }
  if (pmpOnlyWeekdays) {
    pmpOnlyWeekdays.checked = Boolean(activity.onlyWeekdays);
  }
  if (pmpTecnicos) {
    pmpTecnicos.value = Number(activity.tecnicosEstimados || 0);
  }
  if (pmpDuracao) {
    pmpDuracao.value = activity.duracaoMinutos ? formatDuracaoMin(activity.duracaoMinutos) : "";
  }
  if (pmpResponsavel) {
    pmpResponsavel.value = activity.responsavelId || "";
  }
  if (pmpDescricao) {
    pmpDescricao.value = activity.descricao || "";
  }
  if (pmpObservacoes) {
    pmpObservacoes.value = activity.observacoes || "";
  }
  if (pmpProcedimentos) {
    pmpProcedimentos.value = activity.procedimentos || "";
  }
  setPmpProcedimentoDoc(activity.procedimentoDoc || null);
  pmpChecklistItems = normalizePmpChecklistItems(activity.checklist || []);
  pmpFormOrigem = activity.origem || "manual";
  if (activity && Object.prototype.hasOwnProperty.call(activity, "meses")) {
    setPmpSelectedMeses(activity.meses);
  } else {
    setPmpSelectedMeses(null);
  }
  renderPmpChecklist();
  renderPmpEquipamentoOptions(activity.projectId);
  if (pmpEquipamento) {
    pmpEquipamento.value = activity.equipamentoId || "";
  }
}

async function salvarPmpActivity(event) {
  if (event) {
    event.preventDefault();
  }
  if (!currentUser || !canManagePmpActivities(currentUser)) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Sem permissão para gerenciar PMP.";
    }
    return;
  }
  const nome = pmpNome ? pmpNome.value.trim() : "";
  const projectId = pmpProjeto ? pmpProjeto.value : "";
  const frequencia = pmpFrequencia ? pmpFrequencia.value : "";
  if (!nome || !projectId || !frequencia) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Preencha nome, projeto e frequencia.";
    }
    return;
  }
  const payload = {
    nome,
    codigo: pmpCodigo ? pmpCodigo.value.trim() : "",
    tipoManutencao: pmpTipo ? pmpTipo.value : "",
    projectId,
    equipamentoId: pmpEquipamento ? pmpEquipamento.value : "",
    frequencia,
    inicio: pmpInicio ? pmpInicio.value : "",
    onlyWeekdays: pmpOnlyWeekdays ? Boolean(pmpOnlyWeekdays.checked) : false,
    meses: getPmpSelectedMeses(),
    tecnicosEstimados: pmpTecnicos ? Number(pmpTecnicos.value || 0) : 0,
    duracaoMinutos: parseDurationToMinutes(pmpDuracao ? pmpDuracao.value : ""),
    responsavelId: pmpResponsavel ? pmpResponsavel.value : "",
    descricao: pmpDescricao ? pmpDescricao.value.trim() : "",
    observacoes: pmpObservacoes ? pmpObservacoes.value.trim() : "",
    procedimentos: pmpProcedimentos ? pmpProcedimentos.value.trim() : "",
    procedimentoDoc: pmpProcedimentoDoc || null,
    checklist: pmpChecklistItems.slice(),
    origem: pmpFormOrigem || "manual",
    ano: getPmpYearValue(),
  };
  const id = pmpFormId ? pmpFormId.value : "";
  try {
    if (id) {
      const data = await apiPmpActivitiesUpdate(id, payload);
      if (data && data.activity) {
        pmpActivities = pmpActivities.map((item) => (item.id === id ? data.activity : item));
      }
      if (pmpFormMensagem) {
        pmpFormMensagem.textContent = "Atividade atualizada.";
      }
    } else {
      const data = await apiPmpActivitiesCreate(payload);
      if (data && data.activity) {
        pmpActivities = pmpActivities.concat(data.activity);
      }
      if (pmpFormMensagem) {
        pmpFormMensagem.textContent = "Atividade cadastrada.";
      }
    }
    resetPmpForm();
    renderTudo();
  } catch (error) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Erro ao salvar atividade.";
    }
  }
}

async function removerPmpActivity(activityId) {
  if (!activityId) {
    return;
  }
  if (!currentUser || !hasGranularPermission(currentUser, "gerenciarPMP")) {
    return;
  }
  const target = pmpActivities.find((item) => item.id === activityId);
  const confirmacao = window.confirm(
    `Excluir atividade PMP \"${target ? target.nome : activityId}\"?`
  );
  if (!confirmacao) {
    return;
  }
  try {
    await apiPmpActivitiesDelete(activityId);
    pmpActivities = pmpActivities.filter((item) => item.id !== activityId);
    pmpExecutions = pmpExecutions.filter((exec) => exec.activityId !== activityId);
    renderTudo();
  } catch (error) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Erro ao remover atividade.";
    }
  }
}

function renderPmpModule() {
  if (!pmpGridBody || !pmpGridHead) {
    return;
  }
  const canManagePmp = Boolean(currentUser && canManagePmpActivities(currentUser));
  const canUploadProcedimento = Boolean(currentUser && canUploadPmpProcedimento(currentUser));
  if (pmpForm) {
    setFormDisabled(pmpForm, !canManagePmp);
    pmpForm.hidden = !canManagePmp;
  }
  if (pmpProcedimentoUpload) {
    pmpProcedimentoUpload.hidden = !canUploadProcedimento;
    pmpProcedimentoUpload.disabled = !canUploadProcedimento;
  }
  if (pmpProcedimentoFile) {
    pmpProcedimentoFile.disabled = !canUploadProcedimento;
  }
  if (pmpProcedimentoRemove) {
    pmpProcedimentoRemove.hidden = !canUploadProcedimento || !pmpProcedimentoDoc;
    pmpProcedimentoRemove.disabled = !canUploadProcedimento || !pmpProcedimentoDoc;
  }
  if (pmpDuplicarPlano) {
    pmpDuplicarPlano.disabled = !canManagePmp;
    pmpDuplicarPlano.hidden = !canManagePmp;
  }
  if (pmpExportPdf) {
    pmpExportPdf.disabled = !canManagePmp;
  }
  if (pmpExportExcel) {
    pmpExportExcel.disabled = !canManagePmp;
  }
  if (pmpHorasDisponiveis) {
    pmpHorasDisponiveis.disabled = !(currentUser && canManageProjetos(currentUser));
  }
  updatePmpImportButton();
  renderPmpYearOptions();
  renderPmpProjetoOptions();
  renderPmpMonthOptions();
  renderPmpMesesOptions();
  const year = getPmpYearValue();
  const viewMode = getPmpViewMode();
  const monthIndex = getPmpMonthValue();
  if (pmpMesField) {
    pmpMesField.hidden = viewMode !== "day";
  }
  const filtroProjeto = (pmpFiltroProjeto && pmpFiltroProjeto.value) || activeProjectId || "";
  syncPmpHorasDisponiveisInput(filtroProjeto || activeProjectId);
  renderPmpEquipamentoOptions(filtroProjeto || activeProjectId);
  renderPmpResponsavelOptions(filtroProjeto || activeProjectId);
  const filtrados = getPmpFilteredActivities();

  const pendingMaintenance = new Set();
  filtrados.forEach((activity) => {
    if (activity && activity.projectId) {
      pendingMaintenance.add(activity.projectId);
    }
  });
  const pendingLoads = [];
  pendingMaintenance.forEach((projectId) => {
    if (!pmpMaintenanceCache.has(projectId)) {
      pendingLoads.push(ensurePmpMaintenanceCache(projectId));
    }
  });
  if (pendingLoads.length) {
    Promise.all(pendingLoads).then(() => {
      renderPmpModule();
    });
  }

  const periods = getPmpPeriods(viewMode, year, monthIndex);
  const scheduledKeysMap = new Map();
  const manualMap = getExecutionsByActivity();
  const autoMap = buildAutoExecutionMap(filtrados, periods, viewMode, year, monthIndex);
  const today = startOfDay(new Date());
  pmpLastSnapshot = {
    year,
    viewMode,
    monthIndex,
    periods,
    manualMap,
    autoMap,
    activities: filtrados,
  };

  pmpGridHead.innerHTML = "";
  const headers = [
    { label: "Atividade", className: "pmp-col-name" },
    { label: "Codigo", className: "pmp-col-code" },
    { label: "Equipamento", className: "pmp-col-equip" },
    { label: "Freq." },
    { label: "HH" },
    { label: "Tec." },
  ];
  headers.forEach((header) => {
    const th = document.createElement("th");
    th.textContent = header.label;
    if (header.className) {
      th.className = header.className;
    }
    pmpGridHead.append(th);
  });
  periods.forEach((period) => {
    const th = document.createElement("th");
    th.textContent = period.label;
    pmpGridHead.append(th);
  });

  pmpGridBody.innerHTML = "";
  let totalCells = 0;
  let onTimeCells = 0;
  let lateCells = 0;
  let missedCells = 0;
  let scheduledCells = 0;
  let cancelledCells = 0;
  let totalPlannedMinutes = 0;
  let totalPlannedCapacityMinutes = 0;
  let totalExecutedMinutes = 0;
  const statusIconMap = {
    on_time: "&#x2705;",
    scheduled: "&#x1F535;",
    missed: "&#x1F534;",
    late: "&#x26A0;&#xFE0F;",
    cancelled: "&#x1F6AB;",
    empty: "&#x2B1C;",
  };

  if (!filtrados.length) {
    if (pmpGridVazio) {
      pmpGridVazio.hidden = false;
    }
  } else if (pmpGridVazio) {
    pmpGridVazio.hidden = true;
  }

  filtrados.forEach((activity) => {
    const row = document.createElement("tr");
    const projectId = activity.projectId;
    const equipLabel = getEquipamentoNomeById(projectId, activity.equipamentoId);
    const freqLabel = getPmpFrequency(activity.frequencia)
      ? getPmpFrequency(activity.frequencia).label
      : activity.frequencia || "-";
    const duracaoLabel = activity.duracaoMinutos
      ? formatDuracaoMin(activity.duracaoMinutos)
      : "-";
    const scheduledKeys = getScheduledPeriodKeys(activity, year, viewMode, periods, monthIndex);
    scheduledKeysMap.set(activity.id, scheduledKeys);

    const nameCell = document.createElement("td");
    nameCell.className = "pmp-col-name";
    const nameWrap = document.createElement("div");
    nameWrap.className = "pmp-name";
    const nameText = document.createElement("div");
    nameText.textContent = activity.nome || "-";
    const tipoInfo = getPmpTipoInfo(activity.tipoManutencao || activity.tipo || "");
    if (tipoInfo) {
      const badge = document.createElement("span");
      badge.className = `pmp-type pmp-type--${tipoInfo.value}`;
      badge.textContent = tipoInfo.short;
      badge.title = tipoInfo.label;
      nameWrap.append(badge);
    }
    nameWrap.append(nameText);
    if (canManagePmp) {
      const actions = document.createElement("div");
      actions.className = "pmp-actions";
      const btnEdit = document.createElement("button");
      btnEdit.type = "button";
      btnEdit.className = "btn btn--ghost btn--small";
      btnEdit.dataset.pmpAction = "edit";
      btnEdit.dataset.pmpId = activity.id;
      btnEdit.textContent = "Editar";
      const btnDelete = document.createElement("button");
      btnDelete.type = "button";
      btnDelete.className = "btn btn--ghost btn--small btn--danger";
      btnDelete.dataset.pmpAction = "delete";
      btnDelete.dataset.pmpId = activity.id;
      btnDelete.textContent = "Excluir";
      actions.append(btnEdit, btnDelete);
      nameCell.append(nameWrap, actions);
    } else {
      nameCell.append(nameWrap);
    }
    if (activity.procedimentoDoc && activity.procedimentoDoc.url) {
      const procedureWrap = document.createElement("div");
      procedureWrap.className = "pmp-procedure";
      const procedureBtn = document.createElement("button");
      procedureBtn.type = "button";
      procedureBtn.className = "btn btn--ghost btn--small pmp-procedure-btn";
      procedureBtn.dataset.pmpAction = "view-procedure";
      procedureBtn.dataset.pmpId = activity.id;
      procedureBtn.textContent = "Visualizar procedimento";
      procedureBtn.title = activity.procedimentoDoc.originalName || activity.procedimentoDoc.name || "";
      procedureWrap.append(procedureBtn);
      nameCell.append(procedureWrap);
    }
    row.append(nameCell);

    const codeCell = document.createElement("td");
    codeCell.className = "pmp-col-code";
    codeCell.textContent = activity.codigo || "-";
    row.append(codeCell);

    const equipCell = document.createElement("td");
    equipCell.className = "pmp-col-equip";
    equipCell.textContent = equipLabel || "-";
    row.append(equipCell);

    const freqCell = document.createElement("td");
    freqCell.textContent = freqLabel;
    row.append(freqCell);

    const durCell = document.createElement("td");
    durCell.textContent = duracaoLabel;
    row.append(durCell);

    const techCell = document.createElement("td");
    techCell.textContent = activity.tecnicosEstimados ? String(activity.tecnicosEstimados) : "-";
    row.append(techCell);

    periods.forEach((period) => {
      const periodKey = period.key;
      const cell = document.createElement("td");
      const manualEntry = manualMap.get(activity.id)
        ? manualMap.get(activity.id).get(periodKey)
        : null;
      const isScheduled = scheduledKeys.has(periodKey) || Boolean(manualEntry);
      const duracaoBase = Number(activity.duracaoMinutos || 0);
      const tecnicosBase = Number(activity.tecnicosEstimados || 1);
      const statusInfo = getPmpStatusForPeriod(
        activity,
        period,
        periodKey,
        viewMode,
        manualMap,
        autoMap,
        today,
        isScheduled
      );
      const status = statusInfo.status;
      if (status !== "empty") {
        totalCells += 1;
        if (status === "on_time") {
          onTimeCells += 1;
        } else if (status === "late") {
          lateCells += 1;
        } else if (status === "cancelled") {
          cancelledCells += 1;
          missedCells += 1;
        } else if (status === "missed") {
          missedCells += 1;
        } else {
          scheduledCells += 1;
        }
        if (statusInfo.executedAt) {
          totalExecutedMinutes += Number(activity.duracaoMinutos || 0);
        }
        totalPlannedMinutes += duracaoBase;
        totalPlannedCapacityMinutes +=
          duracaoBase * (Number.isFinite(tecnicosBase) ? tecnicosBase : 1);
      }
      cell.className = `pmp-cell pmp-cell--${status === "empty" ? "empty" : status}`;
      const tooltipLines = [];
      if (viewMode === "day") {
        tooltipLines.push(`Data: ${formatDate(period.start)}`);
      } else {
        tooltipLines.push(`Período: ${formatDate(period.start)} - ${formatDate(period.end)}`);
      }
      if (statusInfo.dueDate && viewMode !== "day") {
        tooltipLines.push(`Data prevista: ${formatDate(statusInfo.dueDate)}`);
      }
      if (statusInfo.executedAt) {
        tooltipLines.push(`Executado em: ${formatDate(statusInfo.executedAt)}`);
        const executorId =
          statusInfo.exec && statusInfo.exec.executorId ? statusInfo.exec.executorId : "";
        if (executorId) {
          tooltipLines.push(`Executor: ${getUserLabel(executorId)}`);
        }
        if (statusInfo.exec && statusInfo.exec.osReferencia) {
          tooltipLines.push(`OS/RDO: ${statusInfo.exec.osReferencia}`);
        } else if (statusInfo.exec && statusInfo.exec.manutencaoId) {
          tooltipLines.push(`OS/RDO: ${statusInfo.exec.manutencaoId}`);
        }
      }
      tooltipLines.push(`Status: ${PMP_STATUS_LABELS[status] || status}`);
      cell.title = tooltipLines.join("\\n");
      cell.dataset.pmpCell = "true";
      cell.dataset.activityId = activity.id;
      cell.dataset.periodKey = periodKey;
      cell.dataset.status = status;
      cell.innerHTML = statusIconMap[status] || statusIconMap.scheduled;
      row.append(cell);
    });

    pmpGridBody.append(row);
  });

  const totalPercent = totalCells || 1;
  if (pmpTotalPrevistas) {
    pmpTotalPrevistas.textContent = String(totalCells);
  }
  if (pmpTotalConforme) {
    pmpTotalConforme.textContent = `${Math.round((onTimeCells / totalPercent) * 100)}%`;
  }
  if (pmpTotalAtraso) {
    pmpTotalAtraso.textContent = `${Math.round((lateCells / totalPercent) * 100)}%`;
  }
  if (pmpTotalNaoExecutadas) {
    pmpTotalNaoExecutadas.textContent = `${Math.round((missedCells / totalPercent) * 100)}%`;
  }
  if (pmpHorasPlanejadas) {
    pmpHorasPlanejadas.textContent = totalPlannedMinutes
      ? formatDuracaoMin(totalPlannedMinutes)
      : "00:00";
  }
  if (pmpHorasExecutadas) {
    pmpHorasExecutadas.textContent = totalExecutedMinutes
      ? formatDuracaoMin(totalExecutedMinutes)
      : "00:00";
  }
  if (pmpCargaSemanal) {
    const equipeCount = projectEquipe.length || 0;
    const horasPorTecnico = pmpHorasDisponiveis ? Number(pmpHorasDisponiveis.value || 0) : 0;
    const disponivel = equipeCount * horasPorTecnico;
    const totalWeeks = viewMode === "week" ? periods.length : 52;
    const previstoHoras = totalWeeks
      ? Math.round((totalPlannedCapacityMinutes / totalWeeks) / 60)
      : 0;
    pmpCargaSemanal.textContent = `${previstoHoras}h / ${disponivel}h`;
    const ratio = disponivel > 0 ? previstoHoras / disponivel : 0;
    if (pmpCargaBar) {
      const percent = Math.min(160, Math.round(ratio * 100));
      pmpCargaBar.style.width = `${percent}%`;
      pmpCargaBar.classList.toggle("is-warning", ratio > 1);
    }
    if (pmpCargaBarHint) {
      pmpCargaBarHint.textContent = `${Math.round(ratio * 100)}% utilizado`;
    }
  }
}

function closePmpImportModal() {
  if (modalPmpImport) {
    modalPmpImport.hidden = true;
  }
}

function updatePmpImportConfirmState() {
  if (pmpImportConfirm) {
    pmpImportConfirm.disabled = pmpImportSelection.size === 0;
    pmpImportConfirm.textContent =
      pmpImportSelection.size > 0
        ? `Importar (${pmpImportSelection.size})`
        : "Importar selecionadas";
  }
}

function renderPmpImportList() {
  if (!pmpImportList) {
    return;
  }
  const term = normalizeSearchValue(pmpImportSearch ? pmpImportSearch.value : "");
  pmpImportList.innerHTML = "";
  const items = pmpImportItems.filter((item) => {
    if (!term) {
      return true;
    }
    const equipamento = getEquipamentoNomeById(item.projectId, item.equipamentoId);
    const text = normalizeSearchValue(
      `${item.nome || ""} ${item.codigo || ""} ${equipamento || ""}`
    );
    return text.includes(term);
  });
  items.forEach((item) => {
    const tr = document.createElement("tr");
    const tdCheck = document.createElement("td");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = pmpImportSelection.has(item.id);
    checkbox.addEventListener("change", () => {
      if (checkbox.checked) {
        pmpImportSelection.add(item.id);
      } else {
        pmpImportSelection.delete(item.id);
      }
      updatePmpImportConfirmState();
    });
    tdCheck.append(checkbox);
    tr.append(tdCheck);

    const tdNome = document.createElement("td");
    tdNome.textContent = item.nome || "-";
    tr.append(tdNome);

    const tdCodigo = document.createElement("td");
    tdCodigo.textContent = item.codigo || "-";
    tr.append(tdCodigo);

    const tdEquip = document.createElement("td");
    tdEquip.textContent = getEquipamentoNomeById(item.projectId, item.equipamentoId) || "-";
    tr.append(tdEquip);

    const tdFreq = document.createElement("td");
    tdFreq.textContent = item.frequencia
      ? (getPmpFrequency(item.frequencia) || { label: item.frequencia }).label
      : "-";
    tr.append(tdFreq);

    const tdTec = document.createElement("td");
    tdTec.textContent = item.tecnicosEstimados ? String(item.tecnicosEstimados) : "-";
    tr.append(tdTec);

    const tdDur = document.createElement("td");
    tdDur.textContent = item.duracaoMinutos ? formatDuracaoMin(item.duracaoMinutos) : "-";
    tr.append(tdDur);

    const tdUltima = document.createElement("td");
    tdUltima.textContent = item.ultimaExecucao ? formatDate(item.ultimaExecucao) : "-";
    tr.append(tdUltima);

    const tdStatus = document.createElement("td");
    tdStatus.textContent = item.status || "-";
    tr.append(tdStatus);

    pmpImportList.append(tr);
  });
  if (pmpImportEmpty) {
    pmpImportEmpty.hidden = items.length > 0;
  }
  updatePmpImportConfirmState();
}

async function openPmpImportModal() {
  if (!modalPmpImport || !pmpFiltroProjeto) {
    return;
  }
  const projectId = pmpFiltroProjeto.value;
  if (!projectId) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Selecione um projeto para importar manutenções.";
    }
    return;
  }
  if (!currentUser || !hasGranularPermission(currentUser, "gerenciarPMP")) {
    return;
  }
  if (pmpImportSearch) {
    pmpImportSearch.value = "";
  }
  pmpImportSelection = new Set();
  modalPmpImport.hidden = false;
  await ensurePmpEquipamentos(projectId);
  const items = await ensurePmpMaintenanceCache(projectId);
  pmpImportItems = buildPmpImportItems(projectId, items);
  renderPmpImportList();
}

async function confirmPmpImport() {
  if (!pmpFiltroProjeto) {
    return;
  }
  const projectId = pmpFiltroProjeto.value;
  if (!projectId) {
    return;
  }
  const selecionados = pmpImportItems.filter((item) => pmpImportSelection.has(item.id));
  if (!selecionados.length) {
    return;
  }
  if (pmpImportConfirm) {
    pmpImportConfirm.disabled = true;
  }
  const ano = getPmpYearValue();
  const inicioPadrao = formatDateISO(new Date());
  let fallbackFreq = false;
  const created = [];
  for (const item of selecionados) {
    const frequencia = item.frequencia || "mensal";
    if (!item.frequencia) {
      fallbackFreq = true;
    }
    try {
      const payload = {
        nome: item.nome || "Atividade importada",
        codigo: item.codigo || "",
        projectId,
        equipamentoId: item.equipamentoId || "",
        frequencia,
        inicio: inicioPadrao,
        meses: [],
        tecnicosEstimados: item.tecnicosEstimados || 0,
        duracaoMinutos: item.duracaoMinutos || 0,
        responsavelId: "",
        descricao: "",
        observacoes: "Importado do OS/RDO",
        procedimentos: "",
        checklist: [],
        tipoManutencao: "",
        origem: "importado",
        ano,
      };
      const data = await apiPmpActivitiesCreate(payload);
      if (data && data.activity) {
        created.push(data.activity);
      }
    } catch (error) {
      // ignore to continue others
    }
  }
  if (created.length) {
    pmpActivities = pmpActivities.concat(created);
    preencherPmpForm(created[created.length - 1]);
    renderTudo();
  }
  if (pmpFormMensagem) {
    pmpFormMensagem.textContent = fallbackFreq
      ? "Importação concluída. Revise a frequência das atividades importadas."
      : "Importação concluída.";
  }
  closePmpImportModal();
}

function closePmpCellModal() {
  if (modalPmpCell) {
    modalPmpCell.hidden = true;
  }
  pmpCellContext = null;
}

function renderPmpCellList(target, items, emptyLabel) {
  if (!target) {
    return;
  }
  target.innerHTML = "";
  if (!items.length) {
    const li = document.createElement("li");
    li.textContent = emptyLabel || "-";
    target.append(li);
    return;
  }
  items.forEach((item) => {
    const li = document.createElement("li");
    li.textContent = item;
    target.append(li);
  });
}

function formatPmpTextList(list) {
  if (!Array.isArray(list) || !list.length) {
    return "";
  }
  return list.map((item) => String(item || "").trim()).filter(Boolean).join("\n");
}

function parsePmpTextList(text) {
  return String(text || "")
    .split(/\n+/g)
    .map((item) => item.trim())
    .filter(Boolean);
}

function normalizePmpProcedimentoDoc(doc) {
  if (!doc || typeof doc !== "object") {
    return null;
  }
  const url = resolvePublicUrl(String(doc.url || doc.dataUrl || "").trim());
  if (!url) {
    return null;
  }
  const name = String(doc.originalName || doc.name || "Procedimento.pdf").trim();
  return {
    id: doc.id ? String(doc.id) : "",
    url,
    name,
    originalName: name,
    mime: doc.mime ? String(doc.mime) : "application/pdf",
  };
}

function setPmpProcedimentoDoc(doc) {
  pmpProcedimentoDoc = normalizePmpProcedimentoDoc(doc);
  if (pmpProcedimentoName) {
    pmpProcedimentoName.textContent = pmpProcedimentoDoc ? pmpProcedimentoDoc.name : "Nenhum arquivo";
  }
  if (pmpProcedimentoView) {
    pmpProcedimentoView.hidden = !(pmpProcedimentoDoc && pmpProcedimentoDoc.url);
  }
  if (pmpProcedimentoRemove) {
    pmpProcedimentoRemove.hidden = !pmpProcedimentoDoc;
  }
  if (pmpProcedimentoUpload) {
    pmpProcedimentoUpload.textContent = pmpProcedimentoDoc ? "Alterar PDF" : "Anexar PDF";
  }
}

function openPmpProcedimento(doc) {
  const safeDoc = normalizePmpProcedimentoDoc(doc);
  if (!safeDoc || !safeDoc.url) {
    window.alert("Procedimento não encontrado.");
    return;
  }
  abrirPreview(safeDoc.url);
}

function renderPmpCellExecutorOptions(projectId, selectedId) {
  if (!pmpCellExecutorInput) {
    return;
  }
  const list = [];
  if (Array.isArray(projectEquipe) && projectEquipe.length) {
    projectEquipe.forEach((entry) => {
      const user = entry.user;
      if (user && (!entry.projectId || entry.projectId === projectId)) {
        list.push({ id: user.id, label: `${user.name} (${user.matricula})` });
      }
    });
  }
  if (!list.length && Array.isArray(users)) {
    users.forEach((user) => {
      if (user && user.id) {
        list.push({ id: user.id, label: `${user.name || user.username || "-"} (${user.matricula || "-"})` });
      }
    });
  }
  pmpCellExecutorInput.innerHTML = "";
  const optBlank = document.createElement("option");
  optBlank.value = "";
  optBlank.textContent = "Selecione";
  pmpCellExecutorInput.append(optBlank);
  const unique = new Map();
  list.forEach((entry) => {
    if (!entry.id || unique.has(entry.id)) {
      return;
    }
    unique.set(entry.id, entry);
    const option = document.createElement("option");
    option.value = entry.id;
    option.textContent = entry.label;
    pmpCellExecutorInput.append(option);
  });
  pmpCellExecutorInput.value = selectedId && unique.has(selectedId) ? selectedId : "";
}

function openPmpCellModal(activityId, periodKey) {
  if (!modalPmpCell || !pmpLastSnapshot) {
    return;
  }
  const activity =
    pmpLastSnapshot.activities.find((item) => item.id === activityId) ||
    pmpActivities.find((item) => item.id === activityId);
  const period = pmpLastSnapshot.periods.find((item) => item.key === periodKey);
  if (!activity || !period) {
    return;
  }
  const scheduledKeys = getScheduledPeriodKeys(
    activity,
    pmpLastSnapshot.year,
    pmpLastSnapshot.viewMode,
    pmpLastSnapshot.periods,
    pmpLastSnapshot.monthIndex
  );
  const manualEntry = pmpLastSnapshot.manualMap.get(activity.id)
    ? pmpLastSnapshot.manualMap.get(activity.id).get(periodKey)
    : null;
  const isScheduled = scheduledKeys.has(periodKey) || Boolean(manualEntry);
  const statusInfo = getPmpStatusForPeriod(
    activity,
    period,
    periodKey,
    pmpLastSnapshot.viewMode,
    pmpLastSnapshot.manualMap,
    pmpLastSnapshot.autoMap,
    startOfDay(new Date()),
    isScheduled
  );
  const project = availableProjects.find((item) => item.id === activity.projectId);
  if (pmpCellTitle) {
    pmpCellTitle.textContent = activity.nome || "Atividade PMP";
  }
  if (pmpCellMeta) {
    const projectLabel = project ? getProjectLabel(project) : "-";
    const periodoTexto =
      pmpLastSnapshot.viewMode === "day"
        ? `Data: ${formatDate(period.start)}`
        : `Período: ${period.label} (${formatDate(period.start)} - ${formatDate(period.end)})`;
    pmpCellMeta.textContent = `Projeto: ${projectLabel} | ${periodoTexto} | Status: ${
      PMP_STATUS_LABELS[statusInfo.status] || "-"
    }`;
  }
  const execEntries = [];
  if (statusInfo.exec) {
    const tipo = statusInfo.exec.source === "auto" ? "Automático" : "Manual";
    const data = statusInfo.executedAt ? formatDate(statusInfo.executedAt) : "-";
    const executor = statusInfo.exec.executorId ? getUserLabel(statusInfo.exec.executorId) : "-";
    const os = statusInfo.exec.osReferencia || statusInfo.exec.manutencaoId || "-";
    execEntries.push(`${tipo}: ${data} | ${executor} | OS ${os}`);
    if (statusInfo.exec.observacao) {
      execEntries.push(`Obs: ${statusInfo.exec.observacao}`);
    }
  }
  renderPmpCellList(pmpCellExecList, execEntries, "Sem execução registrada.");

  const execRecord = manualEntry || statusInfo.exec;
  let evidencias = [];
  if (execRecord && Array.isArray(execRecord.evidencias) && execRecord.evidencias.length) {
    evidencias = execRecord.evidencias;
  } else if (statusInfo.exec && statusInfo.exec.manutencaoId) {
    const list = getPmpMaintenanceList(activity.projectId);
    const encontrado = list.find((item) => item && item.id === statusInfo.exec.manutencaoId);
    evidencias = getMaintenanceEvidencias(encontrado).map((evidencia) => {
      if (typeof evidencia === "string") {
        return evidencia;
      }
      return evidencia.nome || evidencia.name || evidencia.url || "Arquivo";
    });
  }
  renderPmpCellList(pmpCellEvidencias, evidencias, "Sem evidências registradas.");

  const checklistExec = execRecord && Array.isArray(execRecord.checklist) ? execRecord.checklist : [];
  const checklist = checklistExec.length
    ? normalizePmpChecklistItems(checklistExec)
    : normalizePmpChecklistItems(activity.checklist || []);
  renderPmpCellList(
    pmpCellChecklist,
    checklist.map((item) => `${item.descricao || "Item"}${item.link ? ` (${item.link})` : ""}`),
    "Sem checklist."
  );

  if (pmpCellObservacoes) {
    pmpCellObservacoes.textContent = activity.observacoes || "-";
  }
  if (pmpCellProcedimentos) {
    pmpCellProcedimentos.textContent = activity.procedimentos || "-";
  }

  const scheduledValue = execRecord && execRecord.scheduledFor
    ? parseAnyDate(execRecord.scheduledFor)
    : statusInfo.dueDate || period.start;
  const executedValue = execRecord && execRecord.executedAt
    ? parseAnyDate(execRecord.executedAt)
    : null;
  if (pmpCellScheduledInput) {
    pmpCellScheduledInput.value = scheduledValue ? formatDateISO(scheduledValue) : "";
  }
  if (pmpCellExecutedInput) {
    pmpCellExecutedInput.value = executedValue ? formatDateISO(executedValue) : "";
  }
  if (pmpCellObsInput) {
    pmpCellObsInput.value = execRecord && execRecord.observacao ? execRecord.observacao : "";
  }
  if (pmpCellEvidenciasInput) {
    pmpCellEvidenciasInput.value = formatPmpTextList(
      execRecord && Array.isArray(execRecord.evidencias) ? execRecord.evidencias : []
    );
  }
  if (pmpCellChecklistInput) {
    pmpCellChecklistInput.value = formatPmpTextList(
      execRecord && Array.isArray(execRecord.checklist) ? execRecord.checklist : []
    );
  }
  renderPmpCellExecutorOptions(
    activity.projectId,
    execRecord && execRecord.executorId ? execRecord.executorId : ""
  );

  const canManage = Boolean(currentUser && canManagePmpActivities(currentUser));
  const canExecute = Boolean(currentUser && canExecutePmp(currentUser));
  if (pmpCellMarkCancel) {
    pmpCellMarkCancel.hidden = !canManage;
    pmpCellMarkCancel.disabled = statusInfo.status === "cancelled";
  }
  if (pmpCellSave) {
    pmpCellSave.disabled = !canExecute;
  }
  if (pmpCellUnset) {
    pmpCellUnset.disabled = !canManage || statusInfo.status === "empty";
  }
  if (pmpCellRemove) {
    pmpCellRemove.hidden = !canManage || !(execRecord && execRecord.id);
    pmpCellRemove.disabled = !canManage || !(execRecord && execRecord.id);
  }
  const cellInputs = [
    pmpCellScheduledInput,
    pmpCellExecutedInput,
    pmpCellExecutorInput,
    pmpCellObsInput,
    pmpCellEvidenciasInput,
    pmpCellChecklistInput,
  ];
  cellInputs.forEach((input) => {
    if (input) {
      input.disabled = !canExecute;
    }
  });
  pmpCellContext = {
    activityId: activity.id,
    periodKey,
    scheduledFor: scheduledValue ? formatDateISO(scheduledValue) : "",
    executionId: execRecord && execRecord.id ? execRecord.id : "",
    projectId: activity.projectId,
  };
  modalPmpCell.hidden = false;
}

function upsertPmpExecution(execution) {
  if (!execution) {
    return;
  }
  const idx = pmpExecutions.findIndex((item) => item.id === execution.id);
  if (idx >= 0) {
    pmpExecutions[idx] = execution;
    return;
  }
  const byKey = pmpExecutions.findIndex(
    (item) =>
      item.activityId === execution.activityId &&
      item.periodKey === execution.periodKey &&
      item.projectId === execution.projectId
  );
  if (byKey >= 0) {
    pmpExecutions[byKey] = execution;
    return;
  }
  pmpExecutions = pmpExecutions.concat(execution);
}

async function marcarPmpCancelada() {
  if (!pmpCellContext || !pmpCellContext.activityId) {
    return;
  }
  if (!currentUser || !canManagePmpActivities(currentUser)) {
    return;
  }
  const confirmacao = window.confirm("Marcar atividade como cancelada neste período?");
  if (!confirmacao) {
    return;
  }
  try {
    const scheduledFor = pmpCellScheduledInput && pmpCellScheduledInput.value
      ? pmpCellScheduledInput.value
      : pmpCellContext.scheduledFor;
    const data = await apiPmpExecutionSave({
      activityId: pmpCellContext.activityId,
      periodKey: pmpCellContext.periodKey,
      scheduledFor,
      status: "cancelada",
    });
    if (data && data.execution) {
      upsertPmpExecution(data.execution);
      renderTudo();
    }
  } catch (error) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Erro ao marcar atividade cancelada.";
    }
  }
  closePmpCellModal();
}

async function salvarPmpExecucaoManual() {
  if (!pmpCellContext || !pmpCellContext.activityId) {
    return;
  }
  if (!currentUser || !canExecutePmp(currentUser)) {
    return;
  }
  const scheduledFor = pmpCellScheduledInput && pmpCellScheduledInput.value
    ? pmpCellScheduledInput.value
    : pmpCellContext.scheduledFor;
  const executedAt = pmpCellExecutedInput && pmpCellExecutedInput.value
    ? pmpCellExecutedInput.value
    : "";
  const executorId = pmpCellExecutorInput ? pmpCellExecutorInput.value : "";
  const observacao = pmpCellObsInput ? pmpCellObsInput.value.trim() : "";
  const evidencias = parsePmpTextList(pmpCellEvidenciasInput ? pmpCellEvidenciasInput.value : "");
  const checklist = parsePmpTextList(pmpCellChecklistInput ? pmpCellChecklistInput.value : "");
  const status = executedAt ? "concluida" : "agendada";
  try {
    const data = await apiPmpExecutionSave({
      activityId: pmpCellContext.activityId,
      periodKey: pmpCellContext.periodKey,
      scheduledFor,
      executedAt,
      executorId,
      observacao,
      evidencias,
      checklist,
      status,
      source: "manual",
    });
    if (data && data.execution) {
      upsertPmpExecution(data.execution);
      renderTudo();
    }
  } catch (error) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Erro ao salvar execução PMP.";
    }
  }
  closePmpCellModal();
}

async function removerPmpExecucaoManual() {
  if (!pmpCellContext || !pmpCellContext.executionId) {
    return;
  }
  if (!currentUser || !canManagePmpActivities(currentUser)) {
    return;
  }
  const confirmacao = window.confirm("Remover execução manual deste período?");
  if (!confirmacao) {
    return;
  }
  try {
    await apiPmpExecutionDelete(pmpCellContext.executionId);
    pmpExecutions = pmpExecutions.filter((item) => item.id !== pmpCellContext.executionId);
    renderTudo();
  } catch (error) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Erro ao remover execução.";
    }
  }
  closePmpCellModal();
}

async function marcarPmpNaoPrevista() {
  if (!pmpCellContext || !pmpCellContext.activityId) {
    return;
  }
  if (!currentUser || !canManagePmpActivities(currentUser)) {
    return;
  }
  const confirmacao = window.confirm("Marcar este período como não previsto?");
  if (!confirmacao) {
    return;
  }
  try {
    const scheduledFor = pmpCellScheduledInput && pmpCellScheduledInput.value
      ? pmpCellScheduledInput.value
      : pmpCellContext.scheduledFor;
    const data = await apiPmpExecutionSave({
      activityId: pmpCellContext.activityId,
      periodKey: pmpCellContext.periodKey,
      scheduledFor,
      status: "removida",
      source: "manual",
    });
    if (data && data.execution) {
      upsertPmpExecution(data.execution);
      renderTudo();
    }
  } catch (error) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Erro ao marcar como não prevista.";
    }
  }
  closePmpCellModal();
}

async function carregarPmpDados() {
  if (!currentUser) {
    pmpActivities = [];
    pmpExecutions = [];
    return;
  }
  const projectId = activeProjectId || "";
  try {
    const data = await apiPmpActivitiesList(projectId ? { projectId } : {});
    pmpActivities = Array.isArray(data.activities) ? data.activities : [];
  } catch (error) {
    pmpActivities = [];
  }
  try {
    const data = await apiPmpExecutionsList(projectId ? { projectId } : {});
    pmpExecutions = Array.isArray(data.executions) ? data.executions : [];
  } catch (error) {
    pmpExecutions = [];
  }
  renderTudo();
}

function buildPmpSnapshot() {
  const year = getPmpYearValue();
  const viewMode = getPmpViewMode();
  const monthIndex = getPmpMonthValue();
  const activities = getPmpFilteredActivities();
  const periods = getPmpPeriods(viewMode, year, monthIndex);
  const manualMap = getExecutionsByActivity();
  const autoMap = buildAutoExecutionMap(activities, periods, viewMode, year, monthIndex);
  const today = startOfDay(new Date());
  const monthLabel = PMP_MONTH_LABELS[monthIndex] || String(monthIndex + 1).padStart(2, "0");
  return { year, viewMode, monthIndex, monthLabel, activities, periods, manualMap, autoMap, today };
}

function exportarPmpExcel() {
  if (!pmpGrid) {
    return;
  }
  const snapshot = buildPmpSnapshot();
  const header = [
    "projeto",
    "equipamento",
    "codigo",
    "atividade",
    "tipo",
    "frequencia",
    "duracao",
    "tecnicos",
    ...snapshot.periods.map((period) => period.label),
  ];
  const linhas = snapshot.activities.map((activity) => {
    const project = availableProjects.find((item) => item.id === activity.projectId);
    const freqLabel = getPmpFrequency(activity.frequencia)
      ? getPmpFrequency(activity.frequencia).label
      : activity.frequencia || "";
    const tipoInfo = getPmpTipoInfo(activity.tipoManutencao || activity.tipo || "");
    const scheduledKeys = getScheduledPeriodKeys(
      activity,
      snapshot.year,
      snapshot.viewMode,
      snapshot.periods,
      snapshot.monthIndex
    );
    const values = [
      project ? getProjectLabel(project) : "",
      getEquipamentoNomeById(activity.projectId, activity.equipamentoId),
      activity.codigo || "",
      activity.nome || "",
      tipoInfo ? tipoInfo.label : activity.tipoManutencao || activity.tipo || "",
      freqLabel,
      activity.duracaoMinutos ? formatDuracaoMin(activity.duracaoMinutos) : "",
      activity.tecnicosEstimados ? String(activity.tecnicosEstimados) : "",
    ];
    snapshot.periods.forEach((period) => {
      const periodKey = period.key;
      const manualEntry = snapshot.manualMap.get(activity.id)
        ? snapshot.manualMap.get(activity.id).get(periodKey)
        : null;
      const isScheduled = scheduledKeys.has(periodKey) || Boolean(manualEntry);
      if (!isScheduled) {
        values.push(snapshot.viewMode === "day" ? (PMP_STATUS_LABELS.empty || "Não prevista") : "");
        return;
      }
      const statusInfo = getPmpStatusForPeriod(
        activity,
        period,
        periodKey,
        snapshot.viewMode,
        snapshot.manualMap,
        snapshot.autoMap,
        snapshot.today,
        isScheduled
      );
      values.push(
        statusInfo.status === "empty"
          ? PMP_STATUS_LABELS.empty || "Não prevista"
          : PMP_STATUS_LABELS[statusInfo.status] || "Planejada"
      );
    });
    return values.map(escapeCsv).join(",");
  });
  const csv = [header.map(escapeCsv).join(","), ...linhas].join("\n");
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  const monthSuffix = snapshot.viewMode === "day" ? `-${snapshot.monthLabel}` : "";
  link.download = `pmp-${snapshot.year}-${snapshot.viewMode}${monthSuffix}.csv`;
  document.body.append(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);
}

function exportarPmpPdf() {
  const snapshot = buildPmpSnapshot();
  const popup = window.open("", "_blank");
  if (!popup) {
    return;
  }
  let totalCells = 0;
  let onTimeCells = 0;
  let lateCells = 0;
  let missedCells = 0;
  let cancelledCells = 0;
  let totalPlannedMinutes = 0;
  let totalExecutedMinutes = 0;
  const statusClassMap = {
    on_time: "on-time",
    late: "late",
    missed: "missed",
    scheduled: "scheduled",
    cancelled: "cancelled",
  };
  const rows = snapshot.activities
    .map((activity) => {
      const project = availableProjects.find((item) => item.id === activity.projectId);
      const projectLabel = project ? getProjectLabel(project) : "-";
      const equipLabel = getEquipamentoNomeById(activity.projectId, activity.equipamentoId);
      const tipoInfo = getPmpTipoInfo(activity.tipoManutencao || activity.tipo || "");
      const tipoLabel = tipoInfo ? tipoInfo.label : activity.tipoManutencao || activity.tipo || "-";
      const freqLabel = getPmpFrequency(activity.frequencia)
        ? getPmpFrequency(activity.frequencia).label
        : activity.frequencia || "-";
      const scheduledKeys = getScheduledPeriodKeys(
        activity,
        snapshot.year,
        snapshot.viewMode,
        snapshot.periods,
        snapshot.monthIndex
      );
      const cells = snapshot.periods
        .map((period) => {
          const periodKey = period.key;
          const manualEntry = snapshot.manualMap.get(activity.id)
            ? snapshot.manualMap.get(activity.id).get(periodKey)
            : null;
          const isScheduled = scheduledKeys.has(periodKey) || Boolean(manualEntry);
          if (!isScheduled) {
            const emptyLabel =
              snapshot.viewMode === "day"
                ? PMP_STATUS_LABELS.empty || "Não prevista"
                : "-";
            return `<td class="pmp-cell empty">${escapeHtml(emptyLabel)}</td>`;
          }
          const statusInfo = getPmpStatusForPeriod(
            activity,
            period,
            periodKey,
            snapshot.viewMode,
            snapshot.manualMap,
            snapshot.autoMap,
            snapshot.today,
            isScheduled
          );
          const status = statusInfo.status;
          if (status === "empty") {
            const emptyLabel = PMP_STATUS_LABELS.empty || "Não prevista";
            return `<td class="pmp-cell empty">${escapeHtml(emptyLabel)}</td>`;
          }
          totalCells += 1;
          totalPlannedMinutes += Number(activity.duracaoMinutos || 0);
          if (status === "on_time") {
            onTimeCells += 1;
          } else if (status === "late") {
            lateCells += 1;
          } else if (status === "cancelled") {
            cancelledCells += 1;
            missedCells += 1;
          } else if (status === "missed") {
            missedCells += 1;
          }
          if (statusInfo.executedAt) {
            totalExecutedMinutes += Number(activity.duracaoMinutos || 0);
          }
          const statusClass = statusClassMap[status] || "scheduled";
          const label = PMP_STATUS_LABELS[status] || "Planejada";
          return `<td class="pmp-cell ${statusClass}">${label}</td>`;
        })
        .join("");
      return `
        <tr>
          <td>${escapeHtml(projectLabel)}</td>
          <td>${escapeHtml(equipLabel)}</td>
          <td>${escapeHtml(activity.codigo || "-")}</td>
          <td>${escapeHtml(activity.nome || "-")}</td>
          <td>${escapeHtml(tipoLabel)}</td>
          <td>${escapeHtml(freqLabel)}</td>
          ${cells}
        </tr>
      `;
    })
    .join("");
  const headerCols = snapshot.periods.map((period) => `<th>${period.label}</th>`).join("");
  const percentBase = totalCells || 1;
  const scheduledCells = totalCells - onTimeCells - lateCells - missedCells - cancelledCells;
  const percentOnTime = Math.round((onTimeCells / percentBase) * 100);
  const percentLate = Math.round((lateCells / percentBase) * 100);
  const percentMissed = Math.round((missedCells / percentBase) * 100);
  const percentScheduled = Math.max(0, 100 - percentOnTime - percentLate - percentMissed);
  const projectFilter = (pmpFiltroProjeto && pmpFiltroProjeto.value) || activeProjectId || "";
  const selectedProject = projectFilter
    ? availableProjects.find((item) => item.id === projectFilter)
    : null;
  const projectLabel = selectedProject ? getProjectLabel(selectedProject) : "Todos os projetos";
  const kpiHtml = `
    <div class="pmp-kpi">
      <span>Total previstas: ${totalCells}</span>
      <span>Conforme: ${Math.round((onTimeCells / percentBase) * 100)}%</span>
      <span>Fora da janela: ${Math.round((lateCells / percentBase) * 100)}%</span>
      <span>Atrasadas: ${Math.round((missedCells / percentBase) * 100)}%</span>
      <span>Canceladas: ${cancelledCells}</span>
      <span>Horas planejadas: ${
        totalPlannedMinutes ? formatDuracaoMin(totalPlannedMinutes) : "00:00"
      }</span>
      <span>Horas executadas: ${
        totalExecutedMinutes ? formatDuracaoMin(totalExecutedMinutes) : "00:00"
      }</span>
    </div>
  `;
  const legendHtml = `
    <div class="pmp-legend">
      <span class="legend-item on-time">Conforme</span>
      <span class="legend-item missed">Atrasada</span>
      <span class="legend-item scheduled">Planejada</span>
      <span class="legend-item late">Fora da janela</span>
      <span class="legend-item empty">Não prevista</span>
      <span class="legend-item cancelled">Cancelada</span>
    </div>
  `;
  const chartHtml = `
    <div class="pmp-chart">
      <span class="chart-on-time" style="width: ${percentOnTime}%"></span>
      <span class="chart-scheduled" style="width: ${percentScheduled}%"></span>
      <span class="chart-late" style="width: ${percentLate}%"></span>
      <span class="chart-missed" style="width: ${percentMissed}%"></span>
    </div>
  `;
  const html = `
    <html>
      <head>
        <title>PMP ${snapshot.year}</title>
        <style>
          body { font-family: Arial, sans-serif; color: #1f2a33; margin: 24px; }
          h1 { margin: 0 0 8px; font-size: 20px; }
          p { margin: 0 0 16px; color: #425363; }
          table { width: 100%; border-collapse: collapse; font-size: 11px; }
          th, td { border: 1px solid #d7d7d7; padding: 6px; text-align: left; }
          th { background: #f0f2f4; text-transform: uppercase; letter-spacing: 0.08em; font-size: 10px; }
          .pmp-cell { text-align: center; font-weight: 600; }
          .pmp-cell.on-time { background: #d1fae5; }
          .pmp-cell.late { background: #fef3c7; }
          .pmp-cell.missed { background: #fee2e2; }
          .pmp-cell.scheduled { background: #dbeafe; }
          .pmp-cell.cancelled { background: #e2e8f0; }
          .pmp-cell.empty { color: #9aa6b2; }
          .pmp-kpi { margin-top: 14px; display: flex; flex-wrap: wrap; gap: 16px; font-size: 10px; color: #425363; }
          .pmp-legend { margin-top: 10px; display: flex; gap: 12px; flex-wrap: wrap; font-size: 10px; color: #425363; }
          .legend-item { display: inline-flex; align-items: center; gap: 6px; }
          .legend-item::before { content: ""; width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
          .legend-item.on-time::before { background: #22c55e; }
          .legend-item.late::before { background: #f59e0b; }
          .legend-item.missed::before { background: #ef4444; }
          .legend-item.scheduled::before { background: #3b82f6; }
          .legend-item.empty::before { background: #94a3b8; }
          .legend-item.cancelled::before { background: #94a3b8; }
          .pmp-chart { margin: 10px 0 4px; height: 10px; background: #e5e7eb; border-radius: 999px; overflow: hidden; display: flex; }
          .pmp-chart span { height: 100%; display: block; }
          .chart-on-time { background: #22c55e; }
          .chart-scheduled { background: #3b82f6; }
          .chart-late { background: #f59e0b; }
          .chart-missed { background: #ef4444; }
          @page { size: A4 landscape; margin: 16mm; }
        </style>
      </head>
      <body>
        <h1>PMP / Cronograma ${snapshot.year}</h1>
        <p>Projeto: ${escapeHtml(projectLabel)} | Visualização: ${
          snapshot.viewMode === "day"
            ? `Diario (${snapshot.monthLabel})`
            : snapshot.viewMode === "week"
              ? "Semanal"
              : "Mensal"
        }</p>
        ${legendHtml}
        ${chartHtml}
        <table>
          <thead>
            <tr>
              <th>Projeto</th>
              <th>Equipamento</th>
              <th>Codigo</th>
              <th>Atividade</th>
              <th>Tipo</th>
              <th>Freq.</th>
              ${headerCols}
            </tr>
          </thead>
          <tbody>
            ${rows || ""}
          </tbody>
        </table>
        ${kpiHtml}
      </body>
    </html>
  `;
  popup.document.open();
  popup.document.write(html);
  popup.document.close();
  popup.focus();
  popup.print();
}

async function duplicarPmpPlano() {
  if (!currentUser || !hasGranularPermission(currentUser, "gerenciarPMP")) {
    return;
  }
  const projectId = pmpFiltroProjeto ? pmpFiltroProjeto.value : activeProjectId;
  if (!projectId) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Selecione um projeto para duplicar.";
    }
    return;
  }
  const anoAtual = getPmpYearValue();
  const targetYear = anoAtual + 1;
  const confirmacao = window.confirm(
    `Duplicar o plano ${anoAtual} para ${targetYear}?`
  );
  if (!confirmacao) {
    return;
  }
  try {
    await apiPmpDuplicate({ projectId, sourceYear: anoAtual, targetYear });
    await carregarPmpDados();
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Plano duplicado.";
    }
  } catch (error) {
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Erro ao duplicar plano.";
    }
  }
}

function gerarManutencoesRecorrentes() {
  if (USE_AUTH_API) {
    return false;
  }
  if (!templates.length) {
    return false;
  }
  const hoje = startOfDay(new Date());
  const limite = addDays(hoje, Math.max(reminderDays, 1));
  const existentes = new Set(
    manutencoes
      .filter((item) => item.templateId && item.data)
      .map((item) => `${item.templateId}|${item.data}`)
  );
  const suppressions = readRecurrenceSuppressions();

  let mudou = false;
  let mudouTemplates = false;

  templates = templates.map((template) => {
    if (!template) {
      return template;
    }

    const normalizado = normalizarTemplate(template);
    let modelo = normalizado.template;
    if (normalizado.mudou) {
      mudouTemplates = true;
    }

    if (!modelo.ativo || modelo.frequencia === "none") {
      return modelo;
    }

    const inicio = parseDate(modelo.inicio);
    let base = hoje;
    if (inicio && inicio > base) {
      base = inicio;
    }

    for (let atual = base; atual <= limite; atual = addDays(atual, 1)) {
      if (!matchesRecorrencia(modelo, atual)) {
        continue;
      }
      const dataStr = formatDateISO(atual);
      const key = `${modelo.id}|${dataStr}`;
      if (suppressions[key]) {
        continue;
      }
      if (existentes.has(key)) {
        continue;
      }
      const agoraIso = toIsoUtc(new Date());
      const participantesModelo = Array.isArray(modelo.participantes)
        ? modelo.participantes
        : typeof modelo.participantes === "string"
          ? modelo.participantes
              .split(";")
              .map((item) => normalizeParticipantName(item))
              .filter(Boolean)
          : [];
      const executadoPorTime = modelo.equipeResponsavel
        ? `team:${modelo.equipeResponsavel}`
        : "";
      const nova = {
        id: criarId(),
        titulo: modelo.nome,
        local: modelo.subestacao,
        data: dataStr,
        observacao: modelo.observacao || "",
        templateId: modelo.id,
        equipamentoId: modelo.equipamentoId || "",
        participantes: participantesModelo,
        executadaPor: executadoPorTime,
        status: "agendada",
        createdAt: agoraIso,
        createdBy: SYSTEM_USER_ID,
        updatedAt: agoraIso,
        updatedBy: SYSTEM_USER_ID,
      };
      manutencoes = [...manutencoes, nova];
      existentes.add(key);
      logAction(
        "create",
        nova,
        {
          source: "recorrente",
          templateId: modelo.id,
          dataProgramada: dataStr,
          resumo: "Manutenção criada automaticamente pela recorrência.",
        },
        SYSTEM_USER_ID
      );
      mudou = true;
    }

    const proxima = getNextOccurrenceDate(modelo, hoje);
    const proximaStr = proxima ? formatDateISO(proxima) : "";
    if (proximaStr !== modelo.proximaData) {
      modelo = { ...modelo, proximaData: proximaStr };
      mudouTemplates = true;
    }
    return modelo;
  });

  if (mudou) {
    salvarManutencoes(manutencoes);
  }
  if (mudou || mudouTemplates) {
    salvarTemplates(templates);
  }
  return mudou || mudouTemplates;
}

function renderSolicitacoes() {
  if (!listaSolicitacoes || !solicitacoesVazio) {
    return;
  }
  listaSolicitacoes.innerHTML = "";
  if (!currentUser || !canViewUsuarios(currentUser)) {
    solicitacoesVazio.textContent = "Acesso restrito.";
    solicitacoesVazio.hidden = false;
    return;
  }
  if (requests.length === 0) {
    solicitacoesVazio.textContent = "Nenhuma solicitação pendente.";
    solicitacoesVazio.hidden = false;
    return;
  }
  solicitacoesVazio.hidden = true;
  const podeAprovar = Boolean(currentUser && canInviteUsuarios(currentUser));

  requests.forEach((request) => {
    const item = document.createElement("div");
    item.className = "account-item";
    item.dataset.requestId = request.id;

    const header = document.createElement("div");
    header.className = "account-header";

    const info = document.createElement("div");
    const titulo = document.createElement("strong");
    titulo.textContent = request.nome;
    const meta = document.createElement("p");
    meta.className = "account-meta";
    meta.textContent = `Matricula: ${request.matricula}`;
    info.append(titulo, meta);

    const role = document.createElement("div");
    role.className = "perm-item";
    const roleInput = document.createElement("input");
    roleInput.type = "checkbox";
    roleInput.dataset.role = "admin";
    roleInput.disabled = !podeAprovar;
    const roleLabel = document.createElement("label");
    roleLabel.textContent = "Administrador";
    role.append(roleInput, roleLabel);

    header.append(info, role);

    const perms = document.createElement("div");
    perms.className = "perm-grid";
    Object.keys(PERMISSIONS).forEach((key) => {
      const permItem = document.createElement("label");
      permItem.className = "perm-item";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = true;
      checkbox.dataset.permission = key;
      checkbox.disabled = !podeAprovar;
      const text = document.createElement("span");
      text.textContent = PERMISSIONS[key];
      permItem.append(checkbox, text);
      perms.append(permItem);
    });

    const sectionsLabel = document.createElement("span");
    sectionsLabel.className = "account-label";
    sectionsLabel.textContent = "Secoes";

    const sections = document.createElement("div");
    sections.className = "perm-grid";
    Object.keys(SECTION_LABELS).forEach((key) => {
      const sectionItem = document.createElement("label");
      sectionItem.className = "perm-item";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = true;
      checkbox.dataset.section = key;
      checkbox.disabled = !podeAprovar;
      const text = document.createElement("span");
      text.textContent = SECTION_LABELS[key];
      sectionItem.append(checkbox, text);
      sections.append(sectionItem);
    });

    const actions = document.createElement("div");
    actions.className = "manutencao-actions";
    const btnAprovar = document.createElement("button");
    btnAprovar.type = "button";
    btnAprovar.className = "btn btn--primary btn--small";
    btnAprovar.dataset.action = "approve";
    btnAprovar.textContent = "Aprovar";
    btnAprovar.disabled = !podeAprovar;
    btnAprovar.classList.toggle("is-disabled", !podeAprovar);
    const btnRecusar = document.createElement("button");
    btnRecusar.type = "button";
    btnRecusar.className = "btn btn--ghost btn--small btn--danger";
    btnRecusar.dataset.action = "reject";
    btnRecusar.textContent = "Recusar";
    btnRecusar.disabled = !podeAprovar;
    btnRecusar.classList.toggle("is-disabled", !podeAprovar);
    actions.append(btnAprovar, btnRecusar);

    item.append(header, perms, sectionsLabel, sections, actions);
    listaSolicitacoes.append(item);
  });
}

function renderUsuarios() {
  if (!listaUsuarios || !usuariosVazio) {
    return;
  }
  listaUsuarios.innerHTML = "";
  if (!currentUser || !canAdminUsersRead()) {
    usuariosVazio.hidden = false;
    usuariosVazio.textContent = "Acesso restrito.";
    return;
  }
  if (users.length === 0) {
    usuariosVazio.hidden = false;
    usuariosVazio.textContent = "Nenhuma conta cadastrada.";
    return;
  }

  const filtroNome = normalizeSearchValue(userFiltroNome ? userFiltroNome.value : "");
  const filtroCargo = normalizeSearchValue(userFiltroCargo ? userFiltroCargo.value : "");
  const filtroProjeto = normalizeSearchValue(userFiltroProjeto ? userFiltroProjeto.value : "");
  const filtroStatus = userFiltroStatus ? userFiltroStatus.value : "";

  const filtrados = users.filter((user) => {
    const nome = normalizeSearchValue(user.name || "");
    const cargo = normalizeSearchValue(user.cargo || "");
    const projeto = normalizeSearchValue(getUserProjectLabel(user));
    const matricula = normalizeSearchValue(user.matricula || user.username || "");
    const ativo = user.active !== false;

    if (filtroNome && !nome.includes(filtroNome) && !matricula.includes(filtroNome)) {
      return false;
    }
    if (filtroCargo && !cargo.includes(filtroCargo)) {
      return false;
    }
    if (filtroProjeto && !projeto.includes(filtroProjeto)) {
      return false;
    }
    if (filtroStatus === "active" && !ativo) {
      return false;
    }
    if (filtroStatus === "inactive" && ativo) {
      return false;
    }
    return true;
  });

  if (filtrados.length === 0) {
    usuariosVazio.hidden = false;
    usuariosVazio.textContent = "Nenhum usuário encontrado.";
    return;
  }

  usuariosVazio.hidden = true;
  filtrados.forEach((user) => {
    const item = document.createElement("div");
    item.className = "account-item is-clickable";
    item.dataset.userId = user.id;
    item.tabIndex = 0;
    const header = document.createElement("div");
    header.className = "account-header";
    const titulo = document.createElement("strong");
    titulo.textContent = user.name || user.matricula || "Usuário";
    const status = document.createElement("span");
    status.className = `status-pill ${user.active === false ? "status-pill--inactive" : "status-pill--active"}`;
    status.textContent = user.active === false ? "Inativo" : "Ativo";
    header.append(titulo, status);
    const meta = document.createElement("p");
    meta.className = "account-meta";
    const roleLabel = getRoleLabel(user);
    meta.textContent = `Matricula: ${user.matricula || "-"} | Perfil: ${roleLabel}`;
    const detalhes = document.createElement("p");
    detalhes.className = "account-meta";
    detalhes.textContent = `Cargo: ${user.cargo || "-"} | Projeto: ${getUserProjectLabel(user)}`;
    item.append(header, meta, detalhes);
    listaUsuarios.append(item);
  });
}

function setAccessMessage(texto, erro = false) {
  if (!accessMsg) {
    return;
  }
  accessMsg.textContent = texto || "";
  accessMsg.hidden = !texto;
  accessMsg.classList.toggle("mensagem--erro", erro);
}

function setAccessStorageWarning(texto = "") {
  if (!accessStorageWarning) {
    return;
  }
  accessStorageWarning.textContent = texto || "";
  accessStorageWarning.hidden = !texto;
}

function applyAccessWriteState() {
  const disabled = !accessWriteEnabled;
  if (btnAccessNewUser) {
    btnAccessNewUser.disabled = disabled;
  }
  if (btnAccessNewRole) {
    btnAccessNewRole.disabled = disabled;
  }
  if (btnAccessImport) {
    btnAccessImport.disabled = disabled;
  }
  if (accessImportInput) {
    accessImportInput.disabled = disabled;
  }
  if (btnAccessUserSave) {
    btnAccessUserSave.disabled = disabled;
  }
  if (btnAccessRoleSave) {
    btnAccessRoleSave.disabled = disabled;
  }
  if (btnResetPasswordConfirm) {
    btnResetPasswordConfirm.disabled = disabled;
  }
  renderAccessUsers();
  renderAccessRoles();
}

async function refreshAccessStorageState() {
  if (!currentUser || !canManageAccess(currentUser)) {
    accessWriteEnabled = true;
    setAccessStorageWarning("");
    applyAccessWriteState();
    return;
  }
  if (!USE_AUTH_API) {
    accessWriteEnabled = true;
    setAccessStorageWarning("");
    applyAccessWriteState();
    return;
  }
  try {
    const status = await apiRequest("/api/admin/access/storage");
    const writeBlocked = Boolean(status && status.writeBlocked);
    accessWriteEnabled = !writeBlocked;
    if (writeBlocked) {
      setAccessStorageWarning(ACCESS_STORAGE_READONLY_MESSAGE);
    } else {
      setAccessStorageWarning("");
    }
  } catch (error) {
    accessWriteEnabled = true;
    setAccessStorageWarning("");
  }
  applyAccessWriteState();
}

function isAccessRoleModalOpen() {
  return Boolean(modalAccessRole && !modalAccessRole.hidden);
}

function setAccessTab(tab) {
  if (!accessTabs.length || !accessPanels.length) {
    return;
  }
  accessTabs.forEach((button) => {
    button.classList.toggle("is-active", button.dataset.accessTab === tab);
  });
  accessPanels.forEach((panel) => {
    panel.hidden = panel.dataset.accessPanel !== tab;
  });
}

function renderAccessRoleSelectOptions() {
  const sorted = sortAccessRolesByOrder(accessRoles);
  if (accessUserRole) {
    accessUserRole.innerHTML = '<option value="">Selecione</option>';
    sorted.forEach((role) => {
      const opt = document.createElement("option");
      opt.value = role.id;
      opt.textContent = role.name || "-";
      accessUserRole.append(opt);
    });
  }
  if (accessUserRoleFilter) {
    accessUserRoleFilter.innerHTML = '<option value="">Todos</option>';
    sorted.forEach((role) => {
      const opt = document.createElement("option");
      opt.value = role.id;
      opt.textContent = role.name || "-";
      accessUserRoleFilter.append(opt);
    });
  }
}

function renderAccessRoleNameOptions(selectedId = "") {
  if (!accessRoleSelect) {
    return;
  }
  const sorted = sortAccessRolesByOrder(accessRoles);
  accessRoleSelectLocked = true;
  accessRoleSelect.innerHTML = "";
  const optionNew = document.createElement("option");
  optionNew.value = "__new__";
  optionNew.textContent = "Novo cargo...";
  accessRoleSelect.append(optionNew);
  sorted.forEach((role) => {
    const opt = document.createElement("option");
    opt.value = role.id;
    opt.textContent = role.name || "-";
    accessRoleSelect.append(opt);
  });
  accessRoleSelect.value = selectedId || "__new__";
  accessRoleSelectLocked = false;
}

function renderAccessProjectSelectOptions() {
  const projects = Array.isArray(availableProjects) ? availableProjects : [];
  if (accessUserProject) {
    accessUserProject.innerHTML = '<option value="">Sem projeto</option>';
    projects.forEach((project) => {
      const opt = document.createElement("option");
      opt.value = project.id;
      opt.textContent = getProjectLabel(project);
      accessUserProject.append(opt);
    });
  }
  if (accessUserProjectFilter) {
    accessUserProjectFilter.innerHTML = '<option value="">Todos</option>';
    projects.forEach((project) => {
      const opt = document.createElement("option");
      opt.value = project.id;
      opt.textContent = getProjectLabel(project);
      accessUserProjectFilter.append(opt);
    });
  }
}

function renderAccessUsers() {
  if (!accessUsersTableBody || !accessUsersEmpty) {
    return;
  }
  accessUsersTableBody.innerHTML = "";
  if (!currentUser || !canManageAccess(currentUser)) {
    accessUsersEmpty.hidden = false;
    accessUsersEmpty.textContent = "Acesso restrito.";
    return;
  }
  const query = normalizeSearchValue(accessUserSearch ? accessUserSearch.value : "");
  const status = accessUserStatusFilter ? accessUserStatusFilter.value : "";
  const roleId = accessUserRoleFilter ? accessUserRoleFilter.value : "";
  const projectId = accessUserProjectFilter ? accessUserProjectFilter.value : "";
  const filtered = accessUsers.filter((user) => {
    const userStatus = normalizeAccessUserStatus(user.status, user.active);
    if (status && userStatus !== status) {
      return false;
    }
    if (roleId && String(user.roleId || "") !== roleId) {
      return false;
    }
    if (projectId && String(user.projectId || "") !== projectId) {
      return false;
    }
    if (query) {
      const nome = normalizeSearchValue(user.name || "");
      const matricula = normalizeSearchValue(user.matricula || "");
      const email = normalizeSearchValue(user.email || "");
      if (!nome.includes(query) && !matricula.includes(query) && !email.includes(query)) {
        return false;
      }
    }
    return true;
  });
  if (!filtered.length) {
    accessUsersEmpty.hidden = false;
    accessUsersEmpty.textContent = "Nenhuma conta cadastrada.";
    return;
  }
  accessUsersEmpty.hidden = true;
  const canWrite = Boolean(currentUser && canManageAccess(currentUser) && accessWriteEnabled);
  filtered.forEach((user) => {
    const tr = document.createElement("tr");
    const userStatus = normalizeAccessUserStatus(user.status, user.active);
    const statusText = userStatus === "INATIVO" ? "Inativo" : "Ativo";
    const statusClass = userStatus === "INATIVO" ? "status-pill--inactive" : "status-pill--active";
    const actions = [];
    const isSelf = Boolean(currentUser && String(user.id) === String(currentUser.id));
    const canDelete = userStatus === "INATIVO" && !isSelf;
    if (canWrite) {
      actions.push(
        `<button class="btn btn--ghost btn--small" type="button" data-action="edit-user" data-user-id="${user.id}">Editar</button>`
      );
      actions.push(
        `<button class="btn btn--ghost btn--small" type="button" data-action="reset-password" data-user-id="${user.id}">Resetar senha</button>`
      );
      actions.push(
        `<button class="btn btn--ghost btn--small" type="button" data-action="toggle-status" data-user-id="${user.id}">${
          userStatus === "INATIVO" ? "Ativar" : "Inativar"
        }</button>`
      );
      if (canDelete) {
        actions.push(
          `<button class="btn btn--ghost btn--small btn--danger" type="button" data-action="delete-user" data-user-id="${user.id}">Excluir</button>`
        );
      }
    }
    const nameLabel = escapeHtml(user.name || "-");
    const nameButton = `<button class="access-user-link link" type="button" data-action="view-profile" data-user-id="${user.id}">${nameLabel}</button>`;
    tr.innerHTML = `
      <td>${nameButton}</td>
      <td>${escapeHtml(user.matricula || "-")}</td>
      <td>${escapeHtml(user.roleName || "-")}</td>
      <td>${escapeHtml(getUserProjectLabel(user))}</td>
      <td><span class="status-pill ${statusClass}">${statusText}</span></td>
      <td class="table-actions">${actions.length ? actions.join(" ") : "-"}</td>
    `;
    accessUsersTableBody.append(tr);
  });
}

function renderAccessRoles() {
  if (!accessRolesTableBody || !accessRolesEmpty) {
    return;
  }
  accessRolesTableBody.innerHTML = "";
  if (!currentUser || !canManageAccess(currentUser)) {
    accessRolesEmpty.hidden = false;
    accessRolesEmpty.textContent = "Acesso restrito.";
    return;
  }
  const query = normalizeSearchValue(accessRoleSearch ? accessRoleSearch.value : "");
  const orderedAll = sortAccessRolesByOrder(accessRoles);
  const filtered = orderedAll.filter((role) => {
    if (!query) {
      return true;
    }
    return normalizeSearchValue(role.name || "").includes(query);
  });
  if (!filtered.length) {
    accessRolesEmpty.hidden = false;
    accessRolesEmpty.textContent = "Nenhum cargo cadastrado.";
    return;
  }
  accessRolesEmpty.hidden = true;
  const canWrite = Boolean(currentUser && canManageAccess(currentUser) && accessWriteEnabled);
  filtered.forEach((role) => {
      const tr = document.createElement("tr");
      const inUse = accessUsers.some((user) => String(user.roleId || "") === String(role.id));
      const statusLabel = role.isSystem ? "Sistema" : inUse ? "Em uso" : "Customizado";
      const permCount = (role.permissions || []).length;
      const permLabel = role.permissions && role.permissions.includes("ADMIN")
        ? "Admin total"
        : `${permCount} permiss${permCount === 1 ? "\u00e3o" : "\u00f5es"}`;
      const actions = [];
      if (canWrite) {
        const index = orderedAll.findIndex((item) => String(item.id) === String(role.id));
        const canMoveUp = index > 0;
        const canMoveDown = index >= 0 && index < orderedAll.length - 1;
        actions.push(
          `<button class="btn btn--ghost btn--small" type="button" data-action="move-role-up" data-role-id="${role.id}" ${canMoveUp ? "" : "disabled"} title="Mover para cima">\u2191</button>`
        );
        actions.push(
          `<button class="btn btn--ghost btn--small" type="button" data-action="move-role-down" data-role-id="${role.id}" ${canMoveDown ? "" : "disabled"} title="Mover para baixo">\u2193</button>`
        );
        actions.push(
          `<button class="btn btn--ghost btn--small" type="button" data-action="edit-role" data-role-id="${role.id}">Editar</button>`
        );
        const disabled = inUse ? "disabled" : "";
        const title = inUse ? "Cargo em uso" : "Remover";
        actions.push(
          `<button class="btn btn--ghost btn--small btn--danger" type="button" data-action="delete-role" data-role-id="${role.id}" ${disabled} title="${title}">Excluir</button>`
        );
      }
      tr.innerHTML = `
        <td>${escapeHtml(role.name || "-")}</td>
        <td>${escapeHtml(permLabel)}</td>
        <td>${escapeHtml(statusLabel)}</td>
        <td class="table-actions">${actions.length ? actions.join(" ") : "-"}</td>
      `;
      accessRolesTableBody.append(tr);
    });
}

function roleNeedsMaintenanceExecuteFix(role) {
  if (!role || !Array.isArray(role.permissions)) {
    return false;
  }
  const normalized = normalizeAccessPermissionList(role.permissions);
  return normalized.includes("MAINT_CREATE") && !normalized.includes("MAINT_COMPLETE");
}

async function moveAccessRole(roleId, direction) {
  const ordered = sortAccessRolesByOrder(accessRoles);
  const index = ordered.findIndex((item) => String(item.id) === String(roleId));
  if (index < 0) {
    return;
  }
  const targetIndex = direction === "up" ? index - 1 : index + 1;
  if (targetIndex < 0 || targetIndex >= ordered.length) {
    return;
  }
  const current = ordered[index];
  const target = ordered[targetIndex];
  const currentOrder = getAccessRoleOrderValue(current, index);
  const targetOrder = getAccessRoleOrderValue(target, targetIndex);
  setAccessMessage("Atualizando ordem...");
  try {
    await Promise.all([
      dataProvider.roles.upsertRole({ ...current, order: targetOrder }),
      dataProvider.roles.upsertRole({ ...target, order: currentOrder }),
    ]);
    await refreshAccessRoles();
    setAccessMessage("Ordem atualizada.");
  } catch (error) {
    setAccessMessage(error.message || "Falha ao mover cargo.", true);
  }
}

async function ensureMaintenanceExecutePermissionForRoles() {
  if (accessRoleAutoFixRunning || accessRoleAutoFixDone) {
    return false;
  }
  if (!USE_AUTH_API || !currentUser || !canManageAccess(currentUser) || !accessWriteEnabled) {
    return false;
  }
  const rolesToFix = accessRoles.filter(roleNeedsMaintenanceExecuteFix);
  if (!rolesToFix.length) {
    accessRoleAutoFixDone = true;
    return false;
  }
  accessRoleAutoFixRunning = true;
  try {
    for (const role of rolesToFix) {
      const permissions = applyMaintenancePermissionDependencies(role.permissions || []);
      await dataProvider.roles.upsertRole({
        id: role.id,
        name: role.name || "",
        permissions,
      });
    }
    showAuthToast(
      "Permissão 'Manutenção - executar' adicionada aos cargos com 'Manutenção - criar'."
    );
    accessRoleAutoFixDone = true;
    return true;
  } catch (error) {
    showAuthToast("Não foi possível atualizar permissões de execução automaticamente.");
    return false;
  } finally {
    accessRoleAutoFixRunning = false;
  }
}

async function refreshAccessRoles(options = {}) {
  const skipEditor = Boolean(options.skipEditor);
  try {
    accessRoles = await dataProvider.roles.listRoles();
  } catch (error) {
    accessRoles = [];
  }
  if (!accessRoles.length) {
    try {
      await dataProvider.roles.seedDefaultRolesIfEmpty();
      accessRoles = await dataProvider.roles.listRoles();
    } catch (error) {
      // noop
    }
  }
  const autoFixed = await ensureMaintenanceExecutePermissionForRoles();
  if (autoFixed) {
    try {
      accessRoles = await dataProvider.roles.listRoles();
    } catch (error) {
      // noop
    }
  }
  accessRoles = accessRoles.map((role) => mergeAccessRoleLevelMarkers(role));
  syncAccessRoleLevelStorage(accessRoles);
  accessRoleMap = new Map(accessRoles.map((role) => [role.id, role]));
  renderAccessRoleSelectOptions();
  if (!skipEditor) {
    renderAccessRoleNameOptions(accessRoleId ? accessRoleId.value : "");
    updateAccessRoleRenameVisibility();
  }
  renderAccessRoles();
}

async function refreshAccessUsers() {
  if (!currentUser) {
    accessUsers = [];
    users = [];
    renderAccessUsers();
    return;
  }
  let shouldRenderAuth = false;
  try {
    const list = await dataProvider.authAdmin.listUsers();
    accessUsers = list
      .map((account) => buildSessionUser(account, resolveRoleFromAccessMap(account)))
      .filter(Boolean);
  } catch (error) {
    accessUsers = [];
  }
  users = accessUsers.slice();
  if (currentUser) {
    const updated = accessUsers.find((item) => String(item.id) === String(currentUser.id));
    if (updated) {
      if (normalizeAccessUserStatus(updated.status, updated.active) === "INATIVO") {
        salvarSessao(null);
        currentUser = null;
      } else {
        currentUser = updated;
      }
      shouldRenderAuth = true;
    }
  }
  renderAccessUsers();
  renderAccessRoles();
  if (shouldRenderAuth) {
    renderAuthUI();
  }
}

async function refreshAccessData(options = {}) {
  const force = Boolean(options.force);
  const now = Date.now();
  if (accessRefreshInFlight) {
    return accessRefreshPromise || Promise.resolve();
  }
  if (!force && now - accessRefreshLastAt < ACCESS_REFRESH_MIN_INTERVAL) {
    return;
  }
  accessRefreshLastAt = now;
  accessRefreshInFlight = true;
  accessRefreshPromise = (async () => {
    try {
      await dataProvider.roles.seedDefaultRolesIfEmpty();
    } catch (error) {
      // noop
    }
    try {
      await ensureBootstrapAccessAccount();
    } catch (error) {
      // noop
    }
    await refreshAccessRoles({ skipEditor: isAccessRoleModalOpen() });
    await refreshAccessUsers();
    await refreshAccessStorageState();
    const accessHash = syncDebugEnabled
      ? hashString(JSON.stringify({ roles: accessRoles, users: accessUsers }))
      : "";
    logSyncDebug("access.fetch", {
      roles: accessRoles.length,
      users: accessUsers.length,
      source: USE_AUTH_API ? "api" : "local",
      hash: accessHash,
    });
  })();
  try {
    await accessRefreshPromise;
  } finally {
    accessRefreshInFlight = false;
    accessRefreshPromise = null;
  }
}

function setAccessUserFormMessage(texto, erro = false) {
  if (!accessUserFormMsg) {
    return;
  }
  accessUserFormMsg.textContent = texto || "";
  accessUserFormMsg.hidden = !texto;
  accessUserFormMsg.classList.toggle("mensagem--erro", erro);
}

function getSelectedAccessUserPasswordMode() {
  const input = document.querySelector('input[name="accessUserPasswordMode"]:checked');
  return input ? input.value : "MANUAL";
}

function updateAccessUserPasswordMode() {
  if (!accessUserPassword) {
    return;
  }
  const mode = getSelectedAccessUserPasswordMode();
  const manual = mode === "MANUAL";
  accessUserPassword.disabled = !manual;
  if (!manual) {
    accessUserPassword.value = "";
  }
}

function openAccessUserModal(user = null) {
  if (!modalAccessUser || !accessUserForm) {
    return;
  }
  const editing = Boolean(user);
  if (accessUserModalTitle) {
    accessUserModalTitle.textContent = editing ? "Editar conta" : "Nova conta";
  }
  if (accessUserModalSubtitle) {
    accessUserModalSubtitle.textContent = editing
      ? "Atualize os dados do usuario."
      : "Defina os dados de acesso.";
  }
  setAccessUserFormMessage("");
  if (accessUserId) {
    accessUserId.value = editing ? user.id : "";
  }
  if (accessUserName) {
    accessUserName.value = editing ? user.name || "" : "";
  }
  if (accessUserMatricula) {
    accessUserMatricula.value = editing ? user.matricula || "" : "";
    accessUserMatricula.disabled = editing;
  }
  if (accessUserEmail) {
    accessUserEmail.value = editing ? user.email || "" : "";
  }
  renderAccessRoleSelectOptions();
  if (accessUserRole) {
    accessUserRole.value = editing ? user.roleId || "" : "";
  }
  renderAccessProjectSelectOptions();
  if (accessUserProject) {
    accessUserProject.value = editing && user.projectId ? String(user.projectId) : "";
  }
  if (accessUserStatus) {
    accessUserStatus.value = editing ? user.status || "ATIVO" : "ATIVO";
  }
  if (accessUserPasswordBlock) {
    accessUserPasswordBlock.hidden = editing;
  }
  const modeInput = document.querySelector('input[name="accessUserPasswordMode"][value="MANUAL"]');
  if (modeInput) {
    modeInput.checked = true;
  }
  if (accessUserPassword) {
    accessUserPassword.value = "";
  }
  if (accessUserPasswordHint) {
    accessUserPasswordHint.textContent = "A senha gerada sera exibida uma unica vez.";
  }
  updateAccessUserPasswordMode();
  modalAccessUser.hidden = false;
}

function closeAccessUserModal() {
  if (!modalAccessUser) {
    return;
  }
  modalAccessUser.hidden = true;
}

function setResetPasswordMessage(texto, erro = false) {
  if (!resetPasswordMsg) {
    return;
  }
  resetPasswordMsg.textContent = texto || "";
  resetPasswordMsg.hidden = !texto;
  resetPasswordMsg.classList.toggle("mensagem--erro", erro);
}

function getSelectedResetPasswordMode() {
  const input = document.querySelector('input[name="resetPasswordMode"]:checked');
  return input ? input.value : "MANUAL";
}

function updateResetPasswordMode() {
  if (!resetPasswordManualField || !resetPasswordValue) {
    return;
  }
  const mode = getSelectedResetPasswordMode();
  const manual = mode === "MANUAL";
  resetPasswordManualField.hidden = !manual;
  resetPasswordValue.disabled = !manual;
  if (!manual) {
    resetPasswordValue.value = "";
  }
}

function openResetPasswordModal(user) {
  if (!modalResetPassword || !resetPasswordForm || !user) {
    return;
  }
  if (resetPasswordUserId) {
    resetPasswordUserId.value = user.id;
  }
  if (resetPasswordUserLabel) {
    resetPasswordUserLabel.textContent = `Usuário: ${user.name || user.matricula || "-"}`;
  }
  const modeInput = document.querySelector('input[name="resetPasswordMode"][value="MANUAL"]');
  if (modeInput) {
    modeInput.checked = true;
  }
  if (resetPasswordValue) {
    resetPasswordValue.value = "";
  }
  setResetPasswordMessage("");
  updateResetPasswordMode();
  modalResetPassword.hidden = false;
}

function closeResetPasswordModal() {
  if (!modalResetPassword) {
    return;
  }
  modalResetPassword.hidden = true;
}

function showGeneratedPassword(password) {
  if (!modalGeneratedPassword || !generatedPasswordValue) {
    return;
  }
  generatedPasswordValue.textContent = password || "-";
  modalGeneratedPassword.hidden = false;
}

function closeGeneratedPasswordModal() {
  if (!modalGeneratedPassword) {
    return;
  }
  modalGeneratedPassword.hidden = true;
}

let confirmModalResolve = null;

function closeConfirmModal(result) {
  if (modalConfirm) {
    modalConfirm.hidden = true;
  }
  if (confirmModalResolve) {
    confirmModalResolve(Boolean(result));
    confirmModalResolve = null;
  }
}

function openConfirmModal(options = {}) {
  const title = options.title || "Confirmar a\u00e7\u00e3o";
  const message = options.message || "";
  const confirmText = options.confirmText || "Confirmar";
  const cancelText = options.cancelText || "Cancelar";
  if (!modalConfirm) {
    return Promise.resolve(window.confirm(message || title));
  }
  if (confirmModalResolve) {
    confirmModalResolve(false);
    confirmModalResolve = null;
  }
  if (modalConfirmTitle) {
    modalConfirmTitle.textContent = title;
  }
  if (modalConfirmMessage) {
    modalConfirmMessage.textContent = message;
  }
  if (btnConfirmOk) {
    btnConfirmOk.textContent = confirmText;
  }
  if (btnConfirmCancel) {
    btnConfirmCancel.textContent = cancelText;
  }
  modalConfirm.hidden = false;
  return new Promise((resolve) => {
    confirmModalResolve = resolve;
  });
}

function showAuthToast(message) {
  if (!authToast) {
    return;
  }
  authToast.textContent = message || "";
  authToast.classList.add("is-visible");
  if (authToastTimeout) {
    window.clearTimeout(authToastTimeout);
  }
  authToastTimeout = window.setTimeout(() => {
    authToast.classList.remove("is-visible");
    authToastTimeout = null;
  }, 2000);
}

if (authToast) {
  scheduleExecucaoRegistradaAlerts();
}

function updatePasswordResetCooldown() {
  if (!btnPasswordResetSendCode) {
    return;
  }
  const remaining = Math.max(
    0,
    Math.ceil((passwordResetCooldownUntil - Date.now()) / 1000)
  );
  if (!remaining) {
    if (passwordResetCooldownTimer) {
      window.clearInterval(passwordResetCooldownTimer);
      passwordResetCooldownTimer = null;
    }
    btnPasswordResetSendCode.disabled = false;
    btnPasswordResetSendCode.textContent = "Enviar codigo";
    return;
  }
  btnPasswordResetSendCode.disabled = true;
  btnPasswordResetSendCode.textContent = `Reenviar (${remaining}s)`;
}

function startPasswordResetCooldown(seconds) {
  if (!btnPasswordResetSendCode) {
    return;
  }
  const safeSeconds = Math.max(0, Number(seconds) || 0);
  if (!safeSeconds) {
    passwordResetCooldownUntil = 0;
    updatePasswordResetCooldown();
    return;
  }
  passwordResetCooldownUntil = Date.now() + safeSeconds * 1000;
  updatePasswordResetCooldown();
  if (passwordResetCooldownTimer) {
    window.clearInterval(passwordResetCooldownTimer);
  }
  passwordResetCooldownTimer = window.setInterval(updatePasswordResetCooldown, 1000);
}

function setPasswordResetCodeValidated(validated) {
  passwordResetCodeValidated = Boolean(validated);
  const enabled = passwordResetCodeValidated;
  if (passwordResetNew) {
    passwordResetNew.disabled = !enabled;
  }
  if (passwordResetConfirm) {
    passwordResetConfirm.disabled = !enabled;
  }
  if (btnPasswordResetSubmit) {
    btnPasswordResetSubmit.disabled = !enabled;
  }
}

function setPasswordResetCodeSent(sent) {
  passwordResetCodeSent = Boolean(sent);
  if (!passwordResetCodeSent) {
    setPasswordResetCodeValidated(false);
  }
  const enabled = passwordResetCodeSent;
  if (passwordResetCode) {
    passwordResetCode.disabled = !enabled;
  }
  if (btnPasswordResetValidate) {
    const codeValue = passwordResetCode ? passwordResetCode.value.trim() : "";
    btnPasswordResetValidate.disabled = !enabled || !codeValue;
  }
}

function openPasswordResetModal(prefillEmail = "") {
  if (!modalPasswordReset) {
    return;
  }
  if (modalAccessHelp && !modalAccessHelp.hidden) {
    closeAccessHelpModal();
  }
  modalPasswordReset.hidden = false;
  setPasswordResetMessage("");
  if (passwordResetCode) {
    passwordResetCode.value = "";
  }
  if (passwordResetNew) {
    passwordResetNew.value = "";
  }
  if (passwordResetConfirm) {
    passwordResetConfirm.value = "";
  }
  const currentEmail = passwordResetEmail ? passwordResetEmail.value.trim() : "";
  const candidate = normalizeVerificationEmail(prefillEmail);
  if (passwordResetEmail && !currentEmail && candidate && isValidEmail(candidate)) {
    passwordResetEmail.value = candidate;
  }
  setPasswordResetCodeSent(false);
  updatePasswordResetCooldown();
  if (passwordResetEmail) {
    passwordResetEmail.focus();
  }
  if (
    passwordResetEmail &&
    passwordResetEmail.value &&
    passwordResetCode &&
    !passwordResetCode.disabled
  ) {
    passwordResetCode.focus();
  }
}

function closePasswordResetModal() {
  if (!modalPasswordReset) {
    return;
  }
  modalPasswordReset.hidden = true;
  if (passwordResetCode) {
    passwordResetCode.value = "";
  }
  if (passwordResetNew) {
    passwordResetNew.value = "";
  }
  if (passwordResetConfirm) {
    passwordResetConfirm.value = "";
  }
  setPasswordResetCodeSent(false);
  setPasswordResetMessage("");
}

function openAccessHelpModal() {
  if (!modalAccessHelp) {
    return;
  }
  modalAccessHelp.hidden = false;
}

function closeAccessHelpModal() {
  if (!modalAccessHelp) {
    return;
  }
  modalAccessHelp.hidden = true;
}

function copyTextToClipboard(text) {
  if (!text) {
    return Promise.resolve(false);
  }
  if (navigator.clipboard && navigator.clipboard.writeText) {
    return navigator.clipboard
      .writeText(text)
      .then(() => true)
      .catch(() => false);
  }
  try {
    const textarea = document.createElement("textarea");
    textarea.value = text;
    textarea.style.position = "fixed";
    textarea.style.left = "-9999px";
    document.body.append(textarea);
    textarea.select();
    const ok = document.execCommand("copy");
    textarea.remove();
    return Promise.resolve(Boolean(ok));
  } catch (error) {
    return Promise.resolve(false);
  }
}

async function handleAccessHelpCopy(kind) {
  const message = ACCESS_HELP_MESSAGES[kind] || "";
  const copied = await copyTextToClipboard(message);
  showAuthToast(copied ? "Copiado!" : "N\u00e3o foi poss\u00edvel copiar.");
}

function expandAccessPermissions(list = []) {
  const normalized = normalizeAccessPermissionList(list);
  const expanded = new Set(normalized);
  const granular = mapAccessPermissionsToGranular(normalized);
  Object.keys(granular).forEach((key) => {
    if (granular[key]) {
      expanded.add(key);
    }
  });
  if (expanded.has("ADMIN")) {
    ACCESS_PERMISSION_KEYS_VISIBLE.forEach((key) => expanded.add(key));
    expanded.add("ADMIN");
  }
  return expanded;
}

function initAccessRoleEditorState(selected = [], roleId = "") {
  const normalized = normalizeAccessPermissionList(selected);
  const expanded = expandAccessPermissions(normalized);
  const adminEnabled = expanded.has("ADMIN");
  accessRoleEditorState = {
    ...accessRoleEditorState,
    roleId: roleId || "",
    baseline: normalized,
    selected: expanded,
    adminSnapshot: adminEnabled ? normalized.filter((key) => key !== "ADMIN") : null,
    adminEnabled,
    activeModule: ACCESS_PERMISSION_MODULES.length ? ACCESS_PERMISSION_MODULES[0].name : "",
    query: "",
    onlySelected: false,
    onlyCritical: false,
    onlyRead: false,
    onlyWrite: false,
    renameMode: false,
  };
  if (accessRolePermissionSearch) {
    accessRolePermissionSearch.value = "";
  }
  renderAccessRolePermissions();
}

function getAccessRoleEffectiveSelected() {
  if (accessRoleEditorState.adminEnabled) {
    return new Set(ACCESS_PERMISSION_KEYS_VISIBLE);
  }
  return new Set(accessRoleEditorState.selected || []);
}

function setAccessRoleToggleState(element, active) {
  if (!element) {
    return;
  }
  element.classList.toggle("is-active", active);
  element.setAttribute("aria-pressed", active ? "true" : "false");
}

function setAccessRoleButtonDisabled(element, disabled) {
  if (!element) {
    return;
  }
  element.disabled = disabled;
  element.classList.toggle("is-disabled", disabled);
}

function filterAccessRolePermissions(list, effectiveSelected) {
  const query = normalizeSearchValue(accessRoleEditorState.query || "");
  return (list || []).filter((permission) => {
    if (!permission || permission.hidden) {
      return false;
    }
    const searchText = normalizeSearchValue(getAccessPermissionSearchText(permission));
    if (query && !searchText.includes(query)) {
      return false;
    }
    if (accessRoleEditorState.onlySelected && !effectiveSelected.has(permission.key)) {
      return false;
    }
    if (accessRoleEditorState.onlyCritical && !permission.dangerous) {
      return false;
    }
    const level = permission.level || "READ";
    if (accessRoleEditorState.onlyRead && level !== "READ") {
      return false;
    }
    if (accessRoleEditorState.onlyWrite && level === "READ") {
      return false;
    }
    return true;
  });
}

function buildAccessRolePermissionItem(permission, checked, disabled) {
  const label = document.createElement("label");
  label.className = `access-role-permission${checked ? " is-checked" : ""}`;
  const checkbox = document.createElement("input");
  checkbox.type = "checkbox";
  checkbox.dataset.permissionKey = permission.key;
  checkbox.checked = checked;
  checkbox.disabled = disabled;
  const content = document.createElement("div");
  const title = document.createElement("div");
  title.className = "access-role-permission__title";
  const name = document.createElement("span");
  name.textContent = formatAccessText(permission.label || permission.key);
  const level = document.createElement("span");
  const levelValue = permission.level || "READ";
  const levelClass = String(levelValue).toLowerCase();
  level.className = `perm-badge perm-badge--${levelClass}`;
  level.textContent = ACCESS_LEVEL_LABELS[levelValue] || levelValue;
  title.append(name, level);
  if (permission.dangerous) {
    const danger = document.createElement("span");
    danger.className = "perm-badge perm-badge--danger";
    danger.textContent = "CR\u00cdTICO";
    title.append(danger);
  }
  if (permission.legacy) {
    const legacy = document.createElement("span");
    legacy.className = "perm-badge perm-badge--legacy";
    legacy.textContent = "LEGADO";
    title.append(legacy);
  }
  content.append(title);
  if (permission.description) {
    const desc = document.createElement("p");
    desc.className = "access-role-permission__desc";
    desc.textContent = formatAccessText(permission.description);
    content.append(desc);
  }
  label.append(checkbox, content);
  return label;
}

function renderAccessRoleGroups(container, module, effectiveSelected) {
  if (!container) {
    return;
  }
  container.innerHTML = "";
  let rendered = false;
  Object.entries(module.groups || {}).forEach(([groupName, items]) => {
    const filtered = filterAccessRolePermissions(items, effectiveSelected);
    if (!filtered.length) {
      return;
    }
    rendered = true;
    const details = document.createElement("details");
    details.className = "access-role-group";
    details.open = true;
    const summary = document.createElement("summary");
    const title = document.createElement("span");
    title.textContent = getAccessGroupLabel(groupName);
    const count = document.createElement("span");
    count.className = "access-role-count";
    const selectedCount = filtered.filter((permission) =>
      effectiveSelected.has(permission.key)
    ).length;
    count.textContent = `${selectedCount}/${filtered.length}`;
    summary.append(title, count);
    const list = document.createElement("div");
    list.className = "access-role-group__list";
    const disabled = accessRoleEditorState.adminEnabled;
    filtered.forEach((permission) => {
      const checked = effectiveSelected.has(permission.key);
      list.append(buildAccessRolePermissionItem(permission, checked, disabled));
    });
    details.append(summary, list);
    container.append(details);
  });
  if (!rendered) {
    const empty = document.createElement("div");
    empty.className = "access-role-empty";
    empty.textContent = "Nenhuma permiss\u00e3o encontrada com esses filtros.";
    container.append(empty);
  }
}

function renderAccessRolePermissions() {
  if (!accessRoleEditor || !accessRolePermissions) {
    return;
  }
  const effectiveSelected = getAccessRoleEffectiveSelected();
  const totalCount = ACCESS_PERMISSION_KEYS_VISIBLE.length;
  const selectedCount = Array.from(effectiveSelected).length;
  if (accessRoleSelectedCount) {
    accessRoleSelectedCount.textContent = `${selectedCount} selecionadas`;
  }
  if (accessRolePermissionsSummary) {
    accessRolePermissionsSummary.textContent = `Total: ${selectedCount}/${totalCount} permiss\u00f5es selecionadas.`;
  }
  if (accessRoleAdminToggle) {
    accessRoleAdminToggle.checked = accessRoleEditorState.adminEnabled;
  }
  if (accessRoleAdminNotice) {
    accessRoleAdminNotice.hidden = !accessRoleEditorState.adminEnabled;
  }
  setAccessRoleToggleState(accessRoleFilterSelected, accessRoleEditorState.onlySelected);
  setAccessRoleToggleState(accessRoleFilterCritical, accessRoleEditorState.onlyCritical);
  setAccessRoleToggleState(accessRoleFilterRead, accessRoleEditorState.onlyRead);
  setAccessRoleToggleState(accessRoleFilterWrite, accessRoleEditorState.onlyWrite);
  const disableActions = accessRoleEditorState.adminEnabled;
  const readKeys = getAccessReadPermissionKeys(ACCESS_PERMISSION_CATALOG);
  const writeKeys = getAccessWritePermissionKeys(ACCESS_PERMISSION_CATALOG);
  const readWriteKeys = getAccessReadWritePermissionKeys(ACCESS_PERMISSION_CATALOG);
  setAccessRoleButtonDisabled(accessRoleSelectAll, disableActions);
  setAccessRoleButtonDisabled(accessRoleClearAll, disableActions);
  setAccessRoleButtonDisabled(accessRoleReadOnly, disableActions || readKeys.length === 0);
  setAccessRoleButtonDisabled(accessRoleWriteOnly, disableActions || writeKeys.length === 0);
  setAccessRoleButtonDisabled(accessRoleReadWrite, disableActions || readWriteKeys.length === 0);
  setAccessRoleButtonDisabled(accessRoleModuleToggle, disableActions);
  setAccessRoleButtonDisabled(accessRoleModuleReadOnly, disableActions);
  setAccessRoleButtonDisabled(accessRoleModuleWriteOnly, disableActions);
  setAccessRoleButtonDisabled(accessRoleModuleReadWrite, disableActions);

  if (accessRoleModules) {
    accessRoleModules.innerHTML = "";
    ACCESS_PERMISSION_MODULES.forEach((module) => {
      const total = module.permissions.length;
      const selected = module.permissions.filter((permission) =>
        effectiveSelected.has(permission.key)
      ).length;
      const button = document.createElement("button");
      button.type = "button";
      button.className = `access-role-module-btn${
        accessRoleEditorState.activeModule === module.name ? " is-active" : ""
      }`;
      button.dataset.roleModule = module.name;
      const name = document.createElement("span");
      name.textContent = getAccessModuleLabel(module.name);
      const count = document.createElement("span");
      count.className = "access-role-count";
      count.textContent = `${selected}/${total}`;
      button.append(name, count);
      accessRoleModules.append(button);
    });
  }

  const activeModule =
    ACCESS_PERMISSION_MODULES.find((module) => module.name === accessRoleEditorState.activeModule) ||
    ACCESS_PERMISSION_MODULES[0];
  if (!activeModule) {
    return;
  }
  accessRoleEditorState.activeModule = activeModule.name;
  const moduleTotal = activeModule.permissions.length;
  const moduleSelected = activeModule.permissions.filter((permission) =>
    effectiveSelected.has(permission.key)
  ).length;
  if (accessRoleModuleTitle) {
    accessRoleModuleTitle.textContent = getAccessModuleLabel(activeModule.name);
  }
  if (accessRoleModuleCount) {
    accessRoleModuleCount.textContent = `${moduleSelected}/${moduleTotal}`;
  }
  if (accessRoleModuleToggle) {
    accessRoleModuleToggle.dataset.moduleAction = "toggle-all";
    accessRoleModuleToggle.dataset.moduleName = activeModule.name;
    const allSelected = activeModule.permissions.every((permission) =>
      effectiveSelected.has(permission.key)
    );
    accessRoleModuleToggle.classList.toggle("is-active", allSelected);
  }
  if (accessRoleModuleReadOnly) {
    accessRoleModuleReadOnly.dataset.moduleAction = "read-only";
    accessRoleModuleReadOnly.dataset.moduleName = activeModule.name;
    const readKeys = getAccessReadPermissionKeys(ACCESS_PERMISSION_CATALOG, activeModule.name);
    setAccessRoleButtonDisabled(accessRoleModuleReadOnly, disableActions || readKeys.length === 0);
  }
  if (accessRoleModuleWriteOnly) {
    accessRoleModuleWriteOnly.dataset.moduleAction = "write-only";
    accessRoleModuleWriteOnly.dataset.moduleName = activeModule.name;
    const writeKeys = getAccessWritePermissionKeys(ACCESS_PERMISSION_CATALOG, activeModule.name);
    setAccessRoleButtonDisabled(
      accessRoleModuleWriteOnly,
      disableActions || writeKeys.length === 0
    );
  }
  if (accessRoleModuleReadWrite) {
    accessRoleModuleReadWrite.dataset.moduleAction = "read-write";
    accessRoleModuleReadWrite.dataset.moduleName = activeModule.name;
    const readWriteKeys = getAccessReadWritePermissionKeys(
      ACCESS_PERMISSION_CATALOG,
      activeModule.name
    );
    setAccessRoleButtonDisabled(
      accessRoleModuleReadWrite,
      disableActions || readWriteKeys.length === 0
    );
  }
  renderAccessRoleGroups(accessRolePermissions, activeModule, effectiveSelected);

  if (accessRoleModulesMobile) {
    accessRoleModulesMobile.innerHTML = "";
    ACCESS_PERMISSION_MODULES.forEach((module) => {
      const total = module.permissions.length;
      const selected = module.permissions.filter((permission) =>
        effectiveSelected.has(permission.key)
      ).length;
      const moduleLabel = getAccessModuleLabel(module.name);
      const details = document.createElement("details");
      details.className = "access-role-module";
      details.open = module.name === accessRoleEditorState.activeModule;
      details.dataset.roleModule = module.name;
      const summary = document.createElement("summary");
      const title = document.createElement("span");
      title.textContent = moduleLabel;
      const count = document.createElement("span");
      count.className = "access-role-count";
      count.textContent = `${selected}/${total}`;
      summary.append(title, count);
      const body = document.createElement("div");
      body.className = "access-role-module__body";
      const header = document.createElement("div");
      header.className = "access-role-module__header";
      const headerInfo = document.createElement("div");
      const headerTitle = document.createElement("h4");
      headerTitle.textContent = moduleLabel;
      const headerCount = document.createElement("span");
      headerCount.className = "access-role-count";
      headerCount.textContent = `${selected}/${total} selecionadas`;
      headerInfo.append(headerTitle, headerCount);
      const actions = document.createElement("div");
      actions.className = "access-role-module-actions";
      const btnAll = document.createElement("button");
      btnAll.type = "button";
      btnAll.className = "btn btn--ghost btn--small";
      btnAll.dataset.moduleAction = "toggle-all";
      btnAll.dataset.moduleName = module.name;
      btnAll.textContent = "Habilitar tudo";
      btnAll.disabled = disableActions;
      const btnRead = document.createElement("button");
      btnRead.type = "button";
      btnRead.className = "btn btn--ghost btn--small";
      btnRead.dataset.moduleAction = "read-only";
      btnRead.dataset.moduleName = module.name;
      btnRead.textContent = "Ver do m\u00f3dulo";
      const moduleReadKeys = getAccessReadPermissionKeys(ACCESS_PERMISSION_CATALOG, module.name);
      btnRead.disabled = disableActions || moduleReadKeys.length === 0;
      const btnWrite = document.createElement("button");
      btnWrite.type = "button";
      btnWrite.className = "btn btn--ghost btn--small";
      btnWrite.dataset.moduleAction = "write-only";
      btnWrite.dataset.moduleName = module.name;
      btnWrite.textContent = "Editar do m\u00f3dulo";
      const moduleWriteKeys = getAccessWritePermissionKeys(ACCESS_PERMISSION_CATALOG, module.name);
      btnWrite.disabled = disableActions || moduleWriteKeys.length === 0;
      const btnReadWrite = document.createElement("button");
      btnReadWrite.type = "button";
      btnReadWrite.className = "btn btn--ghost btn--small";
      btnReadWrite.dataset.moduleAction = "read-write";
      btnReadWrite.dataset.moduleName = module.name;
      btnReadWrite.textContent = "Ver e editar do m\u00f3dulo";
      const moduleReadWriteKeys = getAccessReadWritePermissionKeys(
        ACCESS_PERMISSION_CATALOG,
        module.name
      );
      btnReadWrite.disabled = disableActions || moduleReadWriteKeys.length === 0;
      actions.append(btnAll, btnRead, btnWrite, btnReadWrite);
      header.append(headerInfo, actions);
      body.append(header);
      const groups = document.createElement("div");
      groups.className = "access-role-groups";
      renderAccessRoleGroups(groups, module, effectiveSelected);
      body.append(groups);
      details.append(summary, body);
      accessRoleModulesMobile.append(details);
    });
  }
}

function collectAccessRolePermissions() {
  if (accessRoleEditorState.adminEnabled) {
    return ["ADMIN"];
  }
  const selected = Array.from(accessRoleEditorState.selected || []).filter((key) => key !== "ADMIN");
  return applyMaintenancePermissionDependencies(selected);
}

function setAccessRoleSelection(list) {
  const expanded = expandAccessPermissions(list);
  accessRoleEditorState.selected = expanded;
  accessRoleEditorState.adminEnabled = expanded.has("ADMIN");
  renderAccessRolePermissions();
}

function setAccessRoleNameMode(enabled) {
  accessRoleEditorState.renameMode = enabled;
  if (accessRoleNameField) {
    accessRoleNameField.hidden = !enabled;
  }
  if (accessRoleName) {
    accessRoleName.disabled = !enabled;
    accessRoleName.required = enabled;
  }
  if (btnAccessRoleRename) {
    btnAccessRoleRename.textContent = enabled ? "Usar sele\u00e7\u00e3o" : "Editar nome";
  }
}

function updateAccessRoleRenameVisibility() {
  if (!btnAccessRoleRename || !accessRoleSelect) {
    return;
  }
  const isNew = accessRoleSelect.value === "__new__";
  btnAccessRoleRename.hidden = isNew;
}

function selectAccessRole(role) {
  if (!role) {
    return;
  }
  if (accessRoleId) {
    accessRoleId.value = role.id;
  }
  if (accessRoleName) {
    accessRoleName.value = role.name || "";
  }
  setAccessRoleNameMode(false);
  updateAccessRoleRenameVisibility();
  initAccessRoleEditorState(role.permissions || [], role.id);
}

function resetAccessRoleToNew() {
  if (accessRoleId) {
    accessRoleId.value = "";
  }
  if (accessRoleName) {
    accessRoleName.value = "";
  }
  if (accessRoleModalTitle) {
    accessRoleModalTitle.textContent = "Novo cargo";
  }
  if (accessRoleModalSubtitle) {
    accessRoleModalSubtitle.textContent = "Defina o nome e permiss\u00f5es do cargo.";
  }
  setAccessRoleNameMode(true);
  updateAccessRoleRenameVisibility();
  initAccessRoleEditorState([], "");
}

function toggleAccessRoleAdmin(enabled) {
  if (enabled) {
    accessRoleEditorState.adminSnapshot = Array.from(accessRoleEditorState.selected || []).filter(
      (key) => key !== "ADMIN"
    );
    const next = new Set(ACCESS_PERMISSION_KEYS_ALL);
    next.add("ADMIN");
    accessRoleEditorState.selected = next;
    accessRoleEditorState.adminEnabled = true;
  } else {
    const restore = accessRoleEditorState.adminSnapshot || [];
    accessRoleEditorState.selected = expandAccessPermissions(
      restore.filter((key) => key !== "ADMIN")
    );
    accessRoleEditorState.adminSnapshot = null;
    accessRoleEditorState.adminEnabled = false;
  }
  renderAccessRolePermissions();
}

function setAccessRolePermissionState(key, enabled) {
  if (!key || accessRoleEditorState.adminEnabled) {
    return;
  }
  const next = new Set(accessRoleEditorState.selected || []);
  if (enabled) {
    next.add(key);
  } else {
    next.delete(key);
  }
  setAccessRoleSelection(Array.from(next));
}

function applyAccessRoleSelectAll() {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  setAccessRoleSelection(ACCESS_PERMISSION_KEYS_VISIBLE);
}

function applyAccessRoleClearAll() {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  setAccessRoleSelection([]);
}

function applyAccessRoleReadOnly() {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const readKeys = getAccessReadPermissionKeys(ACCESS_PERMISSION_CATALOG);
  setAccessRoleSelection(readKeys);
}

function applyAccessRoleWriteOnly() {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const writeKeys = getAccessWritePermissionKeys(ACCESS_PERMISSION_CATALOG);
  setAccessRoleSelection(writeKeys);
}

function applyAccessRoleReadWrite() {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const readWriteKeys = getAccessReadWritePermissionKeys(ACCESS_PERMISSION_CATALOG);
  setAccessRoleSelection(readWriteKeys);
}

function applyAccessRoleModuleAll(moduleName) {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const module = ACCESS_PERMISSION_MODULES.find((item) => item.name === moduleName);
  if (!module) {
    return;
  }
  const effectiveSelected = getAccessRoleEffectiveSelected();
  const keys = module.permissions.map((permission) => permission.key);
  const next = new Set(accessRoleEditorState.selected || []);
  const allSelected = keys.every((key) => effectiveSelected.has(key));
  if (allSelected) {
    keys.forEach((key) => next.delete(key));
  } else {
    keys.forEach((key) => next.add(key));
  }
  setAccessRoleSelection(Array.from(next));
}

function applyAccessRoleModuleReadOnly(moduleName) {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const module = ACCESS_PERMISSION_MODULES.find((item) => item.name === moduleName);
  if (!module) {
    return;
  }
  const readKeys = getAccessReadPermissionKeys(ACCESS_PERMISSION_CATALOG, module.name);
  const keys = module.permissions.map((permission) => permission.key);
  const next = new Set(accessRoleEditorState.selected || []);
  keys.forEach((key) => next.delete(key));
  readKeys.forEach((key) => next.add(key));
  setAccessRoleSelection(Array.from(next));
}

function applyAccessRoleModuleWriteOnly(moduleName) {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const module = ACCESS_PERMISSION_MODULES.find((item) => item.name === moduleName);
  if (!module) {
    return;
  }
  const writeKeys = getAccessWritePermissionKeys(ACCESS_PERMISSION_CATALOG, module.name);
  const keys = module.permissions.map((permission) => permission.key);
  const next = new Set(accessRoleEditorState.selected || []);
  keys.forEach((key) => next.delete(key));
  writeKeys.forEach((key) => next.add(key));
  setAccessRoleSelection(Array.from(next));
}

function applyAccessRoleModuleReadWrite(moduleName) {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const module = ACCESS_PERMISSION_MODULES.find((item) => item.name === moduleName);
  if (!module) {
    return;
  }
  const readWriteKeys = getAccessReadWritePermissionKeys(ACCESS_PERMISSION_CATALOG, module.name);
  const keys = module.permissions.map((permission) => permission.key);
  const next = new Set(accessRoleEditorState.selected || []);
  keys.forEach((key) => next.delete(key));
  readWriteKeys.forEach((key) => next.add(key));
  setAccessRoleSelection(Array.from(next));
}

function setAccessRoleActiveModule(moduleName) {
  if (!moduleName) {
    return;
  }
  accessRoleEditorState.activeModule = moduleName;
  renderAccessRolePermissions();
}

function isAccessRoleAdminKey(key) {
  return ACCESS_ROLE_ADMIN_KEYS.includes(key);
}

function hasAccessRoleAdmin(list = []) {
  const normalized = normalizeAccessRoleKeys(list);
  return ACCESS_ROLE_ADMIN_KEYS.some((key) => normalized.includes(key));
}

function getAccessRoleAdminKey(list = []) {
  const normalized = normalizeAccessRoleKeys(list);
  if (normalized.includes("ADMIN_TOTAL")) {
    return "ADMIN_TOTAL";
  }
  if (normalized.includes("ADMIN")) {
    return "ADMIN";
  }
  return "ADMIN";
}

function getAccessRoleItemLevel(keysSet, item) {
  const keys = keysSet instanceof Set ? keysSet : new Set(keysSet || []);
  const editKeys = item.editKeys || [];
  const viewKeys = item.viewKeys || [];
  const viewOnly = editKeys.length === 0;
  const editMarker = viewOnly ? buildAccessRoleLevelKey(item.key) : "";
  const hasEditMarker = editMarker ? keys.has(editMarker) : false;
  if (editKeys.length && editKeys.some((key) => keys.has(key))) {
    return "EDIT";
  }
  if (viewOnly && hasEditMarker) {
    return "EDIT";
  }
  if (viewKeys.some((key) => keys.has(key))) {
    return "VIEW";
  }
  return "NONE";
}

function setAccessRoleItemLevel(keysSet, item, level) {
  const next = new Set(keysSet instanceof Set ? keysSet : new Set(keysSet || []));
  const viewKeys = item.viewKeys || [];
  const editKeys = item.editKeys || [];
  const viewOnly = editKeys.length === 0;
  const editMarker = viewOnly ? buildAccessRoleLevelKey(item.key) : "";
  [...viewKeys, ...editKeys].forEach((key) => next.delete(key));
  if (level === "VIEW") {
    viewKeys.forEach((key) => next.add(key));
  }
  if (level === "EDIT") {
    viewKeys.forEach((key) => next.add(key));
    editKeys.forEach((key) => next.add(key));
  }
  if (editMarker) {
    if (level === "EDIT") {
      next.add(editMarker);
    } else {
      next.delete(editMarker);
    }
  }
  return next;
}

function getAccessRoleUnknownKeys(list = []) {
  const normalized = normalizeAccessRoleKeys(list);
  return normalized.filter(
    (key) => !ACCESS_ROLE_KNOWN_KEYS.has(key) && !isAccessRoleLevelKey(key)
  );
}

function diffAccessRoleKeys(before = [], after = []) {
  const beforeSet = new Set(normalizeAccessRoleKeys(before));
  const afterSet = new Set(normalizeAccessRoleKeys(after));
  const changedItems = [];
  ACCESS_ROLE_ITEMS.forEach((item) => {
    const beforeLevel = getAccessRoleItemLevel(beforeSet, item);
    const afterLevel = getAccessRoleItemLevel(afterSet, item);
    if (beforeLevel !== afterLevel) {
      changedItems.push({ item, from: beforeLevel, to: afterLevel });
    }
  });
  const addedKeys = Array.from(afterSet).filter((key) => !beforeSet.has(key));
  const removedKeys = Array.from(beforeSet).filter((key) => !afterSet.has(key));
  return { changedItems, addedKeys, removedKeys };
}

function filterAccessRoleItems(items, effectiveSelected) {
  const query = normalizeSearchValue(accessRoleEditorState.query || "");
  return (items || []).filter((item) => {
    const searchText = normalizeSearchValue(getAccessRoleItemSearchText(item));
    if (query && !searchText.includes(query)) {
      return false;
    }
    const level = getAccessRoleItemLevel(effectiveSelected, item);
    if (accessRoleEditorState.onlyConfigured && level === "NONE") {
      return false;
    }
    if (accessRoleEditorState.onlyCritical && !item.dangerous) {
      return false;
    }
    return true;
  });
}

function getAccessRoleModuleLevel(items, effectiveSelected) {
  if (!items.length) {
    return "NONE";
  }
  const levels = items.map((item) => getAccessRoleItemLevel(effectiveSelected, item));
  const allNone = levels.every((level) => level === "NONE");
  if (allNone) {
    return "NONE";
  }
  const allMax = items.every((item) => {
    const level = getAccessRoleItemLevel(effectiveSelected, item);
    if (!item.editKeys || item.editKeys.length === 0) {
      return level === "VIEW" || level === "EDIT";
    }
    return level === "EDIT";
  });
  if (allMax) {
    return "EDIT";
  }
  const allConfigured = levels.every((level) => level !== "NONE");
  if (allConfigured) {
    return "VIEW";
  }
  return "MIXED";
}

function getAccessRoleLevelBadgeClass(level) {
  if (level === "VIEW") {
    return "perm-badge--read";
  }
  if (level === "EDIT") {
    return "perm-badge--write";
  }
  return "perm-badge--none";
}

function initAccessRoleEditorState(selected = [], roleId = "") {
  const normalized = normalizeAccessRoleKeys(selected);
  const manualLevels = {};
  normalized.forEach((key) => {
    const itemKey = getAccessRoleLevelItemKey(key);
    if (itemKey) {
      manualLevels[itemKey] = "EDIT";
    }
  });
  const adminEnabled = hasAccessRoleAdmin(normalized);
  const adminKey = getAccessRoleAdminKey(normalized);
  let expanded = new Set(normalized);
  let snapshot = null;
  if (adminEnabled) {
    snapshot = normalized.filter((key) => !isAccessRoleAdminKey(key));
    expanded = new Set(snapshot);
    ACCESS_ROLE_KNOWN_KEYS.forEach((key) => expanded.add(key));
    expanded.add(adminKey);
  }
  accessRoleEditorState = {
    ...accessRoleEditorState,
    roleId: roleId || "",
    baseline: normalized,
    selected: expanded,
    manualLevels,
    adminSnapshot: adminEnabled ? snapshot : null,
    adminEnabled,
    activeModule: ACCESS_ROLE_MODULES.length ? ACCESS_ROLE_MODULES[0].name : "",
    query: "",
    onlyConfigured: false,
    onlyCritical: false,
    renameMode: false,
    showChanges: false,
  };
  if (accessRolePermissionSearch) {
    accessRolePermissionSearch.value = "";
  }
  renderAccessRolePermissions();
}

function getAccessRoleEffectiveSelected() {
  const effective = new Set(accessRoleEditorState.selected || []);
  if (accessRoleEditorState.adminEnabled) {
    ACCESS_ROLE_KNOWN_KEYS.forEach((key) => effective.add(key));
  }
  return effective;
}

function collectAccessRolePermissions() {
  const normalized = normalizeAccessRoleKeys(accessRoleEditorState.selected || []);
  const adminKey = getAccessRoleAdminKey(normalized);
  if (accessRoleEditorState.adminEnabled) {
    const unknown = normalized.filter(
      (key) =>
        !ACCESS_ROLE_KNOWN_KEYS.has(key) &&
        !isAccessRoleAdminKey(key) &&
        !isAccessRoleLevelKey(key)
    );
    return Array.from(new Set([adminKey, ...unknown]));
  }
  return normalized;
}

function setAccessRoleSelection(list) {
  const normalized = normalizeAccessRoleKeys(list);
  const adminEnabled = hasAccessRoleAdmin(normalized);
  const selected = new Set(normalized);
  if (adminEnabled) {
    ACCESS_ROLE_KNOWN_KEYS.forEach((key) => selected.add(key));
  }
  accessRoleEditorState.selected = selected;
  accessRoleEditorState.adminEnabled = adminEnabled;
  renderAccessRolePermissions();
}

async function confirmAccessRoleCriticalChanges(items, level, currentKeys) {
  const currentSet = currentKeys instanceof Set ? currentKeys : new Set(currentKeys || []);
  const criticalItems = (items || []).filter((item) => {
    if (!item.dangerous) {
      return false;
    }
    const currentLevel = getAccessRoleItemLevel(currentSet, item);
    if (!item.editKeys || item.editKeys.length === 0) {
      return level !== "NONE" && currentLevel === "NONE";
    }
    return level === "EDIT" && currentLevel !== "EDIT";
  });
  if (!criticalItems.length) {
    return true;
  }
  const labels = criticalItems
    .map((item) => formatAccessText(item.label || item.key))
    .join(", ");
  const quantidade = criticalItems.length;
  const permLabel = quantidade === 1 ? "permiss\u00e3o cr\u00edtica" : "permiss\u00f5es cr\u00edticas";
  const confirm = await openConfirmModal({
    title: "Permiss\u00e3o cr\u00edtica",
    message: `Voc\u00ea est\u00e1 habilitando ${quantidade} ${permLabel}: ${labels}. Deseja continuar?`,
    confirmText: "Confirmar",
    cancelText: "Cancelar",
  });
  return confirm;
}

async function applyAccessRoleGlobalLevel(level) {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const manualLevels = { ...(accessRoleEditorState.manualLevels || {}) };
  const currentKeys = new Set(accessRoleEditorState.selected || []);
  const confirm = await confirmAccessRoleCriticalChanges(ACCESS_ROLE_ITEMS, level, currentKeys);
  if (!confirm) {
    return;
  }
  let next = new Set(currentKeys);
  ACCESS_ROLE_ITEMS.forEach((item) => {
    next = setAccessRoleItemLevel(next, item, level);
    if (!item.editKeys || item.editKeys.length === 0) {
      if (level === "EDIT") {
        manualLevels[item.key] = "EDIT";
      } else if (level === "VIEW") {
        manualLevels[item.key] = "VIEW";
      } else {
        delete manualLevels[item.key];
      }
    }
  });
  accessRoleEditorState.manualLevels = manualLevels;
  setAccessRoleSelection(Array.from(next));
}

async function applyAccessRoleModuleLevel(moduleName, level) {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const module = ACCESS_ROLE_MODULES.find((item) => item.name === moduleName);
  if (!module) {
    return;
  }
  const manualLevels = { ...(accessRoleEditorState.manualLevels || {}) };
  const currentKeys = new Set(accessRoleEditorState.selected || []);
  const confirm = await confirmAccessRoleCriticalChanges(module.items, level, currentKeys);
  if (!confirm) {
    return;
  }
  let next = new Set(currentKeys);
  module.items.forEach((item) => {
    next = setAccessRoleItemLevel(next, item, level);
    if (!item.editKeys || item.editKeys.length === 0) {
      if (level === "EDIT") {
        manualLevels[item.key] = "EDIT";
      } else if (level === "VIEW") {
        manualLevels[item.key] = "VIEW";
      } else {
        delete manualLevels[item.key];
      }
    }
  });
  accessRoleEditorState.manualLevels = manualLevels;
  setAccessRoleSelection(Array.from(next));
}

async function applyAccessRoleItemLevel(itemKey, level) {
  if (accessRoleEditorState.adminEnabled) {
    return;
  }
  const item = ACCESS_ROLE_ITEM_INDEX.get(itemKey);
  if (!item) {
    return;
  }
  const currentKeys = new Set(accessRoleEditorState.selected || []);
  const currentLevel = getAccessRoleItemLevel(currentKeys, item);
  if (currentLevel === level) {
    return;
  }
  const confirm = await confirmAccessRoleCriticalChanges([item], level, currentKeys);
  if (!confirm) {
    return;
  }
  if (!item.editKeys || item.editKeys.length === 0) {
    if (!accessRoleEditorState.manualLevels) {
      accessRoleEditorState.manualLevels = {};
    }
    if (level === "EDIT") {
      accessRoleEditorState.manualLevels[item.key] = "EDIT";
    } else if (level === "VIEW") {
      accessRoleEditorState.manualLevels[item.key] = "VIEW";
    } else {
      delete accessRoleEditorState.manualLevels[item.key];
    }
  }
  const next = setAccessRoleItemLevel(currentKeys, item, level);
  setAccessRoleSelection(Array.from(next));
}

function renderAccessRolePermissions() {
  if (!accessRoleEditor || !accessRoleItemsList) {
    return;
  }
  const effectiveSelected = getAccessRoleEffectiveSelected();
  const configuredCount = ACCESS_ROLE_ITEMS.filter(
    (item) => getAccessRoleItemLevel(effectiveSelected, item) !== "NONE"
  ).length;
  if (accessRoleConfiguredCount) {
    accessRoleConfiguredCount.textContent = `${configuredCount} item${
      configuredCount === 1 ? "" : "s"
    } configurado${configuredCount === 1 ? "" : "s"}`;
  }
  if (accessRoleAdminToggle) {
    accessRoleAdminToggle.checked = accessRoleEditorState.adminEnabled;
  }
  if (accessRoleAdminNotice) {
    accessRoleAdminNotice.hidden = !accessRoleEditorState.adminEnabled;
  }
  setAccessRoleToggleState(accessRoleFilterConfigured, accessRoleEditorState.onlyConfigured);
  setAccessRoleToggleState(accessRoleFilterCritical, accessRoleEditorState.onlyCritical);
  const disableActions = accessRoleEditorState.adminEnabled;
  setAccessRoleButtonDisabled(accessRoleAllNone, disableActions);
  setAccessRoleButtonDisabled(accessRoleAllView, disableActions);
  setAccessRoleButtonDisabled(accessRoleAllEdit, disableActions);

  if (accessRoleModulesList) {
    accessRoleModulesList.innerHTML = "";
    ACCESS_ROLE_MODULES.forEach((module) => {
      const total = module.items.length;
      const selected = module.items.filter(
        (item) => getAccessRoleItemLevel(effectiveSelected, item) !== "NONE"
      ).length;
      const button = document.createElement("button");
      button.type = "button";
      button.className = `access-role-module-btn${
        accessRoleEditorState.activeModule === module.name ? " is-active" : ""
      }`;
      button.dataset.roleModule = module.name;
      const name = document.createElement("span");
      name.textContent = getAccessModuleLabel(module.name);
      const count = document.createElement("span");
      count.className = "access-role-count";
      count.textContent = `${selected}/${total}`;
      button.append(name, count);
      accessRoleModulesList.append(button);
    });
  }

  const activeModule =
    ACCESS_ROLE_MODULES.find((module) => module.name === accessRoleEditorState.activeModule) ||
    ACCESS_ROLE_MODULES[0];
  if (!activeModule) {
    return;
  }
  accessRoleEditorState.activeModule = activeModule.name;
  const moduleTotal = activeModule.items.length;
  const moduleConfigured = activeModule.items.filter(
    (item) => getAccessRoleItemLevel(effectiveSelected, item) !== "NONE"
  ).length;
  if (accessRoleModuleTitle) {
    accessRoleModuleTitle.textContent = getAccessModuleLabel(activeModule.name);
  }
  if (accessRoleModuleStats) {
    accessRoleModuleStats.textContent = `${moduleConfigured}/${moduleTotal} em VIEW/EDIT`;
  }
  if (accessRoleModuleLevel) {
    const level = getAccessRoleModuleLevel(activeModule.items, effectiveSelected);
    const buttons = Array.from(accessRoleModuleLevel.querySelectorAll("button[data-level]"));
    buttons.forEach((button) => {
      const isActive = level !== "MIXED" && button.dataset.level === level;
      button.classList.toggle("is-active", isActive);
      button.disabled = disableActions;
      button.classList.toggle("is-disabled", disableActions);
    });
  }

  const items = filterAccessRoleItems(activeModule.items, effectiveSelected);
  if (!items.length) {
    accessRoleItemsList.innerHTML = `<div class="access-role-empty">Nenhuma permiss\u00e3o encontrada com esses filtros.</div>`;
  } else {
    accessRoleItemsList.innerHTML = items
      .map((item) => {
        const level = getAccessRoleItemLevel(effectiveSelected, item);
        const viewOnly = !item.editKeys || item.editKeys.length === 0;
        const rowClass = `access-role-item is-${level.toLowerCase()}`;
        const label = escapeHtml(formatAccessText(item.label || item.key));
        const description = item.description
          ? `<p class="access-role-item__desc">${escapeHtml(formatAccessText(item.description))}</p>`
          : "";
        const criticalBadge = item.dangerous
          ? `<span class="perm-badge perm-badge--danger" title="Permiss\u00e3o cr\u00edtica">CR\u00cdTICO</span>`
          : "";
        const viewOnlyBadge = viewOnly
          ? `<span class="perm-badge perm-badge--legacy" title="EDIT = VIEW">EDIT = VIEW</span>`
          : "";
        const controls = ["NONE", "VIEW", "EDIT"]
          .map((option) => {
            const active = option === level;
            const disabled = disableActions;
            return `<button type="button" class="access-role-level${
              active ? " is-active" : ""
            }${disabled ? " is-disabled" : ""}" data-item-key="${escapeHtml(
              item.key
            )}" data-level="${option}" aria-pressed="${
              active ? "true" : "false"
            }"${disabled ? " disabled" : ""}>${option}</button>`;
          })
          .join("");
        return `<div class="${rowClass}">
          <div class="access-role-item__info">
            <div class="access-role-item__title">
              <span>${label}</span>
              ${criticalBadge}
              ${viewOnlyBadge}
            </div>
            ${description}
          </div>
          <div class="access-role-item__controls">
            <div class="access-role-levels" role="group" aria-label="N\u00edvel de acesso para ${label}">
              ${controls}
            </div>
          </div>
        </div>`;
      })
      .join("");
  }

  const unknownKeys = getAccessRoleUnknownKeys(accessRoleEditorState.selected || []);
  if (accessRoleUnknownBlock) {
    accessRoleUnknownBlock.hidden = unknownKeys.length === 0;
  }
  if (accessRoleUnknownList) {
    accessRoleUnknownList.innerHTML = unknownKeys
      .map((key) => `<span class="perm-badge perm-badge--legacy">${escapeHtml(key)}</span>`)
      .join("");
  }

  const diff = diffAccessRoleKeys(
    accessRoleEditorState.baseline || [],
    Array.from(accessRoleEditorState.selected || [])
  );
  const changeCount = diff.changedItems.length;
  if (accessRoleChangesCount) {
    accessRoleChangesCount.textContent = changeCount
      ? `Voc\u00ea alterou ${changeCount} item${changeCount === 1 ? "" : "s"}`
      : "Nenhuma altera\u00e7\u00e3o";
  }
  if (accessRoleChangesDetails) {
    accessRoleChangesDetails.hidden = changeCount === 0;
    accessRoleChangesDetails.textContent = accessRoleEditorState.showChanges
      ? "Ocultar altera\u00e7\u00f5es"
      : "Ver altera\u00e7\u00f5es";
  }
  if (accessRoleChangesList) {
    if (!changeCount || !accessRoleEditorState.showChanges) {
      accessRoleChangesList.hidden = true;
      accessRoleChangesList.innerHTML = "";
    } else {
      accessRoleChangesList.hidden = false;
      accessRoleChangesList.innerHTML = diff.changedItems
        .map((entry) => {
          const label = escapeHtml(formatAccessText(entry.item.label || entry.item.key));
          const fromClass = getAccessRoleLevelBadgeClass(entry.from);
          const toClass = getAccessRoleLevelBadgeClass(entry.to);
          return `<div class="access-role-change">
            <span>${label}</span>
            <span class="access-role-change__levels">
              <span class="perm-badge ${fromClass}">${entry.from}</span>
              <span>&rarr;</span>
              <span class="perm-badge ${toClass}">${entry.to}</span>
            </span>
          </div>`;
        })
        .join("");
    }
  }
}

function toggleAccessRoleAdmin(enabled) {
  if (enabled) {
    accessRoleEditorState.adminSnapshot = Array.from(accessRoleEditorState.selected || []).filter(
      (key) => !isAccessRoleAdminKey(key)
    );
    const adminKey = getAccessRoleAdminKey(accessRoleEditorState.adminSnapshot || []);
    const next = new Set(accessRoleEditorState.adminSnapshot || []);
    ACCESS_ROLE_KNOWN_KEYS.forEach((key) => next.add(key));
    next.add(adminKey);
    accessRoleEditorState.selected = next;
    accessRoleEditorState.adminEnabled = true;
  } else {
    const restore = accessRoleEditorState.adminSnapshot || [];
    accessRoleEditorState.selected = new Set(normalizeAccessRoleKeys(restore));
    accessRoleEditorState.adminSnapshot = null;
    accessRoleEditorState.adminEnabled = false;
  }
  renderAccessRolePermissions();
}

function setAccessRoleFormMessage(texto, erro = false) {
  if (!accessRoleFormMsg) {
    return;
  }
  accessRoleFormMsg.textContent = texto || "";
  accessRoleFormMsg.hidden = !texto;
  accessRoleFormMsg.classList.toggle("mensagem--erro", erro);
}

function openAccessRoleModal(role = null) {
  if (!modalAccessRole || !accessRoleForm) {
    return;
  }
  const editing = Boolean(role);
  if (accessRoleModalTitle) {
    accessRoleModalTitle.textContent = editing ? "Editar cargo" : "Novo cargo";
  }
  if (accessRoleModalSubtitle) {
    accessRoleModalSubtitle.textContent = editing
      ? "Atualize as permiss\u00f5es do cargo."
      : "Defina o nome e permiss\u00f5es do cargo.";
  }
  setAccessRoleFormMessage("");
  if (accessRoleId) {
    accessRoleId.value = editing ? role.id : "";
  }
  renderAccessRoleNameOptions(editing ? role.id : "");
  updateAccessRoleRenameVisibility();
  if (accessRoleName) {
    accessRoleName.value = editing ? role.name || "" : "";
  }
  if (editing) {
    setAccessRoleNameMode(false);
  } else {
    setAccessRoleNameMode(true);
  }
  initAccessRoleEditorState(editing ? role.permissions || [] : [], editing ? role.id : "");
  modalAccessRole.hidden = false;
}

function closeAccessRoleModal() {
  if (!modalAccessRole) {
    return;
  }
  modalAccessRole.hidden = true;
}

function getActiveProject() {
  return availableProjects.find((project) => project.id === activeProjectId) || null;
}

function getProjectTeamName(projectId) {
  const project = availableProjects.find((item) => item && item.id === projectId);
  const nomeTime = project
    ? String(project.nomeTime || project.timeName || project.time || "").trim()
    : "";
  return nomeTime || DEFAULT_TEAM_NAME;
}

function normalizeParticipantName(value) {
  return String(value || "")
    .replace(/\s+/g, " ")
    .trim();
}

function normalizeTeamName(value) {
  const raw = String(value || "").trim();
  if (raw.startsWith("team:") || raw.startsWith("time:")) {
    return raw.slice(5).trim();
  }
  return raw;
}

function getMaintenanceParticipantCandidates() {
  const list = collectActiveProjectMembers([], { includeAdmins: true }).map((user) =>
    normalizeParticipantName(user.name || user.username || user.label || "")
  );
  return Array.from(new Set(list.filter(Boolean))).sort((a, b) => a.localeCompare(b, "pt-BR"));
}

function renderEquipeOptions(select, selectedName = "") {
  if (!select) {
    return;
  }
  const teams = [];
  const seen = new Set();
  const activeTeam = getProjectTeamName(activeProjectId);
  if (activeTeam && !seen.has(activeTeam)) {
    teams.push(activeTeam);
    seen.add(activeTeam);
  }
  const customSelected = normalizeTeamName(selectedName);
  if (customSelected && !seen.has(customSelected)) {
    teams.unshift(customSelected);
    seen.add(customSelected);
  }
  availableProjects.forEach((project) => {
    const nome = String(project.nomeTime || project.timeName || project.time || "").trim();
    if (nome && !seen.has(nome)) {
      teams.push(nome);
      seen.add(nome);
    }
  });
  select.innerHTML = "";
  if (!teams.length) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "Sem equipe definida";
    select.append(opt);
    return;
  }
  teams.forEach((team) => {
    const opt = document.createElement("option");
    opt.value = team;
    opt.textContent = team;
    select.append(opt);
  });
  const fallback = selectedName || activeTeam || teams[0];
  select.value = fallback;
}

function renderManutencaoEquipeOptions(selectedName = "") {
  renderEquipeOptions(manutencaoEquipeResponsavel, selectedName);
}

function renderLiberacaoEquipeOptions(selectedName = "") {
  renderEquipeOptions(liberacaoEquipeResponsavel, selectedName);
}

function renderTemplateEquipeOptions(selectedName = "") {
  renderEquipeOptions(templateEquipeResponsavel, selectedName);
}

function syncManutencaoParticipantesInput() {
  if (!participantesManutencao) {
    return;
  }
  participantesManutencao.value = manutencaoParticipantesSelecionados.join("; ");
}

function renderManutencaoParticipantesSelected() {
  if (!participantesManutencaoSelected) {
    return;
  }
  participantesManutencaoSelected.innerHTML = "";
  if (!manutencaoParticipantesSelecionados.length) {
    const vazio = document.createElement("span");
    vazio.className = "participant-empty";
    vazio.textContent = "Nenhum participante selecionado.";
    participantesManutencaoSelected.append(vazio);
    return;
  }
  const candidatos = new Set(getMaintenanceParticipantCandidates());
  manutencaoParticipantesSelecionados.forEach((name) => {
    const tag = document.createElement("span");
    const isExternal = !candidatos.has(name);
    tag.className = `participant-tag${isExternal ? " participant-tag--external" : ""}`;
    const label = document.createElement("span");
    label.textContent = name;
    const remove = document.createElement("button");
    remove.type = "button";
    remove.className = "participant-remove";
    remove.textContent = "x";
    remove.dataset.participantRemove = name;
    tag.append(label, remove);
    participantesManutencaoSelected.append(tag);
  });
}

function renderManutencaoParticipantesOptions() {
  if (!participantesManutencaoList) {
    return;
  }
  participantesManutencaoList.innerHTML = "";
  const list = getMaintenanceParticipantCandidates();
  if (!list.length) {
    const vazio = document.createElement("span");
    vazio.className = "participant-empty";
    vazio.textContent = "Sem colaboradores vinculados ao projeto.";
    participantesManutencaoList.append(vazio);
    return;
  }
  list.forEach((name) => {
    const button = document.createElement("button");
    button.type = "button";
    button.className = "participant-pill";
    if (manutencaoParticipantesSelecionados.includes(name)) {
      button.classList.add("is-selected");
    }
    button.textContent = name;
    button.dataset.participantName = name;
    participantesManutencaoList.append(button);
  });
}

function setManutencaoParticipantes(list = []) {
  const next = [];
  const seen = new Set();
  list.forEach((entry) => {
    const name = normalizeParticipantName(entry);
    if (!name || seen.has(name)) {
      return;
    }
    seen.add(name);
    next.push(name);
  });
  manutencaoParticipantesSelecionados = next;
  syncManutencaoParticipantesInput();
  renderManutencaoParticipantesOptions();
  renderManutencaoParticipantesSelected();
}

function toggleManutencaoParticipante(name) {
  const normalized = normalizeParticipantName(name);
  if (!normalized) {
    return;
  }
  if (manutencaoParticipantesSelecionados.includes(normalized)) {
    manutencaoParticipantesSelecionados = manutencaoParticipantesSelecionados.filter(
      (item) => item !== normalized
    );
  } else {
    manutencaoParticipantesSelecionados = manutencaoParticipantesSelecionados.concat(normalized);
  }
  syncManutencaoParticipantesInput();
  renderManutencaoParticipantesOptions();
  renderManutencaoParticipantesSelected();
  setFieldError(participantesManutencaoErro, "");
}

function addManutencaoParticipantesExternos(raw) {
  const entries = String(raw || "")
    .split(/[;,]/)
    .map((item) => normalizeParticipantName(item))
    .filter(Boolean);
  if (!entries.length) {
    return;
  }
  const merged = manutencaoParticipantesSelecionados.slice();
  entries.forEach((name) => {
    if (!merged.includes(name)) {
      merged.push(name);
    }
  });
  setManutencaoParticipantes(merged);
}

function getManutencaoParticipantesFromForm() {
  if (manutencaoParticipantesSelecionados.length) {
    return manutencaoParticipantesSelecionados.slice();
  }
  const texto = participantesManutencao ? participantesManutencao.value : "";
  return String(texto || "")
    .split(";")
    .map((item) => normalizeParticipantName(item))
    .filter(Boolean);
}

function syncLiberacaoParticipantesInput() {
  if (!liberacaoParticipantes) {
    return;
  }
  liberacaoParticipantes.value = liberacaoParticipantesSelecionados.join("; ");
}

function renderLiberacaoParticipantesSelected() {
  if (!liberacaoParticipantesSelected) {
    return;
  }
  liberacaoParticipantesSelected.innerHTML = "";
  if (!liberacaoParticipantesSelecionados.length) {
    const vazio = document.createElement("span");
    vazio.className = "participant-empty";
    vazio.textContent = "Nenhum participante selecionado.";
    liberacaoParticipantesSelected.append(vazio);
    return;
  }
  const candidatos = new Set(getMaintenanceParticipantCandidates());
  liberacaoParticipantesSelecionados.forEach((name) => {
    const tag = document.createElement("span");
    const isExternal = !candidatos.has(name);
    tag.className = `participant-tag${isExternal ? " participant-tag--external" : ""}`;
    const label = document.createElement("span");
    label.textContent = name;
    const remove = document.createElement("button");
    remove.type = "button";
    remove.className = "participant-remove";
    remove.textContent = "x";
    remove.dataset.participantRemove = name;
    tag.append(label, remove);
    liberacaoParticipantesSelected.append(tag);
  });
}

function renderLiberacaoParticipantesOptions() {
  if (!liberacaoParticipantesList) {
    return;
  }
  liberacaoParticipantesList.innerHTML = "";
  const list = getMaintenanceParticipantCandidates();
  if (!list.length) {
    const vazio = document.createElement("span");
    vazio.className = "participant-empty";
    vazio.textContent = "Sem colaboradores vinculados ao projeto.";
    liberacaoParticipantesList.append(vazio);
    return;
  }
  list.forEach((name) => {
    const button = document.createElement("button");
    button.type = "button";
    button.className = "participant-pill";
    if (liberacaoParticipantesSelecionados.includes(name)) {
      button.classList.add("is-selected");
    }
    button.textContent = name;
    button.dataset.participantName = name;
    liberacaoParticipantesList.append(button);
  });
}

function setLiberacaoParticipantes(list = []) {
  const next = [];
  const seen = new Set();
  list.forEach((entry) => {
    const name = normalizeParticipantName(entry);
    if (!name || seen.has(name)) {
      return;
    }
    seen.add(name);
    next.push(name);
  });
  liberacaoParticipantesSelecionados = next;
  syncLiberacaoParticipantesInput();
  renderLiberacaoParticipantesOptions();
  renderLiberacaoParticipantesSelected();
  atualizarLiberacaoChecklist();
}

function toggleLiberacaoParticipante(name) {
  const normalized = normalizeParticipantName(name);
  if (!normalized) {
    return;
  }
  if (liberacaoParticipantesSelecionados.includes(normalized)) {
    liberacaoParticipantesSelecionados = liberacaoParticipantesSelecionados.filter(
      (item) => item !== normalized
    );
  } else {
    liberacaoParticipantesSelecionados = liberacaoParticipantesSelecionados.concat(normalized);
  }
  syncLiberacaoParticipantesInput();
  renderLiberacaoParticipantesOptions();
  renderLiberacaoParticipantesSelected();
  setFieldError(liberacaoParticipantesErro, "");
  atualizarLiberacaoChecklist();
}

function addLiberacaoParticipantesExternos(raw) {
  const entries = String(raw || "")
    .split(/[;,]/)
    .map((item) => normalizeParticipantName(item))
    .filter(Boolean);
  if (!entries.length) {
    return;
  }
  const merged = liberacaoParticipantesSelecionados.slice();
  entries.forEach((name) => {
    if (!merged.includes(name)) {
      merged.push(name);
    }
  });
  setLiberacaoParticipantes(merged);
}

function getLiberacaoParticipantesFromForm() {
  if (liberacaoParticipantesSelecionados.length) {
    return liberacaoParticipantesSelecionados.slice();
  }
  const texto = liberacaoParticipantes ? liberacaoParticipantes.value : "";
  const parsed = String(texto || "")
    .split(";")
    .map((item) => normalizeParticipantName(item))
    .filter(Boolean);
  return Array.from(new Set(parsed));
}

function syncTemplateParticipantesInput() {
  if (!templateParticipantes) {
    return;
  }
  templateParticipantes.value = templateParticipantesSelecionados.join("; ");
}

function renderTemplateParticipantesSelected() {
  if (!templateParticipantesSelected) {
    return;
  }
  templateParticipantesSelected.innerHTML = "";
  if (!templateParticipantesSelecionados.length) {
    const vazio = document.createElement("span");
    vazio.className = "participant-empty";
    vazio.textContent = "Nenhum participante selecionado.";
    templateParticipantesSelected.append(vazio);
    return;
  }
  const candidatos = new Set(getMaintenanceParticipantCandidates());
  templateParticipantesSelecionados.forEach((name) => {
    const tag = document.createElement("span");
    const isExternal = !candidatos.has(name);
    tag.className = `participant-tag${isExternal ? " participant-tag--external" : ""}`;
    const label = document.createElement("span");
    label.textContent = name;
    const remove = document.createElement("button");
    remove.type = "button";
    remove.className = "participant-remove";
    remove.textContent = "x";
    remove.dataset.participantRemove = name;
    tag.append(label, remove);
    templateParticipantesSelected.append(tag);
  });
}

function renderTemplateParticipantesOptions() {
  if (!templateParticipantesList) {
    return;
  }
  templateParticipantesList.innerHTML = "";
  const list = getMaintenanceParticipantCandidates();
  if (!list.length) {
    const vazio = document.createElement("span");
    vazio.className = "participant-empty";
    vazio.textContent = "Sem colaboradores vinculados ao projeto.";
    templateParticipantesList.append(vazio);
    return;
  }
  list.forEach((name) => {
    const button = document.createElement("button");
    button.type = "button";
    button.className = "participant-pill";
    if (templateParticipantesSelecionados.includes(name)) {
      button.classList.add("is-selected");
    }
    button.textContent = name;
    button.dataset.participantName = name;
    templateParticipantesList.append(button);
  });
}

function setTemplateParticipantes(list = []) {
  const next = [];
  const seen = new Set();
  list.forEach((entry) => {
    const name = normalizeParticipantName(entry);
    if (!name || seen.has(name)) {
      return;
    }
    seen.add(name);
    next.push(name);
  });
  templateParticipantesSelecionados = next;
  syncTemplateParticipantesInput();
  renderTemplateParticipantesOptions();
  renderTemplateParticipantesSelected();
}

function toggleTemplateParticipante(name) {
  const normalized = normalizeParticipantName(name);
  if (!normalized) {
    return;
  }
  if (templateParticipantesSelecionados.includes(normalized)) {
    templateParticipantesSelecionados = templateParticipantesSelecionados.filter(
      (item) => item !== normalized
    );
  } else {
    templateParticipantesSelecionados = templateParticipantesSelecionados.concat(normalized);
  }
  syncTemplateParticipantesInput();
  renderTemplateParticipantesOptions();
  renderTemplateParticipantesSelected();
  setFieldError(templateParticipantesErro, "");
}

function addTemplateParticipantesExternos(raw) {
  const entries = String(raw || "")
    .split(/[;,]/)
    .map((item) => normalizeParticipantName(item))
    .filter(Boolean);
  if (!entries.length) {
    return;
  }
  const merged = templateParticipantesSelecionados.slice();
  entries.forEach((name) => {
    if (!merged.includes(name)) {
      merged.push(name);
    }
  });
  setTemplateParticipantes(merged);
}

function getTemplateParticipantesFromForm() {
  if (templateParticipantesSelecionados.length) {
    return templateParticipantesSelecionados.slice();
  }
  const texto = templateParticipantes ? templateParticipantes.value : "";
  const parsed = String(texto || "")
    .split(";")
    .map((item) => normalizeParticipantName(item))
    .filter(Boolean);
  return Array.from(new Set(parsed));
}

function getManutencaoEquipeSelecionada() {
  const selecionada = manutencaoEquipeResponsavel
    ? normalizeTeamName(manutencaoEquipeResponsavel.value)
    : "";
  return selecionada || getProjectTeamName(activeProjectId);
}

function getLiberacaoEquipeSelecionada() {
  const selecionada = liberacaoEquipeResponsavel
    ? normalizeTeamName(liberacaoEquipeResponsavel.value)
    : "";
  return selecionada || getProjectTeamName(activeProjectId);
}

function getTemplateEquipeSelecionada() {
  const selecionada = templateEquipeResponsavel
    ? normalizeTeamName(templateEquipeResponsavel.value)
    : "";
  return selecionada || "";
}

function renderProjectSelector() {
  if (!projectSelect) {
    return;
  }
  projectSelect.innerHTML = "";
  if (!availableProjects.length) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "Sem projetos";
    projectSelect.append(opt);
    projectSelect.disabled = true;
  } else {
    availableProjects.forEach((project) => {
      const opt = document.createElement("option");
      const label = `${project.codigo || "-"} - ${project.nome || "-"}`;
      opt.value = project.id;
      opt.textContent = label;
      projectSelect.append(opt);
    });
    projectSelect.disabled = false;
    if (activeProjectId) {
      projectSelect.value = activeProjectId;
    }
  }
  if (projectSelectLabel) {
    projectSelectLabel.textContent = "Projeto ativo";
  }
  if (projectManageBtn) {
    projectManageBtn.hidden = !canViewProjetos(currentUser);
  }
  if (crumbs) {
    renderBreadcrumb();
  }
  renderProjectSelectOptions(manutencaoProjeto, activeProjectId);
  renderProjectSelectOptions(templateProjeto, activeProjectId);
  renderAccessProjectSelectOptions();
  renderRelatorioClienteSelect();
}

function renderRelatorioClienteSelect() {
  if (!relatorioCliente) {
    return;
  }
  const activeProject = getActiveProject();
  const cliente = activeProject && activeProject.cliente ? String(activeProject.cliente).trim() : "";
  const value = cliente || RDO_CLIENTE;
  relatorioCliente.innerHTML = "";
  const opt = document.createElement("option");
  opt.value = value;
  opt.textContent = value;
  relatorioCliente.append(opt);
  relatorioCliente.value = value;
}

function setProjectTab(tab) {
  if (!projectTabs.length || !projectPanels.length) {
    return;
  }
  projectTabs.forEach((button) => {
    button.classList.toggle("is-active", button.dataset.projectTab === tab);
  });
  projectPanels.forEach((panel) => {
    panel.hidden = panel.dataset.projectPanel !== tab;
  });
}

function openProjectVehiclesTab(projectId) {
  abrirPainelComCarregamento("projetos");
  setProjectTab("veiculos");
  if (projectId) {
    setActiveProjectId(projectId);
    if (sstVehicleProject) {
      sstVehicleProject.value = projectId;
    }
    if (sstVehicleFilterProject) {
      sstVehicleFilterProject.value = projectId;
    }
  }
  renderProjectPanel();
}

function renderProjetosTable() {
  if (!projectTableBody) {
    return;
  }
  projectTableBody.innerHTML = "";
  if (!availableProjects.length) {
    return;
  }
  availableProjects.forEach((project) => {
    const tr = document.createElement("tr");
    const actions = [];
    actions.push(`<button type="button" class="btn btn--ghost btn--small" data-action="set-active">Ativar</button>`);
    if (currentUser && canManageProjetos(currentUser)) {
      actions.push(`<button type="button" class="btn btn--ghost btn--small" data-action="edit-project">Editar</button>`);
      actions.push(`<button type="button" class="btn btn--ghost btn--small btn--danger" data-action="delete-project">Excluir</button>`);
    }
    tr.dataset.projectId = project.id;
    tr.innerHTML = `
      <td>${escapeHtml(project.codigo || "-")}</td>
      <td>${escapeHtml(project.nome || "-")}</td>
      <td>${escapeHtml(project.cliente || "-")}</td>
      <td class="table-actions">${actions.join(" ")}</td>
    `;
    projectTableBody.append(tr);
  });
}

function renderProjectFormSelect() {
  if (!projectFormSelect) {
    return;
  }
  projectFormSelect.innerHTML = "";
  const optNew = document.createElement("option");
  optNew.value = "";
  optNew.textContent = "Novo projeto";
  projectFormSelect.append(optNew);
  availableProjects.forEach((project) => {
    const opt = document.createElement("option");
    opt.value = project.id;
    opt.textContent = getProjectLabel(project);
    projectFormSelect.append(opt);
  });
  if (projectFormId && projectFormId.value) {
    projectFormSelect.value = projectFormId.value;
  }
}

function renderEquipamentosTable() {
  if (!equipamentoTableBody) {
    return;
  }
  equipamentoTableBody.innerHTML = "";
  if (!projectEquipamentos.length) {
    return;
  }
  projectEquipamentos.forEach((equip) => {
    const tr = document.createElement("tr");
    const actions = [];
    if (currentUser && canManageEquipamentos(currentUser)) {
      actions.push(`<button type="button" class="btn btn--ghost btn--small" data-action="edit-equipment">Editar</button>`);
      actions.push(`<button type="button" class="btn btn--ghost btn--small btn--danger" data-action="delete-equipment">Excluir</button>`);
    }
    tr.dataset.equipmentId = equip.id;
    tr.innerHTML = `
      <td>${escapeHtml(equip.tag || "-")}</td>
      <td>${escapeHtml(equip.nome || "-")}</td>
      <td>${escapeHtml(equip.categoria || "-")}</td>
      <td>${escapeHtml(equip.descricao || "-")}</td>
      <td class="table-actions">${actions.join(" ")}</td>
    `;
    equipamentoTableBody.append(tr);
  });
}

function resolveEquipamentoIdFromValue(raw) {
  if (!raw) {
    return "";
  }
  if (typeof raw === "string") {
    const texto = raw.trim();
    if (!texto) {
      return "";
    }
    const byId = projectEquipamentos.find((equip) => equip.id === texto);
    if (byId) {
      return byId.id;
    }
    const normalized = normalizeSearchValue(texto);
    const byName = projectEquipamentos.find(
      (equip) =>
        normalizeSearchValue(equip.nome || "") === normalized ||
        normalizeSearchValue(equip.tag || "") === normalized
    );
    return byName ? byName.id : texto;
  }
  if (typeof raw === "object") {
    const id = String(raw.id || "").trim();
    if (id) {
      return id;
    }
    const nome = String(raw.nome || raw.name || raw.label || raw.tag || "").trim();
    if (nome) {
      const normalized = normalizeSearchValue(nome);
      const byName = projectEquipamentos.find(
        (equip) =>
          normalizeSearchValue(equip.nome || "") === normalized ||
          normalizeSearchValue(equip.tag || "") === normalized
      );
      return byName ? byName.id : nome;
    }
  }
  return "";
}

function setEquipamentoSelectValue(select, rawValue) {
  if (!select) {
    return;
  }
  const equipamentoId = resolveEquipamentoIdFromValue(rawValue);
  if (!equipamentoId) {
    select.value = "";
    return;
  }
  const existe = Array.from(select.options || []).some((opt) => opt.value === equipamentoId);
  if (!existe) {
    const equipamento = projectEquipamentos.find((equip) => equip.id === equipamentoId);
    const option = document.createElement("option");
    option.value = equipamentoId;
    option.textContent = equipamento
      ? `${equipamento.tag || "-"} - ${equipamento.nome || "-"}`
      : "Equipamento removido";
    select.append(option);
  }
  select.value = equipamentoId;
}

function renderEquipamentoSelectOptions(select, placeholder = "Selecione um equipamento") {
  if (!select) {
    return;
  }
  const atual = select.value;
  select.innerHTML = `<option value="">${placeholder}</option>`;
  projectEquipamentos.forEach((equip) => {
    const option = document.createElement("option");
    option.value = equip.id;
    option.textContent = `${equip.tag || "-"} - ${equip.nome || "-"}`;
    select.append(option);
  });
  if (atual) {
    const existe = Array.from(select.options || []).some((opt) => opt.value === atual);
    if (!existe) {
      const equipamento = projectEquipamentos.find((equip) => equip.id === atual);
      const option = document.createElement("option");
      option.value = atual;
      option.textContent = equipamento
        ? `${equipamento.tag || "-"} - ${equipamento.nome || "-"}`
        : "Equipamento removido";
      select.append(option);
    }
    select.value = atual;
  }
}

function renderEquipamentoOptions() {
  renderEquipamentoSelectOptions(equipamentoManutencao);
  renderEquipamentoSelectOptions(liberacaoEquipamento);
  renderEquipamentoSelectOptions(templateEquipamento);
}

function renderEquipeSelectOptions() {
  if (!equipeFormUser) {
    return;
  }
  const selecionados = new Set(
    Array.from(equipeFormUser.selectedOptions || []).map((option) => option.value)
  );
  equipeFormUser.innerHTML = "";
  const termo = equipeSearch ? normalizeSearchValue(equipeSearch.value || "") : "";
  const vinculados = new Set(projectEquipe.map((entry) => entry.userId));
  users.forEach((user) => {
    if (!isRealUser(user)) {
      return;
    }
    if (vinculados.has(user.id)) {
      return;
    }
    const label = `${user.name || user.matricula || user.username || "-"} (${getRoleLabel(user)})`;
    if (termo && !normalizeSearchValue(label).includes(termo)) {
      return;
    }
    const opt = document.createElement("option");
    opt.value = user.id;
    opt.textContent = label;
    if (selecionados.has(user.id)) {
      opt.selected = true;
    }
    equipeFormUser.append(opt);
  });
}

function renderEquipeTable() {
  if (!equipeTableBody) {
    return;
  }
  equipeTableBody.innerHTML = "";
  if (!projectEquipe.length) {
    return;
  }
  projectEquipe.forEach((entry) => {
    const user = entry.user || {};
    const tr = document.createElement("tr");
    const actions = [];
    if (currentUser && canManageEquipeProjeto(currentUser)) {
      actions.push(`<button type="button" class="btn btn--ghost btn--small btn--danger" data-action="remove-team">Remover</button>`);
    }
    tr.dataset.userId = entry.userId;
    tr.innerHTML = `
      <td>${escapeHtml(user.name || user.matricula || "-")}</td>
      <td>${escapeHtml(user.cargo || "-")}</td>
      <td>${escapeHtml(entry.papel || "-")}</td>
      <td class="table-actions">${actions.join(" ")}</td>
    `;
    equipeTableBody.append(tr);
  });
}

function renderProjectPanel() {
  carregarVeiculos();
  renderProjetosTable();
  renderProjectFormSelect();
  renderEquipamentosTable();
  renderEquipamentoOptions();
  renderEquipeTable();
  renderEquipeSelectOptions();
  renderProjectSelectOptions(equipamentoFormProject, activeProjectId);
  renderProjectSelectOptions(sstVehicleProject, sstVehicleProject ? sstVehicleProject.value : activeProjectId);
  renderProjectFilterOptions(sstVehicleFilterProject, sstVehicleFilterProject ? sstVehicleFilterProject.value : "");
  renderSstVehicles();
  setFormDisabled(projectForm, !(currentUser && canManageProjetos(currentUser)));
  setFormDisabled(equipamentoForm, !(currentUser && canManageEquipamentos(currentUser)));
  setFormDisabled(equipeForm, !(currentUser && canManageEquipeProjeto(currentUser)));
  setFormDisabled(sstVehicleForm, !(currentUser && canManageProjetos(currentUser)));
  if (projectPanels.length && !projectPanels.some((panel) => !panel.hidden)) {
    setProjectTab("lista");
  }
}

function resetProjectForm() {
  if (projectForm) {
    projectForm.reset();
  }
  if (projectFormId) {
    projectFormId.value = "";
  }
  if (projectFormSelect) {
    projectFormSelect.value = "";
  }
  if (projectFormTime) {
    projectFormTime.value = "";
  }
  if (projectFormLocais) {
    projectFormLocais.value = "";
  }
}

function setProjectFormValues(project) {
  if (!project) {
    resetProjectForm();
    return;
  }
  if (projectFormId) projectFormId.value = project.id || "";
  if (projectFormCodigo) projectFormCodigo.value = project.codigo || "";
  if (projectFormNome) projectFormNome.value = project.nome || "";
  if (projectFormCliente) projectFormCliente.value = project.cliente || "";
  if (projectFormTime) {
    projectFormTime.value = project.nomeTime || project.timeName || project.time || "";
  }
  if (projectFormDescricao) projectFormDescricao.value = project.descricao || "";
  if (projectFormLocais) {
    const locais = Array.isArray(project.locais) ? project.locais : [];
    projectFormLocais.value = locais.join("\n");
  }
  if (projectFormSelect) projectFormSelect.value = project.id || "";
}

function resetEquipamentoForm() {
  if (equipamentoForm) {
    equipamentoForm.reset();
  }
  if (equipamentoFormId) {
    equipamentoFormId.value = "";
  }
  if (equipamentoFormProject) {
    equipamentoFormProject.value = activeProjectId || "";
  }
}

function setFormDisabled(form, disabled) {
  if (!form) {
    return;
  }
  const fields = Array.from(form.querySelectorAll("input, select, textarea, button"));
  fields.forEach((field) => {
    field.disabled = disabled;
  });
}

async function refreshProjects() {
  if (!currentUser) {
    return;
  }
  if (!USE_AUTH_API) {
    try {
      seedDefaultProjectsIfEmpty();
      availableProjects = readProjectsStorage();
    } catch (error) {
      availableProjects = [];
    }
    if (availableProjects.length) {
      writeProjectsStorage(availableProjects);
    }
  } else {
    try {
      const data = await apiProjetosList();
      if (Array.isArray(data.projects)) {
        availableProjects = data.projects;
      }
    } catch (error) {
      // Mantem o que ja carregou de /api/auth/me caso a rota de projetos falhe.
    }
  }
  const projectsHash = syncDebugEnabled
    ? hashString(JSON.stringify(availableProjects))
    : "";
  logSyncDebug("projects.fetch", {
    count: availableProjects.length,
    source: USE_AUTH_API ? "api" : "local",
    hash: projectsHash,
  });
  if (!availableProjects.length) {
    renderProjectSelector();
    renderProjectPanel();
    return;
  }
  const storedProjectId = localStorage.getItem(ACTIVE_PROJECT_KEY) || "";
  const desiredProjectId = activeProjectId || storedProjectId;
  const activeStillValid = desiredProjectId
    ? availableProjects.some((item) => item.id === desiredProjectId)
    : false;
  if (activeStillValid && desiredProjectId !== activeProjectId) {
    await setActiveProjectId(desiredProjectId, { sync: !USE_AUTH_API, force: true });
    return;
  }
  if (!activeStillValid) {
    const fallback = availableProjects[0]?.id || "";
    if (fallback) {
      await setActiveProjectId(fallback, { sync: !USE_AUTH_API, force: true });
      return;
    }
  }
  renderProjectSelector();
  renderProjectPanel();
}

function setInlineMessage(element, message, isError = false) {
  if (!element) {
    return;
  }
  element.textContent = message || "";
  element.hidden = !message;
  element.classList.toggle("mensagem--erro", isError);
}

function isDateExpiring(dateStr, days = 30) {
  const parsed = parseDate(dateStr);
  if (!parsed) {
    return false;
  }
  const diff = diffInDays(startOfDay(new Date()), startOfDay(parsed));
  return diff >= 0 && diff <= days;
}

function getAlmoxItemLabel(itemId) {
  const item = almoxItems.find((entry) => entry && entry.id === itemId);
  if (!item) {
    return itemId || "-";
  }
  return item.name || item.internalCode || item.barcode || item.id;
}

function renderAlmoxItemOptions() {
  if (!almoxMovItem) {
    return;
  }
  const selected = almoxMovItem.value;
  almoxMovItem.innerHTML = '<option value="">Selecione</option>';
  almoxItems
    .filter((item) => item && item.status !== "INATIVO")
    .forEach((item) => {
      const opt = document.createElement("option");
      opt.value = item.id;
      opt.textContent = `${item.name || "-"} (${item.type || "-"})`;
      almoxMovItem.append(opt);
    });
  if (selected) {
    almoxMovItem.value = selected;
  }
}

function renderAlmoxColabOptions() {
  if (!almoxMovColab) {
    return;
  }
  const selected = almoxMovColab.value;
  almoxMovColab.innerHTML = '<option value="">Selecione</option>';
  users.forEach((user) => {
    if (!isRealUser(user)) {
      return;
    }
    const opt = document.createElement("option");
    opt.value = user.id;
    opt.textContent = `${user.name || user.matricula || user.username || "-"} (${getRoleLabel(
      user
    )})`;
    almoxMovColab.append(opt);
  });
  if (selected) {
    almoxMovColab.value = selected;
  }
}

function renderAlmoxProjectOptions() {
  renderProjectSelectOptions(almoxMovProject, activeProjectId);
  renderProjectSelectOptions(almoxMovProjectDest, "");
}

function updateAlmoxTransferFields() {
  if (!almoxMovType) {
    return;
  }
  const isTransfer = almoxMovType.value === "TRANSFERENCIA";
  almoxTransferFields.forEach((field) => {
    field.hidden = !isTransfer;
  });
}

function renderAlmoxSelectors() {
  renderAlmoxProjectOptions();
  renderAlmoxItemOptions();
  renderAlmoxColabOptions();
  updateAlmoxTransferFields();
  setFormDisabled(almoxItemForm, !(currentUser && canManageAlmoxarifado(currentUser)));
  setFormDisabled(almoxMovForm, !(currentUser && canManageAlmoxarifado(currentUser)));
}

function upsertAlmoxStockEntry(entry) {
  if (!entry) {
    return;
  }
  const index = almoxStock.findIndex((item) => item && item.id === entry.id);
  if (index >= 0) {
    almoxStock[index] = entry;
  } else {
    almoxStock = almoxStock.concat(entry);
  }
}

function renderAlmoxarifado() {
  if (!almoxDashCards || !almoxLoaded) {
    return;
  }
  const filteredStock = activeProjectId
    ? almoxStock.filter((entry) => entry.projectId === activeProjectId)
    : almoxStock;
  const lowStock = filteredStock.filter(
    (entry) => Number(entry.min || 0) > 0 && Number(entry.available || 0) <= Number(entry.min || 0)
  );
  const expiring = almoxItems.filter(
    (item) =>
      item &&
      item.type === "EPI" &&
      (isDateExpiring(item.itemValidUntil, 30) || isDateExpiring(item.caValidUntil, 30))
  );
  const today = startOfDay(new Date());
  const scopedMovements = activeProjectId
    ? almoxMovements.filter((mov) => mov.projectId === activeProjectId)
    : almoxMovements;
  const movsToday = scopedMovements.filter((mov) => {
    const created = parseTimestamp(mov.createdAt);
    return created && startOfDay(created).getTime() === today.getTime();
  });
  const cards = [
    { label: "Itens cadastrados", value: almoxItems.length },
    { label: "Itens em baixa", value: lowStock.length },
    { label: "EPIs vencendo (30d)", value: expiring.length },
    { label: "Movimentações hoje", value: movsToday.length },
  ];
  almoxDashCards.innerHTML = cards
    .map(
      (card) =>
        `<div><small>${escapeHtml(card.label)}</small><strong>${escapeHtml(
          String(card.value)
        )}</strong></div>`
    )
    .join("");

  if (almoxAlertas) {
    almoxAlertas.innerHTML = "";
    const alerts = [];
    lowStock.slice(0, 6).forEach((entry) => {
      const project = availableProjects.find((item) => item.id === entry.projectId);
      const label = `${getAlmoxItemLabel(entry.itemId)} em baixa (${entry.available || 0}/${
        entry.min || 0
      }) - ${project ? getProjectLabel(project) : entry.projectId}`;
      alerts.push(label);
    });
    expiring.slice(0, 6).forEach((item) => {
      const valid = item.itemValidUntil || item.caValidUntil || "";
      const label = `${item.name || item.id} vencendo em ${valid || "data indefinida"}`;
      alerts.push(label);
    });
    if (!alerts.length) {
      if (almoxAlertasVazio) {
        almoxAlertasVazio.hidden = false;
      }
    } else {
      if (almoxAlertasVazio) {
        almoxAlertasVazio.hidden = true;
      }
      alerts.forEach((msg) => {
        const card = document.createElement("div");
        card.className = "lembrete-item";
        const title = document.createElement("strong");
        title.textContent = msg;
        card.append(title);
        almoxAlertas.append(card);
      });
    }
  }

  if (almoxMovRecent) {
    const list = activeProjectId
      ? almoxMovements.filter((mov) => mov.projectId === activeProjectId)
      : almoxMovements.slice();
    const rows = list
      .slice()
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
      .slice(0, 6)
      .map((mov) => {
        const project = availableProjects.find((item) => item.id === mov.projectId);
        const data = mov.createdAt ? formatDateTime(parseTimestamp(mov.createdAt)) : "-";
        return `
          <tr>
            <td>${escapeHtml(mov.type || "-")}</td>
            <td>${escapeHtml(getAlmoxItemLabel(mov.itemId))}</td>
            <td>${escapeHtml(String(mov.quantity || 0))}</td>
            <td>${escapeHtml(project ? getProjectLabel(project) : mov.projectId || "-")}</td>
            <td>${escapeHtml(data)}</td>
          </tr>
        `;
      })
      .join("");
    almoxMovRecent.innerHTML = rows;
    if (almoxMovRecentVazio) {
      almoxMovRecentVazio.hidden = Boolean(rows);
    }
  }
}

function renderAlmoxItens() {
  if (!almoxItemTableBody || !almoxLoaded) {
    return;
  }
  const list = almoxItems.filter((item) => item && item.status !== "INATIVO");
  almoxItemTableBody.innerHTML = list
    .map((item) => {
      const qrLink = item.id
        ? `<a class="btn btn--ghost btn--small" target="_blank" href="/api/almox/items/${encodeURIComponent(
            item.id
          )}/qrcode">QR</a>`
        : "-";
      return `
        <tr>
          <td>${escapeHtml(item.name || "-")}</td>
          <td>${escapeHtml(item.type || "-")}</td>
          <td>${escapeHtml(item.unit || "-")}</td>
          <td>${escapeHtml(item.status || "ATIVO")}</td>
          <td>${escapeHtml(item.ca || "-")}</td>
          <td>${qrLink}</td>
        </tr>
      `;
    })
    .join("");
  if (almoxItemEmpty) {
    almoxItemEmpty.hidden = list.length > 0;
  }
  renderAlmoxItemOptions();
}

function renderAlmoxEstoque() {
  if (!almoxStockTableBody || !almoxLoaded) {
    return;
  }
  const list = activeProjectId
    ? almoxStock.filter((entry) => entry.projectId === activeProjectId)
    : almoxStock;
  almoxStockTableBody.innerHTML = list
    .map((entry) => {
      const project = availableProjects.find((item) => item.id === entry.projectId);
      return `
        <tr>
          <td>${escapeHtml(project ? getProjectLabel(project) : entry.projectId || "-")}</td>
          <td>${escapeHtml(getAlmoxItemLabel(entry.itemId))}</td>
          <td>${escapeHtml(String(entry.available || 0))}</td>
          <td>${escapeHtml(String(entry.reserved || 0))}</td>
          <td>${escapeHtml(String(entry.min || 0))}</td>
        </tr>
      `;
    })
    .join("");
  if (almoxStockEmpty) {
    almoxStockEmpty.hidden = list.length > 0;
  }
}

function renderAlmoxMovimentacoes() {
  if (!almoxMovTableBody || !almoxLoaded) {
    return;
  }
  renderAlmoxSelectors();
  const list = activeProjectId
    ? almoxMovements.filter((mov) => mov.projectId === activeProjectId)
    : almoxMovements;
  almoxMovTableBody.innerHTML = list
    .slice()
    .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
    .map((mov) => {
      const project = availableProjects.find((item) => item.id === mov.projectId);
      const data = mov.createdAt ? formatDateTime(parseTimestamp(mov.createdAt)) : "-";
      const termLink =
        mov.type === "SAIDA"
          ? `<a class="btn btn--ghost btn--small" target="_blank" href="/api/almox/movements/${encodeURIComponent(
              mov.id
            )}/term">PDF</a>`
          : "-";
      return `
        <tr>
          <td>${escapeHtml(mov.type || "-")}</td>
          <td>${escapeHtml(getAlmoxItemLabel(mov.itemId))}</td>
          <td>${escapeHtml(String(mov.quantity || 0))}</td>
          <td>${escapeHtml(project ? getProjectLabel(project) : mov.projectId || "-")}</td>
          <td>${escapeHtml(getUserLabel(mov.createdBy))}</td>
          <td>${escapeHtml(data)}</td>
          <td>${termLink}</td>
        </tr>
      `;
    })
    .join("");
  if (almoxMovEmpty) {
    almoxMovEmpty.hidden = list.length > 0;
  }
}

function renderAlmoxEpis() {
  if (!almoxEpiTableBody || !almoxLoaded) {
    return;
  }
  const list = activeProjectId
    ? almoxEpiByUser.filter((entry) => entry.projectId === activeProjectId)
    : almoxEpiByUser;
  almoxEpiTableBody.innerHTML = list
    .map((entry) => {
      const project = availableProjects.find((item) => item.id === entry.projectId);
      const data = entry.lastMovementAt
        ? formatDateTime(parseTimestamp(entry.lastMovementAt))
        : "-";
      return `
        <tr>
          <td>${escapeHtml(getUserLabel(entry.collaboratorId))}</td>
          <td>${escapeHtml(getAlmoxItemLabel(entry.itemId))}</td>
          <td>${escapeHtml(String(entry.quantity || 0))}</td>
          <td>${escapeHtml(project ? getProjectLabel(project) : entry.projectId || "-")}</td>
          <td>${escapeHtml(data)}</td>
        </tr>
      `;
    })
    .join("");
  if (almoxEpiEmpty) {
    almoxEpiEmpty.hidden = list.length > 0;
  }
}

async function carregarAlmoxarifado(force = false) {
  if (!currentUser || !canViewAlmoxarifado(currentUser)) {
    almoxItems = [];
    almoxStock = [];
    almoxMovements = [];
    almoxEpiByUser = [];
    almoxLoaded = false;
    renderAlmoxarifado();
    renderAlmoxItens();
    renderAlmoxEstoque();
    renderAlmoxMovimentacoes();
    renderAlmoxEpis();
    return;
  }
  if (almoxLoaded && !force) {
    renderAlmoxarifado();
    return;
  }
  try {
    const data = await apiAlmoxItemsList();
    almoxItems = Array.isArray(data.items) ? data.items : [];
  } catch (error) {
    almoxItems = [];
  }
  try {
    const data = await apiAlmoxStockList();
    almoxStock = Array.isArray(data.stock) ? data.stock : [];
  } catch (error) {
    almoxStock = [];
  }
  try {
    const data = await apiAlmoxMovementsList();
    almoxMovements = Array.isArray(data.movements) ? data.movements : [];
  } catch (error) {
    almoxMovements = [];
  }
  try {
    const data = await apiAlmoxEpiByUser();
    almoxEpiByUser = Array.isArray(data.records) ? data.records : [];
  } catch (error) {
    almoxEpiByUser = [];
  }
  almoxLoaded = true;
  renderAlmoxarifado();
  renderAlmoxItens();
  renderAlmoxEstoque();
  renderAlmoxMovimentacoes();
  renderAlmoxEpis();
}

function renderSstProjectOptions() {
  renderProjectSelectOptions(sstInspectionProject, activeProjectId);
  renderProjectSelectOptions(sstIncidentProject, activeProjectId);
  const vehicleProjectSelected = sstVehicleProject ? sstVehicleProject.value : "";
  renderProjectSelectOptions(sstVehicleProject, vehicleProjectSelected || activeProjectId);
  const ncProjectSelected = sstNcProject ? sstNcProject.value : "";
  renderProjectSelectOptions(sstNcProject, ncProjectSelected || activeProjectId);
  const docProjectSelected = sstDocProject ? sstDocProject.value : "";
  renderProjectSelectOptions(sstDocProject, docProjectSelected || activeProjectId);
  const filterSelected = sstDocProjectFilter ? sstDocProjectFilter.value : "";
  renderProjectFilterOptions(sstDocProjectFilter, filterSelected);
  const inspectionFilterSelected = sstInspectionFilterProject
    ? sstInspectionFilterProject.value
    : "";
  renderProjectFilterOptions(sstInspectionFilterProject, inspectionFilterSelected);
  const vehicleFilterSelected = sstVehicleFilterProject ? sstVehicleFilterProject.value : "";
  renderProjectFilterOptions(sstVehicleFilterProject, vehicleFilterSelected);
  const ncFilterSelected = sstNcFilterProject ? sstNcFilterProject.value : "";
  renderProjectFilterOptions(sstNcFilterProject, ncFilterSelected);
  const templateProjectSelected = sstTemplateProject ? sstTemplateProject.value : "";
  renderProjectSelectOptions(sstTemplateProject, templateProjectSelected);
}

function renderProjectFilterOptions(select, selectedId) {
  if (!select) {
    return;
  }
  renderProjectSelectOptions(select, selectedId);
  const first = select.querySelector("option");
  if (first) {
    first.textContent = "Todos os projetos";
  }
}

function renderSstInspectionLocalOptions() {
  if (!sstInspectionLocal) {
    return;
  }
  const locais = getActiveProjectLocais();
  const selectedValue = sstInspectionLocal.value;
  sstInspectionLocal.innerHTML = "";
  const empty = document.createElement("option");
  empty.value = "";
  empty.textContent = locais.length ? "Sem local" : "Sem locais";
  sstInspectionLocal.append(empty);
  locais.forEach((local) => {
    const opt = document.createElement("option");
    opt.value = local;
    opt.textContent = local;
    sstInspectionLocal.append(opt);
  });
  if (selectedValue && locais.includes(selectedValue)) {
    sstInspectionLocal.value = selectedValue;
  }
}

function renderSstInspectionTemplateOptions() {
  if (!sstInspectionTemplate) {
    return;
  }
  const projectId = sstInspectionProject ? sstInspectionProject.value : activeProjectId;
  const selected = sstInspectionTemplate.value;
  sstInspectionTemplate.innerHTML = '<option value="">Selecione</option>';
  const templates = Array.isArray(sstInspectionTemplates) ? sstInspectionTemplates : [];
  templates
    .filter((template) => template.isActive !== false)
    .filter((template) => !template.projectId || String(template.projectId) === String(projectId))
    .sort((a, b) => a.name.localeCompare(b.name, "pt-BR"))
    .forEach((template) => {
      const opt = document.createElement("option");
      opt.value = template.id;
      opt.textContent = template.name;
      sstInspectionTemplate.append(opt);
    });
  if (selected) {
    sstInspectionTemplate.value = selected;
  }
  updateSstInspectionVehicleVisibility();
  renderSstVehicleOptions();
}

function renderSstInspectionUserOptions() {
  const usersList = getOperationalUsers();
  const fill = (select, selectedValue, emptyLabel) => {
    if (!select) {
      return;
    }
    const selected = selectedValue || select.value || "";
    select.innerHTML = `<option value="">${emptyLabel}</option>`;
    usersList.forEach((user) => {
      const opt = document.createElement("option");
      opt.value = user.id;
      opt.textContent = getUserLabel(user.id);
      select.append(opt);
    });
    if (selected) {
      select.value = selected;
    }
  };
  const defaultId = currentUser ? currentUser.id : "";
  fill(sstInspectionSafety, sstInspectionSafety ? sstInspectionSafety.value || defaultId : "", "Selecione");
  fill(
    sstInspectionExecutor,
    sstInspectionExecutor ? sstInspectionExecutor.value || defaultId : "",
    "Selecione"
  );
}

function updateSstInspectionVehicleVisibility() {
  if (!sstInspectionVehicleField) {
    return;
  }
  const shouldShow = true;
  sstInspectionVehicleField.hidden = !shouldShow;
  if (sstInspectionVehicleStatusField) {
    sstInspectionVehicleStatusField.hidden = !shouldShow;
  }
  if (sstInspectionVehicleInfo && !shouldShow) {
    sstInspectionVehicleInfo.hidden = true;
  }
  if (!shouldShow) {
    if (sstInspectionVehicle) {
      sstInspectionVehicle.value = "";
    }
    updateSstInspectionVehicleInfo(null);
  }
}

function renderSstVehicleOptions() {
  if (!sstInspectionVehicle) {
    return;
  }
  const projectId = sstInspectionProject ? sstInspectionProject.value : activeProjectId;
  const selected = sstInspectionVehicle.value;
  sstInspectionVehicle.innerHTML = '<option value="">Selecione</option>';
  const list = Array.isArray(sstVehicles) ? sstVehicles.slice() : [];
  const statusFilter = sstInspectionVehicleStatusFilter
    ? sstInspectionVehicleStatusFilter.value
    : "Ativo";
  const filtered = list
    .filter((vehicle) => !projectId || String(vehicle.projectId) === String(projectId))
    .filter((vehicle) => {
      const status = normalizeVehicleStatusValue(vehicle.status);
      if (statusFilter === "ALL") {
        return true;
      }
      return status === normalizeVehicleStatusValue(statusFilter);
    })
    .sort((a, b) => String(a.plate).localeCompare(String(b.plate), "pt-BR"));
  filtered.forEach((vehicle) => {
    const opt = document.createElement("option");
    opt.value = vehicle.id;
    opt.textContent = getSstVehicleLabel(vehicle);
    sstInspectionVehicle.append(opt);
  });
  if (selected) {
    sstInspectionVehicle.value = selected;
  }
  const hasVehicles = filtered.length > 0;
  if (sstInspectionVehicleEmpty) {
    sstInspectionVehicleEmpty.hidden = hasVehicles;
  }
  if (sstInspectionVehicleCta) {
    const base = `?tab=projetos&projectTab=veiculos${
      projectId ? `&projectId=${encodeURIComponent(projectId)}` : ""
    }`;
    sstInspectionVehicleCta.setAttribute("href", base);
  }
  if (!hasVehicles) {
    updateSstInspectionVehicleInfo(null);
  }
  const chosen =
    sstInspectionVehicle && sstInspectionVehicle.value
      ? filtered.find((item) => String(item.id) === String(sstInspectionVehicle.value)) ||
        sstVehicles.find((item) => String(item.id) === String(sstInspectionVehicle.value))
      : null;
  updateSstInspectionVehicleInfo(chosen);
}

function updateSstInspectionVehicleInfo(vehicle) {
  if (!sstInspectionVehicleInfo) {
    return;
  }
  if (!vehicle) {
    if (sstInspectionVehiclePlate) sstInspectionVehiclePlate.textContent = "-";
    if (sstInspectionVehicleModel) sstInspectionVehicleModel.textContent = "-";
    if (sstInspectionVehicleType) sstInspectionVehicleType.textContent = "-";
    if (sstInspectionVehicleStatus) sstInspectionVehicleStatus.textContent = "-";
    sstInspectionVehicleInfo.hidden = true;
    return;
  }
  if (sstInspectionVehiclePlate) sstInspectionVehiclePlate.textContent = vehicle.plate || "-";
  if (sstInspectionVehicleModel) sstInspectionVehicleModel.textContent = vehicle.model || "-";
  if (sstInspectionVehicleType) sstInspectionVehicleType.textContent = vehicle.type || "-";
  if (sstInspectionVehicleStatus) {
    sstInspectionVehicleStatus.textContent = getVehicleStatusLabel(vehicle.status || "-");
  }
  sstInspectionVehicleInfo.hidden = false;
}

function renderSstInspectionFilterTemplateOptions() {
  if (!sstInspectionFilterTemplate) {
    return;
  }
  const selected = sstInspectionFilterTemplate.value;
  sstInspectionFilterTemplate.innerHTML = '<option value="">Todos os templates</option>';
  const templates = Array.isArray(sstInspectionTemplates) ? sstInspectionTemplates : [];
  templates
    .slice()
    .sort((a, b) => a.name.localeCompare(b.name, "pt-BR"))
    .forEach((template) => {
      const opt = document.createElement("option");
      opt.value = template.id;
      opt.textContent = template.name;
      sstInspectionFilterTemplate.append(opt);
    });
  if (selected) {
    sstInspectionFilterTemplate.value = selected;
  }
}

function renderSstDocResponsibleOptions() {
  if (!sstDocResponsible) {
    return;
  }
  const selected = sstDocResponsible.value || (currentUser ? currentUser.id : "");
  sstDocResponsible.innerHTML = '<option value="">Selecione</option>';
  getOperationalUsers().forEach((user) => {
    const opt = document.createElement("option");
    opt.value = user.id;
    opt.textContent = getUserLabel(user.id);
    sstDocResponsible.append(opt);
  });
  if (selected) {
    sstDocResponsible.value = selected;
  }
}

function renderSstNcResponsibleOptions() {
  const usersList = getOperationalUsers();
  const fill = (select, selectedValue, emptyLabel) => {
    if (!select) {
      return;
    }
    const selected = selectedValue || select.value || "";
    select.innerHTML = `<option value="">${emptyLabel}</option>`;
    usersList.forEach((user) => {
      const opt = document.createElement("option");
      opt.value = user.id;
      opt.textContent = getUserLabel(user.id);
      select.append(opt);
    });
    if (selected) {
      select.value = selected;
    }
  };
  const ncResponsibleSelected = sstNcResponsible
    ? sstNcResponsible.value || (currentUser ? currentUser.id : "")
    : currentUser
      ? currentUser.id
      : "";
  fill(sstNcResponsible, ncResponsibleSelected, "Selecione");
  fill(sstNcFilterResponsible, "", "Todos");
  fill(sstNcDetailsResponsible, sstNcDetailsData ? sstNcDetailsData.responsibleId : "", "Selecione");
  const actionSelected = sstNcActionResponsible
    ? sstNcActionResponsible.value || (currentUser ? currentUser.id : "")
    : currentUser
      ? currentUser.id
      : "";
  fill(sstNcActionResponsible, actionSelected, "Selecione");
}

function renderSstNcSourceOptions() {
  if (!sstNcSourceInspection) {
    return;
  }
  const selected = sstNcSourceInspection.value;
  sstNcSourceInspection.innerHTML =
    '<option value="">Sem inspeção vinculada</option>';
  const list = Array.isArray(sstInspections) ? sstInspections.slice() : [];
  list
    .sort((a, b) => {
      const dateA = parseTimestamp(a.startedAt) || 0;
      const dateB = parseTimestamp(b.startedAt) || 0;
      return dateB - dateA;
    })
    .forEach((run) => {
      const project = availableProjects.find((item) => item.id === run.projectId);
      const labelProject = project ? getProjectLabel(project) : run.projectId || "-";
      const when = run.startedAt ? formatDateTime(parseTimestamp(run.startedAt)) : "-";
      const opt = document.createElement("option");
      opt.value = run.id;
      opt.textContent = `${run.templateName || "Checklist"} • ${labelProject} • ${when}`;
      sstNcSourceInspection.append(opt);
    });
  if (selected) {
    sstNcSourceInspection.value = selected;
  }
}

function renderSstSelectors() {
  renderSstProjectOptions();
  renderSstInspectionLocalOptions();
  renderSstInspectionTemplateOptions();
  renderSstInspectionFilterTemplateOptions();
  renderSstInspectionUserOptions();
  const podeGerenciar = Boolean(currentUser && canManageSst(currentUser));
  setFormDisabled(sstTrainingForm, !podeGerenciar);
  setFormDisabled(sstInspectionForm, !podeGerenciar);
  setFormDisabled(sstNcForm, !podeGerenciar);
  setFormDisabled(sstIncidentForm, !podeGerenciar);
  if (sstInspectionStartBtn) {
    sstInspectionStartBtn.disabled = !podeGerenciar;
  }
  if (sstTemplateNewBtn) {
    sstTemplateNewBtn.disabled = !podeGerenciar;
  }
  if (sstTemplateSeedBtn) {
    sstTemplateSeedBtn.disabled = !podeGerenciar;
  }
  renderSstDocResponsibleOptions();
  renderSstNcResponsibleOptions();
  renderSstNcSourceOptions();
  const podeEnviarDocs = Boolean(currentUser && canViewSst(currentUser));
  setFormDisabled(formSstDoc, !podeEnviarDocs);
  if (sstDocNewBtn) {
    sstDocNewBtn.disabled = !podeEnviarDocs;
  }
}

function renderSstDashboard() {
  if (!sstDashCards || !sstLoaded) {
    return;
  }
  const scopedNcs = activeProjectId
    ? sstNonconformities.filter((nc) => nc.projectId === activeProjectId)
    : sstNonconformities;
  const scopedInspections = activeProjectId
    ? sstInspections.filter((insp) => insp.projectId === activeProjectId)
    : sstInspections;
  const scopedIncidents = activeProjectId
    ? sstIncidents.filter((inc) => inc.projectId === activeProjectId)
    : sstIncidents;
  const openNcs = scopedNcs.filter(
    (nc) => normalizeSstNcStatus(nc.status) !== "DONE"
  );
  const naoConformes = scopedInspections.filter(
    (insp) => normalizeSstInspectionStatus(insp.status) === "NON_CONFORMING"
  );
  const incidentes = scopedIncidents.filter((inc) => {
    const data = parseDate(inc.date);
    if (!data) {
      return false;
    }
    const diff = diffInDays(startOfDay(data), startOfDay(new Date()));
    return diff >= 0 && diff <= 30;
  });
  const trainingsExpiring = sstTrainingRecords.filter(
    (record) => record.validUntil && isDateExpiring(record.validUntil, 30)
  );
  const cards = [
    { label: "Treinamentos vencendo (30d)", value: trainingsExpiring.length },
    { label: "Inspeções não conformes", value: naoConformes.length },
    { label: "NCs em aberto", value: openNcs.length },
    { label: "Incidentes (30d)", value: incidentes.length },
  ];
  sstDashCards.innerHTML = cards
    .map(
      (card) =>
        `<div><small>${escapeHtml(card.label)}</small><strong>${escapeHtml(
          String(card.value)
        )}</strong></div>`
    )
    .join("");

  if (sstAlertas) {
    sstAlertas.innerHTML = "";
    const alerts = [];
    trainingsExpiring.slice(0, 4).forEach((record) => {
      const training = sstTrainings.find((t) => t.id === record.trainingId);
      alerts.push(
        `Treinamento ${training ? training.name : record.trainingId} vencendo em ${record.validUntil}`
      );
    });
    openNcs.slice(0, 4).forEach((nc) => {
      const label = nc.title || nc.description || nc.id;
      alerts.push(`NC ${label} - prazo ${nc.dueDate || "-"}`);
    });
    if (!alerts.length) {
      if (sstAlertasVazio) {
        sstAlertasVazio.hidden = false;
      }
    } else {
      if (sstAlertasVazio) {
        sstAlertasVazio.hidden = true;
      }
      alerts.forEach((msg) => {
        const card = document.createElement("div");
        card.className = "lembrete-item";
        const title = document.createElement("strong");
        title.textContent = msg;
        card.append(title);
        sstAlertas.append(card);
      });
    }
  }
}

function renderSstTreinamentos() {
  if (!sstTrainingTableBody || !sstLoaded) {
    return;
  }
  renderSstSelectors();
  const list = sstTrainings.filter((item) => item && item.status !== "INATIVO");
  sstTrainingTableBody.innerHTML = list
    .map(
      (training) => `
        <tr>
          <td>${escapeHtml(training.name || "-")}</td>
          <td>${escapeHtml(training.nr || "-")}</td>
          <td>${escapeHtml(String(training.hours || 0))}</td>
          <td>${escapeHtml(String(training.validityDays || 0))}</td>
        </tr>
      `
    )
    .join("");
  if (sstTrainingEmpty) {
    sstTrainingEmpty.hidden = list.length > 0;
  }
}

function renderSstInspecoes() {
  if (!sstLoaded) {
    return;
  }
  renderSstSelectors();
  renderSstInspectionTemplates();
  renderSstInspectionHistory();
}

function renderSstInspectionTemplates() {
  if (!sstTemplateTableBody) {
    return;
  }
  const list = Array.isArray(sstInspectionTemplates) ? sstInspectionTemplates.slice() : [];
  sstTemplateTableBody.innerHTML = list
    .sort((a, b) => a.name.localeCompare(b.name, "pt-BR"))
    .map((template) => {
      const statusLabel = template.isActive ? "Ativo" : "Inativo";
      const statusBadge = template.isActive
        ? `<span class="badge badge--ok">${statusLabel}</span>`
        : `<span class="badge badge--warn">${statusLabel}</span>`;
      const periodicity = getSstPeriodicityLabel(template.periodicityDays);
      const qtd = Array.isArray(template.questions) ? template.questions.length : 0;
      return `
        <tr>
          <td>${escapeHtml(template.name)}</td>
          <td>${escapeHtml(getSstChecklistTypeLabel(template.type))}</td>
          <td>${escapeHtml(periodicity)}</td>
          <td>${statusBadge}</td>
          <td>${escapeHtml(String(qtd))}</td>
          <td>
            <button class="btn btn--ghost btn--small" data-action="edit" data-id="${template.id}">
              Editar
            </button>
            <button class="btn btn--ghost btn--small" data-action="duplicate" data-id="${template.id}">
              Duplicar
            </button>
            <button class="btn btn--ghost btn--small" data-action="toggle" data-id="${template.id}">
              ${template.isActive ? "Desativar" : "Ativar"}
            </button>
          </td>
        </tr>
      `;
    })
    .join("");
  if (sstTemplateEmpty) {
    sstTemplateEmpty.hidden = list.length > 0;
  }
}

function getSstInspectionHistoryFilters() {
  return {
    projectId: sstInspectionFilterProject ? sstInspectionFilterProject.value : "",
    templateId: sstInspectionFilterTemplate ? sstInspectionFilterTemplate.value : "",
    status: sstInspectionFilterStatus ? sstInspectionFilterStatus.value : "",
    from: sstInspectionFilterFrom ? sstInspectionFilterFrom.value : "",
    to: sstInspectionFilterTo ? sstInspectionFilterTo.value : "",
    q: sstInspectionFilterSearch ? sstInspectionFilterSearch.value : "",
  };
}

function renderSstInspectionHistory() {
  if (!sstInspectionTableBody) {
    return;
  }
  const filters = getSstInspectionHistoryFilters();
  let list = Array.isArray(sstInspections) ? sstInspections.slice() : [];
  if (filters.projectId) {
    list = list.filter((run) => String(run.projectId) === String(filters.projectId));
  }
  if (filters.templateId) {
    list = list.filter((run) => String(run.templateId) === String(filters.templateId));
  }
  if (filters.status) {
    const status = normalizeSstInspectionStatus(filters.status);
    list = list.filter((run) => normalizeSstInspectionStatus(run.status) === status);
  }
  if (filters.from) {
    const fromDate = parseDate(filters.from);
    list = list.filter((run) => {
      const when = parseTimestamp(run.startedAt);
      return when && fromDate ? when >= fromDate : true;
    });
  }
  if (filters.to) {
    const toDate = parseDate(filters.to);
    list = list.filter((run) => {
      const when = parseTimestamp(run.startedAt);
      return when && toDate ? when <= endOfDay(toDate) : true;
    });
  }
  if (filters.q) {
    const term = normalizeSearchValue(filters.q);
    list = list.filter(
      (run) =>
        normalizeSearchValue(run.templateName || "").includes(term) ||
        normalizeSearchValue(run.notes || "").includes(term)
    );
  }
  sstInspectionTableBody.innerHTML = list
    .map((run) => {
      const project = availableProjects.find((item) => item.id === run.projectId);
      const data = run.startedAt ? formatDateTime(parseTimestamp(run.startedAt)) : "-";
      const failLabel = `${run.failCount || 0} / ${run.criticalFailCount || 0}`;
      const safetyLabel = run.safetyResponsibleId
        ? getUserLabel(run.safetyResponsibleId)
        : "-";
      const inspectorLabel = run.inspectorId ? getUserLabel(run.inspectorId) : "-";
      const vehicleData = getRunVehicleData(run);
      const vehicleLabel = vehicleData ? getSstVehicleLabel(vehicleData) : "-";
      const auditLines = [
        `SST: ${escapeHtml(safetyLabel)}`,
        `Insp: ${escapeHtml(inspectorLabel)}`,
      ];
      if (vehicleLabel && vehicleLabel !== "-") {
        auditLines.push(`Veículo: ${escapeHtml(vehicleLabel)}`);
      }
      const auditHtml = auditLines.join("<br/>");
      return `
        <tr>
          <td>${escapeHtml(data)}</td>
          <td>${escapeHtml(run.templateName || "-")}</td>
          <td>${escapeHtml(project ? getProjectLabel(project) : run.projectId || "-")}</td>
          <td>${escapeHtml(run.worksiteId || "-")}</td>
          <td>${auditHtml}</td>
          <td>${escapeHtml(String(run.score ?? "-"))}</td>
          <td>${getSstStatusBadge(run.status)}</td>
          <td>${escapeHtml(failLabel)}</td>
          <td>
            <button class="btn btn--ghost btn--small" data-action="details" data-id="${run.id}">
              Detalhes
            </button>
          </td>
        </tr>
      `;
    })
    .join("");
  if (sstInspectionEmpty) {
    sstInspectionEmpty.hidden = list.length > 0;
  }
}

function resetSstVehicleForm() {
  if (sstVehicleForm) {
    sstVehicleForm.reset();
  }
  if (sstVehicleId) {
    sstVehicleId.value = "";
  }
  sstVehicleEditingId = null;
  if (sstVehicleSubmit) {
    sstVehicleSubmit.textContent = "Salvar veículo";
  }
}

function fillSstVehicleForm(vehicle) {
  if (!vehicle) {
    resetSstVehicleForm();
    return;
  }
  if (sstVehicleId) {
    sstVehicleId.value = vehicle.id || "";
  }
  if (sstVehicleProject) {
    sstVehicleProject.value = vehicle.projectId || "";
  }
  if (sstVehiclePlate) {
    sstVehiclePlate.value = vehicle.plate || "";
  }
  if (sstVehicleModel) {
    sstVehicleModel.value = vehicle.model || "";
  }
  if (sstVehicleType) {
    sstVehicleType.value = vehicle.type || "OUTRO";
  }
  if (sstVehicleStatus) {
    sstVehicleStatus.value = getVehicleStatusLabel(vehicle.status);
  }
  sstVehicleEditingId = vehicle.id || null;
  if (sstVehicleSubmit) {
    sstVehicleSubmit.textContent = "Atualizar veículo";
  }
}

function renderSstVehicles() {
  if (!sstVehicleTableBody) {
    return;
  }
  const filterProject = sstVehicleFilterProject ? sstVehicleFilterProject.value : "";
  const filterStatus = sstVehicleFilterStatus ? sstVehicleFilterStatus.value : "ALL";
  const filterSearch = sstVehicleFilterSearch ? sstVehicleFilterSearch.value : "";
  let list = Array.isArray(sstVehicles) ? sstVehicles.slice() : [];
  if (filterProject) {
    list = list.filter((item) => String(item.projectId) === String(filterProject));
  }
  if (filterStatus && filterStatus !== "ALL") {
    const status = normalizeVehicleStatusValue(filterStatus);
    list = list.filter((item) => normalizeVehicleStatusValue(item.status) === status);
  }
  if (filterSearch) {
    const term = normalizeSearchValue(filterSearch);
    list = list.filter(
      (item) =>
        normalizeSearchValue(item.plate).includes(term) ||
        normalizeSearchValue(item.model).includes(term)
    );
  }
  list.sort((a, b) => String(a.plate).localeCompare(String(b.plate), "pt-BR"));
  sstVehicleTableBody.innerHTML = list
    .map((vehicle) => {
      const project = availableProjects.find((item) => item.id === vehicle.projectId);
      const status = normalizeVehicleStatusValue(vehicle.status);
      const inactiveLabel = status === "INATIVO" ? "Reativar" : "Inativar";
      const inactiveNext = status === "INATIVO" ? "Ativo" : "Inativo";
      const maintenanceLabel = status === "MANUTENCAO" ? "Ativar" : "Manutenção";
      const maintenanceNext = status === "MANUTENCAO" ? "Ativo" : "Manutenção";
      return `
        <tr>
          <td>${escapeHtml(project ? getProjectLabel(project) : vehicle.projectId || "-")}</td>
          <td>${escapeHtml(vehicle.plate || "-")}</td>
          <td>${escapeHtml(vehicle.model || "-")}</td>
          <td>${escapeHtml(vehicle.type || "-")}</td>
          <td>${getSstVehicleStatusBadge(status)}</td>
          <td>
            <button class="btn btn--ghost btn--small" data-action="edit-vehicle" data-id="${vehicle.id}">
              Editar
            </button>
            <button class="btn btn--ghost btn--small" data-action="set-status" data-status="${maintenanceNext}" data-id="${vehicle.id}">
              ${maintenanceLabel}
            </button>
            <button class="btn btn--ghost btn--small btn--danger" data-action="set-status" data-status="${inactiveNext}" data-id="${vehicle.id}">
              ${inactiveLabel}
            </button>
          </td>
        </tr>
      `;
    })
    .join("");
  if (sstVehicleEmpty) {
    sstVehicleEmpty.hidden = list.length > 0;
  }
}

async function handleSstVehicleSubmit(event) {
  event.preventDefault();
  if (!currentUser || !canManageProjetos(currentUser)) {
    setInlineMessage(sstVehicleMsg, "Sem permiss\u00e3o para salvar veiculo.", true);
    return;
  }
  const payload = {
    id: sstVehicleEditingId || (sstVehicleId ? sstVehicleId.value : ""),
    projectId: sstVehicleProject ? sstVehicleProject.value : "",
    plate: sstVehiclePlate ? normalizeVehiclePlate(sstVehiclePlate.value) : "",
    model: sstVehicleModel ? sstVehicleModel.value.trim() : "",
    type: sstVehicleType ? sstVehicleType.value : "",
    status: sstVehicleStatus ? sstVehicleStatus.value : "Ativo",
  };
  if (!payload.projectId) {
    setInlineMessage(sstVehicleMsg, "Selecione o projeto.", true);
    return;
  }
  if (!payload.plate) {
    setInlineMessage(sstVehicleMsg, "Informe a placa.", true);
    return;
  }
  try {
    await dataProvider.vehicles.upsertVehicle(payload);
    sstVehicles = await dataProvider.vehicles.listVehicles();
    renderSstVehicles();
    renderSstVehicleOptions();
    resetSstVehicleForm();
    setInlineMessage(sstVehicleMsg, "Veiculo salvo com sucesso.");
  } catch (error) {
    setInlineMessage(sstVehicleMsg, error.message || "Erro ao salvar veiculo.", true);
  }
}

async function handleSstVehicleTableClick(event) {
  const button = event.target.closest("button[data-action]");
  if (!button) {
    return;
  }
  if (!currentUser || !canManageProjetos(currentUser)) {
    setInlineMessage(sstVehicleMsg, "Sem permiss\u00e3o para alterar veiculo.", true);
    return;
  }
  const id = button.dataset.id;
  if (!id) {
    return;
  }
  const vehicle = sstVehicles.find((item) => String(item.id) === String(id));
  if (!vehicle) {
    return;
  }
  const action = button.dataset.action;
  if (action === "edit-vehicle") {
    fillSstVehicleForm(vehicle);
    return;
  }
  if (action === "set-status") {
    const nextStatus = button.dataset.status || "Ativo";
    try {
      await dataProvider.vehicles.upsertVehicle({ ...vehicle, status: nextStatus });
      sstVehicles = await dataProvider.vehicles.listVehicles();
      renderSstVehicles();
      renderSstVehicleOptions();
    } catch (error) {
      setInlineMessage(sstVehicleMsg, error.message || "Erro ao atualizar veiculo.", true);
    }
  }
}

function getSstNcFilters() {
  return {
    projectId: sstNcFilterProject ? sstNcFilterProject.value : "",
    status: sstNcFilterStatus ? sstNcFilterStatus.value : "",
    severity: sstNcFilterSeverity ? sstNcFilterSeverity.value : "",
    responsibleId: sstNcFilterResponsible ? sstNcFilterResponsible.value : "",
    from: sstNcFilterFrom ? sstNcFilterFrom.value : "",
    to: sstNcFilterTo ? sstNcFilterTo.value : "",
    q: sstNcFilterSearch ? sstNcFilterSearch.value : "",
  };
}

function renderSstNcFileList(container, files) {
  if (!container) {
    return;
  }
  const list = Array.isArray(files) ? files : [];
  container.innerHTML = "";
  if (!list.length) {
    return;
  }
  list.forEach((file) => {
    const item = document.createElement("div");
    item.className = "file-list__item";
    const name = document.createElement("span");
    name.textContent = file.name || "Arquivo";
    const meta = document.createElement("small");
    meta.className = "file-list__meta";
    meta.textContent = formatFileSize(file.size || 0);
    item.append(name, meta);
    container.append(item);
  });
}

function renderSstNcs() {
  if (!sstNcTableBody || !sstLoaded) {
    return;
  }
  renderSstSelectors();
  const filters = getSstNcFilters();
  let list = Array.isArray(sstNonconformities) ? sstNonconformities.slice() : [];
  if (filters.projectId) {
    list = list.filter((nc) => String(nc.projectId) === String(filters.projectId));
  } else if (activeProjectId) {
    list = list.filter((nc) => String(nc.projectId) === String(activeProjectId));
  }
  if (filters.status) {
    const status = normalizeSstNcStatus(filters.status);
    list = list.filter((nc) => normalizeSstNcStatus(nc.status) === status);
  }
  if (filters.severity) {
    const sev = normalizeSstSeverity(filters.severity);
    list = list.filter((nc) => normalizeSstSeverity(nc.severity) === sev);
  }
  if (filters.responsibleId) {
    list = list.filter((nc) => String(nc.responsibleId) === String(filters.responsibleId));
  }
  if (filters.from) {
    const fromDate = parseDate(filters.from);
    list = list.filter((nc) => {
      const when = parseDate(nc.dueDate) || parseTimestamp(nc.createdAt);
      return when && fromDate ? when >= fromDate : true;
    });
  }
  if (filters.to) {
    const toDate = parseDate(filters.to);
    list = list.filter((nc) => {
      const when = parseDate(nc.dueDate) || parseTimestamp(nc.createdAt);
      return when && toDate ? when <= endOfDay(toDate) : true;
    });
  }
  if (filters.q) {
    const term = normalizeSearchValue(filters.q);
    list = list.filter((nc) => {
      return (
        normalizeSearchValue(nc.title || "").includes(term) ||
        normalizeSearchValue(nc.description || "").includes(term) ||
        normalizeSearchValue(nc.category || "").includes(term)
      );
    });
  }
  list.sort((a, b) => {
    const dateA = parseTimestamp(a.updatedAt || a.createdAt) || 0;
    const dateB = parseTimestamp(b.updatedAt || b.createdAt) || 0;
    return dateB - dateA;
  });
  sstNcTableBody.innerHTML = list
    .map((nc) => {
      const project = availableProjects.find((item) => item.id === nc.projectId);
      const title = nc.title || nc.description || "-";
      const responsavel = getUserLabel(nc.responsibleId);
      const updatedAt = nc.updatedAt ? formatDateTime(parseTimestamp(nc.updatedAt)) : "-";
      const dueDate = nc.dueDate || "-";
      const due = parseDate(nc.dueDate);
      const overdue =
        due && diffInDays(startOfDay(due), startOfDay(new Date())) < 0 ? "text-danger" : "";
      return `
        <tr>
          <td>${escapeHtml(getSstNcCode(nc))}</td>
          <td>${escapeHtml(title)}</td>
          <td>${escapeHtml(project ? getProjectLabel(project) : nc.projectId || "-")}</td>
          <td>${getSstSeverityBadge(nc.severity || "")}</td>
          <td>${getSstNcStatusBadge(nc.status)}</td>
          <td class="${overdue}">${escapeHtml(dueDate)}</td>
          <td>${escapeHtml(responsavel || "-")}</td>
          <td>${escapeHtml(updatedAt)}</td>
          <td>
            <button class="btn btn--ghost btn--small" data-action="details" data-id="${nc.id}">
              Detalhes
            </button>
          </td>
        </tr>
      `;
    })
    .join("");
  if (sstNcEmpty) {
    sstNcEmpty.hidden = list.length > 0;
  }
}

function renderSstIncidentes() {
  if (!sstIncidentTableBody || !sstLoaded) {
    return;
  }
  renderSstSelectors();
  const list = activeProjectId
    ? sstIncidents.filter((item) => item.projectId === activeProjectId)
    : sstIncidents;
  sstIncidentTableBody.innerHTML = list
    .map((inc) => {
      const project = availableProjects.find((item) => item.id === inc.projectId);
      return `
        <tr>
          <td>${escapeHtml(project ? getProjectLabel(project) : inc.projectId || "-")}</td>
          <td>${escapeHtml(inc.category || "-")}</td>
          <td>${escapeHtml(inc.severity || "-")}</td>
          <td>${escapeHtml(inc.date || "-")}</td>
        </tr>
      `;
    })
    .join("");
  if (sstIncidentEmpty) {
    sstIncidentEmpty.hidden = list.length > 0;
  }
}

function getSstDocStatusLabel(status) {
  const normalizado = String(status || "").toUpperCase();
  if (normalizado === "APROVADO") {
    return "Aprovado";
  }
  if (normalizado === "REPROVADO") {
    return "Reprovado";
  }
  return "Pendente";
}

function getSstDocStatusBadge(status) {
  const normalizado = String(status || "").toUpperCase();
  if (normalizado === "APROVADO") {
    return `<span class="badge badge--ok">Aprovado</span>`;
  }
  if (normalizado === "REPROVADO") {
    return `<span class="badge badge--crit">Reprovado</span>`;
  }
  return `<span class="badge badge--warn">Pendente</span>`;
}

function normalizeSstDoc(doc) {
  if (!doc || typeof doc !== "object") {
    return null;
  }
  const createdAt = doc.createdAt || toIsoUtc(new Date());
  const status = doc.status ? String(doc.status).toUpperCase() : "PENDENTE";
  return {
    id: doc.id || criarId(),
    activity: doc.activity || doc.activityName || "",
    projectId: doc.projectId || "",
    responsibleId: doc.responsibleId || doc.createdBy || "",
    aprCode: doc.aprCode || "",
    aprDoc: doc.aprDoc || doc.apr || null,
    attachments: Array.isArray(doc.attachments) ? doc.attachments.filter(Boolean) : [],
    status,
    notes: doc.notes || "",
    createdAt,
    createdBy: doc.createdBy || doc.responsibleId || "",
    reviewedAt: doc.reviewedAt || "",
    reviewedBy: doc.reviewedBy || "",
    reviewNotes: doc.reviewNotes || "",
    correctionInstructions: doc.correctionInstructions || "",
    notifiedAt: doc.notifiedAt || "",
    source: doc.source || "manual",
    relatedId: doc.relatedId || "",
    updatedAt: doc.updatedAt || createdAt,
  };
}

function normalizeSstChecklistType(value) {
  const raw = String(value || "").trim();
  if (!raw) {
    return "";
  }
  return raw.replace(/\s+/g, "_").replace(/[^a-z0-9_]/gi, "").toUpperCase();
}

function normalizeSstSeverity(value) {
  const raw = String(value || "").trim().toUpperCase();
  if (raw === "LOW" || raw === "BAIXA") {
    return "LOW";
  }
  if (raw === "MED" || raw === "MEDIA" || raw === "MÉDIA") {
    return "MED";
  }
  if (raw === "HIGH" || raw === "ALTA") {
    return "HIGH";
  }
  if (raw === "CRITICAL" || raw === "CRITICA" || raw === "CRÍTICA") {
    return "CRITICAL";
  }
  return "MED";
}

function normalizeSstAnswerValue(value) {
  const raw = String(value || "").trim().toUpperCase();
  if (raw === "OK") {
    return "OK";
  }
  if (raw === "FAIL" || raw === "FALHA" || raw === "NAO_CONFORME" || raw === "NAO CONFORME") {
    return "FAIL";
  }
  if (raw === "NA" || raw === "N/A") {
    return "NA";
  }
  return "";
}

function normalizeSstInspectionStatus(value) {
  const raw = String(value || "").trim().toUpperCase();
  if (raw === "OK") {
    return "OK";
  }
  if (raw === "ATTENTION" || raw === "ATENCAO") {
    return "ATTENTION";
  }
  if (raw === "NON_CONFORMING" || raw === "NAO CONFORME" || raw === "NAO_CONFORME") {
    return "NON_CONFORMING";
  }
  return "OK";
}

function normalizeSstChecklistQuestion(question, templateId, order) {
  if (!question || typeof question !== "object") {
    return null;
  }
  const text = String(question.text || "").trim();
  if (!text) {
    return null;
  }
  const safeOrder = Number.isFinite(Number(order)) ? Number(order) : Number(question.order || 1);
  return {
    id: question.id || criarId(),
    templateId,
    order: safeOrder || 1,
    text,
    helpText: question.helpText ? String(question.helpText) : "",
    severity: normalizeSstSeverity(question.severity),
    requiresPhotoOnFail: Boolean(question.requiresPhotoOnFail),
    autoCreateNc: question.autoCreateNc !== false,
  };
}

function normalizeSstChecklistTemplate(template) {
  if (!template || typeof template !== "object") {
    return null;
  }
  const name = String(template.name || template.nome || "").trim();
  if (!name) {
    return null;
  }
  const id = template.id || criarId();
  const createdAt = template.createdAt || toIsoUtc(new Date());
  const updatedAt = template.updatedAt || createdAt;
  let periodicityDays = template.periodicityDays;
  if (periodicityDays === "" || periodicityDays === undefined || periodicityDays === null) {
    periodicityDays = null;
  } else {
    const num = Number(periodicityDays);
    periodicityDays = Number.isFinite(num) && num > 0 ? Math.round(num) : null;
  }
  const rawQuestions = Array.isArray(template.questions) ? template.questions : [];
  const questions = rawQuestions
    .map((question, index) =>
      normalizeSstChecklistQuestion(question, id, question.order || index + 1)
    )
    .filter(Boolean)
    .sort((a, b) => a.order - b.order);
  return {
    id,
    name,
    type: normalizeSstChecklistType(template.type),
    periodicityDays,
    isActive: template.isActive !== false,
    projectId: template.projectId || "",
    createdAt,
    updatedAt,
    questions,
  };
}

function normalizeSstInspectionAnswer(answer, runId, question) {
  if (!answer || typeof answer !== "object") {
    return null;
  }
  const answerValue = normalizeSstAnswerValue(answer.answer);
  if (!answerValue) {
    return null;
  }
  const questionId = answer.questionId || (question ? question.id : "");
  if (!questionId) {
    return null;
  }
  return {
    id: answer.id || criarId(),
    runId: answer.runId || runId || "",
    questionId,
    answer: answerValue,
    notes: answer.notes ? String(answer.notes) : "",
    severitySnapshot: normalizeSstSeverity(
      answer.severitySnapshot || (question ? question.severity : "")
    ),
    createdAt: answer.createdAt || toIsoUtc(new Date()),
    evidenceIds: Array.isArray(answer.evidenceIds) ? answer.evidenceIds.filter(Boolean) : [],
  };
}

function normalizeSstInspectionRun(run) {
  if (!run || typeof run !== "object") {
    return null;
  }
  const templateId = run.templateId || "";
  const projectId = run.projectId || "";
  if (!templateId || !projectId) {
    return null;
  }
  const id = run.id || criarId();
  const startedAt = run.startedAt || run.createdAt || toIsoUtc(new Date());
  const finishedAt = run.finishedAt || "";
  const rawAnswers = Array.isArray(run.answers) ? run.answers : [];
  const answers = rawAnswers
    .map((answer) => normalizeSstInspectionAnswer(answer, id))
    .filter(Boolean);
  return {
    id,
    templateId,
    projectId,
    worksiteId: run.worksiteId || "",
    inspectorId: run.inspectorId || run.createdBy || "",
    safetyResponsibleId: run.safetyResponsibleId || "",
    vehicleId: run.vehicleId || "",
    vehicleSnapshot: run.vehicleSnapshot || null,
    startedAt,
    finishedAt,
    score: Number.isFinite(Number(run.score)) ? Number(run.score) : 0,
    status: normalizeSstInspectionStatus(run.status),
    notes: run.notes ? String(run.notes) : "",
    answers,
  };
}

function normalizeVehiclePlate(rawPlate) {
  return String(rawPlate || "")
    .toUpperCase()
    .replace(/[^A-Z0-9]/g, "");
}

function normalizeVehicleStatusValue(status) {
  const normalized = String(status || "ATIVO").toUpperCase();
  if (normalized === "MANUTENCAO" || normalized === "MANUTENÇÃO") {
    return "MANUTENCAO";
  }
  if (normalized === "INATIVO" || normalized === "INACTIVE") {
    return "INATIVO";
  }
  return "ATIVO";
}

function getVehicleStatusLabel(status) {
  const normalized = normalizeVehicleStatusValue(status);
  if (normalized === "MANUTENCAO") {
    return "Manutenção";
  }
  if (normalized === "INATIVO") {
    return "Inativo";
  }
  return "Ativo";
}

function normalizeVehicleType(type) {
  const normalized = String(type || "OUTRO").toUpperCase();
  if (normalized === "CARRO") {
    return "Carro";
  }
  if (normalized === "CAMINHONETE") {
    return "Caminhonete";
  }
  if (normalized === "CAMINHAO" || normalized === "CAMINHÃO") {
    return "Caminhão";
  }
  if (normalized === "VAN") {
    return "Van";
  }
  if (normalized === "ONIBUS" || normalized === "ÔNIBUS") {
    return "Ônibus";
  }
  if (normalized === "MOTO") {
    return "Moto";
  }
  return "Outro";
}

function normalizeSstVehicle(vehicle) {
  if (!vehicle || typeof vehicle !== "object") {
    return null;
  }
  const projectId = String(vehicle.projectId || "").trim();
  const plateRaw = String(vehicle.plate || vehicle.placa || "").trim();
  const plate = normalizeVehiclePlate(plateRaw);
  if (!projectId || !plate) {
    return null;
  }
  const id = vehicle.id || criarId();
  const createdAt = vehicle.createdAt || toIsoUtc(new Date());
  const updatedAt = vehicle.updatedAt || createdAt;
  return {
    id,
    projectId,
    plate,
    plateNormalized: normalizeVehiclePlate(plate),
    model: vehicle.model ? String(vehicle.model) : "",
    type: normalizeVehicleType(vehicle.type),
    status: getVehicleStatusLabel(vehicle.status),
    notes: vehicle.notes ? String(vehicle.notes) : "",
    createdBy: vehicle.createdBy || (currentUser ? currentUser.id : ""),
    createdAt,
    updatedAt,
  };
}

function getSstVehicleLabel(vehicleOrId) {
  if (!vehicleOrId) {
    return "-";
  }
  const vehicle =
    typeof vehicleOrId === "object"
      ? vehicleOrId
      : sstVehicles.find((item) => String(item.id) === String(vehicleOrId));
  if (!vehicle) {
    return String(vehicleOrId || "-");
  }
  const model = vehicle.model ? ` • ${vehicle.model}` : "";
  return `${vehicle.plate}${model}`;
}

function getRunVehicleData(run) {
  if (!run) {
    return null;
  }
  if (run.vehicleSnapshot && run.vehicleSnapshot.plate) {
    return run.vehicleSnapshot;
  }
  if (run.vehicleId) {
    return sstVehicles.find((item) => String(item.id) === String(run.vehicleId)) || null;
  }
  return null;
}

function getSstVehicleStatusBadge(status) {
  const normalized = normalizeVehicleStatusValue(status);
  if (normalized === "MANUTENCAO") {
    return `<span class="badge badge--warn">Manutenção</span>`;
  }
  if (normalized === "INATIVO") {
    return `<span class="badge badge--crit">Inativo</span>`;
  }
  return `<span class="badge badge--ok">Ativo</span>`;
}

function normalizeSstEvidence(evidence) {
  if (!evidence || typeof evidence !== "object") {
    return null;
  }
  const ownerType = String(evidence.ownerType || "").trim().toUpperCase();
  if (!ownerType) {
    return null;
  }
  const ownerId = String(evidence.ownerId || "").trim();
  if (!ownerId) {
    return null;
  }
  return {
    id: evidence.id || criarId(),
    ownerType,
    ownerId,
    fileName: evidence.fileName || evidence.name || "Evidencia",
    fileType: evidence.fileType || "",
    size: Number.isFinite(Number(evidence.size)) ? Number(evidence.size) : 0,
    createdAt: evidence.createdAt || toIsoUtc(new Date()),
    caption: evidence.caption ? String(evidence.caption) : "",
    metadata: evidence.metadata || null,
    createdBy: evidence.createdBy || "",
    dataUrl: evidence.dataUrl || "",
  };
}

function normalizeSstNcStatus(status) {
  const normalized = String(status || "OPEN").toUpperCase();
  if (normalized === "RESOLVIDA") {
    return "DONE";
  }
  if (["OPEN", "IN_PROGRESS", "VERIFY", "DONE"].includes(normalized)) {
    return normalized;
  }
  return "OPEN";
}

function normalizeSstNcAction(action) {
  if (!action || typeof action !== "object") {
    return null;
  }
  const title = String(action.title || action.item || "").trim();
  if (!title) {
    return null;
  }
  return {
    id: action.id || criarId(),
    title,
    status: String(action.status || "OPEN").toUpperCase() === "DONE" ? "DONE" : "OPEN",
    responsibleId: action.responsibleId || "",
    dueDate: action.dueDate || "",
    notes: action.notes || "",
    createdAt: action.createdAt || toIsoUtc(new Date()),
    completedAt: action.completedAt || "",
  };
}

function normalizeSstNcHistory(entry) {
  if (!entry || typeof entry !== "object") {
    return null;
  }
  const message = String(entry.message || entry.descricao || "").trim();
  if (!message) {
    return null;
  }
  return {
    id: entry.id || criarId(),
    action: String(entry.action || "UPDATE").toUpperCase(),
    message,
    createdAt: entry.createdAt || toIsoUtc(new Date()),
    createdBy: entry.createdBy || "",
    metadata: entry.metadata || null,
  };
}

function normalizeSstNonconformity(nc) {
  if (!nc || typeof nc !== "object") {
    return null;
  }
  const projectId = nc.projectId || "";
  if (!projectId) {
    return null;
  }
  const severity = normalizeSstSeverity(nc.severity);
  const rawActions = Array.isArray(nc.actions) ? nc.actions : [];
  const actions = rawActions.map(normalizeSstNcAction).filter(Boolean);
  const rawHistory = Array.isArray(nc.history) ? nc.history : [];
  const history = rawHistory.map(normalizeSstNcHistory).filter(Boolean);
  return {
    id: nc.id || criarId(),
    projectId,
    worksiteId: nc.worksiteId || "",
    sourceType: nc.sourceType || "INSPECTION",
    sourceId: nc.sourceId || "",
    severity,
    title: nc.title || "",
    description: nc.description || "",
    status: normalizeSstNcStatus(nc.status),
    dueDate: nc.dueDate || "",
    category: nc.category || "",
    responsibleId: nc.responsibleId || "",
    rootCause: nc.rootCause || "",
    correction: nc.correction || "",
    createdBy: nc.createdBy || "",
    createdAt: nc.createdAt || toIsoUtc(new Date()),
    updatedAt: nc.updatedAt || nc.createdAt || toIsoUtc(new Date()),
    updatedBy: nc.updatedBy || "",
    closedAt: nc.closedAt || "",
    actions,
    history,
  };
}

function getSstChecklistTypeLabel(type) {
  if (!type) {
    return "-";
  }
  const key = normalizeSstChecklistType(type);
  return SST_CHECKLIST_TYPE_LABELS[key] || type;
}

function getSstPeriodicityLabel(days) {
  if (!days || Number(days) <= 0) {
    return "Por operacao";
  }
  if (Number(days) === 1) {
    return "Diaria";
  }
  if (Number(days) === 7) {
    return "Semanal";
  }
  if (Number(days) === 30) {
    return "Mensal";
  }
  return `${days} dias`;
}

function getSstSeverityBadge(severity) {
  const normalized = normalizeSstSeverity(severity);
  const label = SST_SEVERITY_LABELS[normalized] || normalized;
  if (normalized === "LOW") {
    return `<span class="badge badge--ok">${label}</span>`;
  }
  if (normalized === "MED") {
    return `<span class="badge badge--warn">${label}</span>`;
  }
  return `<span class="badge badge--crit">${label}</span>`;
}

function getSstSeveritySelectValue(severity) {
  const normalized = normalizeSstSeverity(severity);
  if (normalized === "LOW") {
    return "BAIXA";
  }
  if (normalized === "MED") {
    return "MEDIA";
  }
  if (normalized === "HIGH") {
    return "ALTA";
  }
  if (normalized === "CRITICAL") {
    return "CRITICA";
  }
  return "";
}

function getSstStatusBadge(status) {
  const normalized = normalizeSstInspectionStatus(status);
  const label = SST_STATUS_LABELS[normalized] || normalized;
  if (normalized === "OK") {
    return `<span class="badge badge--ok">${label}</span>`;
  }
  if (normalized === "ATTENTION") {
    return `<span class="badge badge--warn">${label}</span>`;
  }
  return `<span class="badge badge--crit">${label}</span>`;
}

function getSstNcStatusLabel(status) {
  const normalized = normalizeSstNcStatus(status);
  if (normalized === "DONE") {
    return "Resolvida";
  }
  if (normalized === "IN_PROGRESS") {
    return "Em andamento";
  }
  if (normalized === "VERIFY") {
    return "Verificar";
  }
  return "Aberta";
}

function getSstNcStatusBadge(status) {
  const normalized = normalizeSstNcStatus(status);
  const label = getSstNcStatusLabel(normalized);
  if (normalized === "DONE") {
    return `<span class="badge badge--ok">${label}</span>`;
  }
  if (normalized === "VERIFY") {
    return `<span class="badge badge--warn">${label}</span>`;
  }
  if (normalized === "IN_PROGRESS") {
    return `<span class="badge badge--warn">${label}</span>`;
  }
  return `<span class="badge badge--warn">${label}</span>`;
}

function getSstNcCode(nc) {
  if (!nc) {
    return "NC";
  }
  const base = String(nc.code || nc.id || "").toUpperCase();
  if (!base) {
    return "NC";
  }
  if (base.startsWith("NC-")) {
    return base;
  }
  return `NC-${base.slice(-6)}`;
}

function buildSstFailStats(answers) {
  const stats = { total: 0, LOW: 0, MED: 0, HIGH: 0, CRITICAL: 0 };
  (answers || []).forEach((answer) => {
    if (!answer || answer.answer !== "FAIL") {
      return;
    }
    const severity = normalizeSstSeverity(answer.severitySnapshot);
    stats.total += 1;
    if (stats[severity] !== undefined) {
      stats[severity] += 1;
    }
  });
  return stats;
}

function calculateSstScore(answers) {
  const penalties = { LOW: 2, MED: 5, HIGH: 12, CRITICAL: 25 };
  let score = 100;
  (answers || []).forEach((answer) => {
    if (!answer || answer.answer !== "FAIL") {
      return;
    }
    const severity = normalizeSstSeverity(answer.severitySnapshot);
    score -= penalties[severity] || 0;
  });
  if (score < 0) {
    return 0;
  }
  if (score > 100) {
    return 100;
  }
  return Math.round(score);
}

function calculateSstStatus(answers) {
  const stats = buildSstFailStats(answers);
  if (stats.CRITICAL > 0 || stats.HIGH >= 2) {
    return "NON_CONFORMING";
  }
  if (stats.HIGH > 0 || stats.MED > 0) {
    return "ATTENTION";
  }
  return "OK";
}

function getSstDueDateForSeverity(severity) {
  const normalized = normalizeSstSeverity(severity);
  const today = new Date();
  if (normalized === "CRITICAL") {
    return toIsoUtc(addDays(today, 3));
  }
  if (normalized === "HIGH") {
    return toIsoUtc(addDays(today, 7));
  }
  if (normalized === "MED") {
    return toIsoUtc(addDays(today, 14));
  }
  return toIsoUtc(addDays(today, 30));
}

function getSstInspectionSeedTemplates() {
  const photoHelp = "Se FAIL, descreva e fotografe a evidencia.";
  return [
    {
      name: "NR-35 - Trabalho em Altura (pre-check)",
      type: "WORK_AT_HEIGHT",
      periodicityDays: 1,
      questions: [
        {
          text: "Ancoragem/linha de vida certificada e inspecionada?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Cinto paraquedista + talabarte (com absorvedor) em bom estado?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Conexoes/travas funcionando e sem deformacoes?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Plano de resgate disponivel e equipe ciente?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Area isolada e sinalizada abaixo do trabalho?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Condicoes climaticas seguras (vento/chuva)?", severity: "MED" },
        { text: "Ferramentas com retencao/amarracao quando necessario?", severity: "MED" },
        { text: "Checklist NR-35 do colaborador preenchido?", severity: "LOW" },
      ],
    },
    {
      name: "Andaimes - Montagem e Condicao",
      type: "SCAFFOLDING",
      periodicityDays: 7,
      questions: [
        {
          text: "Guarda-corpo completo (superior/intermediario/rodape)?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Piso completo, fixo e sem vaos?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Acesso seguro (escada) fixado?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Travamentos/contraventamentos integros?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Base/sapatas niveladas?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Sinalizacao de carga maxima visivel?", severity: "MED" },
        { text: "Rodizios travados (se movel)?", severity: "MED" },
        { text: "Inspecao diaria registrada?", severity: "LOW" },
      ],
    },
    {
      name: "Escadas Portateis",
      type: "LADDERS",
      periodicityDays: 7,
      questions: [
        {
          text: "Escada sem trincas/deformacoes e com sapatas integras?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Angulo correto e base estavel?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Escada fixada no topo quando necessario?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Proibido usar ultimos degraus (quando aplicavel)?", severity: "MED" },
        { text: "Sem improvisos (caixas/tambores)?", severity: "MED" },
        { text: "Area isolada em caso de circulacao?", severity: "LOW" },
      ],
    },
    {
      name: "EPI - Uso e Conformidade (campo)",
      type: "PPE_COMPLIANCE",
      periodicityDays: 1,
      questions: [
        {
          text: "Capacete com jugular quando exigido e sem avarias?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Oculos/face shield quando risco de projecao?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Luvas corretas para a atividade?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Botina adequada (biqueira/solado)?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Protetor auricular quando ruido elevado?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Vestimenta adequada e em boas condicoes?", severity: "MED" },
        { text: "EPI limpo e armazenado adequadamente?", severity: "LOW" },
      ],
    },
    {
      name: "EPC - Sinalizacao e Isolamento de Area",
      type: "EPC_ISOLATION",
      periodicityDays: 1,
      questions: [
        {
          text: "Area de risco isolada com barreira fisica (nao so fita)?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Sinalizacao visivel e coerente com o risco?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Rotas de fuga desobstruidas?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Iluminacao adequada na area?", severity: "MED" },
        { text: "Placas de obrigatoriedade de EPI instaladas?", severity: "LOW" },
      ],
    },
    {
      name: "Extintores - Inspecao Mensal",
      type: "FIRE_EXTINGUISHERS",
      periodicityDays: 30,
      questions: [
        {
          text: "Extintor acessivel e desobstruido?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Lacre e pino intactos?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Manometro na faixa verde (se aplicavel)?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Sinalizacao e suporte adequados?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Validade da carga/manutencao em dia?", severity: "MED" },
        { text: "Identificacao do tipo correta para o risco do local?", severity: "LOW" },
      ],
    },
    {
      name: "Prevencao de Incendio - Housekeeping",
      type: "FIRE_PREVENTION",
      periodicityDays: 7,
      questions: [
        {
          text: "Combustiveis armazenados corretamente?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Sem acumulo de residuos/embalagens?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Proibido fumar sinalizado e respeitado?", severity: "MED" },
        { text: "Extintores presentes nos pontos criticos?", severity: "MED" },
        { text: "Rotas de fuga marcadas?", severity: "LOW" },
      ],
    },
    {
      name: "Eletricidade - NR-10 (campo)",
      type: "NR10_ELECTRICAL",
      periodicityDays: 7,
      questions: [
        {
          text: "Quadros energizados fechados e identificados?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "LOTO aplicado quando intervencao?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Cabos/plugues sem emendas improvisadas?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Aterramento/DR onde exigido?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Ferramentas isoladas quando aplicavel?", severity: "MED" },
        { text: "Organizacao de cabos evitando tropeco?", severity: "LOW" },
      ],
    },
    {
      name: "Ferramentas Eletricas Portateis",
      type: "POWER_TOOLS",
      periodicityDays: 7,
      questions: [
        {
          text: "Carcaca integra, sem fios expostos?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Protecoes/carenagens instaladas?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Disco/acessorio correto e sem trincas?", severity: "MED" },
        { text: "EPI adequado no uso?", severity: "MED" },
        { text: "Check de funcionamento antes do uso?", severity: "LOW" },
      ],
    },
    {
      name: "Maquinas - Protecoes e Emergencia",
      type: "MACHINERY_GUARDS",
      periodicityDays: 7,
      questions: [
        {
          text: "Protecoes fisicas instaladas?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Botao de emergencia funcional e acessivel?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Operador autorizado/treinado?", severity: "HIGH" },
        { text: "Area sinalizada e sem terceiros?", severity: "MED" },
        { text: "Manutencao preventiva registrada?", severity: "LOW" },
      ],
    },
    {
      name: "Icamento - Pre-operacao",
      type: "LIFTING_OPERATIONS",
      periodicityDays: null,
      questions: [
        {
          text: "Plano de rigging e capacidade compativel?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Cintas/manilhas/ganchos inspecionados?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Area isolada e sinalizada?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Sinaleiro designado e comunicacao definida?", severity: "HIGH" },
        { text: "Solo/apoios estabilizados?", severity: "MED" },
        { text: "Condicoes climaticas avaliadas?", severity: "LOW" },
      ],
    },
    {
      name: "Talhas/Guinchos/Correntes",
      type: "HOISTS_CHAINS",
      periodicityDays: 30,
      questions: [
        {
          text: "Correntes/cabos sem deformacao/trinca?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Trava de seguranca do gancho ok?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Capacidade visivel?", severity: "MED" },
        { text: "Registro de inspecao periodico?", severity: "LOW" },
      ],
    },
    {
      name: "Veiculos - Checklist Diario",
      type: "VEHICLES_DAILY",
      periodicityDays: 1,
      questions: [
        { text: "Freios/iluminacao/setas ok?", severity: "HIGH" },
        { text: "Pneus ok?", severity: "HIGH" },
        { text: "Cinto funciona?", severity: "MED" },
        { text: "Extintor/triangulo presentes?", severity: "MED" },
        { text: "Documentacao/habilitacao ok?", severity: "LOW" },
      ],
    },
    {
      name: "Empilhadeira - Operacao",
      type: "FORKLIFT",
      periodicityDays: 1,
      questions: [
        {
          text: "Operador habilitado/autorizado?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Buzina/alarme de re funcionando?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Garfos/correntes sem trincas?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Rotas segregadas de pedestres?", severity: "MED" },
        { text: "Checklist preenchido?", severity: "LOW" },
      ],
    },
    {
      name: "Espaco Confinado - Pre-Entrada",
      type: "CONFINED_SPACE",
      periodicityDays: null,
      questions: [
        {
          text: "PT emitida e valida?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Monitoramento atmosferico (O2/LEL/H2S/CO)?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Vigia presente e comunicacao definida?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Ventilacao/exaustao instalada?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Plano de resgate e equipamentos?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "EPIs especificos disponiveis?", severity: "MED" },
        { text: "Isolamento e sinalizacao do acesso?", severity: "LOW" },
      ],
    },
    {
      name: "Solda/Trabalho a Quente - PTQ",
      type: "HOT_WORK",
      periodicityDays: null,
      questions: [
        {
          text: "PTQ emitida e valida?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Area limpa de combustiveis?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Cortina/protecao de faiscas instalada?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Extintor adequado proximo?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Aterramento e cabos ok?", severity: "MED" },
        { text: "Vigilancia pos-trabalho realizada?", severity: "LOW" },
      ],
    },
    {
      name: "Quimicos - Armazenamento/Manuseio",
      type: "CHEMICALS",
      periodicityDays: 30,
      questions: [
        {
          text: "FISPQ disponivel?",
          severity: "CRITICAL",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Embalagens identificadas e integras?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Armazenamento segregado e ventilado?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Kit de contencao disponivel?", severity: "MED" },
        { text: "EPI quimico disponivel/uso?", severity: "MED" },
        { text: "Registro de controle ok?", severity: "LOW" },
      ],
    },
    {
      name: "Ergonomia - Movimentacao Manual",
      type: "ERGONOMICS",
      periodicityDays: 30,
      questions: [
        { text: "Tecnica correta de levantamento?", severity: "MED" },
        { text: "Peso compativel ou auxilio mecanico?", severity: "MED" },
        { text: "Pausas/rodizio quando repetitivo?", severity: "LOW" },
        { text: "Posto ajustado quando aplicavel?", severity: "LOW" },
      ],
    },
    {
      name: "Ordem e Limpeza - 5S",
      type: "HOUSEKEEPING",
      periodicityDays: 1,
      questions: [
        {
          text: "Rotas livres de obstaculos?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Materiais organizados/empilhamento seguro?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        {
          text: "Residuos segregados e coletores disponiveis?",
          severity: "MED",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Ferramentas guardadas apos uso?", severity: "MED" },
        { text: "Iluminacao/sinalizacao ok?", severity: "LOW" },
      ],
    },
    {
      name: "Primeiros Socorros - Prontidao",
      type: "FIRST_AID",
      periodicityDays: 30,
      questions: [
        {
          text: "Kit completo e dentro da validade?",
          severity: "HIGH",
          requiresPhotoOnFail: true,
          helpText: photoHelp,
        },
        { text: "Pessoas treinadas identificadas?", severity: "HIGH" },
        { text: "Contatos/rota de emergencia disponiveis?", severity: "MED" },
        { text: "Registro de inspecao do kit em dia?", severity: "LOW" },
      ],
    },
  ];
}

async function salvarSstDocArquivo(file) {
  if (!file) {
    return null;
  }
  const agoraIso = toIsoUtc(new Date());
  const nome = file.name || "Documento";
  if (USE_AUTH_API) {
    try {
      const uploaded = await uploadEvidenceFile(file);
      if (!uploaded) {
        return null;
      }
      const uploadName = uploaded.nome || uploaded.name || nome;
      return {
        name: uploadName,
        nome: uploadName,
        mime: uploaded.mime || file.type || "",
        url: uploaded.url || uploaded.dataUrl || "",
        size: uploaded.size || file.size || 0,
        createdAt: agoraIso,
      };
    } catch (error) {
      // fallback para armazenamento local
    }
  }
  const docId = criarId();
  if (typeof indexedDB === "undefined") {
    const data = await lerDocumentoFile(file);
    if (!data || !data.dataUrl) {
      return null;
    }
    return {
      docId,
      name: data.nome || nome,
      nome: data.nome || nome,
      mime: data.type || file.type || "",
      dataUrl: data.dataUrl,
      createdAt: agoraIso,
    };
  }
  try {
    const db = await openDocsDB();
    await new Promise((resolve, reject) => {
      const tx = db.transaction("docs", "readwrite");
      const store = tx.objectStore("docs");
      store.put({
        docId,
        blob: file,
        name: nome,
        mime: file.type || "",
        size: file.size || 0,
        createdAt: agoraIso,
      });
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
      tx.onabort = () => reject(tx.error);
    });
    return {
      docId,
      name: nome,
      nome,
      mime: file.type || "",
      size: file.size || 0,
      createdAt: agoraIso,
    };
  } catch (error) {
    const data = await lerDocumentoFile(file);
    if (!data || !data.dataUrl) {
      return null;
    }
    return {
      docId,
      name: data.nome || nome,
      nome: data.nome || nome,
      mime: data.type || file.type || "",
      dataUrl: data.dataUrl,
      createdAt: agoraIso,
    };
  }
}

async function salvarSstEvidenceArquivo(file) {
  if (!file) {
    return null;
  }
  const evidenceId = criarId();
  const createdAt = toIsoUtc(new Date());
  const name = file.name || "Evidencia";
  if (typeof indexedDB === "undefined") {
    const data = await lerDocumentoFile(file);
    if (!data || !data.dataUrl) {
      return null;
    }
    return {
      evidenceId,
      name: data.nome || name,
      fileType: data.type || file.type || "",
      size: file.size || 0,
      createdAt,
      dataUrl: data.dataUrl,
    };
  }
  try {
    const db = await openOpscopeDb();
    await new Promise((resolve, reject) => {
      const tx = db.transaction("sst_evidences", "readwrite");
      const store = tx.objectStore("sst_evidences");
      store.put({
        evidenceId,
        blob: file,
        name,
        fileType: file.type || "",
        size: file.size || 0,
        createdAt,
      });
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
      tx.onabort = () => reject(tx.error);
    });
    return {
      evidenceId,
      name,
      fileType: file.type || "",
      size: file.size || 0,
      createdAt,
    };
  } catch (error) {
    const data = await lerDocumentoFile(file);
    if (!data || !data.dataUrl) {
      return null;
    }
    return {
      evidenceId,
      name: data.nome || name,
      fileType: data.type || file.type || "",
      size: file.size || 0,
      createdAt,
      dataUrl: data.dataUrl,
    };
  }
}

async function getSstEvidenceById(evidenceId) {
  if (!evidenceId) {
    return null;
  }
  if (typeof indexedDB === "undefined") {
    return null;
  }
  try {
    const db = await openOpscopeDb();
    return await new Promise((resolve) => {
      const tx = db.transaction("sst_evidences", "readonly");
      const store = tx.objectStore("sst_evidences");
      const request = store.get(evidenceId);
      request.onsuccess = () => resolve(request.result || null);
      request.onerror = () => resolve(null);
    });
  } catch (error) {
    return null;
  }
}

function getSstDocsScoped() {
  let list = Array.isArray(sstDocs) ? sstDocs.slice() : [];
  if (!currentUser || !canViewSst(currentUser)) {
    return [];
  }
  const projectFilter = sstDocProjectFilter ? sstDocProjectFilter.value : "";
  if (projectFilter) {
    list = list.filter((doc) => String(doc.projectId || "") === String(projectFilter));
  }
  return list;
}

function getSstDocsFiltered() {
  let list = getSstDocsScoped();
  const statusFilter = sstDocStatusFilter ? sstDocStatusFilter.value : "";
  if (statusFilter) {
    list = list.filter(
      (doc) => String(doc.status || "").toUpperCase() === String(statusFilter).toUpperCase()
    );
  }
  const termo = sstDocSearch ? normalizeSearchValue(sstDocSearch.value || "") : "";
  if (termo) {
    list = list.filter((doc) => {
      const project = availableProjects.find((item) => item.id === doc.projectId);
      const projectLabel = project ? getProjectLabel(project) : doc.projectId || "";
      const responsavel = getUserLabel(doc.responsibleId);
      const aprLabel =
        doc.aprCode || (doc.aprDoc && (doc.aprDoc.name || doc.aprDoc.nome)) || "";
      const base = `${doc.activity || ""} ${projectLabel} ${responsavel} ${aprLabel}`;
      return normalizeSearchValue(base).includes(termo);
    });
  }
  list.sort((a, b) => {
    const stampA = parseTimestamp(a.createdAt) || 0;
    const stampB = parseTimestamp(b.createdAt) || 0;
    return stampB - stampA;
  });
  return list;
}

function renderSstDocStats(scopedDocs) {
  if (!sstDocStats) {
    return;
  }
  const total = scopedDocs.length;
  const pendentes = scopedDocs.filter(
    (doc) => String(doc.status || "").toUpperCase() === "PENDENTE"
  ).length;
  const aprovados = scopedDocs.filter(
    (doc) => String(doc.status || "").toUpperCase() === "APROVADO"
  ).length;
  const reprovados = scopedDocs.filter(
    (doc) => String(doc.status || "").toUpperCase() === "REPROVADO"
  ).length;
  const cards = [
    { label: "Pendentes", value: pendentes },
    { label: "Aprovadas", value: aprovados },
    { label: "Reprovadas", value: reprovados },
    { label: "Total", value: total },
  ];
  sstDocStats.innerHTML = cards
    .map(
      (card) =>
        `<div class="stat-card"><small>${escapeHtml(card.label)}</small><strong>${escapeHtml(
          String(card.value)
        )}</strong></div>`
    )
    .join("");
}

function renderSstDocQueue(scopedDocs) {
  if (!sstDocQueue) {
    return;
  }
  const pendentes = scopedDocs.filter(
    (doc) => String(doc.status || "").toUpperCase() === "PENDENTE"
  );
  const lista = pendentes.slice(0, 6);
  sstDocQueue.innerHTML = lista
    .map((doc) => {
      const project = availableProjects.find((item) => item.id === doc.projectId);
      const projectLabel = project ? getProjectLabel(project) : doc.projectId || "-";
      const responsavel = getUserLabel(doc.responsibleId);
      const enviadoEm = doc.createdAt ? formatDateTime(parseTimestamp(doc.createdAt)) : "-";
      return `
        <div class="doc-queue-item" data-doc-id="${escapeHtml(String(doc.id))}">
          <div>
            <strong>${escapeHtml(doc.activity || "Atividade")}</strong>
            <div class="doc-queue-meta">
              ${escapeHtml(projectLabel)} · ${escapeHtml(responsavel)} · ${escapeHtml(enviadoEm)}
            </div>
          </div>
          <button class="btn btn--ghost btn--small" type="button" data-action="review">
            ${currentUser && canManageSst(currentUser) ? "Revisar" : "Detalhes"}
          </button>
        </div>
      `;
    })
    .join("");
  if (sstDocQueueEmpty) {
    sstDocQueueEmpty.hidden = lista.length > 0;
  }
}

function renderSstDocArchive(scopedDocs) {
  if (!sstDocArchive) {
    return;
  }
  const aprovadas = scopedDocs
    .filter((doc) => String(doc.status || "").toUpperCase() === "APROVADO")
    .sort((a, b) => {
      const stampA = parseTimestamp(a.reviewedAt || a.updatedAt || a.createdAt) || 0;
      const stampB = parseTimestamp(b.reviewedAt || b.updatedAt || b.createdAt) || 0;
      return stampB - stampA;
    });
  sstDocArchive.innerHTML = aprovadas
    .map((doc) => {
      const project = availableProjects.find((item) => item.id === doc.projectId);
      const projectLabel = project ? getProjectLabel(project) : doc.projectId || "-";
      const responsavel = getUserLabel(doc.responsibleId);
      const revisadoEm = doc.reviewedAt
        ? formatDateTime(parseTimestamp(doc.reviewedAt))
        : doc.updatedAt
          ? formatDateTime(parseTimestamp(doc.updatedAt))
          : "-";
      const revisadoPor = doc.reviewedBy ? getUserLabel(doc.reviewedBy) : "Sistema";
      return `
        <div class="doc-queue-item" data-doc-id="${escapeHtml(String(doc.id))}">
          <div>
            <strong>${escapeHtml(doc.activity || "Documentação")}</strong>
            <div class="doc-queue-meta">
              ${escapeHtml(projectLabel)} · ${escapeHtml(responsavel)} · Aprovado em ${escapeHtml(revisadoEm)}
            </div>
            <div class="doc-queue-meta">
              Revisado por ${escapeHtml(revisadoPor)}
            </div>
          </div>
          <button class="btn btn--ghost btn--small" type="button" data-action="review">
            ${currentUser && canManageSst(currentUser) ? "Revisar" : "Detalhes"}
          </button>
        </div>
      `;
    })
    .join("");
  if (sstDocArchiveEmpty) {
    sstDocArchiveEmpty.hidden = aprovadas.length > 0;
  }
}

function renderSstAprPt() {
  if (!sstDocTableBody || !sstLoaded) {
    return;
  }
  renderSstSelectors();
  if (sstDocProjectFilter && !sstDocProjectFilter.dataset.init) {
    if (activeProjectId) {
      sstDocProjectFilter.value = activeProjectId;
    }
    sstDocProjectFilter.dataset.init = "true";
  }
  const scoped = getSstDocsScoped();
  renderSstDocStats(scoped);
  renderSstDocQueue(scoped);
  renderSstDocArchive(scoped);
  const list = getSstDocsFiltered();
  sstDocTableBody.innerHTML = list
    .map((doc) => {
      const project = availableProjects.find((item) => item.id === doc.projectId);
      const projectLabel = project ? getProjectLabel(project) : doc.projectId || "-";
      const responsavel = getUserLabel(doc.responsibleId);
      const envio = doc.createdAt ? formatDateTime(parseTimestamp(doc.createdAt)) : "-";
      const aprLabel =
        doc.aprCode || (doc.aprDoc && (doc.aprDoc.name || doc.aprDoc.nome)) || "-";
      return `
        <tr data-doc-id="${escapeHtml(String(doc.id))}">
          <td>${getSstDocStatusBadge(doc.status)}</td>
          <td>${escapeHtml(doc.activity || "-")}</td>
          <td>${escapeHtml(projectLabel)}</td>
          <td>${escapeHtml(responsavel)}</td>
          <td>${escapeHtml(aprLabel)}</td>
          <td>${escapeHtml(envio)}</td>
          <td>
            <div class="table-actions">
              <button class="btn btn--ghost btn--small" type="button" data-action="review">
                ${currentUser && canManageSst(currentUser) ? "Revisar" : "Detalhes"}
              </button>
            </div>
          </td>
        </tr>
      `;
    })
    .join("");
  if (sstDocEmpty) {
    sstDocEmpty.hidden = list.length > 0;
  }
}

async function carregarVeiculos(force = false) {
  if (vehiclesLoaded && !force) {
    renderSstVehicles();
    renderSstVehicleOptions();
    return;
  }
  try {
    sstVehicles = await dataProvider.vehicles.listVehicles();
  } catch (error) {
    sstVehicles = [];
  }
  vehiclesLoaded = true;
  renderSstVehicles();
  renderSstVehicleOptions();
}

async function carregarSst(force = false) {
  if (!currentUser || !canViewSst(currentUser)) {
    sstTrainings = [];
    sstTrainingRecords = [];
    sstInspectionTemplates = [];
    sstInspections = [];
    sstVehicles = [];
    vehiclesLoaded = false;
    sstNonconformities = [];
    sstIncidents = [];
    sstDocs = [];
    sstLoaded = false;
    renderSstDashboard();
    renderSstTreinamentos();
    renderSstInspecoes();
    renderSstNcs();
    renderSstIncidentes();
    renderSstAprPt();
    return;
  }
  if (sstLoaded && !force) {
    renderSstDashboard();
    return;
  }
  try {
    const data = await apiSstTrainingsList();
    sstTrainings = Array.isArray(data.trainings) ? data.trainings : [];
  } catch (error) {
    sstTrainings = [];
  }
  try {
    const data = await apiSstTrainingRecordsList();
    sstTrainingRecords = Array.isArray(data.records) ? data.records : [];
  } catch (error) {
    sstTrainingRecords = [];
  }
  try {
    await dataProvider.sstInspections.seedTemplatesIfEmpty();
    sstInspectionTemplates = await dataProvider.sstInspections.listTemplates();
  } catch (error) {
    sstInspectionTemplates = [];
  }
  try {
    sstInspections = await dataProvider.sstInspections.listRuns();
  } catch (error) {
    sstInspections = [];
  }
  await carregarVeiculos(true);
  let localNcs = [];
  try {
    localNcs = await dataProvider.sstInspections.listNcs();
  } catch (error) {
    localNcs = [];
  }
  try {
    const data = await apiSstNonconformitiesList();
    const remote = Array.isArray(data.nonconformities) ? data.nonconformities : [];
    const normalizedRemote = remote.map(normalizeSstNonconformity).filter(Boolean);
    const ids = new Set(localNcs.map((item) => item.id));
    sstNonconformities = localNcs.concat(
      normalizedRemote.filter((item) => !ids.has(item.id))
    );
  } catch (error) {
    sstNonconformities = localNcs;
  }
  try {
    const data = await apiSstIncidentsList();
    sstIncidents = Array.isArray(data.incidents) ? data.incidents : [];
  } catch (error) {
    sstIncidents = [];
  }
  sstDocs = await dataProvider.sstDocs.list();
  sstLoaded = true;
  renderSstDashboard();
  renderSstTreinamentos();
  renderSstInspecoes();
  renderSstNcs();
  renderSstIncidentes();
  renderSstAprPt();
}

async function handleAlmoxItemSubmit(event) {
  event.preventDefault();
  if (!currentUser || !canManageAlmoxarifado(currentUser)) {
    setInlineMessage(almoxItemMsg, "Sem permissão para salvar item.", true);
    return;
  }
  const payload = {
    type: almoxItemType ? almoxItemType.value : "",
    unit: almoxItemUnit ? almoxItemUnit.value : "",
    name: almoxItemName ? almoxItemName.value.trim() : "",
    internalCode: almoxItemCode ? almoxItemCode.value.trim() : "",
    barcode: almoxItemBarcode ? almoxItemBarcode.value.trim() : "",
    ca: almoxItemCA ? almoxItemCA.value.trim() : "",
    caValidUntil: almoxItemCaValid ? almoxItemCaValid.value : "",
    itemValidUntil: almoxItemValid ? almoxItemValid.value : "",
    description: almoxItemDesc ? almoxItemDesc.value.trim() : "",
  };
  if (!payload.name) {
    setInlineMessage(almoxItemMsg, "Informe o nome do item.", true);
    return;
  }
  try {
    const data = await apiAlmoxItemCreate(payload);
    if (data && data.item) {
      almoxItems = almoxItems.concat(data.item);
      almoxLoaded = true;
      if (almoxItemForm) {
        almoxItemForm.reset();
      }
      setInlineMessage(almoxItemMsg, "Item salvo com sucesso.");
      renderAlmoxItens();
      renderAlmoxarifado();
    }
  } catch (error) {
    setInlineMessage(almoxItemMsg, error.message || "Erro ao salvar item.", true);
  }
}

async function handleAlmoxMovSubmit(event) {
  event.preventDefault();
  if (!currentUser || !canManageAlmoxarifado(currentUser)) {
    setInlineMessage(almoxMovMsg, "Sem permissão para movimentar estoque.", true);
    return;
  }
  const payload = {
    type: almoxMovType ? almoxMovType.value : "",
    itemId: almoxMovItem ? almoxMovItem.value : "",
    quantity: almoxMovQty ? Number(almoxMovQty.value || 0) : 0,
    projectId: almoxMovProject ? almoxMovProject.value : "",
    projectIdDestino: almoxMovProjectDest ? almoxMovProjectDest.value : "",
    worksite: almoxMovWorksite ? almoxMovWorksite.value.trim() : "",
    worksiteDestino: almoxMovWorksiteDest ? almoxMovWorksiteDest.value.trim() : "",
    collaboratorId: almoxMovColab ? almoxMovColab.value : "",
    reason: almoxMovReason ? almoxMovReason.value.trim() : "",
  };
  if (!payload.projectId) {
    setInlineMessage(almoxMovMsg, "Selecione o projeto.", true);
    return;
  }
  if (!payload.itemId) {
    setInlineMessage(almoxMovMsg, "Selecione o item.", true);
    return;
  }
  if (!payload.quantity || payload.quantity <= 0) {
    setInlineMessage(almoxMovMsg, "Quantidade inválida.", true);
    return;
  }
  if (payload.type === "TRANSFERENCIA" && !payload.projectIdDestino) {
    setInlineMessage(almoxMovMsg, "Informe o projeto destino da transferência.", true);
    return;
  }
  try {
    const data = await apiAlmoxMovementCreate(payload);
    if (data && data.movement) {
      almoxMovements = [data.movement].concat(
        almoxMovements.filter((item) => item.id !== data.movement.id)
      );
      if (Array.isArray(data.stockEntries)) {
        data.stockEntries.forEach((entry) => upsertAlmoxStockEntry(entry));
      }
      try {
        const epiData = await apiAlmoxEpiByUser();
        almoxEpiByUser = Array.isArray(epiData.records) ? epiData.records : almoxEpiByUser;
      } catch (error) {
        // manter cache atual
      }
      setInlineMessage(almoxMovMsg, "Movimentação registrada.");
      if (almoxMovForm) {
        almoxMovForm.reset();
      }
      if (almoxMovQty) {
        almoxMovQty.value = "1";
      }
      renderAlmoxarifado();
      renderAlmoxEstoque();
      renderAlmoxMovimentacoes();
      renderAlmoxEpis();
    }
  } catch (error) {
    setInlineMessage(almoxMovMsg, error.message || "Erro ao registrar movimentação.", true);
  }
}

async function handleSstTrainingSubmit(event) {
  event.preventDefault();
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstTrainingMsg, "Sem permissão para salvar treinamento.", true);
    return;
  }
  const payload = {
    name: sstTrainingName ? sstTrainingName.value.trim() : "",
    nr: sstTrainingNr ? sstTrainingNr.value.trim() : "",
    hours: sstTrainingHours ? Number(sstTrainingHours.value || 0) : 0,
    validityDays: sstTrainingValidity ? Number(sstTrainingValidity.value || 0) : 0,
  };
  if (!payload.name) {
    setInlineMessage(sstTrainingMsg, "Informe o nome do treinamento.", true);
    return;
  }
  try {
    const data = await apiSstTrainingCreate(payload);
    if (data && data.training) {
      sstTrainings = sstTrainings.concat(data.training);
      sstLoaded = true;
      if (sstTrainingForm) {
        sstTrainingForm.reset();
      }
      setInlineMessage(sstTrainingMsg, "Treinamento salvo.");
      renderSstTreinamentos();
      renderSstDashboard();
    }
  } catch (error) {
    setInlineMessage(sstTrainingMsg, error.message || "Erro ao salvar treinamento.", true);
  }
}




function openModal(modal) {
  if (!modal) {
    return;
  }
  modal.hidden = false;
}

function closeModal(modal) {
  if (!modal) {
    return;
  }
  modal.hidden = true;
}

function resetSstTemplateForm() {
  if (formSstTemplate) {
    formSstTemplate.reset();
  }
  if (sstTemplateId) {
    sstTemplateId.value = "";
  }
  if (sstTemplateActive) {
    sstTemplateActive.checked = true;
  }
  if (sstTemplateQuestions) {
    sstTemplateQuestions.innerHTML = "";
  }
  setInlineMessage(sstTemplateMsg, "");
}

function addSstTemplateQuestionRow(question) {
  if (!sstTemplateQuestions) {
    return;
  }
  const data = question || {
    id: criarId(),
    text: "",
    severity: "MED",
    requiresPhotoOnFail: false,
    autoCreateNc: true,
    helpText: "",
  };
  const row = document.createElement("div");
  row.className = "question-row";
  row.dataset.questionId = data.id || criarId();
  row.innerHTML = `
    <div class="field" data-full>
      <label>Pergunta</label>
      <input type="text" data-field="text" placeholder="Descreva a pergunta" />
    </div>
    <div class="field">
      <label>Severidade</label>
      <select data-field="severity">
        <option value="LOW">Baixa</option>
        <option value="MED">Media</option>
        <option value="HIGH">Alta</option>
        <option value="CRITICAL">Critica</option>
      </select>
    </div>
    <div class="field">
      <label class="inline-check">
        <input type="checkbox" data-field="photo" />
        Foto obrigatoria no FAIL
      </label>
    </div>
    <div class="field">
      <label class="inline-check">
        <input type="checkbox" data-field="autoNc" />
        Gerar NC automaticamente
      </label>
    </div>
    <div class="field" data-full>
      <label>Help</label>
      <input type="text" data-field="helpText" placeholder="Dica/observacao para o inspetor" />
    </div>
    <div class="question-actions">
      <button class="btn btn--ghost btn--small" type="button" data-action="up">?</button>
      <button class="btn btn--ghost btn--small" type="button" data-action="down">?</button>
      <button class="btn btn--ghost btn--small btn--danger" type="button" data-action="remove">
        Remover
      </button>
    </div>
  `;
  const textInput = row.querySelector("[data-field='text']");
  const severityInput = row.querySelector("[data-field='severity']");
  const photoInput = row.querySelector("[data-field='photo']");
  const autoNcInput = row.querySelector("[data-field='autoNc']");
  const helpInput = row.querySelector("[data-field='helpText']");
  if (textInput) {
    textInput.value = data.text || "";
  }
  if (severityInput) {
    severityInput.value = normalizeSstSeverity(data.severity);
  }
  if (photoInput) {
    photoInput.checked = Boolean(data.requiresPhotoOnFail);
  }
  if (autoNcInput) {
    autoNcInput.checked = data.autoCreateNc !== false;
  }
  if (helpInput) {
    helpInput.value = data.helpText || "";
  }
  sstTemplateQuestions.append(row);
}

function renderSstTemplateQuestionsEditor(questions) {
  if (!sstTemplateQuestions) {
    return;
  }
  sstTemplateQuestions.innerHTML = "";
  const list = Array.isArray(questions) ? questions.slice() : [];
  if (!list.length) {
    addSstTemplateQuestionRow();
    return;
  }
  list
    .sort((a, b) => a.order - b.order)
    .forEach((question) => addSstTemplateQuestionRow(question));
}

function openSstTemplateModal(template) {
  if (!modalSstTemplate) {
    return;
  }
  resetSstTemplateForm();
  if (template) {
    if (sstTemplateModalTitle) {
      sstTemplateModalTitle.textContent = "Editar template de checklist";
    }
    if (sstTemplateId) {
      sstTemplateId.value = template.id;
    }
    if (sstTemplateName) {
      sstTemplateName.value = template.name || "";
    }
    if (sstTemplateType) {
      sstTemplateType.value = template.type || "";
    }
    if (sstTemplatePeriodicity) {
      sstTemplatePeriodicity.value =
        template.periodicityDays !== null && template.periodicityDays !== undefined
          ? String(template.periodicityDays)
          : "";
    }
    if (sstTemplateProject) {
      sstTemplateProject.value = template.projectId || "";
    }
    if (sstTemplateActive) {
      sstTemplateActive.checked = template.isActive !== false;
    }
    renderSstTemplateQuestionsEditor(template.questions || []);
  } else {
    if (sstTemplateModalTitle) {
      sstTemplateModalTitle.textContent = "Novo template de checklist";
    }
    renderSstTemplateQuestionsEditor([]);
  }
  openModal(modalSstTemplate);
}

function closeSstTemplateModal() {
  closeModal(modalSstTemplate);
  setInlineMessage(sstTemplateMsg, "");
}

function getSstTemplateFormData() {
  const payload = {
    id: sstTemplateId ? sstTemplateId.value : "",
    name: sstTemplateName ? sstTemplateName.value.trim() : "",
    type: sstTemplateType ? sstTemplateType.value.trim() : "",
    periodicityDays: sstTemplatePeriodicity ? sstTemplatePeriodicity.value : "",
    projectId: sstTemplateProject ? sstTemplateProject.value : "",
    isActive: sstTemplateActive ? sstTemplateActive.checked : true,
    questions: [],
  };
  const rows = sstTemplateQuestions ? sstTemplateQuestions.querySelectorAll(".question-row") : [];
  Array.from(rows).forEach((row, index) => {
    const textInput = row.querySelector("[data-field='text']");
    const severityInput = row.querySelector("[data-field='severity']");
    const photoInput = row.querySelector("[data-field='photo']");
    const autoNcInput = row.querySelector("[data-field='autoNc']");
    const helpInput = row.querySelector("[data-field='helpText']");
    const text = textInput ? textInput.value.trim() : "";
    if (!text) {
      return;
    }
    payload.questions.push({
      id: row.dataset.questionId || criarId(),
      order: index + 1,
      text,
      severity: severityInput ? severityInput.value : "MED",
      requiresPhotoOnFail: Boolean(photoInput && photoInput.checked),
      autoCreateNc: autoNcInput ? autoNcInput.checked : true,
      helpText: helpInput ? helpInput.value.trim() : "",
    });
  });
  return payload;
}

async function handleSstTemplateSubmit(event) {
  event.preventDefault();
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstTemplateMsg, "Sem permiss\u00e3o para salvar template.", true);
    return;
  }
  const payload = getSstTemplateFormData();
  if (!payload.name) {
    setInlineMessage(sstTemplateMsg, "Informe o nome do template.", true);
    return;
  }
  if (!payload.questions.length) {
    setInlineMessage(sstTemplateMsg, "Adicione pelo menos uma pergunta.", true);
    return;
  }
  try {
    await dataProvider.sstInspections.upsertTemplate(payload);
    sstInspectionTemplates = await dataProvider.sstInspections.listTemplates();
    setInlineMessage(sstTemplateMsg, "Template salvo com sucesso.");
    closeSstTemplateModal();
    renderSstInspecoes();
  } catch (error) {
    setInlineMessage(sstTemplateMsg, error.message || "Erro ao salvar template.", true);
  }
}

async function handleSstTemplateSeed() {
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstInspectionMsg, "Sem permiss\u00e3o para carregar templates.", true);
    return;
  }
  try {
    const result = await dataProvider.sstInspections.seedTemplatesIfEmpty();
    sstInspectionTemplates = await dataProvider.sstInspections.listTemplates();
    renderSstInspecoes();
    if (result.seeded) {
      setInlineMessage(sstInspectionMsg, `Templates iniciais carregados (${result.count}).`);
    } else {
      setInlineMessage(sstInspectionMsg, "Templates ja existentes.");
    }
  } catch (error) {
    setInlineMessage(sstInspectionMsg, error.message || "Erro ao carregar templates.", true);
  }
}

function handleSstTemplateTableClick(event) {
  const button = event.target.closest("button[data-action]");
  if (!button) {
    return;
  }
  const id = button.dataset.id;
  const action = button.dataset.action;
  const template = sstInspectionTemplates.find((item) => String(item.id) === String(id));
  if (!template) {
    return;
  }
  if (action === "edit") {
    openSstTemplateModal(template);
    return;
  }
  if (action === "duplicate") {
    openSstTemplateModal({
      ...template,
      id: "",
      name: `${template.name} (copia)`,
    });
    return;
  }
  if (action === "toggle") {
    dataProvider.sstInspections
      .upsertTemplate({ ...template, isActive: !template.isActive })
      .then(async () => {
        sstInspectionTemplates = await dataProvider.sstInspections.listTemplates();
        renderSstInspecoes();
      });
  }
}

function handleSstInspectionHistoryClick(event) {
  const button = event.target.closest("button[data-action='details']");
  if (!button) {
    return;
  }
  const id = button.dataset.id;
  if (!id) {
    return;
  }
  openSstInspectionDetails(id);
}

function handleSstTemplateQuestionsClick(event) {
  const button = event.target.closest("button[data-action]");
  if (!button || !sstTemplateQuestions) {
    return;
  }
  const row = button.closest(".question-row");
  if (!row) {
    return;
  }
  const action = button.dataset.action;
  if (action === "remove") {
    row.remove();
    return;
  }
  if (action === "up" && row.previousElementSibling) {
    sstTemplateQuestions.insertBefore(row, row.previousElementSibling);
  }
  if (action === "down" && row.nextElementSibling) {
    sstTemplateQuestions.insertBefore(row.nextElementSibling, row);
  }
}

async function handleSstInspectionStart() {
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstInspectionMsg, "Sem permiss\u00e3o para iniciar inspecao.", true);
    return;
  }
  const projectId = sstInspectionProject ? sstInspectionProject.value : "";
  const templateId = sstInspectionTemplate ? sstInspectionTemplate.value : "";
  const worksiteId = sstInspectionLocal ? sstInspectionLocal.value : "";
  const safetyResponsibleId = sstInspectionSafety ? sstInspectionSafety.value : "";
  const inspectorId = sstInspectionExecutor ? sstInspectionExecutor.value : "";
  const vehicleId = sstInspectionVehicle ? sstInspectionVehicle.value : "";
  if (!projectId) {
    setInlineMessage(sstInspectionMsg, "Selecione o projeto.", true);
    return;
  }
  if (!templateId) {
    setInlineMessage(sstInspectionMsg, "Selecione o template.", true);
    return;
  }
  if (!safetyResponsibleId) {
    setInlineMessage(sstInspectionMsg, "Selecione o responsavel SST.", true);
    return;
  }
  if (!inspectorId) {
    setInlineMessage(sstInspectionMsg, "Selecione o inspetor designado.", true);
    return;
  }
  const template = sstInspectionTemplates.find((item) => String(item.id) === String(templateId));
  if (!template) {
    setInlineMessage(sstInspectionMsg, "Template nao encontrado.", true);
    return;
  }
  const typeNormalized = normalizeSstChecklistType(template.type);
  const nameNormalized = normalizeSearchValue(template.name || "");
  const isVehicle =
    typeNormalized === "VEHICLES_DAILY" ||
    typeNormalized === "VEICULOS_DIARIO" ||
    typeNormalized === "VEICULOS" ||
    nameNormalized.includes("veiculo");
  if (isVehicle && !vehicleId) {
    setInlineMessage(sstInspectionMsg, "Selecione o veiculo.", true);
    return;
  }
  const selectedVehicle =
    vehicleId && sstVehicles.length
      ? sstVehicles.find((vehicle) => String(vehicle.id) === String(vehicleId))
      : null;
  const vehicleSnapshot = selectedVehicle
    ? {
        plate: selectedVehicle.plate || "",
        model: selectedVehicle.model || "",
        type: selectedVehicle.type || "",
        status: selectedVehicle.status || "",
      }
    : null;
  sstWizardState = {
    template,
    projectId,
    worksiteId,
    inspectorId,
    safetyResponsibleId,
    vehicleId,
    vehicleSnapshot,
    startedAt: toIsoUtc(new Date()),
    currentIndex: 0,
    answers: {},
    completed: false,
    runId: "",
    summary: null,
  };
  setInlineMessage(sstInspectionMsg, "");
  openModal(modalSstInspectionWizard);
  renderSstWizard();
}

function getWizardAnswerState(questionId) {
  if (!sstWizardState) {
    return null;
  }
  if (!sstWizardState.answers[questionId]) {
    sstWizardState.answers[questionId] = {
      answer: "",
      notes: "",
      evidences: [],
    };
  }
  return sstWizardState.answers[questionId];
}

function clearWizardEvidenceUrls() {
  if (!sstWizardState) {
    return;
  }
  Object.values(sstWizardState.answers).forEach((state) => {
    (state.evidences || []).forEach((item) => {
      if (item.previewUrl) {
        URL.revokeObjectURL(item.previewUrl);
      }
    });
  });
}

function closeSstInspectionWizard() {
  closeModal(modalSstInspectionWizard);
  clearWizardEvidenceUrls();
  sstWizardState = null;
  setInlineMessage(sstWizardMsg, "");
}

function renderSstWizard() {
  if (!sstWizardState || !sstWizardBody || !sstWizardProgress) {
    return;
  }
  const { template, currentIndex, completed } = sstWizardState;
  if (!template) {
    return;
  }
  if (sstWizardTitle) {
    sstWizardTitle.textContent = template.name;
  }
  if (sstWizardMeta) {
    const project = availableProjects.find((item) => item.id === sstWizardState.projectId);
    const projectLabel = project ? getProjectLabel(project) : sstWizardState.projectId || "-";
    const localLabel = sstWizardState.worksiteId ? sstWizardState.worksiteId : "";
    const safetyLabel = sstWizardState.safetyResponsibleId
      ? getUserLabel(sstWizardState.safetyResponsibleId)
      : "-";
    const inspectorLabel = sstWizardState.inspectorId
      ? getUserLabel(sstWizardState.inspectorId)
      : "-";
    const vehicleData =
      sstWizardState.vehicleSnapshot ||
      (sstWizardState.vehicleId
        ? sstVehicles.find((item) => String(item.id) === String(sstWizardState.vehicleId))
        : null);
    const vehicleLabel = vehicleData ? getSstVehicleLabel(vehicleData) : "";
    const base = localLabel ? `${projectLabel} • ${localLabel}` : projectLabel;
    const auditParts = [
      `Resp. SST: ${safetyLabel}`,
      `Inspetor: ${inspectorLabel}`,
    ];
    if (vehicleLabel) {
      auditParts.push(`Veículo: ${vehicleLabel}`);
    }
    sstWizardMeta.textContent = `${base} • ${auditParts.join(" • ")}`;
  }
  const questions = Array.isArray(template.questions) ? template.questions : [];
  if (completed) {
    if (sstWizardSummary) {
      sstWizardSummary.hidden = false;
    }
    if (sstWizardBody) {
      sstWizardBody.innerHTML = "";
    }
    if (sstWizardPrev) {
      sstWizardPrev.disabled = true;
    }
    if (sstWizardNext) {
      sstWizardNext.textContent = "Fechar";
    }
    return;
  }
  if (!questions.length) {
    sstWizardBody.innerHTML = `<p class="empty-state">Template sem perguntas.</p>`;
    return;
  }
  const question = questions[currentIndex];
  const state = getWizardAnswerState(question.id);
  if (!state) {
    return;
  }
  sstWizardProgress.textContent = `${currentIndex + 1} / ${questions.length}`;
  const answerButtons = ["OK", "FAIL", "NA"]
    .map((value) => {
      const active = state.answer === value ? "is-active" : "";
      const label = value === "NA" ? "N/A" : value;
      return `<button class="${active}" type="button" data-answer="${value}" data-question-id="${question.id}">${label}</button>`;
    })
    .join("");
  const evidenceItems = (state.evidences || [])
    .map(
      (item, index) => `
        <div class="wizard-evidence-item">
          <span>${escapeHtml(item.file.name)}</span>
          <div class="question-actions">
            <button class="btn btn--ghost btn--small" type="button" data-action="view-evidence" data-index="${index}" data-question-id="${question.id}">Ver</button>
            <button class="btn btn--ghost btn--small btn--danger" type="button" data-action="remove-evidence" data-index="${index}" data-question-id="${question.id}">Remover</button>
          </div>
        </div>
      `
    )
    .join("");
  sstWizardBody.innerHTML = `
    <div class="wizard-question">
      <div class="wizard-question__title">
        <div>
          <h4>${escapeHtml(question.text)}</h4>
          ${question.helpText ? `<p class="hint">${escapeHtml(question.helpText)}</p>` : ""}
        </div>
      </div>
      <div class="wizard-answers">${answerButtons}</div>
      <div class="field" data-full>
        <label>Observacoes</label>
        <textarea id="sstWizardNotes" rows="2" placeholder="Observacoes rapidas"></textarea>
      </div>
      <div class="wizard-evidences">
        <div class="section-title section-title--compact">
          <div>
            <h4>Evidencias</h4>
            <p class="hint">Fotos ou PDFs da inspecao.</p>
          </div>
          <button class="btn btn--ghost btn--small" type="button" data-action="add-evidence">Adicionar</button>
        </div>
        <input id="sstWizardEvidenceInput" type="file" multiple accept="image/*,application/pdf" hidden />
        <div class="wizard-evidences__list">${evidenceItems || "<p class=\"empty-state\">Sem evidencias anexadas.</p>"}</div>
      </div>
    </div>
  `;
  if (sstWizardSummary) {
    sstWizardSummary.hidden = true;
  }
  const notesField = sstWizardBody.querySelector("#sstWizardNotes");
  if (notesField) {
    notesField.value = state.notes || "";
    notesField.addEventListener("input", (event) => {
      state.notes = event.target.value;
    });
  }
  const evidenceInput = sstWizardBody.querySelector("#sstWizardEvidenceInput");
  if (evidenceInput) {
    evidenceInput.addEventListener("change", (event) => {
      const files = Array.from(event.target.files || []);
      if (!files.length) {
        return;
      }
      files.forEach((file) => {
        state.evidences.push({
          file,
          previewUrl: URL.createObjectURL(file),
        });
      });
      evidenceInput.value = "";
      renderSstWizard();
    });
  }
  if (sstWizardPrev) {
    sstWizardPrev.disabled = currentIndex === 0;
  }
  if (sstWizardNext) {
    sstWizardNext.textContent = currentIndex === questions.length - 1 ? "Finalizar" : "Proximo";
  }
}

function validateSstWizardStep(question, state) {
  if (!state.answer) {
    return "Selecione OK, FAIL ou N/A.";
  }
  if (state.answer === "FAIL" && question.requiresPhotoOnFail) {
    const hasPhoto = (state.evidences || []).some((item) =>
      item.file && item.file.type && item.file.type.startsWith("image/")
    );
    if (!hasPhoto) {
      return "Anexe pelo menos uma foto para FAIL.";
    }
  }
  return "";
}

async function finalizeSstWizard() {
  if (!sstWizardState) {
    return;
  }
  const template = sstWizardState.template;
  const questions = Array.isArray(template.questions) ? template.questions : [];
  const run = await dataProvider.sstInspections.startRun({
    templateId: template.id,
    projectId: sstWizardState.projectId,
    worksiteId: sstWizardState.worksiteId,
    inspectorId: sstWizardState.inspectorId,
    safetyResponsibleId: sstWizardState.safetyResponsibleId,
    vehicleId: sstWizardState.vehicleId,
    vehicleSnapshot: sstWizardState.vehicleSnapshot,
    startedAt: sstWizardState.startedAt,
  });
  for (const question of questions) {
    const state = getWizardAnswerState(question.id);
    if (!state || !state.answer) {
      continue;
    }
    const answer = await dataProvider.sstInspections.saveAnswer({
      runId: run.id,
      questionId: question.id,
      answer: state.answer,
      notes: state.notes || "",
    });
    for (const item of state.evidences || []) {
      await dataProvider.sstInspections.attachEvidence({
        ownerType: "INSPECTION_ANSWER",
        ownerId: answer.id,
        file: item.file,
      });
    }
  }
  const finished = await dataProvider.sstInspections.finishRun({ runId: run.id });
  const details = await dataProvider.sstInspections.getRunDetails(run.id);
  sstWizardState.completed = true;
  sstWizardState.runId = run.id;
  sstWizardState.summary = details || finished;
  sstInspections = await dataProvider.sstInspections.listRuns();
  renderSstInspecoes();
  renderSstDashboard();
  if (sstWizardSummary) {
    const stats = details ? details.failStats : buildSstFailStats(finished.answers || []);
    const statusBadge = getSstStatusBadge(finished.status);
    sstWizardSummary.innerHTML = `
      <div class="wizard-summary__stats wizard-summary__stats--cards">
        <div class="stat"><small>Score</small><strong>${escapeHtml(
          String(finished.score)
        )}</strong></div>
        <div class="stat"><small>Status</small>${statusBadge}</div>
        <div class="stat"><small>Falhas</small><strong>${escapeHtml(
          String(stats.total)
        )}</strong></div>
        <div class="stat"><small>Criticas</small><strong>${escapeHtml(
          String(stats.CRITICAL)
        )}</strong></div>
      </div>
      <div class="wizard-summary__actions">
        <label class="inline-check">
          <input id="sstWizardIncludeMed" type="checkbox" />
          Incluir severidade MED
        </label>
        <button id="sstWizardGenerateNc" class="btn btn--primary btn--small" type="button">
          Gerar NCs
        </button>
      </div>
    `;
    const generateBtn = sstWizardSummary.querySelector("#sstWizardGenerateNc");
    if (generateBtn) {
      generateBtn.addEventListener("click", async () => {
        const includeMed = Boolean(
          sstWizardSummary.querySelector("#sstWizardIncludeMed")?.checked
        );
        const include = includeMed ? ["HIGH", "CRITICAL", "MED"] : ["HIGH", "CRITICAL"];
        const created = await dataProvider.sstInspections.generateNcsFromRun({
          runId: run.id,
          includeSeverities: include,
        });
        if (created.length) {
          const localNcs = await dataProvider.sstInspections.listNcs();
          const ids = new Set(localNcs.map((item) => item.id));
          sstNonconformities = localNcs.concat(
            sstNonconformities.filter((item) => !ids.has(item.id))
          );
          renderSstNcs();
          renderSstDashboard();
          setInlineMessage(sstWizardMsg, `${created.length} NC(s) geradas.`);
        } else {
          setInlineMessage(sstWizardMsg, "Nenhuma NC nova para gerar.");
        }
      });
    }
  }
  renderSstWizard();
}

function handleSstWizardBodyClick(event) {
  if (!sstWizardState) {
    return;
  }
  const answerBtn = event.target.closest("button[data-answer]");
  if (answerBtn) {
    const questionId = answerBtn.dataset.questionId;
    const state = getWizardAnswerState(questionId);
    if (state) {
      state.answer = answerBtn.dataset.answer;
      renderSstWizard();
    }
    return;
  }
  const actionBtn = event.target.closest("button[data-action]");
  if (!actionBtn) {
    return;
  }
  const action = actionBtn.dataset.action;
  const questionId = actionBtn.dataset.questionId;
  const state = getWizardAnswerState(questionId);
  if (!state) {
    return;
  }
  if (action === "remove-evidence") {
    const index = Number(actionBtn.dataset.index);
    const item = state.evidences[index];
    if (item && item.previewUrl) {
      URL.revokeObjectURL(item.previewUrl);
    }
    state.evidences.splice(index, 1);
    renderSstWizard();
    return;
  }
  if (action === "view-evidence") {
    const index = Number(actionBtn.dataset.index);
    const item = state.evidences[index];
    if (item) {
      openInNewTab(item.previewUrl || URL.createObjectURL(item.file));
    }
    return;
  }
  if (action === "add-evidence") {
    const input = sstWizardBody.querySelector("#sstWizardEvidenceInput");
    if (input) {
      input.click();
    }
  }
}

async function handleSstWizardNext() {
  if (!sstWizardState) {
    return;
  }
  if (sstWizardState.completed) {
    closeSstInspectionWizard();
    return;
  }
  const template = sstWizardState.template;
  const questions = Array.isArray(template.questions) ? template.questions : [];
  const question = questions[sstWizardState.currentIndex];
  const state = getWizardAnswerState(question.id);
  const errorMessage = validateSstWizardStep(question, state);
  if (errorMessage) {
    setInlineMessage(sstWizardMsg, errorMessage, true);
    return;
  }
  setInlineMessage(sstWizardMsg, "");
  if (sstWizardState.currentIndex >= questions.length - 1) {
    if (sstWizardNext) {
      sstWizardNext.disabled = true;
    }
    try {
      await finalizeSstWizard();
    } finally {
      if (sstWizardNext) {
        sstWizardNext.disabled = false;
      }
    }
    return;
  }
  sstWizardState.currentIndex += 1;
  renderSstWizard();
}

function handleSstWizardPrev() {
  if (!sstWizardState || sstWizardState.completed) {
    return;
  }
  if (sstWizardState.currentIndex > 0) {
    sstWizardState.currentIndex -= 1;
    renderSstWizard();
  }
}

async function openSstInspectionDetails(runId) {
  if (!modalSstInspectionDetails || !sstInspectionDetailsBody) {
    return;
  }
  sstInspectionDetailsId = runId;
  sstInspectionDetailsData = null;
  sstInspectionDetailsBody.innerHTML = "<p class=\"empty-state\">Carregando...</p>";
  setInlineMessage(sstInspectionDetailsMsg, "");
  openModal(modalSstInspectionDetails);
  const details = await dataProvider.sstInspections.getRunDetails(runId);
  if (!details) {
    sstInspectionDetailsBody.innerHTML = "<p class=\"empty-state\">Inspecao nao encontrada.</p>";
    return;
  }
  sstInspectionDetailsData = details;
  const project = availableProjects.find((item) => item.id === details.projectId);
  const projectLabel = project ? getProjectLabel(project) : details.projectId || "-";
  const dataLabel = details.startedAt ? formatDateTime(parseTimestamp(details.startedAt)) : "-";
  if (sstInspectionDetailsTitle) {
    sstInspectionDetailsTitle.textContent = details.template
      ? details.template.name
      : "Detalhes da inspecao";
  }
  if (sstInspectionDetailsMeta) {
    sstInspectionDetailsMeta.textContent = `${projectLabel} - ${dataLabel}`;
  }
  const safetyLabel = details.safetyResponsibleId
    ? getUserLabel(details.safetyResponsibleId)
    : "-";
  const inspectorLabel = details.inspectorId ? getUserLabel(details.inspectorId) : "-";
  const vehicleData = getRunVehicleData(details);
  const vehicleStatusLabel = vehicleData ? getVehicleStatusLabel(vehicleData.status || "") : "-";
  const vehicleBase = vehicleData ? getSstVehicleLabel(vehicleData) : "-";
  const vehicleType = vehicleData && vehicleData.type ? ` • ${vehicleData.type}` : "";
  const vehicleLabel = vehicleData ? `${vehicleBase}${vehicleType} (${vehicleStatusLabel})` : "-";
  const summary = `
    <div class="inspection-details">
      <div class="wizard-summary__stats wizard-summary__stats--cards">
        <div class="stat"><small>Score</small><strong>${escapeHtml(
          String(details.score)
        )}</strong></div>
        <div class="stat"><small>Status</small>${getSstStatusBadge(details.status)}</div>
        <div class="stat"><small>Falhas</small><strong>${escapeHtml(
          String(details.failStats.total)
        )}</strong></div>
        <div class="stat"><small>Criticas</small><strong>${escapeHtml(
          String(details.failStats.CRITICAL)
        )}</strong></div>
      </div>
        <div class="inspection-meta-grid">
          <div><small>Responsável SST</small><strong>${escapeHtml(safetyLabel)}</strong></div>
          <div><small>Inspetor</small><strong>${escapeHtml(inspectorLabel)}</strong></div>
          <div><small>Veículo</small><strong>${escapeHtml(vehicleLabel)}</strong></div>
        </div>
    </div>
  `;
  const questions = details.template ? details.template.questions : [];
  const answers = details.answers || [];
  const answerMap = new Map(answers.map((answer) => [answer.questionId, answer]));
  const htmlQuestions = questions
    .map((question) => {
      const answer = answerMap.get(question.id);
      let badge = `<span class="badge badge--warn">Sem resposta</span>`;
      if (answer) {
        if (answer.answer === "OK") {
          badge = `<span class="badge badge--ok">OK</span>`;
        } else if (answer.answer === "FAIL") {
          badge = `<span class="badge badge--crit">FAIL</span>`;
        } else {
          badge = `<span class="badge badge--warn">N/A</span>`;
        }
      }
      const evidences = answer ? details.evidencesByAnswerId[answer.id] || [] : [];
      const evidenceList = evidences.length
        ? evidences
            .map(
              (evidence) => `
            <div class="wizard-evidence-item">
              <span>${escapeHtml(evidence.fileName)}</span>
              <button class="btn btn--ghost btn--small" type="button" data-evidence-id="${evidence.id}">Ver</button>
            </div>
          `
            )
            .join("")
        : `<p class="empty-state">Sem evidencias</p>`;
      return `
        <div class="wizard-question wizard-question--compact">
          <div class="wizard-question__title">
            <div>
              <h4>${escapeHtml(question.text)}</h4>
              ${question.helpText ? `<p class="hint">${escapeHtml(question.helpText)}</p>` : ""}
            </div>
            ${badge}
          </div>
          ${answer && answer.notes ? `<p class="hint">${escapeHtml(answer.notes)}</p>` : ""}
          <div class="wizard-evidences__list">${evidenceList}</div>
        </div>
      `;
    })
    .join("");
  sstInspectionDetailsBody.innerHTML = summary + htmlQuestions;
  if (sstInspectionGenerateNc) {
    sstInspectionGenerateNc.disabled = details.failStats.total === 0;
  }
}

function closeSstInspectionDetails() {
  closeModal(modalSstInspectionDetails);
  sstInspectionDetailsId = null;
  sstInspectionDetailsData = null;
  setInlineMessage(sstInspectionDetailsMsg, "");
}

async function handleSstInspectionDetailsClick(event) {
  const button = event.target.closest("button[data-evidence-id]");
  if (!button) {
    return;
  }
  const evidenceId = button.dataset.evidenceId;
  if (!evidenceId) {
    return;
  }
  const details = sstInspectionDetailsData;
  let evidence =
    details && details.evidencesByAnswerId
      ? Object.values(details.evidencesByAnswerId)
          .flat()
          .find((item) => String(item.id) === String(evidenceId))
      : null;
  if (!evidence) {
    return;
  }
  if (evidence.dataUrl) {
    openInNewTab(evidence.dataUrl);
    return;
  }
  const stored = await getSstEvidenceById(evidence.id);
  if (stored && stored.blob) {
    const url = URL.createObjectURL(stored.blob);
    openInNewTab(url);
    setTimeout(() => URL.revokeObjectURL(url), 300000);
  }
}

async function handleSstInspectionGenerateNc() {
  if (!sstInspectionDetailsId) {
    return;
  }
  const includeMed = window.confirm(
    "Incluir severidade MEDIA? (OK para incluir, Cancelar para HIGH/CRITICAL)"
  );
  const include = includeMed ? ["HIGH", "CRITICAL", "MED"] : ["HIGH", "CRITICAL"];
  try {
    const created = await dataProvider.sstInspections.generateNcsFromRun({
      runId: sstInspectionDetailsId,
      includeSeverities: include,
    });
    if (created.length) {
      const localNcs = await dataProvider.sstInspections.listNcs();
      const ids = new Set(localNcs.map((item) => item.id));
      sstNonconformities = localNcs.concat(
        sstNonconformities.filter((item) => !ids.has(item.id))
      );
      renderSstNcs();
      renderSstDashboard();
      setInlineMessage(sstInspectionDetailsMsg, `${created.length} NC(s) geradas.`);
    } else {
      setInlineMessage(sstInspectionDetailsMsg, "Nenhuma NC nova para gerar.");
    }
  } catch (error) {
    setInlineMessage(
      sstInspectionDetailsMsg,
      error.message || "Erro ao gerar NCs.",
      true
    );
  }
}

function appendSstNcHistory(nc, action, message, metadata) {
  const history = Array.isArray(nc && nc.history) ? nc.history.slice() : [];
  const entry = normalizeSstNcHistory({
    action,
    message,
    createdBy: currentUser ? currentUser.id : "",
    metadata,
    createdAt: toIsoUtc(new Date()),
  });
  if (entry) {
    history.unshift(entry);
  }
  return history;
}

function upsertSstNcInMemory(nc) {
  if (!nc) {
    return;
  }
  const list = Array.isArray(sstNonconformities) ? sstNonconformities.slice() : [];
  const index = list.findIndex((item) => String(item.id) === String(nc.id));
  if (index >= 0) {
    list[index] = nc;
  } else {
    list.unshift(nc);
  }
  sstNonconformities = list;
}

function getSstNcSourceLabel(nc) {
  if (!nc) {
    return "-";
  }
  if (String(nc.sourceType || "").toUpperCase() === "INSPECTION" && nc.sourceId) {
    const run = sstInspections.find((item) => String(item.id) === String(nc.sourceId));
    if (run) {
      const when = run.startedAt ? formatDateTime(parseTimestamp(run.startedAt)) : "-";
      return `${run.templateName || "Inspecao"} - ${when}`;
    }
    return `Inspecao ${nc.sourceId}`;
  }
  return "Manual";
}

async function openSstNcDetails(ncId) {
  if (!modalSstNcDetails) {
    return;
  }
  const nc = sstNonconformities.find((item) => String(item.id) === String(ncId));
  if (!nc) {
    return;
  }
  sstNcDetailsData = nc;
  pendingSstNcDetailsAttachments = [];
  if (sstNcDetailsFiles) {
    sstNcDetailsFiles.innerHTML = "";
  }
  try {
    sstNcDetailsEvidences = await dataProvider.sstInspections.listEvidences({
      ownerType: "NON_CONFORMITY",
      ownerId: nc.id,
    });
  } catch (error) {
    sstNcDetailsEvidences = [];
  }
  if (sstNcDetailsMsg) {
    setInlineMessage(sstNcDetailsMsg, "");
  }
  renderSstNcDetails(nc);
  modalSstNcDetails.hidden = false;
}

function closeSstNcDetails() {
  if (!modalSstNcDetails) {
    return;
  }
  modalSstNcDetails.hidden = true;
  sstNcDetailsData = null;
  sstNcDetailsEvidences = [];
  pendingSstNcDetailsAttachments = [];
  if (sstNcDetailsFiles) {
    sstNcDetailsFiles.innerHTML = "";
  }
  if (sstNcDetailsMsg) {
    setInlineMessage(sstNcDetailsMsg, "");
  }
}

function renderSstNcActionsList(actions) {
  if (!sstNcActionsList) {
    return;
  }
  const list = Array.isArray(actions) ? actions : [];
  if (!list.length) {
    sstNcActionsList.innerHTML = `<p class="empty-state">Nenhuma acao registrada.</p>`;
    return;
  }
  sstNcActionsList.innerHTML = list
    .map((action) => {
      const status = String(action.status || "OPEN").toUpperCase();
      const badge =
        status === "DONE"
          ? '<span class="badge badge--ok">Concluida</span>'
          : '<span class="badge badge--warn">Pendente</span>';
      const resp = getUserLabel(action.responsibleId);
      return `
        <div class="nc-action" data-action-id="${action.id}">
          <div>
            <strong>${escapeHtml(action.title)}</strong>
            <div class="nc-action__meta">
              ${badge} - Responsavel: ${escapeHtml(resp || "-")} - Prazo: ${escapeHtml(
        action.dueDate || "-"
      )}
            </div>
          </div>
          <div class="table-actions">
            <button class="btn btn--ghost btn--small" data-action="toggle">
              ${status === "DONE" ? "Reabrir" : "Concluir"}
            </button>
          </div>
        </div>
      `;
    })
    .join("");
}

function renderSstNcHistory(history) {
  if (!sstNcHistory) {
    return;
  }
  const list = Array.isArray(history) ? history : [];
  if (!list.length) {
    sstNcHistory.innerHTML = `<p class="empty-state">Sem historico.</p>`;
    return;
  }
  sstNcHistory.innerHTML = list
    .map((entry) => {
      const when = entry.createdAt ? formatDateTime(parseTimestamp(entry.createdAt)) : "-";
      const by = getUserLabel(entry.createdBy);
      return `
        <div class="nc-history-item">
          <strong>${escapeHtml(entry.message)}</strong>
          <small>${escapeHtml(when)} - ${escapeHtml(by || "Sistema")}</small>
        </div>
      `;
    })
    .join("");
}

function renderSstNcEvidenceList(list) {
  if (!sstNcDetailsEvidenceList) {
    return;
  }
  const evidences = Array.isArray(list) ? list : [];
  if (!evidences.length) {
    sstNcDetailsEvidenceList.innerHTML =
      '<p class="empty-state">Sem evidencias anexadas.</p>';
    return;
  }
  sstNcDetailsEvidenceList.innerHTML = evidences
    .map((evidence) => {
      const isImage = evidence.fileType && evidence.fileType.startsWith("image/");
      const name = evidence.fileName || "Arquivo";
      const preview = isImage && evidence.dataUrl
        ? `<img src="${escapeHtml(evidence.dataUrl)}" alt="${escapeHtml(name)}" />`
        : `<div class="file-list__meta">${escapeHtml(
            (evidence.fileType || "ARQ").split("/").pop().toUpperCase()
          )}</div>`;
      return `
        <button class="nc-evidence-item" type="button" data-evidence-id="${evidence.id}">
          ${preview}
          <strong>${escapeHtml(name)}</strong>
          <span class="file-list__meta">${escapeHtml(formatFileSize(evidence.size || 0))}</span>
        </button>
      `;
    })
    .join("");
}

function renderSstNcDetails(nc) {
  if (!nc) {
    return;
  }
  if (sstNcDetailsId) {
    sstNcDetailsId.value = nc.id;
  }
  if (sstNcDetailsHeader) {
    sstNcDetailsHeader.textContent = getSstNcCode(nc);
  }
  if (sstNcDetailsMeta) {
    const project = availableProjects.find((item) => item.id === nc.projectId);
    const label = project ? getProjectLabel(project) : nc.projectId || "-";
    sstNcDetailsMeta.textContent = `${label} - ${getSstNcStatusLabel(nc.status)}`;
  }
  if (sstNcDetailsTitleInput) {
    sstNcDetailsTitleInput.value = nc.title || "";
  }
  if (sstNcDetailsStatus) {
    sstNcDetailsStatus.value = normalizeSstNcStatus(nc.status);
  }
  if (sstNcDetailsSeverity) {
    sstNcDetailsSeverity.value = getSstSeveritySelectValue(nc.severity) || "MEDIA";
  }
  if (sstNcDetailsDue) {
    sstNcDetailsDue.value = nc.dueDate || "";
  }
  if (sstNcDetailsCategory) {
    sstNcDetailsCategory.value = nc.category || "";
  }
  renderSstNcResponsibleOptions();
  if (sstNcDetailsResponsible) {
    sstNcDetailsResponsible.value = nc.responsibleId || "";
  }
  if (sstNcDetailsDescription) {
    sstNcDetailsDescription.value = nc.description || "";
  }
  if (sstNcDetailsRootCause) {
    sstNcDetailsRootCause.value = nc.rootCause || "";
  }
  if (sstNcDetailsCorrection) {
    sstNcDetailsCorrection.value = nc.correction || "";
  }
  if (sstNcDetailsSource) {
    sstNcDetailsSource.value = getSstNcSourceLabel(nc);
  }
  if (sstNcDetailsCreated) {
    sstNcDetailsCreated.value = nc.createdAt
      ? formatDateTime(parseTimestamp(nc.createdAt))
      : "-";
  }
  if (sstNcDetailsUpdated) {
    sstNcDetailsUpdated.value = nc.updatedAt
      ? formatDateTime(parseTimestamp(nc.updatedAt))
      : "-";
  }
  renderSstNcActionsList(nc.actions);
  renderSstNcEvidenceList(sstNcDetailsEvidences);
  renderSstNcHistory(nc.history);
  const podeGerenciar = Boolean(currentUser && canManageSst(currentUser));
  if (sstNcDetailsSave) {
    sstNcDetailsSave.disabled = !podeGerenciar;
  }
  if (sstNcNotifyBtn) {
    sstNcNotifyBtn.disabled = !podeGerenciar;
  }
  if (sstNcActionAdd) {
    sstNcActionAdd.disabled = !podeGerenciar;
  }
  if (sstNcDetailsAttachments) {
    sstNcDetailsAttachments.disabled = !podeGerenciar;
  }
}

async function handleSstNcEvidenceOpen(event) {
  const target = event.target.closest("[data-evidence-id]");
  if (!target) {
    return;
  }
  const evidenceId = target.dataset.evidenceId;
  if (!evidenceId) {
    return;
  }
  const evidence = (sstNcDetailsEvidences || []).find(
    (item) => String(item.id) === String(evidenceId)
  );
  if (!evidence) {
    return;
  }
  if (evidence.dataUrl) {
    openInNewTab(evidence.dataUrl);
    return;
  }
  const stored = await getSstEvidenceById(evidence.id);
  if (stored && stored.blob) {
    const url = URL.createObjectURL(stored.blob);
    openInNewTab(url);
    setTimeout(() => URL.revokeObjectURL(url), 300000);
  }
}

async function persistSstNcUpdate(nc, patch, historyAction, historyMessage, metadata) {
  if (!nc) {
    return null;
  }
  const now = toIsoUtc(new Date());
  const history =
    historyAction && historyMessage
      ? appendSstNcHistory(nc, historyAction, historyMessage, metadata)
      : Array.isArray(nc.history)
        ? nc.history
        : [];
  const updated = await dataProvider.sstInspections.updateNc(nc.id, {
    ...patch,
    history,
    updatedAt: now,
    updatedBy: currentUser ? currentUser.id : "",
  });
  if (updated) {
    sstNcDetailsData = updated;
    upsertSstNcInMemory(updated);
    renderSstNcs();
    renderSstDashboard();
  }
  return updated;
}

async function handleSstNcDetailsSave() {
  if (!sstNcDetailsData) {
    return;
  }
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstNcDetailsMsg, "Sem permiss\u00e3o para atualizar NC.", true);
    return;
  }
  const patch = {
    title: sstNcDetailsTitleInput ? sstNcDetailsTitleInput.value.trim() : "",
    status: sstNcDetailsStatus ? sstNcDetailsStatus.value : "OPEN",
    severity: sstNcDetailsSeverity ? sstNcDetailsSeverity.value : "MEDIA",
    dueDate: sstNcDetailsDue ? sstNcDetailsDue.value : "",
    responsibleId: sstNcDetailsResponsible ? sstNcDetailsResponsible.value : "",
    category: sstNcDetailsCategory ? sstNcDetailsCategory.value.trim() : "",
    description: sstNcDetailsDescription ? sstNcDetailsDescription.value.trim() : "",
    rootCause: sstNcDetailsRootCause ? sstNcDetailsRootCause.value.trim() : "",
    correction: sstNcDetailsCorrection ? sstNcDetailsCorrection.value.trim() : "",
  };
  if (!patch.title && !patch.description) {
    setInlineMessage(sstNcDetailsMsg, "Informe o titulo ou descricao.", true);
    return;
  }
  if (!patch.responsibleId) {
    setInlineMessage(sstNcDetailsMsg, "Defina o responsavel pela NC.", true);
    return;
  }
  const changes = [];
  if (patch.title !== (sstNcDetailsData.title || "")) {
    changes.push("Titulo atualizado");
  }
  if (patch.status && normalizeSstNcStatus(patch.status) !== normalizeSstNcStatus(sstNcDetailsData.status)) {
    changes.push(`Status: ${getSstNcStatusLabel(patch.status)}`);
  }
  if (patch.severity && normalizeSstSeverity(patch.severity) !== normalizeSstSeverity(sstNcDetailsData.severity)) {
    changes.push(`Severidade: ${SST_SEVERITY_LABELS[normalizeSstSeverity(patch.severity)]}`);
  }
  if (patch.dueDate !== (sstNcDetailsData.dueDate || "")) {
    changes.push("Prazo ajustado");
  }
  if (patch.responsibleId !== (sstNcDetailsData.responsibleId || "")) {
    changes.push(`Responsavel: ${getUserLabel(patch.responsibleId)}`);
  }
  if (patch.category !== (sstNcDetailsData.category || "")) {
    changes.push("Categoria ajustada");
  }
  if (patch.description !== (sstNcDetailsData.description || "")) {
    changes.push("Descricao atualizada");
  }
  if (patch.rootCause !== (sstNcDetailsData.rootCause || "")) {
    changes.push("Causa raiz atualizada");
  }
  if (patch.correction !== (sstNcDetailsData.correction || "")) {
    changes.push("Acao corretiva atualizada");
  }
  const normalizedStatus = normalizeSstNcStatus(patch.status);
  const closedAt =
    normalizedStatus === "DONE" && normalizeSstNcStatus(sstNcDetailsData.status) !== "DONE"
      ? toIsoUtc(new Date())
      : normalizedStatus !== "DONE"
        ? ""
        : sstNcDetailsData.closedAt || "";
  const updated = await persistSstNcUpdate(
    sstNcDetailsData,
    {
      ...patch,
      status: normalizedStatus,
      severity: normalizeSstSeverity(patch.severity),
      closedAt,
    },
    "UPDATE",
    changes.length ? `Atualizacoes: ${changes.join(" | ")}` : "Atualizacao registrada"
  );
  if (!updated) {
    setInlineMessage(sstNcDetailsMsg, "Falha ao salvar.", true);
    return;
  }
  if (pendingSstNcDetailsAttachments.length) {
    const files = pendingSstNcDetailsAttachments.slice();
    for (const file of files) {
      try {
        await dataProvider.sstInspections.attachEvidence({
          ownerType: "NON_CONFORMITY",
          ownerId: updated.id,
          file,
        });
      } catch (error) {
        // segue tentando
      }
    }
    pendingSstNcDetailsAttachments = [];
    renderSstNcFileList(sstNcDetailsFiles, []);
    sstNcDetailsEvidences = await dataProvider.sstInspections.listEvidences({
      ownerType: "NON_CONFORMITY",
      ownerId: updated.id,
    });
    await persistSstNcUpdate(
      updated,
      {},
      "EVIDENCE",
      `${files.length} evidencia(s) anexada(s)`
    );
  }
  if (sstNcDetailsMsg) {
    setInlineMessage(sstNcDetailsMsg, "NC atualizada.");
  }
  renderSstNcDetails(updated || sstNcDetailsData);
}

async function handleSstNcActionAdd() {
  if (!sstNcDetailsData) {
    return;
  }
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstNcDetailsMsg, "Sem permiss\u00e3o para adicionar acao.", true);
    return;
  }
  const title = sstNcActionTitle ? sstNcActionTitle.value.trim() : "";
  if (!title) {
    setInlineMessage(sstNcDetailsMsg, "Informe a acao corretiva.", true);
    return;
  }
  const action = normalizeSstNcAction({
    title,
    responsibleId: sstNcActionResponsible ? sstNcActionResponsible.value : "",
    dueDate: sstNcActionDue ? sstNcActionDue.value : "",
  });
  if (!action) {
    setInlineMessage(sstNcDetailsMsg, "Acao invalida.", true);
    return;
  }
  const actions = Array.isArray(sstNcDetailsData.actions)
    ? sstNcDetailsData.actions.concat(action)
    : [action];
  const updated = await persistSstNcUpdate(
    sstNcDetailsData,
    { actions },
    "ACTION_ADD",
    `Acao adicionada: ${action.title}`
  );
  if (updated) {
    if (sstNcActionTitle) {
      sstNcActionTitle.value = "";
    }
    if (sstNcActionDue) {
      sstNcActionDue.value = "";
    }
    renderSstNcDetails(updated);
  }
}

async function handleSstNcActionsClick(event) {
  const button = event.target.closest("button[data-action]");
  if (!button || !sstNcDetailsData) {
    return;
  }
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstNcDetailsMsg, "Sem permiss\u00e3o para atualizar acao.", true);
    return;
  }
  const card = button.closest("[data-action-id]");
  if (!card) {
    return;
  }
  const actionId = card.dataset.actionId;
  const actions = Array.isArray(sstNcDetailsData.actions)
    ? sstNcDetailsData.actions.slice()
    : [];
  const index = actions.findIndex((item) => String(item.id) === String(actionId));
  if (index < 0) {
    return;
  }
  const current = actions[index];
  const nextStatus = String(current.status || "OPEN").toUpperCase() === "DONE" ? "OPEN" : "DONE";
  const updatedAction = {
    ...current,
    status: nextStatus,
    completedAt: nextStatus === "DONE" ? toIsoUtc(new Date()) : "",
  };
  actions[index] = updatedAction;
  const updated = await persistSstNcUpdate(
    sstNcDetailsData,
    { actions },
    "ACTION_UPDATE",
    `Acao ${nextStatus === "DONE" ? "concluida" : "reaberta"}: ${current.title}`
  );
  if (updated) {
    renderSstNcDetails(updated);
  }
}

async function handleSstNcNotify() {
  if (!sstNcDetailsData) {
    return;
  }
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstNcDetailsMsg, "Sem permiss\u00e3o para notificar.", true);
    return;
  }
  const responsavel = getUserLabel(sstNcDetailsData.responsibleId);
  await persistSstNcUpdate(
    sstNcDetailsData,
    {},
    "NOTIFY",
    `Responsavel notificado: ${responsavel || "nao definido"}`
  );
  setInlineMessage(sstNcDetailsMsg, "Notificacao registrada.");
}

function handleSstNcAttachmentsChange() {
  if (!sstNcAttachments) {
    return;
  }
  pendingSstNcAttachments = Array.from(sstNcAttachments.files || []);
  renderSstNcFileList(sstNcAttachmentsList, pendingSstNcAttachments);
}

function handleSstNcDetailsAttachmentsChange() {
  if (!sstNcDetailsAttachments) {
    return;
  }
  pendingSstNcDetailsAttachments = Array.from(sstNcDetailsAttachments.files || []);
  renderSstNcFileList(sstNcDetailsFiles, pendingSstNcDetailsAttachments);
}

function handleSstNcSourceChange() {
  if (!sstNcSourceInspection || !sstNcProject) {
    return;
  }
  const id = sstNcSourceInspection.value;
  if (!id) {
    return;
  }
  const run = sstInspections.find((item) => String(item.id) === String(id));
  if (run && run.projectId) {
    sstNcProject.value = run.projectId;
  }
}

function handleSstNcTableClick(event) {
  const button = event.target.closest("button[data-action='details']");
  if (!button) {
    return;
  }
  const ncId = button.dataset.id;
  if (!ncId) {
    return;
  }
  openSstNcDetails(ncId);
}



async function handleSstNcSubmit(event) {
  event.preventDefault();
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstNcMsg, "Sem permiss\u00e3o para registrar NC.", true);
    return;
  }
  const payload = {
    projectId: sstNcProject ? sstNcProject.value : activeProjectId || "",
    severity: sstNcSeverity ? sstNcSeverity.value : "",
    status: sstNcStatus ? sstNcStatus.value : "OPEN",
    dueDate: sstNcDue ? sstNcDue.value : "",
    category: sstNcCategory ? sstNcCategory.value.trim() : "",
    responsibleId: sstNcResponsible ? sstNcResponsible.value : "",
    title: sstNcTitle ? sstNcTitle.value.trim() : "",
    description: sstNcDesc ? sstNcDesc.value.trim() : "",
    sourceType: sstNcSourceInspection && sstNcSourceInspection.value ? "INSPECTION" : "MANUAL",
    sourceId: sstNcSourceInspection ? sstNcSourceInspection.value : "",
    createdBy: currentUser.id,
    createdAt: toIsoUtc(new Date()),
    updatedAt: toIsoUtc(new Date()),
  };
  if (!payload.projectId) {
    setInlineMessage(sstNcMsg, "Selecione um projeto ativo.", true);
    return;
  }
  if (!payload.title && !payload.description) {
    setInlineMessage(sstNcMsg, "Informe um titulo ou descricao.", true);
    return;
  }
  if (!payload.responsibleId) {
    setInlineMessage(sstNcMsg, "Defina o responsavel pela NC.", true);
    return;
  }
  try {
    const created = await dataProvider.sstInspections.createNc({
      ...payload,
      history: appendSstNcHistory(payload, "CREATE", "NC registrada no sistema"),
    });
    let updated = created;
    if (pendingSstNcAttachments.length) {
      const files = pendingSstNcAttachments.slice();
      for (const file of files) {
        try {
          await dataProvider.sstInspections.attachEvidence({
            ownerType: "NON_CONFORMITY",
            ownerId: created.id,
            file,
          });
        } catch (error) {
          // segue
        }
      }
      updated = await dataProvider.sstInspections.updateNc(created.id, {
        history: appendSstNcHistory(
          created,
          "EVIDENCE",
          `${files.length} evidencia(s) anexada(s)`
        ),
      });
      pendingSstNcAttachments = [];
      renderSstNcFileList(sstNcAttachmentsList, []);
      if (sstNcAttachments) {
        sstNcAttachments.value = "";
      }
    }
    if (updated) {
      upsertSstNcInMemory(updated);
    }
    sstLoaded = true;
    if (sstNcForm) {
      sstNcForm.reset();
    }
    pendingSstNcAttachments = [];
    renderSstNcFileList(sstNcAttachmentsList, []);
    renderSstSelectors();
    setInlineMessage(sstNcMsg, "NC registrada.");
    renderSstNcs();
    renderSstDashboard();
  } catch (error) {
    setInlineMessage(sstNcMsg, error.message || "Erro ao registrar NC.", true);
  }
}

async function handleSstIncidentSubmit(event) {
  event.preventDefault();
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstIncidentMsg, "Sem permissão para registrar incidente.", true);
    return;
  }
  const payload = {
    projectId: sstIncidentProject ? sstIncidentProject.value : "",
    severity: sstIncidentSeverity ? sstIncidentSeverity.value : "",
    date: sstIncidentDate ? sstIncidentDate.value : "",
    category: sstIncidentCategory ? sstIncidentCategory.value.trim() : "",
    description: sstIncidentDesc ? sstIncidentDesc.value.trim() : "",
  };
  if (!payload.projectId) {
    setInlineMessage(sstIncidentMsg, "Selecione o projeto.", true);
    return;
  }
  if (!payload.date) {
    setInlineMessage(sstIncidentMsg, "Informe a data.", true);
    return;
  }
  if (!payload.description) {
    setInlineMessage(sstIncidentMsg, "Descreva o incidente.", true);
    return;
  }
  try {
    const data = await apiSstIncidentCreate(payload);
    if (data && data.incident) {
      sstIncidents = [data.incident].concat(sstIncidents);
      sstLoaded = true;
      if (sstIncidentForm) {
        sstIncidentForm.reset();
      }
      setInlineMessage(sstIncidentMsg, "Incidente registrado.");
      renderSstIncidentes();
      renderSstDashboard();
    }
  } catch (error) {
    setInlineMessage(sstIncidentMsg, error.message || "Erro ao registrar incidente.", true);
  }
}

function abrirSstDocForm() {
  if (!modalSstDocForm) {
    return;
  }
  if (!currentUser || !canViewSst(currentUser)) {
    window.alert("Sem permissão para enviar documentação.");
    return;
  }
  renderSstSelectors();
  if (sstDocProject && activeProjectId) {
    sstDocProject.value = activeProjectId;
  }
  if (sstDocResponsible && currentUser) {
    sstDocResponsible.value = currentUser.id;
  }
  setInlineMessage(sstDocFormMsg, "");
  modalSstDocForm.hidden = false;
}

function fecharSstDocForm() {
  if (!modalSstDocForm) {
    return;
  }
  modalSstDocForm.hidden = true;
  if (formSstDoc) {
    formSstDoc.reset();
  }
  pendingSstDocAprPreview = null;
  if (sstDocAprName) {
    sstDocAprName.textContent = "Nenhum arquivo";
  }
  if (sstDocAprView) {
    sstDocAprView.disabled = true;
  }
  setInlineMessage(sstDocFormMsg, "");
}

async function handleSstDocAprChange() {
  if (!sstDocAprInput) {
    return;
  }
  const file = sstDocAprInput.files && sstDocAprInput.files[0] ? sstDocAprInput.files[0] : null;
  pendingSstDocAprPreview = null;
  if (!file) {
    if (sstDocAprName) {
      sstDocAprName.textContent = "Nenhum arquivo";
    }
    if (sstDocAprView) {
      sstDocAprView.disabled = true;
    }
    return;
  }
  if (sstDocAprName) {
    sstDocAprName.textContent = file.name;
  }
  const preview = await lerDocumentoFile(file);
  if (preview && preview.dataUrl) {
    pendingSstDocAprPreview = preview;
    if (sstDocAprView) {
      sstDocAprView.disabled = false;
    }
  }
}

function handleSstDocAprView() {
  if (!pendingSstDocAprPreview || !pendingSstDocAprPreview.dataUrl) {
    return;
  }
  abrirDocumento({ dataUrl: pendingSstDocAprPreview.dataUrl });
}

async function handleSstDocSubmit(event) {
  event.preventDefault();
  if (!currentUser || !canViewSst(currentUser)) {
    setInlineMessage(sstDocFormMsg, "Sem permissão para enviar documentação.", true);
    return;
  }
  const payload = {
    projectId: sstDocProject ? sstDocProject.value : "",
    responsibleId: sstDocResponsible ? sstDocResponsible.value : "",
    activity: sstDocActivity ? sstDocActivity.value.trim() : "",
    aprCode: sstDocAprCode ? sstDocAprCode.value.trim() : "",
    notes: sstDocNotes ? sstDocNotes.value.trim() : "",
  };
  if (!payload.projectId) {
    setInlineMessage(sstDocFormMsg, "Selecione o projeto.", true);
    return;
  }
  if (!payload.responsibleId) {
    setInlineMessage(sstDocFormMsg, "Informe o responsável.", true);
    return;
  }
  if (!payload.activity) {
    setInlineMessage(sstDocFormMsg, "Informe a atividade.", true);
    return;
  }
  const aprFile =
    sstDocAprInput && sstDocAprInput.files && sstDocAprInput.files[0]
      ? sstDocAprInput.files[0]
      : null;
  if (!aprFile) {
    setInlineMessage(sstDocFormMsg, "Anexe a APR obrigatória.", true);
    return;
  }
  const aprDoc = await salvarSstDocArquivo(aprFile);
  if (!aprDoc) {
    setInlineMessage(sstDocFormMsg, "Não foi possível anexar a APR.", true);
    return;
  }
  const attachments = [];
  const extraFiles = sstDocAttachments ? Array.from(sstDocAttachments.files || []) : [];
  for (const file of extraFiles) {
    const doc = await salvarSstDocArquivo(file);
    if (doc) {
      attachments.push({ label: file.name || "Anexo", doc });
    }
  }
  const novo = normalizeSstDoc({
    id: criarId(),
    activity: payload.activity,
    projectId: payload.projectId,
    responsibleId: payload.responsibleId,
    aprCode: payload.aprCode,
    aprDoc,
    attachments,
    notes: payload.notes,
    status: "PENDENTE",
    createdAt: toIsoUtc(new Date()),
    createdBy: currentUser.id,
    source: "manual",
  });
  if (!novo) {
    setInlineMessage(sstDocFormMsg, "Falha ao registrar documentação.", true);
    return;
  }
  const result = await dataProvider.sstDocs.create(novo);
  sstDocs = result.list;
  sstLoaded = true;
  fecharSstDocForm();
  renderSstAprPt();
  renderSstDashboard();
}

function abrirSstDocReview(docId) {
  if (!modalSstDocReview) {
    return;
  }
  const doc = sstDocs.find((item) => String(item.id) === String(docId));
  if (!doc) {
    return;
  }
  sstDocReviewingId = doc.id;
  if (sstDocReviewId) {
    sstDocReviewId.value = doc.id;
  }
  if (sstDocReviewTitle) {
    sstDocReviewTitle.textContent = doc.activity || "Documentação";
  }
  if (sstDocReviewStatus) {
    sstDocReviewStatus.innerHTML = getSstDocStatusBadge(doc.status);
  }
  if (sstDocReviewMeta) {
    const project = availableProjects.find((item) => item.id === doc.projectId);
    const projectLabel = project ? getProjectLabel(project) : doc.projectId || "-";
    const responsavel = getUserLabel(doc.responsibleId);
    const enviadoEm = doc.createdAt ? formatDateTime(parseTimestamp(doc.createdAt)) : "-";
    sstDocReviewMeta.textContent = `${projectLabel} · ${responsavel} · Enviado em ${enviadoEm}`;
  }
  if (sstDocReviewNotes) {
    sstDocReviewNotes.value = doc.reviewNotes || "";
  }
  if (sstDocReviewInstructions) {
    sstDocReviewInstructions.value = doc.correctionInstructions || "";
  }
  if (sstDocReviewAttachments) {
    sstDocReviewAttachments.innerHTML = "";
    const lista = [];
    if (doc.aprDoc) {
      lista.push({ label: "APR", doc: doc.aprDoc });
    }
    if (Array.isArray(doc.attachments)) {
      doc.attachments.forEach((item) => {
        if (item && item.doc) {
          lista.push({ label: item.label || "Anexo", doc: item.doc });
        }
      });
    }
    if (!lista.length) {
      const vazio = document.createElement("p");
      vazio.className = "empty-state";
      vazio.textContent = "Sem anexos.";
      sstDocReviewAttachments.append(vazio);
    } else {
      lista.forEach((item) => {
        const row = document.createElement("div");
        row.className = "doc-row";
        const label = document.createElement("span");
        label.textContent = item.label;
        const action = document.createElement("div");
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn btn--ghost btn--small";
        btn.textContent = "Visualizar";
        btn.addEventListener("click", () => abrirDocumento(item.doc));
        action.append(btn);
        row.append(label, action);
        sstDocReviewAttachments.append(row);
      });
    }
  }
  const podeRevisar = Boolean(currentUser && canManageSst(currentUser));
  if (sstDocApproveBtn) {
    sstDocApproveBtn.disabled = !podeRevisar;
  }
  if (sstDocRejectBtn) {
    sstDocRejectBtn.disabled = !podeRevisar;
  }
  if (sstDocReviewNotes) {
    sstDocReviewNotes.disabled = !podeRevisar;
  }
  if (sstDocReviewInstructions) {
    sstDocReviewInstructions.disabled = !podeRevisar;
  }
  setInlineMessage(sstDocReviewMsg, "");
  modalSstDocReview.hidden = false;
}

function fecharSstDocReview() {
  if (!modalSstDocReview) {
    return;
  }
  modalSstDocReview.hidden = true;
  sstDocReviewingId = null;
  if (sstDocReviewId) {
    sstDocReviewId.value = "";
  }
  setInlineMessage(sstDocReviewMsg, "");
}

async function atualizarSstDocStatus(status) {
  if (!currentUser || !canManageSst(currentUser)) {
    setInlineMessage(sstDocReviewMsg, "Sem permissão para revisar.", true);
    return;
  }
  const docId = sstDocReviewingId || (sstDocReviewId ? sstDocReviewId.value : "");
  const index = sstDocs.findIndex((item) => String(item.id) === String(docId));
  if (index < 0) {
    setInlineMessage(sstDocReviewMsg, "Documentação não encontrada.", true);
    return;
  }
  const notes = sstDocReviewNotes ? sstDocReviewNotes.value.trim() : "";
  const instructions = sstDocReviewInstructions
    ? sstDocReviewInstructions.value.trim()
    : "";
  if (String(status).toUpperCase() === "REPROVADO" && !instructions) {
    setInlineMessage(sstDocReviewMsg, "Informe as instruções de correção.", true);
    return;
  }
  const agoraIso = toIsoUtc(new Date());
  const atualizado = {
    ...sstDocs[index],
    status: String(status).toUpperCase(),
    reviewedAt: agoraIso,
    reviewedBy: currentUser.id,
    reviewNotes: notes,
    correctionInstructions: instructions,
    notifiedAt: String(status).toUpperCase() === "REPROVADO" ? agoraIso : "",
    updatedAt: agoraIso,
  };
  const result = await dataProvider.sstDocs.update(docId, atualizado);
  sstDocs = result.list;
  renderSstAprPt();
  renderSstDashboard();
  if (sstDocReviewStatus) {
    sstDocReviewStatus.innerHTML = getSstDocStatusBadge(atualizado.status);
  }
  setInlineMessage(
    sstDocReviewMsg,
    atualizado.status === "APROVADO" ? "Documentação aprovada." : "Documentação reprovada."
  );
}

async function registrarSstDocumentacao(item, liberacao) {
  if (!item || !liberacao || !liberacao.documentos) {
    return;
  }
  const aprDoc = liberacao.documentos.apr || null;
  if (!aprDoc) {
    return;
  }
  const attachments = [];
  Object.keys(liberacao.documentos || {}).forEach((key) => {
    if (key === "apr") {
      return;
    }
    const doc = liberacao.documentos[key];
    if (doc) {
      attachments.push({ label: DOC_LABELS[key] || key.toUpperCase(), doc });
    }
  });
  let responsavel = liberacao.liberadoPor || item.updatedBy || item.createdBy || "";
  if (
    typeof responsavel === "string" &&
    (responsavel.startsWith("team:") || responsavel.startsWith("time:"))
  ) {
    responsavel = currentUser ? currentUser.id : "";
  }
  const novo = normalizeSstDoc({
    id: criarId(),
    activity: item.titulo || item.atividade || item.local || "Atividade",
    projectId: item.projectId || "",
    responsibleId: responsavel,
    aprCode: liberacao.aprCode || "",
    aprDoc,
    attachments,
    status: "PENDENTE",
    createdAt: liberacao.liberadoEm || toIsoUtc(new Date()),
    createdBy: liberacao.liberadoPor || (currentUser ? currentUser.id : ""),
    source: "liberacao",
    relatedId: item.id || "",
  });
  if (!novo) {
    return;
  }
  const result = await dataProvider.sstDocs.upsertByRelatedId(novo);
  sstDocs = result.list;
}

function handleSstDocContainerClick(event) {
  const target = event.target;
  if (!target) {
    return;
  }
  const button = target.closest("button[data-action]");
  if (!button) {
    return;
  }
  const row = target.closest("[data-doc-id]");
  if (!row) {
    return;
  }
  const docId = row.dataset.docId;
  if (!docId) {
    return;
  }
  abrirSstDocReview(docId);
}


async function carregarEquipamentosProjeto() {
  if (!currentUser || !activeProjectId) {
    projectEquipamentos = [];
    renderEquipamentosTable();
    return;
  }
  try {
    const data = await apiProjetosEquipamentosList(activeProjectId);
    projectEquipamentos = Array.isArray(data.equipamentos) ? data.equipamentos : [];
  } catch (error) {
    projectEquipamentos = [];
  }
  renderEquipamentosTable();
  renderEquipamentoOptions();
}

async function carregarTemplatesServidor(force = false) {
  if (!USE_AUTH_API || !currentUser || !activeProjectId) {
    return;
  }
  if (!force && templatesLoadedProjects.has(activeProjectId)) {
    return;
  }
  try {
    const data = await apiTemplatesList(activeProjectId);
    const list = Array.isArray(data.items) ? data.items : [];
    const localSnapshot = Array.isArray(templates) ? templates.slice() : [];
    if (!list.length && localSnapshot.length) {
      const normalizados = normalizarTemplates(localSnapshot);
      templates = normalizados.normalizadas;
      salvarTemplates(templates, { skipSync: true });
      templatesLoadedProjects.add(activeProjectId);
      const nextHash = hashString(JSON.stringify(templates));
      const prevHash = templatesRenderHashes.get(activeProjectId);
      templatesRenderHashes.set(activeProjectId, nextHash);
      if (!prevHash || nextHash !== prevHash) {
        renderTudo();
      }
      templatesSyncEnabled = true;
      if (can("edit") || can("create")) {
        syncTemplatesNow(templates);
      }
      return;
    }
    const serverIds = new Set(
      list.map((item) => (item && item.id ? String(item.id) : "")).filter(Boolean)
    );
    const extras = localSnapshot.filter(
      (item) => item && item.id && !serverIds.has(String(item.id))
    );
    const extrasToMerge = extras.filter((item) => !isDefaultSeedTemplate(item));
    if (list.length && extrasToMerge.length) {
      const mergedList = list.concat(extrasToMerge);
      templates = mergedList.map((item) => ({
        ...item,
        projectId: item.projectId || activeProjectId,
      }));
      const normalizados = normalizarTemplates(templates);
      templates = normalizados.normalizadas;
      salvarTemplates(templates, { skipSync: true });
      templatesLoadedProjects.add(activeProjectId);
      const nextHash = hashString(JSON.stringify(templates));
      const prevHash = templatesRenderHashes.get(activeProjectId);
      templatesRenderHashes.set(activeProjectId, nextHash);
      if (!prevHash || nextHash !== prevHash) {
        renderTudo();
      }
      templatesSyncEnabled = true;
      if (can("edit") || can("create")) {
        syncTemplatesNow(templates);
      }
      return;
    }
    templates = list.map((item) => ({
      ...item,
      projectId: item.projectId || activeProjectId,
    }));
    const normalizados = normalizarTemplates(templates);
    templates = normalizados.normalizadas;
    salvarTemplates(templates, { skipSync: true });
    templatesLoadedProjects.add(activeProjectId);
    const nextHash = hashString(JSON.stringify(templates));
    const prevHash = templatesRenderHashes.get(activeProjectId);
    if (!prevHash || nextHash !== prevHash) {
      templatesRenderHashes.set(activeProjectId, nextHash);
      renderTudo();
    }
  } catch (error) {
    if (STRICT_SERVER_SYNC) {
      showAuthToast("Falha ao carregar modelos do servidor.");
    }
  } finally {
    templatesSyncEnabled = true;
  }
}

async function carregarManutencoesServidor(force = false) {
  if (!currentUser || !activeProjectId) {
    return;
  }
  if (!force && maintenanceLoadedProjects.has(activeProjectId)) {
    return;
  }
  try {
    const data = await apiMaintenanceList(activeProjectId);
    if (data && Array.isArray(data.items)) {
      let needsSync = false;
      const previousServerIds = maintenanceServerIdsByProject.get(activeProjectId) || null;
      const remoteIds = new Set(
        data.items
          .map((item) => (item && item.id ? String(item.id) : ""))
          .filter(Boolean)
      );
      maintenanceServerIdsByProject.set(activeProjectId, remoteIds);
      const tombstones = readMaintenanceTombstoneMap();
      let tombstonesChanged = false;
      remoteIds.forEach((id) => {
        if (tombstones[id]) {
          delete tombstones[id];
          tombstonesChanged = true;
        }
      });
      if (tombstonesChanged) {
        writeMaintenanceTombstoneMap(tombstones);
      }
      const localCache = readJson(getProjectStorageKey(STORAGE_KEY), []);
      const localMap = new Map(
        Array.isArray(localCache)
          ? localCache.filter((item) => item && item.id).map((item) => [item.id, item])
          : []
      );
      let merged = [];
      if (STRICT_SERVER_SYNC) {
        merged = data.items.map((item) => {
          const localItem = localMap.get(item.id);
          if (!localItem) {
            return item;
          }
          const localHasExec = hasExecucaoRegistrada(localItem);
          const remoteHasExec = hasExecucaoRegistrada(item);
          if (localHasExec && !remoteHasExec) {
            needsSync = true;
          }
          return mergeLocalExecucaoRegistro(item, localItem);
        });
      } else {
        merged = data.items.map((item) => {
          const localItem = localMap.get(item.id);
          if (!localItem) {
            return item;
          }
          const localHasExec = hasExecucaoRegistrada(localItem);
          const remoteHasExec = hasExecucaoRegistrada(item);
          if (localHasExec && !remoteHasExec) {
            needsSync = true;
          }
          const resolved = pickMaintenanceMerge(item, localItem);
          if (resolved.source === "local") {
            needsSync = true;
          }
          return resolved.item;
        });
      }
      const lastFetchAt = maintenanceLastFetch;
      if (Array.isArray(localCache)) {
        localCache.forEach((item) => {
          if (!item || !item.id) {
            return;
          }
          const id = String(item.id);
          if (!remoteIds.has(id)) {
            if (previousServerIds && previousServerIds.has(id)) {
              markMaintenanceDeletedIds(id);
              clearMaintenanceDirtyIds(id);
              return;
            }
            if (shouldKeepLocalOnlyMaintenance(item, lastFetchAt)) {
              merged.push(item);
              needsSync = true;
            }
          }
        });
      }
      manutencoes = dedupeMaintenanceList(merged);
      const payloadHash = syncDebugEnabled
        ? hashString(JSON.stringify(data.items))
        : "";
      logSyncDebug("maintenance.fetch", {
        count: data.items.length,
        source: "api",
        projectId: activeProjectId || "",
        hash: payloadHash,
      });
      const resultado = normalizarManutencoes(manutencoes);
      manutencoes = resultado.normalizadas;
      salvarManutencoes(manutencoes, { skipSync: true, skipDirty: true });
      pmpMaintenanceCache.set(activeProjectId, manutencoes);
      maintenanceLoadedProjects.add(activeProjectId);
      maintenanceLastFetch = Date.now();
      if (needsSync) {
        scheduleMaintenanceSync(manutencoes, true);
      }
      const nextHash = getMaintenanceListFingerprint(manutencoes);
      const prevHash = maintenanceRenderHashes.get(activeProjectId);
      const changed = nextHash && nextHash !== prevHash;
      maintenanceRenderHashes.set(activeProjectId, nextHash);
      if (changed) {
        renderTudo();
        showTeamMaintenanceNotifications();
      }
      triggerExecucaoRegistradaAlertIfDue();
    }
  } catch (error) {
    if (STRICT_SERVER_SYNC) {
      maintenanceSyncFailed = true;
      showAuthToast("Falha ao carregar dados do servidor. Tente sincronizar novamente.");
    }
  }
}

async function carregarEquipeProjeto() {
  if (!currentUser || !activeProjectId) {
    projectEquipe = [];
    renderEquipeTable();
    renderManutencaoEquipeOptions();
    renderManutencaoParticipantesOptions();
    renderManutencaoParticipantesSelected();
    renderLiberacaoEquipeOptions();
    renderLiberacaoParticipantesOptions();
    renderLiberacaoParticipantesSelected();
    renderTemplateEquipeOptions();
    renderTemplateParticipantesOptions();
    renderTemplateParticipantesSelected();
    return;
  }
  try {
    const data = await apiProjetosEquipeList(activeProjectId);
    projectEquipe = Array.isArray(data.equipe) ? data.equipe : [];
  } catch (error) {
    projectEquipe = [];
  }
  renderEquipeTable();
  renderManutencaoEquipeOptions();
  renderManutencaoParticipantesOptions();
  renderManutencaoParticipantesSelected();
  renderLiberacaoEquipeOptions();
  renderLiberacaoParticipantesOptions();
  renderLiberacaoParticipantesSelected();
  renderTemplateEquipeOptions();
  renderTemplateParticipantesOptions();
  renderTemplateParticipantesSelected();
}

function renderPerfil() {
  if (!perfilNome) {
    return;
  }

  const editRequested = isProfileEditMode();
  const perfilUsuario = getProfileTargetUser();
  const podeEditarPerfil =
    currentUser && perfilUsuario ? canEditProfile(currentUser, perfilUsuario) : false;
  const isEdit = Boolean(editRequested && podeEditarPerfil);
  const isSelfProfile = Boolean(
    currentUser && perfilUsuario && String(currentUser.id) === String(perfilUsuario.id)
  );

  if (editRequested && !podeEditarPerfil) {
    setProfileEditParam(false);
  }

  if (perfilCard) {
    perfilCard.classList.toggle("is-editing", isEdit);
  }
  if (perfilView) {
    perfilView.hidden = isEdit;
  }
  if (perfilViewActions) {
    perfilViewActions.hidden = isEdit;
  }
  if (perfilEditActions) {
    perfilEditActions.hidden = !isEdit;
  }
  if (perfilModeBadge) {
    perfilModeBadge.hidden = !isEdit;
  }
  if (perfilTitle) {
    if (isEdit) {
      perfilTitle.textContent = "Editar perfil";
    } else if (isSelfProfile) {
      perfilTitle.textContent = "Meu perfil";
    } else {
      const displayName = perfilUsuario && String(perfilUsuario.name || "").trim();
      perfilTitle.textContent = displayName ? `Perfil de ${displayName}` : "Perfil do colaborador";
    }
  }
  if (btnPerfilEditar) {
    btnPerfilEditar.hidden = !podeEditarPerfil;
  }
  if (btnPerfilTrocarContexto) {
    btnPerfilTrocarContexto.disabled = !podeEditarPerfil;
  }
  if (btnPerfilDefinirAtribuicoes) {
    btnPerfilDefinirAtribuicoes.disabled = !podeEditarPerfil;
  }

  if (isEdit) {
    if (isSelfProfile) {
      mountProfileAvatarActions();
    } else {
      unmountProfileAvatarActions();
    }
    mountProfileEdit();
  } else {
    unmountProfileAvatarActions();
    unmountProfileEdit();
    setPerfilSaveMessage("");
    pendingAvatarDataUrl = "";
  }

  if (!perfilUsuario) {
    perfilNome.textContent = "-";
    if (perfilMatricula) {
      perfilMatricula.textContent = "-";
    }
    if (perfilCargo) {
      perfilCargo.textContent = "-";
    }
    if (perfilProjeto) {
      perfilProjeto.textContent = "-";
    }
    if (perfilUen) {
      perfilUen.textContent = "-";
    }
    if (perfilRole) {
      perfilRole.textContent = "-";
    }
    if (perfilAtribuicoes) {
      perfilAtribuicoes.textContent = "-";
    }
    if (perfilPermissoes) {
      perfilPermissoes.textContent = "-";
    }
    if (perfilSecoes) {
      perfilSecoes.textContent = "-";
    }
    if (perfilViewActions) {
      perfilViewActions.hidden = true;
    }
    if (perfilEditActions) {
      perfilEditActions.hidden = true;
    }
    if (btnPerfilEditar) {
      btnPerfilEditar.hidden = true;
    }
    clearProfileHub();
    setAvatarError("");
    applyAvatarToElement(perfilAvatarPreview, "");
    applyAvatarToElement(userAvatar, "");
    return;
  }

  const isAdminUser = isFullAccessUser(perfilUsuario);
  const secConfig = getSectionConfig(perfilUsuario);
  const permissoesAtivas = Object.keys(PERMISSIONS)
    .filter(
      (key) => !isAdminUser && perfilUsuario.permissions && perfilUsuario.permissions[key]
    )
    .map((key) => PERMISSIONS[key]);
  const secoesAtivas = Object.keys(SECTION_LABELS)
    .filter((key) => secConfig[key])
    .map((key) => SECTION_LABELS[key]);

  perfilNome.textContent = formatProfileValue(perfilUsuario.name);
  if (perfilMatricula) {
    perfilMatricula.textContent = formatProfileValue(
      perfilUsuario.matricula || perfilUsuario.username || ""
    );
  }
  if (perfilCargo) {
    perfilCargo.textContent = formatProfileValue(perfilUsuario.cargo);
  }
  if (perfilProjeto) {
    perfilProjeto.textContent = formatProfileValue(getUserProjectLabel(perfilUsuario));
  }
  if (perfilUen) {
    perfilUen.textContent = formatProfileValue(perfilUsuario.uen);
  }
  if (perfilRole) {
    perfilRole.textContent = formatProfileValue(getRoleLabel(perfilUsuario));
  }
  if (perfilAtribuicoes) {
    perfilAtribuicoes.textContent = perfilUsuario.atribuicoes || "N\u00e3o informado.";
  }
  if (perfilPermissoes) {
    perfilPermissoes.textContent = isAdminUser
      ? "Total"
      : permissoesAtivas.length
        ? permissoesAtivas.join(", ")
        : "Sem permiss\u00f5es.";
  }
  if (perfilSecoes) {
    perfilSecoes.textContent = isAdminUser
      ? "Todas (inclui governan\u00e7a)"
      : secoesAtivas.length
        ? secoesAtivas.join(", ")
        : "Nenhuma.";
  }
  applyProfilePreferences(perfilUsuario, isSelfProfile);
  updateProfileHub(perfilUsuario, { isAdminUser, permissoesAtivas, secoesAtivas });
  const perfilUenInputAtual = document.getElementById("perfilUenInput");
  if (perfilUenInputAtual) {
    perfilUenInputAtual.value = perfilUsuario.uen || "";
  }
  const perfilProjetoInputAtual = document.getElementById("perfilProjetoInput");
  if (perfilProjetoInputAtual) {
    renderProjectSelectOptions(perfilProjetoInputAtual, perfilUsuario.projectId || "");
  }
  const perfilAtribuicoesInputAtual = document.getElementById("perfilAtribuicoesInput");
  if (perfilAtribuicoesInputAtual) {
    perfilAtribuicoesInputAtual.value = perfilUsuario.atribuicoes || "";
  }
  const btnSalvarAtual = document.getElementById("btnPerfilSalvar");
  if (btnSalvarAtual) {
    btnSalvarAtual.disabled = !podeEditarPerfil;
  }
  const btnAvatarSaveAtual = document.getElementById("btnAvatarSave");
  if (btnAvatarSaveAtual) {
    btnAvatarSaveAtual.disabled = !isSelfProfile || !pendingAvatarDataUrl;
  }
  const btnAvatarRemoveAtual = document.getElementById("btnAvatarRemove");
  if (btnAvatarRemoveAtual) {
    btnAvatarRemoveAtual.disabled =
      !isSelfProfile || (!perfilUsuario.avatarUrl && !pendingAvatarDataUrl);
  }

  const avatarUrl = isSelfProfile
    ? pendingAvatarDataUrl || getAvatarUrl(perfilUsuario)
    : getAvatarUrl(perfilUsuario);
  applyAvatarToElement(perfilAvatarPreview, avatarUrl);
  applyAvatarToElement(userAvatar, getAvatarUrl(currentUser));
}

profileTabs.forEach((tab) => {
  tab.addEventListener("click", () => {
    setProfileTab(tab.dataset.profileTab);
  });
});
if (profileTabs.length) {
  setProfileTab(activeProfileTab);
}

[
  profileThemeSelect,
  profileDensitySelect,
  profileLanguageSelect,
  profileTimezoneSelect,
  profileDashboardSelect,
  profileNotifyAssigned,
  profileNotifyDue,
  profileNotifyCritical,
  profileNotifyWeekly,
  profile2faToggle,
  profileBlockUnknown,
]
  .filter(Boolean)
  .forEach((input) => {
    input.addEventListener("change", queueProfilePreferencesSave);
  });

function renderAuthUI() {
  const autenticado = Boolean(currentUser);
  document.body.classList.toggle("is-authenticated", autenticado);
  document.body.classList.toggle("is-admin", isAdmin());
  document.body.classList.toggle("is-visitor", !autenticado);

  if (!autenticado) {
    clearProfileTargetUserId();
    fecharPainelLembretes();
    fecharUserMenu();
    esconderCarregando();
    dashboardSummary = null;
    dashboardError = "";
    dashboardLastFetch = 0;
    maintenanceLastSync = 0;
    maintenanceLastUserId = null;
    filesState.items = [];
    permissoesState.values = {};
    permissoesState.profiles = [];
    permissoesState.permissions = [];
    permissoesState.loaded = false;
    if (maintenanceSyncTimer) {
      clearTimeout(maintenanceSyncTimer);
      maintenanceSyncTimer = null;
    }
  }

  if (autenticado) {
    const displayName = getDisplayName(currentUser);
    usuarioAtual.textContent = displayName;
    usuarioAtual.hidden = false;
    if (userMenuName) {
      userMenuName.textContent = displayName;
    }
    if (userMenuRole) {
      userMenuRole.textContent = getUserMenuRoleText(currentUser);
    }
    applyAvatarToElement(userAvatar, getAvatarUrl(currentUser));
    applyAvatarToElement(userMenuAvatar, getAvatarUrl(currentUser));
    if (btnTabLogin) {
      btnTabLogin.hidden = true;
    }
    if (btnTabRegistro) {
      btnTabRegistro.hidden = true;
    }
    if (btnSair) {
      btnSair.hidden = false;
    }
    esconderAuthPanels();
    if (maintenanceLastUserId !== currentUser.id) {
      if (maintenanceLoadedProjects.has(activeProjectId)) {
        scheduleMaintenanceSync(manutencoes, true);
      }
    }
  } else {
    usuarioAtual.textContent = "Visitante";
    usuarioAtual.hidden = true;
    if (btnTabLogin) {
      btnTabLogin.hidden = false;
    }
    if (btnTabRegistro) {
      btnTabRegistro.hidden = false;
    }
    if (btnSair) {
      btnSair.hidden = true;
    }
    pendingAvatarDataUrl = "";
    const btnAvatarSaveAtual = document.getElementById("btnAvatarSave");
    if (btnAvatarSaveAtual) {
      btnAvatarSaveAtual.disabled = true;
    }
    setAvatarError("");
    applyAvatarToElement(perfilAvatarPreview, "");
    applyAvatarToElement(userAvatar, "");
    applyAvatarToElement(userMenuAvatar, "");
  }

  const secConfig = getSectionConfig(currentUser);

  tabButtons.forEach((botao) => {
    const tab = botao.dataset.tab;
    const podeVer = autenticado && canViewTab(tab, currentUser, secConfig);
    botao.hidden = !podeVer;
  });

  panels.forEach((panel) => {
    const nome = panel.dataset.panel;
    const podeVer = autenticado && canViewTab(nome, currentUser, secConfig);
    panel.hidden = !podeVer;
  });

  const tabAtiva = Array.from(tabButtons).find(
    (botao) => botao.classList.contains("is-active") || botao.classList.contains("active")
  );
  if (!tabAtiva || tabAtiva.hidden) {
    const primeira = Array.from(tabButtons).find((botao) => !botao.hidden);
    if (primeira) {
      ativarTab(primeira.dataset.tab);
    }
  }

  adminElements.forEach((section) => {
    const tab = section.dataset.tab || section.dataset.panel;
    if (tab) {
      section.hidden = !autenticado || !canViewTab(tab, currentUser, secConfig);
      return;
    }
    section.hidden = !autenticado || !canViewGerencial(currentUser);
  });

  document.querySelectorAll(".nav-group").forEach((grupo) => {
    const itens = Array.from(grupo.querySelectorAll("[data-tab]"));
    const algumVisivel = itens.some((item) => !item.hidden);
    grupo.hidden = !algumVisivel;
  });

  if (gerencialHealth) {
    gerencialHealth.hidden =
      !currentUser ||
      !canViewGerencial(currentUser) ||
      !hasGranularPermission(currentUser, "verDiagnostico");
  }
  if (gerencialLogs) {
    gerencialLogs.hidden =
      !currentUser ||
      !canViewGerencial(currentUser) ||
      !hasGranularPermission(currentUser, "verLogsAPI");
  }
  if (gerencialAutomations) {
    gerencialAutomations.hidden =
      !currentUser ||
      !canViewGerencial(currentUser) ||
      !hasGranularPermission(currentUser, "verAutomacoes");
  }
  if (gerencialFiles) {
    gerencialFiles.hidden =
      !currentUser ||
      !canViewGerencial(currentUser) ||
      !canManageFilesClient(currentUser);
  }
  if (gerencialPermissoes) {
    const podeVerGerencial = Boolean(currentUser && canViewGerencial(currentUser));
    gerencialPermissoes.hidden = !podeVerGerencial;
  }
  updateGerencialTabVisibility();
  const podeUploadArquivos = currentUser && canUploadFilesClient(currentUser);
  if (filesUploadInput) {
    filesUploadInput.disabled = !podeUploadArquivos;
  }
  if (btnFilesUpload) {
    btnFilesUpload.disabled = !podeUploadArquivos;
  }

  if (btnAdicionarManutencao) {
    const podeCriar = can("create") && secConfig.nova !== false;
    const podeSalvar = manutencaoEmEdicao ? can("edit") : podeCriar;
    btnAdicionarManutencao.disabled = !podeSalvar;
    btnAdicionarManutencao.classList.toggle("is-disabled", !podeSalvar);
  }

  if (btnGerarRelatorio) {
    const podeExportar = currentUser && canExportRelatorios(currentUser);
    btnGerarRelatorio.disabled = !podeExportar;
    btnGerarRelatorio.classList.toggle("is-disabled", !podeExportar);
  }

  aplicarPermissoesRdo();

  if (diasLembrete) {
    diasLembrete.textContent = reminderDays;
  }

  if (configDiasLembrete && configDiasLembrete.value !== String(reminderDays)) {
    configDiasLembrete.value = reminderDays;
  }

  renderFeedbackRecipients();
  atualizarFeedbackBadge();
  renderFeedbackInbox();
  updateSyncStatusLabel();
  updateCompatStatusLabel();
}

function initAvatarUpload() {
  if (avatarUploadBound) {
    return;
  }
  avatarUploadBound = true;

  document.addEventListener("click", (event) => {
    const changeBtn = event.target.closest("#btnAvatarChange");
    if (changeBtn) {
      const input = document.getElementById("perfilAvatarInput");
      if (input) {
        input.click();
      }
      return;
    }

    const removeBtn = event.target.closest("#btnAvatarRemove");
    if (removeBtn) {
      if (!currentUser) {
        return;
      }
      removeBtn.disabled = true;
      setAvatarError("");
      apiDeleteAvatar()
        .then((data) => {
          if (data && data.user) {
            currentUser = data.user;
          } else if (currentUser) {
            currentUser.avatarUrl = "";
            currentUser.avatarUpdatedAt = "";
          }
          pendingAvatarDataUrl = "";
          applyAvatarToElement(perfilAvatarPreview, "");
          renderAuthUI();
          renderPerfil();
        })
        .catch((error) => {
          const message = error && error.message ? error.message : "Falha ao remover foto.";
          setAvatarError(message);
          removeBtn.disabled = false;
        });
      return;
    }

    const saveBtn = event.target.closest("#btnAvatarSave");
    if (!saveBtn) {
      return;
    }
    if (!pendingAvatarDataUrl) {
      return;
    }
    saveBtn.disabled = true;
    setAvatarError("");
    apiUploadAvatar(pendingAvatarDataUrl)
      .then((data) => {
        if (data && data.user) {
          currentUser = data.user;
        } else if (currentUser && data && data.avatarUrl) {
          currentUser.avatarUrl = data.avatarUrl;
          currentUser.avatarUpdatedAt = data.avatarUpdatedAt || new Date().toISOString();
        }
        const input = document.getElementById("perfilAvatarInput");
        if (input) {
          input.value = "";
        }
        pendingAvatarDataUrl = "";
        renderAuthUI();
        renderPerfil();
      })
      .catch((error) => {
        const message = error && error.message ? error.message : "Falha ao salvar foto.";
        setAvatarError(message);
        saveBtn.disabled = false;
      });
  });

  document.addEventListener("change", (event) => {
    const input = event.target;
    if (!input || input.id !== "perfilAvatarInput") {
      return;
    }
    pendingAvatarDataUrl = "";
    setAvatarError("");
    const saveBtn = document.getElementById("btnAvatarSave");
    if (saveBtn) {
      saveBtn.disabled = true;
    }

    const file = input.files && input.files[0];
    if (!file) {
      applyAvatarToElement(perfilAvatarPreview, getAvatarUrl(currentUser));
      return;
    }
    if (!AVATAR_ALLOWED_TYPES.includes(file.type)) {
      setAvatarError("Formato de imagem não suportado.");
      return;
    }
    if (file.size > AVATAR_MAX_BYTES) {
      setAvatarError("Imagem acima de 10 MB.");
      return;
    }

    const reader = new FileReader();
    reader.onload = () => {
      pendingAvatarDataUrl = String(reader.result || "");
      if (!pendingAvatarDataUrl) {
        setAvatarError("Falha ao ler a imagem.");
        return;
      }
      applyAvatarToElement(perfilAvatarPreview, pendingAvatarDataUrl);
      if (saveBtn) {
        saveBtn.disabled = false;
      }
    };
    reader.onerror = () => {
      setAvatarError("Falha ao ler a imagem.");
    };
    reader.readAsDataURL(file);
  });
}

function exportarDados() {
  if (!isAdmin()) {
    mostrarMensagemGerencial("Apenas administradores podem exportar dados.", true);
    return;
  }
  const payload = {
    manutencoes,
    templates,
    users,
    requests,
    auditLog,
    config: { reminderDays },
  };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {
    type: "application/json",
  });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  const dataAtual = new Date().toISOString().slice(0, 10);
  link.href = url;
  link.download = `denemanu-backup-${dataAtual}.json`;
  document.body.append(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);
  mostrarMensagemGerencial("Backup exportado.");
}

function buildAccessPackageFilename() {
  const dataAtual = new Date().toISOString().slice(0, 10);
  return `opscope-acessos-${dataAtual}.json`;
}

async function buildAccessPackage() {
  const roles = await dataProvider.roles.listRoles();
  const usersList = await dataProvider.authAdmin.listUsers();
  const projects = readProjectsStorage();
  return {
    version: ACCESS_PACKAGE_VERSION,
    exportedAt: toIsoUtc(new Date()),
    roles,
    users: usersList,
    projects,
  };
}

function normalizeAccessPackage(payload) {
  if (!payload || typeof payload !== "object") {
    throw new Error("Arquivo invalido.");
  }
  const roles = Array.isArray(payload.roles)
    ? payload.roles.map(normalizeAccessRoleRecord).filter(Boolean)
    : [];
  const usersList = Array.isArray(payload.users)
    ? payload.users.map(normalizeAccessUserRecord).filter(Boolean)
    : [];
  const projects = Array.isArray(payload.projects)
    ? payload.projects.map(normalizeProjectRecord).filter(Boolean)
    : [];
  if (!roles.length) {
    throw new Error("Arquivo sem cargos validos.");
  }
  if (!usersList.length) {
    throw new Error("Arquivo sem contas validas.");
  }
  return { roles, users: usersList, projects };
}

async function persistAccessRoles(roles) {
  writeRolesStorage(roles);
  if (typeof indexedDB === "undefined") {
    return;
  }
  const db = await openOpscopeDb();
  await new Promise((resolve, reject) => {
    const tx = db.transaction("roles", "readwrite");
    const store = tx.objectStore("roles");
    const clearRequest = store.clear();
    clearRequest.onsuccess = () => {
      roles.forEach((role) => store.put(role));
    };
    clearRequest.onerror = () =>
      reject(clearRequest.error || new Error("Falha ao importar cargos."));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error || new Error("Falha ao importar cargos."));
  });
}

async function persistAccessUsers(usersList) {
  writeUsersStorage(usersList);
  if (typeof indexedDB === "undefined") {
    return;
  }
  const db = await openOpscopeDb();
  await new Promise((resolve, reject) => {
    const tx = db.transaction("users", "readwrite");
    const store = tx.objectStore("users");
    const clearRequest = store.clear();
    clearRequest.onsuccess = () => {
      usersList.forEach((user) => store.put(user));
    };
    clearRequest.onerror = () =>
      reject(clearRequest.error || new Error("Falha ao importar contas."));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error || new Error("Falha ao importar contas."));
  });
}

function persistAccessProjects(projects) {
  if (!Array.isArray(projects) || !projects.length) {
    return;
  }
  writeProjectsStorage(projects);
}

function showAccessImportMessage(texto, erro = false) {
  if (currentUser) {
    setAccessMessage(texto, erro);
  } else {
    mostrarMensagemConta(texto, erro);
    if (!erro) {
      showAuthToast(texto);
    }
  }
}

async function applyAccessPackage(payload) {
  if (USE_AUTH_API) {
    await apiRequest("/api/admin/access/import", {
      method: "POST",
      body: JSON.stringify(payload || {}),
    });
    if (currentUser) {
      await refreshAccessRoles();
      await refreshAccessUsers();
      await refreshProjects();
    }
    return;
  }
  const normalized = normalizeAccessPackage(payload);
  await persistAccessRoles(normalized.roles);
  await persistAccessUsers(normalized.users);
  if (normalized.projects.length) {
    persistAccessProjects(normalized.projects);
  } else {
    seedDefaultProjectsIfEmpty();
  }
  if (currentUser) {
    await refreshAccessRoles();
    await refreshAccessUsers();
    await refreshProjects();
  }
}

async function exportAccessPackage() {
  if (!currentUser || !canManageAccess(currentUser)) {
    setAccessMessage("Sem permiss\u00e3o para exportar acessos.", true);
    return;
  }
  setAccessMessage("Gerando pacote de acesso...");
  try {
    const payload = await buildAccessPackage();
    const blob = new Blob([JSON.stringify(payload, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = buildAccessPackageFilename();
    document.body.append(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
    setAccessMessage("Pacote de acesso exportado.");
  } catch (error) {
    setAccessMessage(error.message || "Falha ao exportar acessos.", true);
  }
}

function openAccessImportDialog() {
  if (!accessImportInput) {
    return;
  }
  accessImportInput.value = "";
  accessImportInput.click();
}

function importAccessPackageFromFile(file) {
  if (!file) {
    return;
  }
  const reader = new FileReader();
  reader.onload = () => {
    let payload;
    try {
      payload = JSON.parse(reader.result);
    } catch (error) {
      showAccessImportMessage("Arquivo invalido ou corrompido.", true);
      return;
    }
    applyAccessPackage(payload)
      .then(() => {
        showAccessImportMessage("Acessos importados. Fa\u00e7a login novamente.");
        if (modalAccessHelp && !modalAccessHelp.hidden) {
          closeAccessHelpModal();
        }
      })
      .catch((error) => {
        showAccessImportMessage(error.message || "Falha ao importar acessos.", true);
      });
  };
  reader.onerror = () => {
    showAccessImportMessage("Falha ao ler o arquivo.", true);
  };
  reader.readAsText(file);
}

function importarDados() {
  if (!isAdmin()) {
    mostrarMensagemGerencial("Apenas administradores podem importar dados.", true);
    return;
  }
  const arquivo =
    inputImportarDados && inputImportarDados.files ? inputImportarDados.files[0] : null;
  if (!arquivo) {
    mostrarMensagemGerencial("Selecione um arquivo JSON.", true);
    return;
  }
  const confirmar = window.confirm("Importar dados vai substituir as informacoes locais. Continuar?");
  if (!confirmar) {
    return;
  }
  const leitor = new FileReader();
  leitor.onload = () => {
    try {
      const data = JSON.parse(leitor.result);
      if (data.manutencoes && Array.isArray(data.manutencoes)) {
        manutencoes = data.manutencoes;
      }
      if (data.templates && Array.isArray(data.templates)) {
        templates = data.templates;
      }
      garantirTemplatesPadrao();
      const normalizados = normalizarTemplates(templates);
      templates = normalizados.normalizadas;
      if (data.users && Array.isArray(data.users)) {
        users = data.users;
      }
      if (data.requests && Array.isArray(data.requests)) {
        requests = data.requests;
      }
      if (data.auditLog && Array.isArray(data.auditLog)) {
        auditLog = data.auditLog;
      }
      iniciarAuditChain();
      if (data.config && Number.isFinite(Number(data.config.reminderDays))) {
        reminderDays = Number(data.config.reminderDays);
      }
      salvarManutencoes(manutencoes);
      salvarTemplates(templates);
      salvarUsuarios(users);
      salvarSolicitacoes(requests);
      salvarAuditoria(auditLog);
      writeJson(REMINDER_KEY, reminderDays);
      gerarManutencoesRecorrentes();
      renderTudo();
      mostrarMensagemGerencial("Dados importados com sucesso.");
    } catch (error) {
      mostrarMensagemGerencial("Arquivo inválido ou corrompido.", true);
    }
  };
  leitor.readAsText(arquivo);
}

function limparConcluidas() {
  if (!isAdmin()) {
    mostrarMensagemGerencial("Apenas administradores podem limpar dados.", true);
    return;
  }
  const dias = Number(inputDiasLimpeza.value) || 30;
  const limite = Date.now() - dias * DAY_MS;
  const antes = manutencoes.length;
  manutencoes = manutencoes.filter((item) => {
    if (item.status !== "concluida") {
      return true;
    }
    if (!item.doneAt) {
      return false;
    }
    const doneAt = getTimeValue(item.doneAt);
    return doneAt !== null && doneAt >= limite;
  });
  const removidas = antes - manutencoes.length;
  salvarManutencoes(manutencoes);
  renderTudo();
  mostrarMensagemGerencial(`Concluidas removidas: ${removidas}.`);
}

function limparAuditoria() {
  if (!isAdmin()) {
    mostrarMensagemGerencial("Apenas administradores podem limpar auditoria.", true);
    return;
  }
  const confirmar = window.confirm("Limpar toda a auditoria?");
  if (!confirmar) {
    return;
  }
  auditLog = [];
  salvarAuditoria(auditLog);
  iniciarAuditChain();
  renderTudo();
  mostrarMensagemGerencial("Auditoria limpa.");
}

function recalcularBacklog() {
  atualizarSeNecessario();
  mostrarMensagemGerencial("Backlog recalculado.");
}

function gerarRelatorio() {
  if (!currentUser || !canExportRelatorios(currentUser)) {
    mostrarMensagemGerencial("Sem permissão para gerar relatório.", true);
    return;
  }
  const total = manutencoes.length;
  const agendadas = manutencoes.filter(
    (item) => item.status === "agendada" || item.status === "liberada"
  ).length;
  const backlog = manutencoes.filter((item) => item.status === "backlog").length;
  const concluidas = manutencoes.filter((item) => item.status === "concluida");
  const taxaConclusao = total ? Math.round((concluidas.length / total) * 100) : 0;
  const pontuais = concluidas.filter((item) => {
    const data = parseDate(item.data);
    const doneAt = parseTimestamp(item.doneAt);
    if (!data || !doneAt) {
      return false;
    }
    return startOfDay(doneAt) <= startOfDay(data);
  });
  const taxaPontual = concluidas.length
    ? Math.round((pontuais.length / concluidas.length) * 100)
    : 0;

  const reagendamentos = auditLog.filter((entry) => entry.action === "reschedule");
  const reagendamentosTotal = reagendamentos.length;
  const motivosReagendamento = reagendamentos.reduce((acc, entry) => {
    const motivo =
      entry && entry.detalhes && entry.detalhes.motivo ? entry.detalhes.motivo : "N\u00e3o informado";
    acc[motivo] = (acc[motivo] || 0) + 1;
    return acc;
  }, {});
  const motivosTexto = Object.keys(motivosReagendamento).length
    ? Object.entries(motivosReagendamento)
        .sort((a, b) => b[1] - a[1])
        .map(([motivo, totalMotivo]) => `${motivo}: ${totalMotivo}`)
        .join(" | ")
    : "-";

  const backlogEventos = auditLog.filter((entry) => entry.action === "backlog_auto");
  const backlogEntradas = backlogEventos.length;
  const backlogUnicos = new Set(backlogEventos.map((entry) => entry.manutencaoId)).size;

  const hoje = startOfDay(new Date());
  const backlogItens = manutencoes
    .filter((item) => item.status === "backlog")
    .map((item) => {
      const data = parseDate(item.data);
      if (!data) {
        return null;
      }
      const atraso = diffInDays(startOfDay(data), hoje);
      return { item, atraso: Math.max(0, atraso) };
    })
    .filter(Boolean);
  const backlogSoma = backlogItens.reduce((acc, entry) => acc + entry.atraso, 0);
  const backlogMedio = backlogItens.length ? (backlogSoma / backlogItens.length).toFixed(1) : "-";
  const backlogTop = [...backlogItens].sort((a, b) => b.atraso - a.atraso).slice(0, 5);
  const backlogTopTexto = backlogTop.length
    ? backlogTop
        .map((entry) => `- ${entry.item.titulo} | ${entry.item.local} | ${entry.atraso}d`)
        .join("\n")
    : "-";
  const backlogMotivos = manutencoes
    .filter((item) => item.status === "backlog" && item.backlogMotivo && item.backlogMotivo.motivo)
    .map((item) => item.backlogMotivo.motivo.trim())
    .filter(Boolean);
  const backlogMotivosTotal = backlogMotivos.length;
  const backlogMotivosResumo = backlogMotivosTotal
    ? Object.entries(
        backlogMotivos.reduce((acc, motivo) => {
          acc[motivo] = (acc[motivo] || 0) + 1;
          return acc;
        }, {})
      )
        .sort((a, b) => b[1] - a[1])
        .map(([motivo, totalMotivo]) => `${motivo}: ${totalMotivo}`)
        .join(" | ")
    : "-";

  const outrosObservacoes = reagendamentos
    .filter((entry) => entry.detalhes && entry.detalhes.motivo === "Outros")
    .map((entry) => (entry.detalhes.observacao || "").trim())
    .filter(Boolean);
  const outrosTotal = outrosObservacoes.length;
  const outrosContagem = outrosObservacoes.reduce((acc, obs) => {
    acc[obs] = (acc[obs] || 0) + 1;
    return acc;
  }, {});
  const outrosLista = Object.entries(outrosContagem)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);
  const outrosTexto = outrosLista.length
    ? outrosLista.map(([obs, count]) => `- ${obs} (${count})`).join("\n")
    : "-";

  const manutencaoMap = new Map(manutencoes.map((item) => [item.id, item]));
  const templateMap = new Map(templates.map((item) => [item.id, item.nome]));
  const reagPorModelo = reagendamentos.reduce((acc, entry) => {
    const detalhe = entry.detalhes || {};
    const manutencao = manutencaoMap.get(entry.manutencaoId);
    const templateId = detalhe.templateId || (manutencao ? manutencao.templateId : "");
    const label = templateId ? templateMap.get(templateId) || "Modelo removido" : "Sem modelo";
    acc[label] = (acc[label] || 0) + 1;
    return acc;
  }, {});
  const reagPorModeloTexto = Object.keys(reagPorModelo).length
    ? Object.entries(reagPorModelo)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([label, count]) => `- ${label}: ${count}`)
        .join("\n")
    : "-";

  const execucaoDiffs = concluidas
    .map((item) => {
      const data = parseDate(item.data);
      const doneAt = parseTimestamp(item.doneAt);
      if (!data || !doneAt) {
        return null;
      }
      return diffInDays(startOfDay(data), startOfDay(doneAt));
    })
    .filter((value) => Number.isFinite(value));
  const somaExecucao = execucaoDiffs.reduce((acc, val) => acc + val, 0);
  const tempoMedioExecucao = execucaoDiffs.length ? (somaExecucao / execucaoDiffs.length).toFixed(1) : "-";
  const execAtrasos = execucaoDiffs.filter((diff) => diff > 0);
  const mediaAtrasoExec = execAtrasos.length
    ? (execAtrasos.reduce((acc, val) => acc + val, 0) / execAtrasos.length).toFixed(1)
    : "-";
  const execPontuais = execucaoDiffs.filter((diff) => diff === 0).length;
  const execAdiantadas = execucaoDiffs.filter((diff) => diff < 0).length;
  const execAtrasadas = execucaoDiffs.filter((diff) => diff > 0).length;
  const duracoesExecucao = concluidas
    .map((item) => (item.conclusao ? item.conclusao.duracaoMin : null))
    .filter((valor) => Number.isFinite(valor));
  const mediaDuracaoExecucao = duracoesExecucao.length
    ? formatDuracaoMin(
        duracoesExecucao.reduce((acc, val) => acc + val, 0) / duracoesExecucao.length
      )
    : "-";
  const execComRessalva = concluidas.filter(
    (item) => item.conclusao && item.conclusao.resultado === "ressalva"
  ).length;
  const execNaoExecutada = concluidas.filter(
    (item) => item.conclusao && item.conclusao.resultado === "nao_executada"
  ).length;
  const execucoesIniciadas = auditLog.filter((entry) => entry.action === "execute").length;
  const cancelamentosInicio = auditLog.filter((entry) => entry.action === "cancel_start");
  const execucoesCanceladas = cancelamentosInicio.length;
  const cancelMotivos = cancelamentosInicio.reduce((acc, entry) => {
    const motivo =
      entry && entry.detalhes && entry.detalhes.motivo ? entry.detalhes.motivo : "N\u00e3o informado";
    acc[motivo] = (acc[motivo] || 0) + 1;
    return acc;
  }, {});
  const cancelMotivosTexto = Object.keys(cancelMotivos).length
    ? Object.entries(cancelMotivos)
        .sort((a, b) => b[1] - a[1])
        .map(([motivo, totalMotivo]) => `${motivo}: ${totalMotivo}`)
        .join(" | ")
    : "-";
  const complianceDocs = concluidas.filter((item) => isLiberacaoOk(item)).length;
  const compliancePercent = concluidas.length
    ? Math.round((complianceDocs / concluidas.length) * 100)
    : 0;
  const evidenciasMedia = concluidas.length
    ? (
        concluidas.reduce((acc, item) => {
          const evidencias = item.conclusao && item.conclusao.evidencias;
          return acc + (Array.isArray(evidencias) ? evidencias.length : 0);
        }, 0) / concluidas.length
      ).toFixed(1)
    : "-";

  if (relatorioGerencial) {
    relatorioGerencial.textContent =
      `Total: ${total}\n` +
      `Agendadas: ${agendadas}\n` +
      `Backlog: ${backlog}\n` +
      `Concluídas: ${concluidas.length}\n` +
      `Conclusão: ${taxaConclusao}%\n` +
      `Percentual no prazo: ${taxaPontual}%\n` +
      `Reagendamentos: ${reagendamentosTotal}\n` +
      `Motivos de reagendamento: ${motivosTexto}\n` +
      `Reagendamentos por modelo (top 5):\n${reagPorModeloTexto}\n` +
      `Outros (total): ${outrosTotal}\n` +
      `Observações de Outros (top 10):\n${outrosTexto}\n` +
      `Backlog (entradas): ${backlogEntradas}\n` +
      `Backlog (manutenções afetadas): ${backlogUnicos}\n` +
      `Backlog médio (dias): ${backlogMedio}\n` +
      `Top 5 atrasadas:\n${backlogTopTexto}\n` +
      `Motivos não executada (backlog): ${backlogMotivosTotal}\n` +
      `Detalhes motivos backlog: ${backlogMotivosResumo}\n` +
      `Tempo médio entre programada e execução (dias): ${tempoMedioExecucao}\n` +
      `Tempo médio de execução (HH:MM): ${mediaDuracaoExecucao}\n` +
      `Tempo médio de atraso (dias): ${mediaAtrasoExec}\n` +
        `Execuções: ${execPontuais} no prazo, ${execAdiantadas} adiantadas, ${execAtrasadas} atrasadas\n` +
        `Execuções com ressalva: ${execComRessalva}\n` +
        `Execuções não executadas: ${execNaoExecutada}\n` +
        `Execuções iniciadas: ${execucoesIniciadas}\n` +
        `Inícios cancelados: ${execucoesCanceladas}\n` +
        `Motivos de cancelamento: ${cancelMotivosTexto}\n` +
        `Compliance documental: ${complianceDocs}/${concluidas.length} (${compliancePercent}%)\n` +
        `Evidências médias por manutenção: ${evidenciasMedia}`;
  }
  mostrarMensagemGerencial("Relatório atualizado.");
}

function renderTudo() {
  atualizarResumo();
  renderLembretes();
  renderProgramacao();
  renderListaStatus("backlog", listaBacklog, listaBacklogVazia, {
    allowedActions: ["reschedule", "history", "backlog_reason"],
  });
  renderListaStatus("concluida", listaConcluidas, listaConcluidasVazia, {
    limit: 6,
    allowedActions: ["history", "reopen", "remove"],
  });
  renderExecucao();
  renderKPIs();
  renderDesempenho();
  renderGrafico();
  renderAuditoria();
  renderRelatorios();
  renderPerformanceProjetos();
  renderPerformancePessoas();
  renderFeedbackList();
  renderFeedbackInbox();
  renderRdoList();
  renderModelos();
  renderPmpModule();
  renderSolicitacoes();
  renderUsuarios();
  renderProjectPanel();
  renderPerfil();
  renderAlmoxarifado();
  renderAlmoxItens();
  renderAlmoxEstoque();
  renderAlmoxMovimentacoes();
  renderAlmoxEpis();
  renderSstDashboard();
  renderSstTreinamentos();
  renderSstInspecoes();
  renderSstNcs();
  renderSstIncidentes();
  renderSstAprPt();
  renderSubestacoes();
  renderTipoOptions();
  renderAuthUI();
  syncEditFormIfNeeded();
}
function atualizarSeNecessario() {
  const gerou = gerarManutencoesRecorrentes();
  const resultado = normalizarManutencoes(manutencoes);
  if (resultado.mudou) {
    manutencoes = resultado.normalizadas;
    salvarManutencoes(manutencoes);
    resultado.changes.forEach((change) => {
      if (change.to === "backlog") {
        const item = manutencoes.find((registro) => registro.id === change.id);
        if (item) {
          const dataProgramada = parseDate(item.data);
          const atrasoDias = dataProgramada
            ? Math.max(0, diffInDays(startOfDay(dataProgramada), startOfDay(new Date())))
            : null;
          logAction(
            "backlog_auto",
            item,
            {
              from: change.from,
              to: change.to,
              dataProgramada: item.data || "",
              atrasoDias,
              resumo: "Manutenção movida para backlog por não conclusão até a data programada.",
            },
            SYSTEM_USER_ID
          );
        }
      }
    });
    renderTudo();
    return;
  }
  if (gerou) {
    renderTudo();
  }
  triggerExecucaoRegistradaAlertIfDue();
}

async function adicionarManutencao() {
  const editId =
    manutencaoEmEdicao ||
    (manutencaoEditBanner && !manutencaoEditBanner.hidden
      ? manutencaoEditBanner.dataset.editId
      : "");
  if (editId) {
    manutencaoEmEdicao = editId;
    if (!requirePermission("edit")) {
      return;
    }
    await salvarEdicaoManutencao();
    return;
  }
  if (!requirePermission("create")) {
    return;
  }
  if (!requirePermission("complete")) {
    return;
  }
  if (manutencaoProjeto && manutencaoProjeto.value && manutencaoProjeto.value !== activeProjectId) {
    await setActiveProjectId(manutencaoProjeto.value);
    mostrarMensagemManutencao("Projeto ativo alterado. Revise os dados e clique em salvar novamente.", true);
    return;
  }
  const tipoSelecionado = tipoManutencao ? tipoManutencao.value : "";
  let titulo = "";
  let templateId = null;

  if (tipoSelecionado && tipoSelecionado !== CUSTOM_TIPO_OPTION) {
    const template = getTemplateById(tipoSelecionado);
    if (template) {
      titulo = template.nome;
      templateId = template.id;
    } else {
      titulo = tipoSelecionado.trim();
    }
  } else {
    titulo = tituloManutencao ? tituloManutencao.value.trim() : "";
  }

  const local =
    (subestacaoManutencao ? subestacaoManutencao.value.trim() : "") ||
    getSubestacoesBase()[0] ||
    "";
  const equipamentoId = equipamentoManutencao ? equipamentoManutencao.value.trim() : "";
  const data = dataManutencao
    ? dataManutencao.value || formatDateISO(new Date())
    : "";
  if (dataManutencao && !dataManutencao.value) {
    dataManutencao.value = data;
  }
  if (obsManutencaoEditor) {
    syncObsEditor(true);
  }
  const observacaoHtmlRaw = obsManutencaoHtml ? obsManutencaoHtml.value.trim() : "";
  const observacaoHtml = observacaoHtmlRaw ? sanitizeRichText(observacaoHtmlRaw) : "";
  const observacao = observacaoHtml
    ? stripHtml(observacaoHtml).trim()
    : obsManutencao
      ? obsManutencao.value.trim()
      : "";
  const categoria = categoriaManutencao ? categoriaManutencao.value.trim() : "";
  const prioridade = prioridadeManutencao ? prioridadeManutencao.value.trim() : "";
  const osReferencia = osReferenciaManutencao ? osReferenciaManutencao.value.trim() : "";
  const participantes = getManutencaoParticipantesFromForm();
  const criticoValor = criticoManutencao ? criticoManutencao.value : "nao";
  const critico = criticoValor === "sim";

  if (!activeProjectId) {
    mostrarMensagemManutencao("Selecione um projeto ativo antes de criar.", true);
    return;
  }
  if (!titulo || !local || !data || !categoria || !prioridade) {
    mostrarMensagemManutencao(
      "Preencha tipo, subestação, início da execução, categoria e prioridade.",
      true
    );
    return;
  }
  if (!equipamentoId) {
    mostrarMensagemManutencao("Informe o equipamento da manutenção.", true);
    return;
  }
  if (!observacao) {
    mostrarMensagemManutencao("Descreva a demanda técnica.", true);
    return;
  }
  if (!osReferencia) {
    mostrarMensagemManutencao("Informe a OS / referência.", true);
    return;
  }
  setFieldError(participantesManutencaoErro, "");
  if (participantes.length < 2) {
    setFieldError(participantesManutencaoErro, "Informe ao menos 2 participantes.");
    mostrarMensagemManutencao("Informe ao menos 2 participantes.", true);
    return;
  }

  const documentos = {};
  for (const chave of DOC_KEYS) {
    const input = novaDocInputs.find((itemInput) => itemInput.dataset.novaDocInput === chave);
    const file = input && input.files && input.files[0] ? input.files[0] : null;
    if (file) {
      try {
        documentos[chave] = await uploadLiberacaoDoc(file, chave);
      } catch (error) {
        mostrarMensagemManutencao(
          error && error.message ? error.message : "Não foi possível enviar o documento.",
          true
        );
        return;
      }
    }
  }
  if (!documentos.apr || !documentos.os || !documentos.pte) {
    mostrarMensagemManutencao("Anexe APR, OS e PTE para iniciar.", true);
    return;
  }
  if (critico && !documentos.pt) {
    mostrarMensagemManutencao("PT obrigatória para trabalho crítico.", true);
    return;
  }

  const agora = new Date();
  const agoraIso = toIsoUtc(agora);
  const usuarioLabel = getUserLabel(currentUser.id);
  const teamName = getManutencaoEquipeSelecionada();
  const executadoPorTime = teamName ? `team:${teamName}` : currentUser.id;
  const ultimaAcao = `Execução iniciada em ${formatDateTime(agora)} por ${usuarioLabel}`;
  const liberacao = {
    osNumero: osReferencia,
    participantes,
    critico,
    documentos,
    liberadoEm: agoraIso,
    liberadoPor: currentUser.id,
  };
  const nova = {
    id: criarId(),
    titulo,
    local,
    data,
    projectId: activeProjectId,
    equipamentoId,
    observacao,
    observacaoHtml,
    templateId,
    status: "em_execucao",
    categoria,
    prioridade,
    criticidade: critico ? "sim" : "nao",
    osReferencia,
    participantes,
    documentos,
    abertaEm: agoraIso,
    inicioExecucao: agoraIso,
    abertaPor: currentUser.id,
    executadaPor: executadoPorTime,
    ultimaAcao,
    executionStartedAt: agoraIso,
    executionStartedBy: currentUser.id,
    registroExecucao: { executadoPor: executadoPorTime },
    liberacao,
    createdAt: agoraIso,
    createdBy: currentUser.id,
    updatedAt: agoraIso,
    updatedBy: currentUser.id,
  };

  manutencoes = [...manutencoes, nova];
  const resultado = normalizarManutencoes(manutencoes);
  manutencoes = resultado.normalizadas;
  salvarManutencoes(manutencoes);
  logAction("create", nova, {
    source: "manual",
    dataProgramada: data,
    resumo: "Manutenção criada e iniciada.",
  });
  const documentosLista = DOC_KEYS.filter((key) => documentos[key]).map(
    (key) => DOC_LABELS[key] || key
  );
  logAction("execute", nova, {
    dataProgramada: data,
    inicioExecucao: agoraIso,
    osNumero: osReferencia,
    participantes,
    critico,
    documentos: documentosLista,
    resumo: "Execução iniciada.",
  });
  await registrarSstDocumentacao(nova, liberacao);
  renderTudo();
  showTeamMaintenanceNotifications();
  limparFormularioManutencao();

  const criada = manutencoes.find((item) => item.id === nova.id);
  if (criada) {
    abrirRegistroExecucao(criada);
  }
  mostrarMensagemManutencao("Execução iniciada.");
}

let manutencaoEmConclusao = null;
let conclusaoItemAtual = null;
let manutencaoEmRegistro = null;
let manutencaoEmEdicao = null;
let manutencaoEditSnapshot = null;
let manutencaoEditDirty = false;

function setEditModeManutencao(item) {
  const ativo = Boolean(item);
  manutencaoEmEdicao = ativo ? item.id : null;
  manutencaoEditSnapshot = ativo
    ? typeof structuredClone === "function"
      ? structuredClone(item)
      : JSON.parse(JSON.stringify(item))
    : null;
  manutencaoEditDirty = false;
  if (manutencaoEditBanner) {
    manutencaoEditBanner.hidden = !ativo;
    if (ativo) {
      manutencaoEditBanner.dataset.editId = item.id;
      manutencaoEditBanner.dataset.editTitle = item.titulo || "";
    } else {
      delete manutencaoEditBanner.dataset.editId;
      delete manutencaoEditBanner.dataset.editTitle;
    }
  }
  if (manutencaoEditInfo) {
    if (!ativo) {
      manutencaoEditInfo.textContent = "-";
    } else {
      const projeto = getProjectById(item.projectId);
      const projetoLabel = projeto
        ? `${projeto.codigo || "-"} - ${projeto.nome || "-"}`
        : "Projeto";
      const dataParsed = item.data ? parseDate(item.data) : null;
      let dataValor = dataParsed ? formatDate(dataParsed) : "";
      if (!dataValor && item.data) {
        dataValor = String(item.data);
      }
      if (!dataValor) {
        const doneDate = item.doneAt ? parseTimestamp(item.doneAt) : null;
        if (doneDate) {
          dataValor = formatDate(startOfDay(doneDate));
        }
      }
      if (!dataValor) {
        dataValor = "-";
      }
      manutencaoEditInfo.textContent = `${projetoLabel} · ${item.titulo || "-"} · ${
        item.local || "-"
      } · ${dataValor}`;
    }
  }
  if (btnAdicionarManutencao) {
    btnAdicionarManutencao.textContent = ativo ? "Salvar edição" : "Iniciar execução";
    const podeCriar = can("create") && secConfig.nova !== false;
    const podeSalvar = ativo ? can("edit") : podeCriar;
    btnAdicionarManutencao.disabled = !podeSalvar;
    btnAdicionarManutencao.classList.toggle("is-disabled", !podeSalvar);
  }
  if (manutencaoProjeto) {
    if (ativo) {
      manutencaoProjeto.disabled = true;
      if (item.projectId) {
        manutencaoProjeto.value = item.projectId;
      }
    } else {
      manutencaoProjeto.disabled = false;
      if (activeProjectId) {
        manutencaoProjeto.value = activeProjectId;
      }
    }
  }
}

function limparFormularioManutencao() {
  if (tituloManutencao) {
    tituloManutencao.value = "";
  }
  if (tipoManutencao) {
    tipoManutencao.value = templates.length === 0 ? CUSTOM_TIPO_OPTION : "";
    atualizarTipoSelecionado();
  }
  const baseSubestacoes = getSubestacoesBase();
  if (subestacaoManutencao && baseSubestacoes.length > 0) {
    subestacaoManutencao.value = baseSubestacoes[0];
  }
  if (equipamentoManutencao) {
    equipamentoManutencao.value = "";
  }
  if (futuraManutencao) {
    futuraManutencao.checked = false;
  }
  if (dataManutencao) {
    atualizarDataManutencaoState();
  }
  if (obsManutencao) {
    obsManutencao.value = "";
  }
  if (obsManutencaoHtml) {
    obsManutencaoHtml.value = "";
  }
  if (obsManutencaoEditor) {
    obsManutencaoEditor.innerHTML = "";
  }
  if (categoriaManutencao) {
    categoriaManutencao.value = "";
  }
  if (prioridadeManutencao) {
    prioridadeManutencao.value = "";
  }
  if (osReferenciaManutencao) {
    osReferenciaManutencao.value = "";
  }
  if (participantesManutencao) {
    participantesManutencao.value = "";
  }
  if (participanteExternoManutencao) {
    participanteExternoManutencao.value = "";
  }
  setManutencaoParticipantes([]);
  renderManutencaoEquipeOptions();
  if (criticoManutencao) {
    criticoManutencao.value = "nao";
  }
  novaDocInputs.forEach((input) => {
    if (input) {
      input.value = "";
    }
  });
  novaDocExisting = {};
  atualizarNovaDocsUI();
  atualizarNovaCriticoUI();
  setFieldError(participantesManutencaoErro, "");
  if (customTipoField && !customTipoField.hidden && tituloManutencao) {
    tituloManutencao.focus();
  } else if (tipoManutencao) {
    tipoManutencao.focus();
  }
}

function limparEdicaoManutencao() {
  setEditModeManutencao(null);
  limparFormularioManutencao();
}

function syncEditFormIfNeeded() {
  if (!manutencaoEmEdicao || manutencaoEditDirty) {
    return;
  }
  const item =
    manutencoes.find((registro) => registro.id === manutencaoEmEdicao) ||
    manutencaoEditSnapshot;
  if (item) {
    preencherFormularioManutencao(item);
    return;
  }
  if (manutencaoEditBanner && manutencaoEditBanner.dataset.editTitle) {
    const titulo = manutencaoEditBanner.dataset.editTitle;
    if (tipoManutencao) {
      tipoManutencao.value = CUSTOM_TIPO_OPTION;
      atualizarTipoSelecionado();
    }
    if (tituloManutencao && titulo) {
      tituloManutencao.value = titulo;
    }
  }
}

function preencherFormularioManutencao(item) {
  if (!item) {
    return;
  }
  renderTipoOptions();
  renderSubestacoes();
  renderEquipamentoOptions();

  const projectId = pickItemValue(item, ["projectId", "projetoId"]);
  if (manutencaoProjeto && projectId) {
    manutencaoProjeto.value = projectId;
  }

  const rdoItem = getRdoItemSnapshot(item.id);
  const similarItem = findSimilarMaintenance(item);
  const templateKey = pickItemValue(item, ["templateId", "template"]);
  let template = templateKey ? getTemplateById(templateKey) : null;
  if (!template && item.titulo) {
    const tituloNorm = normalizeSearchValue(item.titulo);
    template =
      templates.find(
        (modelo) => normalizeSearchValue(modelo && modelo.nome ? modelo.nome : "") === tituloNorm
      ) || null;
  }
  if (tipoManutencao) {
    tipoManutencao.value = template ? template.id : CUSTOM_TIPO_OPTION;
    atualizarTipoSelecionado();
  }
  if (tituloManutencao) {
    tituloManutencao.value = template
      ? ""
      : item.titulo ||
        item.nome ||
        (rdoItem ? rdoItem.titulo || "" : "") ||
        (similarItem ? similarItem.titulo || similarItem.nome || "" : "");
  }

  if (subestacaoManutencao) {
    const local =
      getItemSubestacao(item) ||
      (rdoItem ? rdoItem.subestacao || "" : "") ||
      (similarItem ? getItemSubestacao(similarItem) : "");
    if (local) {
      const existe = Array.from(subestacaoManutencao.options || []).some(
        (opt) => opt.value === local
      );
      if (!existe) {
        const option = document.createElement("option");
        option.value = local;
        option.textContent = local;
        subestacaoManutencao.append(option);
      }
    }
    subestacaoManutencao.value = local;
  }

  if (equipamentoManutencao) {
    const equipamentoRaw =
      pickItemValue(item, ["equipamentoId", "equipamento"]) ||
      (item.conclusao ? pickItemValue(item.conclusao, ["equipamentoId", "equipamento"]) : "") ||
      (similarItem ? pickItemValue(similarItem, ["equipamentoId", "equipamento"]) : "");
    const equipamentoNome =
      equipamentoRaw && typeof equipamentoRaw === "object"
        ? equipamentoRaw.nome || equipamentoRaw.name || equipamentoRaw.label || ""
        : "";
    let equipamentoId =
      typeof equipamentoRaw === "object" && equipamentoRaw
        ? equipamentoRaw.id || ""
        : String(equipamentoRaw || "").trim();
    if (!equipamentoId && equipamentoNome) {
      const matchByName = projectEquipamentos.find(
        (equip) =>
          normalizeSearchValue(equip.nome || "") === normalizeSearchValue(equipamentoNome) ||
          normalizeSearchValue(equip.tag || "") === normalizeSearchValue(equipamentoNome)
      );
      if (matchByName) {
        equipamentoId = matchByName.id;
      }
    }
    if (equipamentoId) {
      const matchById = projectEquipamentos.find((equip) => equip.id === equipamentoId);
      if (matchById) {
        equipamentoId = matchById.id;
      } else if (equipamentoNome) {
        const matchByName = projectEquipamentos.find(
          (equip) =>
            normalizeSearchValue(equip.nome || "") === normalizeSearchValue(equipamentoNome) ||
            normalizeSearchValue(equip.tag || "") === normalizeSearchValue(equipamentoNome)
        );
        if (matchByName) {
          equipamentoId = matchByName.id;
        }
      }
    }
    if (equipamentoId) {
      const existe = Array.from(equipamentoManutencao.options || []).some(
        (opt) => opt.value === equipamentoId
      );
      if (!existe) {
        const equipamento = projectEquipamentos.find((equip) => equip.id === equipamentoId);
        const option = document.createElement("option");
        option.value = equipamentoId;
        option.textContent = equipamento
          ? `${equipamento.tag || "-"} - ${equipamento.nome || "-"}`
          : equipamentoNome || equipamentoId;
        equipamentoManutencao.append(option);
      }
    }
    equipamentoManutencao.value = equipamentoId;
  }

  const dataValor =
    item.data ||
    (getItemConclusaoDate(item) ? formatDateISO(getItemConclusaoDate(item)) : "") ||
    formatDateISO(new Date());
  if (futuraManutencao) {
    const hoje = formatDateISO(new Date());
    futuraManutencao.checked = Boolean(dataValor && dataValor !== hoje);
  }
  atualizarDataManutencaoState();
  if (dataManutencao) {
    dataManutencao.value = dataValor;
  }

  const liberacao = getLiberacao(item) || {};
  const auditDetalhes = getHistoricoDetalhes(item.id, [
    "osNumero",
    "referencia",
    "participantes",
    "critico",
  ]);
  const osNumero =
    pickItemValue(item, ["osReferencia", "osNumero", "referencia"]) ||
    liberacao.osNumero ||
    (item.conclusao && item.conclusao.referencia) ||
    (item.conclusao && item.conclusao.osNumero) ||
    (auditDetalhes && (auditDetalhes.osNumero || auditDetalhes.referencia)) ||
    "";
  if (osReferenciaManutencao) {
    osReferenciaManutencao.value = osNumero;
  }
  if (categoriaManutencao) {
    const valorCategoria =
      getItemCategoria(item) ||
      (rdoItem ? rdoItem.categoria || "" : "") ||
      (similarItem ? getItemCategoria(similarItem) : "");
    if (valorCategoria) {
      const categoriaNormalizada = normalizeSearchValue(valorCategoria);
      const match = Array.from(categoriaManutencao.options || []).find(
        (opt) => normalizeSearchValue(opt.value) === categoriaNormalizada
      );
      if (match) {
        categoriaManutencao.value = match.value;
      } else {
        const option = document.createElement("option");
        option.value = valorCategoria;
        option.textContent = valorCategoria;
        categoriaManutencao.append(option);
        categoriaManutencao.value = valorCategoria;
      }
    } else {
      categoriaManutencao.value = "";
    }
  }
  if (prioridadeManutencao) {
    const valorPrioridade =
      getItemPrioridade(item) ||
      (rdoItem ? rdoItem.prioridade || "" : "") ||
      (similarItem ? getItemPrioridade(similarItem) : "");
    if (valorPrioridade) {
      const prioridadeNormalizada = normalizeSearchValue(valorPrioridade);
      const match = Array.from(prioridadeManutencao.options || []).find(
        (opt) => normalizeSearchValue(opt.value) === prioridadeNormalizada
      );
      if (match) {
        prioridadeManutencao.value = match.value;
      } else {
        const option = document.createElement("option");
        option.value = valorPrioridade;
        option.textContent = valorPrioridade;
        prioridadeManutencao.append(option);
        prioridadeManutencao.value = valorPrioridade;
      }
    } else {
      prioridadeManutencao.value = "";
    }
  }

  const participantesBase =
    Array.isArray(item.participantes) && item.participantes.length
      ? item.participantes
      : Array.isArray(item.conclusao && item.conclusao.participantes)
        ? item.conclusao.participantes
        : Array.isArray(item.registroExecucao && item.registroExecucao.participantes)
          ? item.registroExecucao.participantes
          : Array.isArray(liberacao.participantes)
            ? liberacao.participantes
            : Array.isArray(auditDetalhes && auditDetalhes.participantes)
              ? auditDetalhes.participantes
              : typeof (auditDetalhes && auditDetalhes.participantes) === "string"
                ? auditDetalhes.participantes.split(";").map((p) => p.trim()).filter(Boolean)
                : rdoItem && rdoItem.participantes
                  ? String(rdoItem.participantes)
                      .split(",")
                      .map((p) => p.trim())
                      .filter(Boolean)
                  : [];
  const participantesNormalizados = participantesBase
    .map((entry) => {
      if (!entry) {
        return "";
      }
      if (typeof entry === "string") {
        return entry;
      }
      if (typeof entry === "object") {
        return (
          entry.id ||
          entry.userId ||
          entry.matricula ||
          entry.nome ||
          entry.name ||
          entry.label ||
          ""
        );
      }
      return "";
    })
    .filter(Boolean);
  const participantesLista = participantesNormalizados
    .map((entry) => {
      if (!entry) {
        return "";
      }
      if (typeof entry === "string") {
        const user = getUserById(entry);
        return normalizeParticipantName(user && user.name ? user.name : entry);
      }
      if (typeof entry === "object") {
        const raw =
          entry.name ||
          entry.nome ||
          entry.label ||
          entry.id ||
          entry.userId ||
          entry.matricula ||
          "";
        const user = raw ? getUserById(raw) : null;
        return normalizeParticipantName(user && user.name ? user.name : raw);
      }
      return "";
    })
    .filter(Boolean);
  setManutencaoParticipantes(participantesLista);
  setFieldError(participantesManutencaoErro, "");
  const equipeBase = item.executadaPor || item.responsavel || item.responsavelManutencao || "";
  const equipeSelecionada = isTeamUserId(equipeBase)
    ? normalizeTeamName(equipeBase)
    : "";
  renderManutencaoEquipeOptions(equipeSelecionada);

  const critico =
    isCriticoValor(item.criticidade) ||
    isCriticoValor(liberacao.critico) ||
    isCriticoValor(auditDetalhes && auditDetalhes.critico) ||
    (rdoItem ? Boolean(rdoItem.critico) : false);
  if (criticoManutencao) {
    criticoManutencao.value = critico ? "sim" : "nao";
  }
  atualizarNovaCriticoUI();

  const descricaoRegistro =
    getItemDescricaoRdo(item) ||
    (rdoItem ? rdoItem.descricao || "" : "") ||
    (similarItem ? getItemDescricaoRdo(similarItem) : "");
  const usaRegistro =
    Boolean(item.registroExecucao && item.registroExecucao.comentario) ||
    Boolean(item.conclusao && item.conclusao.comentario);
  if (obsManutencaoEditor) {
    setObsEditorContent({
      html: usaRegistro ? "" : item.observacaoHtml || "",
      text: usaRegistro ? descricaoRegistro : item.observacao || descricaoRegistro || "",
    });
  } else if (obsManutencao) {
    obsManutencao.value = usaRegistro
      ? descricaoRegistro || ""
      : item.observacao || descricaoRegistro || "";
  }

  if (!template && tipoManutencao) {
    tipoManutencao.value = CUSTOM_TIPO_OPTION;
    atualizarTipoSelecionado();
    if (tituloManutencao && !tituloManutencao.value) {
      tituloManutencao.value = item.titulo || item.nome || "";
    }
  }
  if (tipoManutencao && tituloManutencao && tituloManutencao.value.trim()) {
    tipoManutencao.value = CUSTOM_TIPO_OPTION;
    atualizarTipoSelecionado();
  }

  novaDocInputs.forEach((input) => {
    if (input) {
      input.value = "";
    }
  });
  novaDocExisting = {
    ...(item.documentos || {}),
    ...((liberacao && liberacao.documentos) || {}),
  };
  atualizarNovaDocsUI();
}

async function abrirEdicaoManutencao(item) {
  if (!item) {
    return;
  }
  if (item.status === "concluida" && !canEditConcludedMaintenance(currentUser)) {
    mostrarMensagemManutencao("Sem permiss\u00e3o para editar manutencoes concluidas.", true);
    return;
  }
  if (item.projectId && item.projectId !== activeProjectId) {
    await setActiveProjectId(item.projectId);
  }
  const atualizado = manutencoes.find((registro) => registro.id === item.id) || item;
  ativarTab("nova");
  setEditModeManutencao(atualizado);
  limparFormularioManutencao();
  preencherFormularioManutencao(atualizado);
  manutencaoEditDirty = false;
  if (manutencaoEditBanner && manutencaoEditBanner.scrollIntoView) {
    manutencaoEditBanner.scrollIntoView({ behavior: "smooth", block: "center" });
  }
}

async function salvarEdicaoManutencao() {
  if (!manutencaoEmEdicao) {
    return;
  }
  if (!requirePermission("edit")) {
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === manutencaoEmEdicao);
  if (index < 0) {
    mostrarMensagemManutencao("Manutenção não encontrada.", true);
    return;
  }
  const item = manutencoes[index];
  const isConcluida = item.status === "concluida";
  if (isConcluida && !canEditConcludedMaintenance(currentUser)) {
    mostrarMensagemManutencao("Sem permiss\u00e3o para editar manutencoes concluidas.", true);
    return;
  }

  if (obsManutencaoEditor) {
    syncObsEditor(true);
  }

  const tipoSelecionado = tipoManutencao ? tipoManutencao.value : "";
  let titulo = "";
  let templateId = null;

  if (tipoSelecionado && tipoSelecionado !== CUSTOM_TIPO_OPTION) {
    const template = getTemplateById(tipoSelecionado);
    if (template) {
      titulo = template.nome;
      templateId = template.id;
    } else {
      titulo = tipoSelecionado.trim();
    }
  } else {
    titulo = tituloManutencao ? tituloManutencao.value.trim() : "";
  }
  let templateFinal = templateId;
  if (!templateFinal) {
    if (tipoSelecionado === CUSTOM_TIPO_OPTION) {
      templateFinal = titulo ? null : item.templateId || null;
    } else if (!tipoSelecionado) {
      templateFinal = item.templateId || null;
    } else {
      templateFinal = item.templateId || null;
    }
  }
  const tituloFinal = titulo || item.titulo || item.nome || "";

  const localInput = subestacaoManutencao ? subestacaoManutencao.value.trim() : "";
  const local =
    localInput ||
    getItemSubestacao(item) ||
    getSubestacoesBase()[0] ||
    "";
  const equipamentoInput = equipamentoManutencao ? equipamentoManutencao.value.trim() : "";
  const equipamentoId =
    equipamentoInput ||
    (typeof item.equipamentoId === "string" && item.equipamentoId) ||
    (typeof item.equipamento === "string" && item.equipamento) ||
    "";
  const data = dataManutencao
    ? dataManutencao.value || item.data || formatDateISO(new Date())
    : item.data || "";
  if (dataManutencao && !dataManutencao.value) {
    dataManutencao.value = data;
  }
  const observacaoHtmlRaw = obsManutencaoHtml ? obsManutencaoHtml.value.trim() : "";
  const observacaoHtml = observacaoHtmlRaw ? sanitizeRichText(observacaoHtmlRaw) : "";
  const observacao = observacaoHtml
    ? stripHtml(observacaoHtml).trim()
    : obsManutencao
      ? obsManutencao.value.trim()
      : "";
  const categoriaInput = categoriaManutencao ? categoriaManutencao.value.trim() : "";
  const prioridadeInput = prioridadeManutencao ? prioridadeManutencao.value.trim() : "";
  const osReferenciaInput = osReferenciaManutencao ? osReferenciaManutencao.value.trim() : "";
  const auditDetalhes = getHistoricoDetalhes(item.id, [
    "osNumero",
    "referencia",
    "participantes",
    "critico",
  ]);
  const categoria = categoriaInput || getItemCategoria(item) || "";
  const prioridade = prioridadeInput || getItemPrioridade(item) || "";
  const osReferencia =
    osReferenciaInput ||
    pickItemValue(item, ["osReferencia", "osNumero", "referencia"]) ||
    (item.conclusao && item.conclusao.referencia) ||
    (getLiberacao(item) && getLiberacao(item).osNumero) ||
    (auditDetalhes && (auditDetalhes.osNumero || auditDetalhes.referencia)) ||
    "";
  let participantes = getManutencaoParticipantesFromForm();
  if (!participantes.length) {
    const base =
      Array.isArray(item.participantes) && item.participantes.length
        ? item.participantes
        : Array.isArray(item.conclusao && item.conclusao.participantes)
          ? item.conclusao.participantes
          : Array.isArray(item.registroExecucao && item.registroExecucao.participantes)
            ? item.registroExecucao.participantes
            : Array.isArray((getLiberacao(item) || {}).participantes)
              ? (getLiberacao(item) || {}).participantes
              : Array.isArray(auditDetalhes && auditDetalhes.participantes)
                ? auditDetalhes.participantes
                : typeof (auditDetalhes && auditDetalhes.participantes) === "string"
                  ? auditDetalhes.participantes.split(";").map((p) => p.trim()).filter(Boolean)
                  : [];
    participantes = base
      .map((entry) => {
        if (!entry) {
          return "";
        }
        if (typeof entry === "string") {
          return entry;
        }
        if (typeof entry === "object") {
          return (
            entry.id ||
            entry.userId ||
            entry.matricula ||
            entry.nome ||
            entry.name ||
            entry.label ||
            ""
          );
        }
        return "";
      })
      .filter(Boolean);
  }
  const criticoValor = criticoManutencao ? criticoManutencao.value : "";
  const critico =
    criticoValor === "sim"
      ? true
      : criticoValor === "nao"
        ? false
        : isItemCritico(item) || isCriticoValor(auditDetalhes && auditDetalhes.critico);

  const equipamentoObj =
    item.equipamento && typeof item.equipamento === "object" ? item.equipamento : null;
  const equipamentoFallback = equipamentoObj
    ? equipamentoObj.id || equipamentoObj.nome || equipamentoObj.name || equipamentoObj.tag || ""
    : "";
  const equipamentoFinal = equipamentoId || equipamentoFallback || "";
  const localFinal = local || getItemSubestacao(item) || "";
  const dataFinal = data || item.data || formatDateISO(new Date());
  if (dataManutencao && !dataManutencao.value) {
    dataManutencao.value = dataFinal;
  }
  const observacaoFinal = observacao || item.observacao || getItemDescricaoRdo(item) || "";
  const observacaoHtmlFinal = observacaoHtml || item.observacaoHtml || "";
  const categoriaFinal = categoria || getItemCategoria(item) || "";
  const prioridadeFinal = prioridade || getItemPrioridade(item) || "";
  const osReferenciaFinal = osReferencia || "";
  const participantesFinal = participantes;
  const equipeSelecionada = getManutencaoEquipeSelecionada();
  const executadoPorTime = equipeSelecionada
    ? `team:${equipeSelecionada}`
    : item.executadaPor || item.doneBy || item.createdBy || "";

  if (!tituloFinal || !localFinal || !dataFinal) {
    mostrarMensagemManutencao("Preencha tipo, subestação e início da execução.", true);
    return;
  }
  if (!isConcluida && (!categoriaFinal || !prioridadeFinal)) {
    mostrarMensagemManutencao(
      "Preencha tipo, subestação, início da execução, categoria e prioridade.",
      true
    );
    return;
  }
  if (!isConcluida && !equipamentoFinal) {
    mostrarMensagemManutencao("Informe o equipamento da manutenção.", true);
    return;
  }
  if (!isConcluida && !observacaoFinal) {
    mostrarMensagemManutencao("Descreva a demanda técnica.", true);
    return;
  }
  if (!isConcluida && !osReferenciaFinal) {
    mostrarMensagemManutencao("Informe a OS / referência.", true);
    return;
  }
  setFieldError(participantesManutencaoErro, "");
  if (!isConcluida && participantesFinal.length < 2) {
    setFieldError(participantesManutencaoErro, "Informe ao menos 2 participantes.");
    mostrarMensagemManutencao("Informe ao menos 2 participantes.", true);
    return;
  }

  const liberacaoAtual = getLiberacao(item) || {};
  const documentosAtualizados = {
    ...(item.documentos || {}),
    ...((liberacaoAtual && liberacaoAtual.documentos) || {}),
  };

  for (const chave of DOC_KEYS) {
    const input = novaDocInputs.find((itemInput) => itemInput.dataset.novaDocInput === chave);
    const file = input && input.files && input.files[0] ? input.files[0] : null;
    if (file) {
      try {
        documentosAtualizados[chave] = await uploadLiberacaoDoc(file, chave);
      } catch (error) {
        mostrarMensagemManutencao(
          error && error.message ? error.message : "Não foi possível enviar o documento.",
          true
        );
        return;
      }
    }
  }

  const exigirDocs = !isConcluida && item.status !== "agendada" && item.status !== "backlog";
  if (exigirDocs) {
    if (!documentosAtualizados.apr || !documentosAtualizados.os || !documentosAtualizados.pte) {
      mostrarMensagemManutencao("Anexe APR, OS e PTE para manter a execução.", true);
      return;
    }
    if (critico && !documentosAtualizados.pt) {
      mostrarMensagemManutencao("PT obrigatória para trabalho crítico.", true);
      return;
    }
  }

  const liberacaoAtualizada = {
    ...liberacaoAtual,
    osNumero: osReferenciaFinal,
    participantes: participantesFinal,
    critico,
    documentos: documentosAtualizados,
  };

  const manterLiberacao =
    (liberacaoAtual && Object.keys(liberacaoAtual).length > 0) ||
    (item.status !== "agendada" && item.status !== "backlog");

  const registroAtualizado = item.registroExecucao
    ? {
        ...item.registroExecucao,
        comentario: observacaoFinal,
        executadoPor: executadoPorTime || item.registroExecucao.executadoPor,
      }
    : item.registroExecucao;
  const conclusaoAtualizada = item.conclusao
    ? {
        ...item.conclusao,
        comentario: observacaoFinal,
        referencia: osReferenciaFinal || item.conclusao.referencia,
        osNumero: osReferenciaFinal || item.conclusao.osNumero,
        participantes: participantesFinal.length
          ? participantesFinal
          : item.conclusao.participantes,
        critico: critico,
        categoria: categoriaFinal || item.conclusao.categoria,
        prioridade: prioridadeFinal || item.conclusao.prioridade,
        equipamentoId: equipamentoFinal || item.conclusao.equipamentoId,
      }
    : item.conclusao;

  const atualizado = {
    ...item,
    titulo: tituloFinal,
    local: localFinal,
    data: dataFinal,
    equipamentoId: equipamentoFinal,
    observacao: observacaoFinal,
    observacaoHtml: observacaoHtmlFinal,
    templateId: templateFinal,
    categoria: categoriaFinal,
    prioridade: prioridadeFinal,
    osReferencia: osReferenciaFinal,
    participantes: participantesFinal,
    executadaPor: executadoPorTime || item.executadaPor,
    criticidade: critico ? "sim" : "nao",
    documentos: documentosAtualizados,
    liberacao: manterLiberacao ? liberacaoAtualizada : item.liberacao,
    registroExecucao: registroAtualizado,
    conclusao: conclusaoAtualizada,
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser.id,
  };

  manutencoes[index] = atualizado;
  const resultado = normalizarManutencoes(manutencoes);
  manutencoes = resultado.normalizadas;
  salvarManutencoes(manutencoes);
  logAction("edit", atualizado, { resumo: "Edição via painel" });
  renderTudo();
  showTeamMaintenanceNotifications();
  limparEdicaoManutencao();
  mostrarMensagemManutencao("Manutenção atualizada.");
}

function normalizeUserLookup(value) {
  return normalizeSearchValue(value)
    .replace(/\(.*?\)/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function findOperationalUserByInput(value) {
  const normalizado = normalizeUserLookup(value);
  if (!normalizado) {
    return null;
  }
  const byId = getUserById(value);
  if (byId && isRealUser(byId)) {
    return byId;
  }
  return (
    getOperationalUsers().find((user) => {
      const nome = normalizeUserLookup(user.name || "");
      const matricula = normalizeUserLookup(user.matricula || "");
      const username = normalizeUserLookup(user.username || "");
      return (
        normalizado === nome || normalizado === matricula || normalizado === username
      );
    }) || null
  );
}

function resolveExecutadoPorInput(valor, fallbackId = "") {
  const entrada = String(valor || "").trim();
  if (!entrada) {
    return fallbackId;
  }
  if (isTeamUserId(entrada)) {
    const nomeTime = entrada.split(":").slice(1).join(":");
    const normalizado = normalizeUserLookup(nomeTime);
    if (normalizado.includes("sistema") || normalizado.includes("admin")) {
      return "";
    }
    return entrada;
  }
  const normalizado = normalizeUserLookup(entrada);
  if (normalizado.includes("sistema") || normalizado.includes("admin")) {
    return "";
  }
  const user = findOperationalUserByInput(entrada);
  if (user) {
    return user.id;
  }
  return entrada ? `team:${entrada}` : fallbackId;
}

function resolveParticipantesInput(valor) {
  const tokens = String(valor || "")
    .split(";")
    .map((item) => item.trim())
    .filter(Boolean);
  if (!tokens.length) {
    return [];
  }
  const resolved = tokens
    .map((token) => {
      const normalizado = normalizeUserLookup(token);
      if (!normalizado || normalizado.includes("sistema") || normalizado.includes("admin")) {
        return "";
      }
      if (isTeamUserId(token)) {
        const nomeTime = token.split(":").slice(1).join(":");
        const timeNormalizado = normalizeUserLookup(nomeTime);
        if (timeNormalizado.includes("sistema") || timeNormalizado.includes("admin")) {
          return "";
        }
        return token;
      }
      const user = findOperationalUserByInput(token);
      if (user) {
        return user.id;
      }
      return token;
    })
    .filter(Boolean);
  return Array.from(new Set(resolved));
}

function normalizeResultadoInput(valor) {
  const normalizado = normalizeSearchValue(valor).replace(/\s+/g, " ").trim();
  if (!normalizado) {
    return "";
  }
  if (normalizado === "concluida") {
    return "concluida";
  }
  if (normalizado.includes("ressalva")) {
    return "ressalva";
  }
  if (normalizado.includes("nao executada") || normalizado.includes("nao_executada")) {
    return "nao_executada";
  }
  return "";
}

function parseDateTimeInputFlexible(valor) {
  if (!valor) {
    return null;
  }
  const ajustado = String(valor).trim().replace(" ", "T");
  return parseDateTimeInput(ajustado);
}

async function editarManutencao(index) {
  if (!requirePermission("edit")) {
    return;
  }
  const item = manutencoes[index];
  if (!item) {
    return;
  }
  if (item.status === "concluida" && !canEditConcludedMaintenance(currentUser)) {
    mostrarMensagemManutencao("Sem permiss\u00e3o para editar manutencoes concluidas.", true);
    return;
  }
  await abrirEdicaoManutencao(item);
}


function editarManutencaoConcluida(index) {
  const item = manutencoes[index];
  if (!item) {
    return;
  }
  const liberacao = getLiberacao(item) || {};
  const registro = item.registroExecucao || {};
  const conclusao = item.conclusao || {};

  const novoTitulo = window.prompt("Título da manutenção:", item.titulo || "");
  if (novoTitulo === null) {
    return;
  }
  const tituloLimpo = novoTitulo.trim();
  if (!tituloLimpo) {
    mostrarMensagemManutencao("Título inválido.", true);
    return;
  }

  const novoLocal = window.prompt("Local/Subestação:", item.local || "");
  if (novoLocal === null) {
    return;
  }
  const localLimpo = novoLocal.trim();
  if (!localLimpo) {
    mostrarMensagemManutencao("Local inválido.", true);
    return;
  }

  const novaObs = window.prompt("Observações:", item.observacao || "");
  if (novaObs === null) {
    return;
  }

  const dataAtual = item.data ? formatDateISO(parseDate(item.data)) : "";
  const novaDataInput = window.prompt(
    "Data programada (AAAA-MM-DD). Deixe vazio para manter:",
    dataAtual
  );
  if (novaDataInput === null) {
    return;
  }
  let dataFinal = item.data || "";
  if (novaDataInput.trim()) {
    const parsed = parseDate(novaDataInput.trim());
    if (!parsed) {
      mostrarMensagemManutencao("Data inválida.", true);
      return;
    }
    dataFinal = formatDateISO(parsed);
  }

  const categoriaInput = window.prompt("Categoria:", item.categoria || "");
  if (categoriaInput === null) {
    return;
  }
  const prioridadeInput = window.prompt("Prioridade:", item.prioridade || "");
  if (prioridadeInput === null) {
    return;
  }
  const categoriaFinal = categoriaInput.trim() || item.categoria || "";
  const prioridadeFinal = prioridadeInput.trim() || item.prioridade || "";

  const executadoPorAtual = getExecutadoPorId(item);
  const executadoPorLabel = executadoPorAtual ? getUserLabel(executadoPorAtual) : "";
  const executadoPorInput = window.prompt(
    "Executada por (matrícula, nome ou time:Nome). Deixe vazio para manter:",
    executadoPorLabel
  );
  if (executadoPorInput === null) {
    return;
  }
  const executadoPorFinal = resolveExecutadoPorInput(executadoPorInput, executadoPorAtual);
  if (!executadoPorFinal) {
    mostrarMensagemManutencao("Executada por inválida.", true);
    return;
  }

  const resultadoAtual = conclusao.resultado || registro.resultado || "";
  const resultadoInput = window.prompt(
    "Resultado (concluida, ressalva, nao_executada). Deixe vazio para manter:",
    resultadoAtual
  );
  if (resultadoInput === null) {
    return;
  }
  const resultadoNormalizado = normalizeResultadoInput(resultadoInput);
  const resultadoFinal = resultadoNormalizado || resultadoAtual;
  if (!resultadoFinal) {
    mostrarMensagemManutencao("Resultado inválido.", true);
    return;
  }

  const comentarioAtual = registro.comentario || conclusao.comentario || "";
  const comentarioInput = window.prompt(
    "Descrição técnica (registro de execução):",
    comentarioAtual
  );
  if (comentarioInput === null) {
    return;
  }
  const comentarioFinal = normalizeResumoRdoTexto(comentarioInput);
  const comentarioMsg = getMensagemResumoRdo(comentarioFinal);
  if (comentarioMsg) {
    mostrarMensagemManutencao(comentarioMsg, true);
    return;
  }

  const obsExecucaoAtual = registro.observacaoExecucao || conclusao.observacaoExecucao || "";
  const obsExecucaoInput = window.prompt(
    "Observação de execução (opcional):",
    obsExecucaoAtual
  );
  if (obsExecucaoInput === null) {
    return;
  }
  const obsExecucaoFinal = obsExecucaoInput.trim();

  const referenciaAtual = conclusao.referencia || liberacao.osNumero || "";
  const referenciaInput = window.prompt("Nº OS / referência:", referenciaAtual);
  if (referenciaInput === null) {
    return;
  }
  const referenciaFinal = referenciaInput.trim() || referenciaAtual;
  if (!referenciaFinal) {
    mostrarMensagemManutencao("Nº OS / referência obrigatório.", true);
    return;
  }

  const participantesAtual = Array.isArray(liberacao.participantes)
    ? liberacao.participantes
        .map((id) => (getUserById(id) ? getUserLabel(id) : id))
        .join("; ")
    : "";
  const participantesInput = window.prompt(
    "Participantes (separe por ;). Deixe vazio para manter:",
    participantesAtual
  );
  if (participantesInput === null) {
    return;
  }
  let participantesFinal = Array.isArray(liberacao.participantes)
    ? liberacao.participantes
    : [];
  if (participantesInput.trim()) {
    participantesFinal = resolveParticipantesInput(participantesInput);
    if (!participantesFinal.length) {
      mostrarMensagemManutencao("Participantes inválidos.", true);
      return;
    }
  }

  const inicioAtual = getItemInicioExecucaoDate(item);
  const fimAtual = getItemFimExecucaoDate(item) || getItemConclusaoDate(item);
  const inicioInput = window.prompt(
    "Início da execução (AAAA-MM-DDTHH:MM). Deixe vazio para manter:",
    inicioAtual ? formatDateTimeInput(inicioAtual) : ""
  );
  if (inicioInput === null) {
    return;
  }
  let inicioFinal = inicioAtual;
  if (inicioInput.trim()) {
    const parsed = parseDateTimeInputFlexible(inicioInput);
    if (!parsed) {
      mostrarMensagemManutencao("Início inválido.", true);
      return;
    }
    inicioFinal = parsed;
  }

  const fimInput = window.prompt(
    "Fim da execução (AAAA-MM-DDTHH:MM). Deixe vazio para manter:",
    fimAtual ? formatDateTimeInput(fimAtual) : ""
  );
  if (fimInput === null) {
    return;
  }
  let fimFinal = fimAtual;
  if (fimInput.trim()) {
    const parsed = parseDateTimeInputFlexible(fimInput);
    if (!parsed) {
      mostrarMensagemManutencao("Fim inválido.", true);
      return;
    }
    fimFinal = parsed;
  }
  if (inicioFinal && fimFinal && fimFinal < inicioFinal) {
    mostrarMensagemManutencao("Fim deve ser maior ou igual ao início.", true);
    return;
  }

  const inicioIso =
    (inicioFinal ? toIsoUtc(inicioFinal) : "") ||
    item.executionStartedAt ||
    conclusao.inicio ||
    "";
  const fimIso =
    (fimFinal ? toIsoUtc(fimFinal) : "") ||
    item.executionFinishedAt ||
    item.doneAt ||
    conclusao.fim ||
    "";
  const duracaoMin =
    inicioFinal && fimFinal
      ? Math.max(0, Math.round((fimFinal.getTime() - inicioFinal.getTime()) / 60000))
      : Number.isFinite(conclusao.duracaoMin)
        ? conclusao.duracaoMin
        : null;

  const registroAtualizado = {
    ...registro,
    executadoPor: executadoPorFinal,
    comentario: comentarioFinal,
    observacaoExecucao: obsExecucaoFinal,
    resultado: resultadoFinal,
  };

  const conclusaoAtualizada = {
    ...conclusao,
    executadoPor: executadoPorFinal,
    comentario: comentarioFinal,
    observacaoExecucao: obsExecucaoFinal,
    resultado: resultadoFinal,
    referencia: referenciaFinal,
    inicio: inicioIso || conclusao.inicio || item.executionStartedAt || "",
    fim: fimIso || conclusao.fim || item.executionFinishedAt || item.doneAt || "",
    duracaoMin: Number.isFinite(duracaoMin) ? duracaoMin : conclusao.duracaoMin,
  };

  const liberacaoAtualizada = {
    ...liberacao,
    osNumero: referenciaFinal,
    participantes: participantesFinal,
  };

  const atualizado = {
    ...item,
    titulo: tituloLimpo,
    local: localLimpo,
    observacao: novaObs.trim(),
    observacaoHtml: "",
    data: dataFinal,
    categoria: categoriaFinal,
    prioridade: prioridadeFinal,
    registroExecucao: registroAtualizado,
    liberacao: liberacaoAtualizada,
    conclusao: conclusaoAtualizada,
    executionStartedAt: inicioIso || item.executionStartedAt || conclusao.inicio || "",
    executionFinishedAt: fimIso || item.executionFinishedAt || item.doneAt || conclusao.fim || "",
    doneAt: fimIso || item.doneAt || item.executionFinishedAt || conclusao.fim || "",
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser.id,
  };

  manutencoes[index] = atualizado;
  const resultado = normalizarManutencoes(manutencoes);
  manutencoes = resultado.normalizadas;
  salvarManutencoes(manutencoes);
  logAction("edit", atualizado, { resumo: "Edição após conclusão" });
  renderTudo();
  mostrarMensagemManutencao("Manutenção concluída atualizada.");
}

function registrarObservacao(index) {
  if (!requirePermission("edit")) {
    return;
  }
  const item = manutencoes[index];
  const novaObs = window.prompt("Observação técnica:", item.observacao || "");
  if (novaObs === null) {
    return;
  }
  const obsLimpa = novaObs.trim();
  if (!obsLimpa) {
    mostrarMensagemManutencao("Observação vazia.", true);
    return;
  }

  const atualizado = {
    ...item,
    observacao: obsLimpa,
    observacaoHtml: "",
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser.id,
  };

  manutencoes[index] = atualizado;
  const resultado = normalizarManutencoes(manutencoes);
  manutencoes = resultado.normalizadas;
  salvarManutencoes(manutencoes);
  logAction("note", atualizado, { resumo: "Observação registrada" });
  renderTudo();
  mostrarMensagemManutencao("Observação registrada.");
}

function registrarMotivoBacklog(index) {
  if (!requirePermission("edit")) {
    return;
  }
  const item = manutencoes[index];
  if (!item || item.status !== "backlog") {
    mostrarMensagemManutencao("Somente itens em backlog aceitam motivo.", true);
    return;
  }
  abrirBacklogMotivo(item);
}

function abrirBacklogMotivo(item) {
  if (!modalBacklogMotivo || !formBacklogMotivo) {
    return;
  }
  manutencaoEmBacklogMotivo = item.id;
  mostrarMensagemBacklogMotivo("");
  if (backlogMotivoId) {
    backlogMotivoId.value = item.id;
  }
  if (backlogMotivoSelect) {
    backlogMotivoSelect.value =
      item.backlogMotivo && item.backlogMotivo.motivo ? item.backlogMotivo.motivo : "";
  }
  if (backlogMotivoObs) {
    backlogMotivoObs.value =
      item.backlogMotivo && item.backlogMotivo.observacao ? item.backlogMotivo.observacao : "";
  }
  modalBacklogMotivo.hidden = false;
}

function fecharBacklogMotivo() {
  if (!modalBacklogMotivo) {
    return;
  }
  modalBacklogMotivo.hidden = true;
  manutencaoEmBacklogMotivo = null;
  mostrarMensagemBacklogMotivo("");
}

function salvarBacklogMotivo(event) {
  event.preventDefault();
  if (!requirePermission("edit")) {
    return;
  }
  if (!manutencaoEmBacklogMotivo || !backlogMotivoSelect) {
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === manutencaoEmBacklogMotivo);
  if (index < 0) {
    mostrarMensagemBacklogMotivo("Manutenção não encontrada.", true);
    return;
  }
  const item = manutencoes[index];
  if (item.status !== "backlog") {
    mostrarMensagemBacklogMotivo("Somente itens em backlog aceitam motivo.", true);
    return;
  }
  const motivo = backlogMotivoSelect.value.trim();
  if (!motivo) {
    mostrarMensagemBacklogMotivo("Selecione o motivo.", true);
    return;
  }
  const observacao = backlogMotivoObs ? backlogMotivoObs.value.trim() : "";
  if (motivo === "Outros" && !observacao) {
    mostrarMensagemBacklogMotivo("Informe a observação para o motivo Outros.", true);
    return;
  }

  const registro = {
    motivo,
    observacao,
    registradoEm: toIsoUtc(new Date()),
    registradoPor: currentUser ? currentUser.id : SYSTEM_USER_ID,
  };
  const atualizado = {
    ...item,
    backlogMotivo: registro,
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser ? currentUser.id : SYSTEM_USER_ID,
  };

  manutencoes[index] = atualizado;
  const resultado = normalizarManutencoes(manutencoes);
  manutencoes = resultado.normalizadas;
  salvarManutencoes(manutencoes);
  logAction("backlog_reason", atualizado, {
    motivo,
    observacao,
    resumo: "Motivo registrado.",
  });
  renderTudo();
  fecharBacklogMotivo();
  mostrarMensagemManutencao("Motivo registrado.");
}

function collectDrawerPermissions() {
  const permissions = {};
  if (!drawerPermissions) {
    return permissions;
  }
  drawerPermissions.querySelectorAll("input[data-permission-key]").forEach((input) => {
    permissions[input.dataset.permissionKey] = input.checked;
  });
  return permissions;
}

function renderDrawerPermissions(user, overridePermissions = null) {
  if (!drawerPermissions) {
    return;
  }
  drawerPermissions.innerHTML = "";
  if (!adminPermissionCatalog.length) {
    const aviso = document.createElement("p");
    aviso.className = "hint";
    aviso.textContent = "Catálogo de permissões indisponível.";
    drawerPermissions.append(aviso);
    return;
  }
  const roleValue = drawerRole ? drawerRole.value : "";
  const resolvedRole =
    roleValue ||
    user.rbacRole ||
    (user.role === "admin" ? "pcm" : user.role === "supervisor" ? "supervisor_om" : "");
  const isFullAccess = FULL_ACCESS_RBAC.has(String(resolvedRole || "").toLowerCase());
  const permissaoEdicao = Boolean(currentUser && canEditProfile(currentUser, user));
  const basePermissions = overridePermissions || user.permissions || {};

  adminPermissionCatalog.forEach((grupo) => {
    const bloco = document.createElement("div");
    bloco.className = "perm-group";
    const titulo = document.createElement("strong");
    titulo.textContent = grupo.label || "Módulo";
    const grid = document.createElement("div");
    grid.className = "perm-grid";

    (grupo.permissions || []).forEach((perm) => {
      const item = document.createElement("label");
      item.className = "perm-item";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.dataset.permissionKey = perm.key;
      checkbox.checked = isFullAccess ? true : Boolean(basePermissions[perm.key]);
      checkbox.disabled = !permissaoEdicao || isFullAccess;
      const texto = document.createElement("span");
      texto.textContent = perm.label || perm.key;
      item.append(checkbox, texto);
      grid.append(item);
    });

    bloco.append(titulo, grid);
    drawerPermissions.append(bloco);
  });
}

function mostrarMensagemDrawer(texto, erro = false) {
  if (!drawerMessage) {
    return;
  }
  drawerMessage.textContent = texto;
  drawerMessage.classList.toggle("mensagem--erro", erro);
}

function abrirUserDrawer(userId) {
  if (!canAdminUsersRead()) {
    mostrarMensagemGerencial("Sem permissão para visualizar usuários.", true);
    return;
  }
  const user = users.find((item) => item.id === userId);
  if (!user || !userDrawer) {
    return;
  }
  const legacyToRbac = {
    admin: "pcm",
    supervisor: "supervisor_om",
    executor: "tecnico_junior",
    leitura: "leitura",
  };
  const rbacRole = user.rbacRole || legacyToRbac[user.role] || "tecnico_junior";

  if (drawerUserId) {
    drawerUserId.value = user.id;
  }
  if (drawerNome) {
    drawerNome.value = user.name || "";
  }
  if (drawerCargo) {
    const cargoAtual = user.cargo || "";
    const temCargo = Array.from(drawerCargo.options).some((opt) => opt.value === cargoAtual);
    if (cargoAtual && !temCargo) {
      const extra = document.createElement("option");
      extra.value = cargoAtual;
      extra.textContent = cargoAtual;
      drawerCargo.append(extra);
    }
    drawerCargo.value = cargoAtual;
  }
  if (drawerRole) {
    drawerRole.value = rbacRole;
  }
  if (drawerProjeto) {
    renderProjectSelectOptions(drawerProjeto, user.projectId || "");
  }
  if (drawerActive) {
    drawerActive.checked = user.active !== false;
  }
  const podeEditarPerfil = Boolean(currentUser && canEditProfile(currentUser, user));
  const podeDesativar = Boolean(currentUser && canDesativarUsuarios(currentUser));
  const podeSalvar = podeEditarPerfil || podeDesativar;

  [drawerNome, drawerCargo, drawerRole, drawerProjeto].forEach((campo) => {
    if (campo) {
      campo.disabled = !podeEditarPerfil;
    }
  });
  if (drawerActive) {
    drawerActive.disabled = !podeDesativar;
  }
  if (drawerSubtitle) {
    const perfil = getRoleLabel(user);
    drawerSubtitle.textContent = `Matrícula: ${user.matricula || "-"} | Perfil: ${perfil}`;
  }
  if (btnSalvarUserDrawer) {
    btnSalvarUserDrawer.disabled = !podeSalvar;
  }
  renderDrawerPermissions(user);
  if (!podeSalvar) {
    mostrarMensagemDrawer("Sem permissão para alterar este perfil.", true);
  } else if (!podeEditarPerfil && podeDesativar) {
    mostrarMensagemDrawer("Edição bloqueada. Apenas ativação/desativação disponível.", true);
  } else {
    mostrarMensagemDrawer("");
  }
  userDrawer.hidden = false;
}

function fecharUserDrawer() {
  if (!userDrawer) {
    return;
  }
  userDrawer.hidden = true;
  mostrarMensagemDrawer("");
}

async function salvarUserDrawer(event) {
  event.preventDefault();
  const userId = drawerUserId ? drawerUserId.value : "";
  const user = users.find((item) => item.id === userId);
  if (!user) {
    mostrarMensagemDrawer("Usuário não encontrado.", true);
    return;
  }
  const podeEditarPerfil = Boolean(currentUser && canEditProfile(currentUser, user));
  const podeDesativar = Boolean(currentUser && canDesativarUsuarios(currentUser));
  if (!podeEditarPerfil && !podeDesativar) {
    mostrarMensagemDrawer("Sem permissão para salvar alterações.", true);
    return;
  }
  const payload = {};
  if (podeEditarPerfil) {
    const nome = drawerNome ? drawerNome.value.trim() : "";
    if (!nome) {
      mostrarMensagemDrawer("Informe o nome do colaborador.", true);
      return;
    }
    const cargo = drawerCargo ? drawerCargo.value.trim() : "";
    const rbacRole = drawerRole ? drawerRole.value : user.rbacRole;
    const projetoId = drawerProjeto ? drawerProjeto.value.trim() : "";
    const permissions = collectDrawerPermissions();
    payload.name = nome;
    payload.cargo = cargo;
    payload.rbacRole = rbacRole;
    payload.projectId = projetoId;
    payload.permissions = permissions;
  }
  if (podeDesativar) {
    payload.active = drawerActive ? drawerActive.checked : true;
  }
  if (!Object.keys(payload).length) {
    mostrarMensagemDrawer("Nenhuma alteração permitida.", true);
    return;
  }
  try {
    const data = await apiAdminUpdateUser(userId, payload);
    const atualizado = data.user || null;
    if (atualizado) {
      users = users.map((item) => (item.id === atualizado.id ? atualizado : item));
      if (currentUser && currentUser.id === atualizado.id) {
        currentUser = atualizado;
        renderAuthUI();
      }
      renderUsuarios();
    }
    mostrarMensagemDrawer("Perfil atualizado.");
  } catch (error) {
    mostrarMensagemDrawer("Não foi possível salvar. Tente novamente.", true);
  }
}
function executarManutencao(index) {
  if (!requirePermission("complete")) {
    return;
  }
  const item = manutencoes[index];
  if (item.status === "backlog") {
    mostrarMensagemManutencao("Manutenção em backlog. Registre o motivo.", true);
    return;
  }
  if (!isLiberacaoOk(item)) {
    abrirLiberacao(item);
    return;
  }
  abrirInicioExecucao(item);
}

function abrirInicioExecucao(item) {
  if (!modalInicioExecucao || !inicioExecucaoId) {
    return;
  }
  if (!item) {
    return;
  }
  if (item.status === "concluida") {
    mostrarMensagemManutencao("Manutenção concluída. Apenas leitura.", true);
    return;
  }
  if (item.status === "backlog") {
    mostrarMensagemManutencao("Manutenção em backlog. Registre o motivo.", true);
    return;
  }
  if (item.status === "em_execucao") {
    mostrarMensagemManutencao("Manutenção já está em execução.", true);
    return;
  }
  if (item.status === "encerramento") {
    mostrarMensagemManutencao("Encerramento em andamento. Apenas leitura.", true);
    return;
  }
  if (!isLiberacaoOk(item)) {
    mostrarMensagemManutencao("Liberação incompleta. Preencha os requisitos.", true);
    return;
  }
  inicioExecucaoId.value = item.id;
  mostrarMensagemInicioExecucao("");
  modalInicioExecucao.hidden = false;
}

function fecharInicioExecucao() {
  if (!modalInicioExecucao) {
    return;
  }
  modalInicioExecucao.hidden = true;
  if (inicioExecucaoId) {
    inicioExecucaoId.value = "";
  }
}

function confirmarInicioExecucao() {
  if (!requirePermission("complete")) {
    return;
  }
  if (!inicioExecucaoId || !inicioExecucaoId.value) {
    mostrarMensagemInicioExecucao("Selecione uma manutenção.", true);
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === inicioExecucaoId.value);
  if (index < 0) {
    mostrarMensagemInicioExecucao("Manutenção não encontrada.", true);
    return;
  }
  const item = manutencoes[index];
  if (item.status === "concluida") {
    mostrarMensagemInicioExecucao("Manutenção concluída. Apenas leitura.", true);
    return;
  }
  if (item.status === "em_execucao") {
    mostrarMensagemInicioExecucao("Manutenção já está em execução.", true);
    return;
  }
  if (item.status === "encerramento") {
    mostrarMensagemInicioExecucao("Encerramento em andamento. Apenas leitura.", true);
    return;
  }
  if (!isLiberacaoOk(item)) {
    mostrarMensagemInicioExecucao("Liberação incompleta. Preencha os requisitos.", true);
    return;
  }
  const inicioIso = toIsoUtc(new Date());
  const atualizado = {
    ...item,
    status: "em_execucao",
    executionStartedAt: inicioIso,
    executionStartedBy: currentUser.id,
    updatedAt: inicioIso,
    updatedBy: currentUser.id,
  };
  manutencoes[index] = atualizado;
  salvarManutencoes(manutencoes);
  scheduleMaintenanceSync(manutencoes, true);
  const liberacao = getLiberacao(item) || {};
  const documentosLista = DOC_KEYS.filter((key) => liberacao.documentos && liberacao.documentos[key]).map(
    (key) => DOC_LABELS[key] || key
  );
  logAction("execute", atualizado, {
    dataProgramada: item.data || "",
    inicioExecucao: inicioIso,
    osNumero: liberacao.osNumero || "",
    participantes: liberacao.participantes || [],
    critico: liberacao.critico,
    documentos: documentosLista,
    resumo: "Execução iniciada.",
  });
  renderTudo();
  fecharInicioExecucao();
  mostrarMensagemManutencao("Execução iniciada.");
}

function abrirRegistroExecucao(item) {
  if (!requirePermission("complete")) {
    return;
  }
  if (!modalRegistroExecucao || !formRegistroExecucao) {
    return;
  }
  if (!item || (item.status !== "em_execucao" && item.status !== "encerramento")) {
    mostrarMensagemManutencao("Inicie a execução antes de registrar.", true);
    return;
  }
  const inicio = parseTimestamp(item.executionStartedAt);
  if (!inicio) {
    mostrarMensagemManutencao("Início da execução não encontrado.", true);
    return;
  }
  manutencaoEmRegistro = item.id;
  mostrarMensagemRegistroExecucao("");
  mostrarMensagemCancelarExecucao("");
  if (registroResumo) {
    registroResumo.textContent = buildManutencaoResumoTexto(item);
  }
  if (formRegistroExecucao) {
    formRegistroExecucao.hidden = false;
  }
  if (formCancelarExecucao) {
    formCancelarExecucao.hidden = true;
  }
  if (cancelarExecucaoMotivo) {
    cancelarExecucaoMotivo.value = "";
    cancelarExecucaoMotivo.required = false;
  }
  if (btnCancelarExecucao) {
    btnCancelarExecucao.hidden = item.status !== "em_execucao";
  }
  if (registroId) {
    registroId.value = item.id;
  }
  if (registroTipo) {
    registroTipo.value = item.titulo || "";
  }
  if (registroSubestacao) {
    registroSubestacao.value = item.local || "";
  }
  if (registroCodigo) {
    registroCodigo.value = item.id;
  }
  if (registroAbertaPor) {
    registroAbertaPor.value = getUserLabel(item.createdBy);
  }
  if (registroAbertaEm) {
    const createdAt = parseTimestamp(item.createdAt);
    registroAbertaEm.value = createdAt ? formatDateTime(createdAt) : "-";
  }
  if (registroInicio) {
    registroInicio.value = formatDateTime(inicio);
  }
  const liberacao = getLiberacao(item) || {};
  if (registroOsNumero) {
    registroOsNumero.value = liberacao.osNumero || "-";
  }
  if (registroParticipantes) {
    registroParticipantes.value = getParticipantesLabel(liberacao.participantes);
  }
  if (registroDocs) {
    const docs = liberacao.documentos || item.documentos || {};
    renderDocList(registroDocs, docs, isItemCritico(item));
  }
  const registroSalvo = item.registroExecucao || {};
  if (registroExecutadaPor) {
    registroExecutadaPor.innerHTML = "";
    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.textContent = "Selecione";
    registroExecutadaPor.append(placeholder);
    const teamName = getProjectTeamName(item.projectId);
    const teamValue = teamName ? `team:${teamName}` : "";
    if (teamName) {
      const teamOption = document.createElement("option");
      teamOption.value = teamValue;
      teamOption.textContent = teamName;
      registroExecutadaPor.append(teamOption);
    }
    getOperationalUsers()
      .sort((a, b) => (a.name || "").localeCompare(b.name || "", "pt-BR"))
      .forEach((user) => {
        const option = document.createElement("option");
        option.value = user.id;
        option.textContent = user.name || user.matricula;
        registroExecutadaPor.append(option);
      });
    const defaultId =
      registroSalvo.executadoPor || teamValue || (currentUser ? currentUser.id : "");
    if (defaultId) {
      registroExecutadaPor.value = defaultId;
    }
  }
  if (registroResultado) {
    const resultadoField = registroResultado.closest(".field");
    const mostrarResultado =
      item.status !== "em_execucao" || Boolean(registroSalvo.resultado);
    if (resultadoField) {
      resultadoField.hidden = !mostrarResultado;
    }
    registroResultado.required = mostrarResultado;
    registroResultado.value = registroSalvo.resultado || "";
  }
  if (registroComentario) {
    registroComentario.value = registroSalvo.comentario || "";
  }
  if (registroObsExecucao) {
    registroObsExecucao.value = registroSalvo.observacaoExecucao || "";
  }
  modalRegistroExecucao.hidden = false;
}

function fecharRegistroExecucao() {
  if (!modalRegistroExecucao) {
    return;
  }
  modalRegistroExecucao.hidden = true;
  manutencaoEmRegistro = null;
  if (formRegistroExecucao) {
    formRegistroExecucao.hidden = false;
  }
  if (formCancelarExecucao) {
    formCancelarExecucao.hidden = true;
  }
  if (cancelarExecucaoMotivo) {
    cancelarExecucaoMotivo.value = "";
    cancelarExecucaoMotivo.required = false;
  }
  mostrarMensagemCancelarExecucao("");
}

function abrirCancelarExecucao() {
  if (!formRegistroExecucao || !formCancelarExecucao) {
    return;
  }
  if (!manutencaoEmRegistro) {
    mostrarMensagemRegistroExecucao("Selecione uma manutenção.", true);
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === manutencaoEmRegistro);
  if (index < 0) {
    mostrarMensagemRegistroExecucao("Manutenção não encontrada.", true);
    return;
  }
  const item = manutencoes[index];
  if (item.status !== "em_execucao") {
    mostrarMensagemRegistroExecucao("A manutenção precisa estar em execução.", true);
    return;
  }
  formRegistroExecucao.hidden = true;
  formCancelarExecucao.hidden = false;
  if (cancelarExecucaoMotivo) {
    cancelarExecucaoMotivo.value = "";
    cancelarExecucaoMotivo.required = true;
  }
  mostrarMensagemCancelarExecucao("");
}

function fecharCancelarExecucao() {
  if (!formRegistroExecucao || !formCancelarExecucao) {
    return;
  }
  formCancelarExecucao.hidden = true;
  formRegistroExecucao.hidden = false;
  if (cancelarExecucaoMotivo) {
    cancelarExecucaoMotivo.value = "";
    cancelarExecucaoMotivo.required = false;
  }
  mostrarMensagemCancelarExecucao("");
}

function salvarCancelamentoExecucao(event) {
  event.preventDefault();
  if (!requirePermission("complete")) {
    return;
  }
  if (!manutencaoEmRegistro) {
    mostrarMensagemCancelarExecucao("Selecione uma manutenção.", true);
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === manutencaoEmRegistro);
  if (index < 0) {
    mostrarMensagemCancelarExecucao("Manutenção não encontrada.", true);
    return;
  }
  const item = manutencoes[index];
  if (item.status !== "em_execucao") {
    mostrarMensagemCancelarExecucao("A manutenção precisa estar em execução.", true);
    return;
  }
  const motivo = cancelarExecucaoMotivo ? cancelarExecucaoMotivo.value.trim() : "";
  if (!motivo) {
    mostrarMensagemCancelarExecucao("Informe o motivo do cancelamento.", true);
    return;
  }
  const registroExecucao = {
    ...(item.registroExecucao || {}),
    motivoCancelamento: motivo,
    canceladoPor: currentUser.id,
    canceladoEm: Date.now(),
  };
  const atualizado = {
    ...item,
    registroExecucao,
    status: "CANCELADA",
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser.id,
  };
  manutencoes[index] = atualizado;
  salvarManutencoes(manutencoes);
  renderTudo();
  fecharRegistroExecucao();
  mostrarMensagemManutencao("Execução cancelada.");
}

function salvarRegistroExecucao(event) {
  event.preventDefault();
  if (!requirePermission("complete")) {
    return;
  }
  if (!manutencaoEmRegistro) {
    mostrarMensagemRegistroExecucao("Selecione uma manutenção.", true);
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === manutencaoEmRegistro);
  if (index < 0) {
    mostrarMensagemRegistroExecucao("Manutenção não encontrada.", true);
    return;
  }
  const item = manutencoes[index];
  if (item.status !== "em_execucao" && item.status !== "encerramento") {
    mostrarMensagemRegistroExecucao("Inicie a execução antes de registrar.", true);
    return;
  }
  if (!item.executionStartedAt) {
    mostrarMensagemRegistroExecucao("Início da execução não encontrado.", true);
    return;
  }
  const executadoPor = registroExecutadaPor ? registroExecutadaPor.value : "";
  if (!executadoPor) {
    mostrarMensagemRegistroExecucao("Selecione quem executou.", true);
    return;
  }
  const registroSalvo = item.registroExecucao || {};
  const resultadoField = registroResultado ? registroResultado.closest(".field") : null;
  const resultadoVisivel = !resultadoField || !resultadoField.hidden;
  const resultadoInformado = registroResultado ? registroResultado.value : "";
  if (resultadoVisivel && !resultadoInformado) {
    mostrarMensagemRegistroExecucao("Informe o resultado da execução.", true);
    return;
  }
  const resultadoFinal = resultadoInformado || registroSalvo.resultado || "";
  const comentarioRaw = registroComentario ? registroComentario.value : "";
  const comentario = normalizeResumoRdoTexto(comentarioRaw);
  const comentarioMsg = getMensagemResumoRdo(comentario);
  if (comentarioMsg) {
    mostrarMensagemRegistroExecucao(comentarioMsg, true);
    return;
  }
  const observacaoExecucao = registroObsExecucao ? registroObsExecucao.value.trim() : "";
  const registroExecucao = {
    executadoPor,
    resultado: resultadoFinal,
    comentario,
    observacaoExecucao,
    registradoEm: toIsoUtc(new Date()),
  };
  const novoStatus = resultadoFinal ? "encerramento" : "em_execucao";
  const atualizado = {
    ...item,
    registroExecucao,
    status: novoStatus,
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser.id,
  };
  manutencoes[index] = atualizado;
  salvarManutencoes(manutencoes);
  const liberacao = getLiberacao(item) || {};
  const documentosLista = DOC_KEYS.filter((key) => liberacao.documentos && liberacao.documentos[key]).map(
    (key) => DOC_LABELS[key] || key
  );
  logAction("execute_register", atualizado, {
    executadoPor,
    resultado: resultadoFinal || undefined,
    observacaoExecucao,
    inicioExecucao: item.executionStartedAt || "",
    osNumero: liberacao.osNumero || "",
    participantes: liberacao.participantes || [],
    critico: liberacao.critico,
    documentos: documentosLista,
    resumo: "Registro de execução salvo.",
  });
  renderTudo();
  fecharRegistroExecucao();
  mostrarMensagemManutencao("Registro de execução salvo.");
}

function preencherParticipantesSelect(select, selecionados = []) {
  if (!select) {
    return;
  }
  const selecionadosSet = new Set(selecionados);
  select.innerHTML = "";
  const lista = getOperationalUsers()
    .sort((a, b) => (a.name || "").localeCompare(b.name || "", "pt-BR"));
  if (!lista.length && currentUser) {
    const option = document.createElement("option");
    option.value = currentUser.id;
    option.textContent = currentUser.name || currentUser.matricula;
    option.selected = true;
    select.append(option);
    return;
  }
  lista.forEach((user) => {
    const option = document.createElement("option");
    option.value = user.id;
    option.textContent = user.name || user.matricula;
    option.selected = selecionadosSet.has(user.id);
    select.append(option);
  });
  if (!selecionadosSet.size && currentUser) {
    const option = Array.from(select.options).find((item) => item.value === currentUser.id);
    if (option) {
      option.selected = true;
    }
  }
}

function getLiberacaoDocAtual(chave) {
  return liberacaoDocsPreview[chave] || liberacaoDocsBase[chave] || null;
}

function atualizarLiberacaoDocsUI() {
  DOC_KEYS.forEach((chave) => {
    const nomeEl = liberacaoDocNames.find((item) => item.dataset.docName === chave);
    const viewBtn = liberacaoDocViews.find((item) => item.dataset.docView === chave);
    const doc = getLiberacaoDocAtual(chave);
    if (nomeEl) {
      nomeEl.textContent = doc ? doc.nome || doc.name || "Arquivo" : "Nenhum arquivo";
    }
    if (viewBtn) {
      viewBtn.disabled = !doc;
    }
  });
}

function atualizarNovaDocsUI() {
  if (!novaDocInputs.length) {
    return;
  }
  DOC_KEYS.forEach((chave) => {
    const nomeEl = novaDocNames.find((item) => item.dataset.novaDocName === chave);
    const viewBtn = novaDocViews.find((item) => item.dataset.novaDocView === chave);
    const input = novaDocInputs.find((item) => item.dataset.novaDocInput === chave);
    const file = input && input.files && input.files[0] ? input.files[0] : null;
    const existing = novaDocExisting && novaDocExisting[chave] ? novaDocExisting[chave] : null;
    if (nomeEl) {
      if (file) {
        nomeEl.textContent = file.name;
      } else if (existing) {
        nomeEl.textContent = existing.nome || existing.name || "Arquivo";
      } else {
        nomeEl.textContent = "Nenhum arquivo";
      }
    }
    if (viewBtn) {
      viewBtn.disabled = !file && !existing;
    }
  });
}

function atualizarNovaCriticoUI() {
  const critico = criticoManutencao && criticoManutencao.value === "sim";
  if (novaDocPt) {
    novaDocPt.hidden = !critico;
    novaDocPt.style.display = critico ? "" : "none";
  }
  if (novaPtLabel) {
    novaPtLabel.textContent = critico ? "PT*" : "PT";
  }
  const ptInput = novaDocInputs.find(
    (input) => input && input.dataset.novaDocInput === "pt"
  );
  if (ptInput) {
    ptInput.required = critico;
    ptInput.disabled = !critico;
    if (!critico) {
      ptInput.value = "";
      atualizarNovaDocsUI();
    }
  }
}

function preencherInicioExecucaoNova() {
  if (!dataManutencao) {
    return;
  }
  atualizarDataManutencaoState();
}

function atualizarDataManutencaoState() {
  if (!dataManutencao) {
    return;
  }
  const permitirEdicao = futuraManutencao && futuraManutencao.checked;
  dataManutencao.readOnly = !permitirEdicao;
  if (!permitirEdicao || !dataManutencao.value) {
    dataManutencao.value = formatDateISO(new Date());
  }
}

function atualizarLiberacaoChecklist() {
  if (!liberacaoChecklist) {
    return;
  }
  const osNumero = liberacaoOs ? liberacaoOs.value.trim() : "";
  const participantes = getLiberacaoParticipantesFromForm();
  const equipamentoValor = liberacaoEquipamento ? liberacaoEquipamento.value.trim() : "";
  const criticoSelecionado = liberacaoCritico ? liberacaoCritico.value : "";
  const critico = criticoSelecionado === "sim";
  const docApr = getLiberacaoDocAtual("apr");
  const docOs = getLiberacaoDocAtual("os");
  const docPte = getLiberacaoDocAtual("pte");
  const docPt = getLiberacaoDocAtual("pt");
  const itens = [
    { label: "Trabalho crítico definido", ok: Boolean(criticoSelecionado) },
    { label: "OS / referência", ok: Boolean(osNumero) },
    { label: "Participantes", ok: participantes.length > 0 },
    ...(liberacaoEquipamento
      ? [{ label: "Equipamento", ok: Boolean(equipamentoValor) }]
      : []),
    { label: "APR anexada", ok: Boolean(docApr) },
    { label: "OS anexada", ok: Boolean(docOs) },
    { label: "PTE anexada", ok: Boolean(docPte) },
  ];
  if (critico) {
    itens.push({ label: "PT anexada", ok: Boolean(docPt) });
  }
  liberacaoChecklist.innerHTML = "";
  itens.forEach((item) => {
    const li = document.createElement("li");
    const status = document.createElement("span");
    status.className = item.ok ? "is-ok" : "is-pending";
    status.textContent = item.ok ? "OK" : "Pendente";
    const texto = document.createElement("span");
    texto.textContent = item.label;
    li.append(status, texto);
    liberacaoChecklist.append(li);
  });
  if (liberacaoParticipantesErro) {
    if (!participantes.length) {
      setFieldError(liberacaoParticipantesErro, "Informe ao menos 1 participante.");
    } else if (critico && participantes.length < 2) {
      setFieldError(
        liberacaoParticipantesErro,
        "Para trabalho crítico, informe ao menos 2 participantes."
      );
    } else {
      setFieldError(liberacaoParticipantesErro, "");
    }
  }
}

function atualizarLiberacaoCriticoUI() {
  const critico = liberacaoCritico && liberacaoCritico.value === "sim";
  if (liberacaoDocPt) {
    liberacaoDocPt.hidden = !critico;
    liberacaoDocPt.style.display = critico ? "" : "none";
  }
  const ptInput = liberacaoDocInputs.find(
    (input) => input && input.dataset.docInput === "pt"
  );
  if (ptInput) {
    ptInput.required = critico;
    ptInput.disabled = !critico;
    if (!critico) {
      ptInput.value = "";
      delete liberacaoDocsPreview.pt;
      atualizarLiberacaoDocsUI();
    }
  }
  atualizarLiberacaoChecklist();
}

function abrirLiberacao(item) {
  if (!modalLiberacao || !formLiberacao) {
    return;
  }
  if (!item) {
    return;
  }
  if (item.status === "concluida") {
    mostrarMensagemManutencao("Manutenção concluída. Apenas leitura.", true);
    return;
  }
  if (item.status === "em_execucao" || item.status === "encerramento") {
    mostrarMensagemManutencao("Execução em andamento. Não é possível liberar.", true);
    return;
  }
  manutencaoEmLiberacao = item.id;
  mostrarMensagemLiberacao("");
  const liberacao = getLiberacao(item) || {};
  liberacaoDocsBase = liberacao.documentos ? { ...liberacao.documentos } : {};
  liberacaoDocsPreview = {};
  if (liberacaoId) {
    liberacaoId.value = item.id;
  }
  if (liberacaoOs) {
    liberacaoOs.value = liberacao.osNumero || "";
  }
  if (liberacaoCritico) {
    const criticoValor = liberacao.critico;
    if (criticoValor === undefined || criticoValor === null || criticoValor === "") {
      liberacaoCritico.value = "";
    } else {
      liberacaoCritico.value = isCriticoValor(criticoValor) ? "sim" : "nao";
    }
  }
  const participantesBase = Array.isArray(liberacao.participantes)
    ? liberacao.participantes
    : typeof liberacao.participantes === "string"
      ? liberacao.participantes
          .split(";")
          .map((item) => normalizeParticipantName(item))
          .filter(Boolean)
      : Array.isArray(item.participantes)
        ? item.participantes
        : typeof item.participantes === "string"
          ? item.participantes
              .split(";")
              .map((item) => normalizeParticipantName(item))
              .filter(Boolean)
          : [];
  setLiberacaoParticipantes(participantesBase);
  const equipeBase =
    liberacao.equipeResponsavel ||
    (isTeamUserId(item.executadaPor) ? item.executadaPor : "") ||
    item.responsavel ||
    item.responsavelManutencao ||
    "";
  const equipeSelecionada = isTeamUserId(equipeBase)
    ? normalizeTeamName(equipeBase)
    : equipeBase;
  renderLiberacaoEquipeOptions(equipeSelecionada);
  const equipamentoBase = liberacao.equipamentoId || item.equipamentoId || item.equipamento || "";
  setEquipamentoSelectValue(liberacaoEquipamento, equipamentoBase);
  liberacaoDocInputs.forEach((input) => {
    if (input) {
      input.value = "";
    }
  });
  atualizarLiberacaoDocsUI();
  atualizarLiberacaoCriticoUI();
  modalLiberacao.hidden = false;
}

function fecharLiberacao() {
  if (!modalLiberacao) {
    return;
  }
  modalLiberacao.hidden = true;
  manutencaoEmLiberacao = null;
  liberacaoDocsBase = {};
  liberacaoDocsPreview = {};
}

function abrirOverrideLiberacao(dataProgramada) {
  if (!modalOverride || !formOverride) {
    return;
  }
  if (overrideInfo) {
    const dataLabel = dataProgramada ? formatDate(dataProgramada) : "-";
    overrideInfo.textContent = `Liberação antes da data prevista (${dataLabel}).`;
  }
  if (overrideMotivo) {
    overrideMotivo.value = "";
  }
  mostrarMensagemOverride("");
  modalOverride.hidden = false;
}

function fecharOverrideLiberacao() {
  if (!modalOverride) {
    return;
  }
  modalOverride.hidden = true;
  mostrarMensagemOverride("");
  pendingLiberacaoOverride = null;
}

async function finalizarLiberacao(index, item, liberacaoBase, overrideJustificativa = "") {
  const dataProgramada = parseDate(item.data);
  const atrasada = dataProgramada && dataProgramada < startOfDay(new Date());
  const agoraIso = toIsoUtc(new Date());
  const liberacao = {
    ...liberacaoBase,
    liberadoEm: agoraIso,
    liberadoPor: currentUser.id,
  };
  if (overrideJustificativa) {
    liberacao.overrideJustificativa = overrideJustificativa;
    liberacao.overrideRole = getRoleLabel(currentUser);
    liberacao.overrideAt = agoraIso;
  }
  const participantesFinal =
    Array.isArray(liberacao.participantes) && liberacao.participantes.length
      ? liberacao.participantes
      : Array.isArray(item.participantes)
        ? item.participantes
        : [];
  const equipamentoFinal =
    liberacao.equipamentoId ||
    item.equipamentoId ||
    resolveEquipamentoIdFromValue(item.equipamento);
  const equipeResponsavel = liberacao.equipeResponsavel || "";
  const executadoPorTime = equipeResponsavel ? `team:${equipeResponsavel}` : "";
  const registroExecucaoAtual = executadoPorTime
    ? { ...(item.registroExecucao || {}), executadoPor: executadoPorTime }
    : item.registroExecucao;
  const atualizado = {
    ...item,
    liberacao,
    status: atrasada ? "backlog" : "liberada",
    equipamentoId: equipamentoFinal || item.equipamentoId,
    participantes: participantesFinal.length ? participantesFinal : item.participantes,
    executadaPor: executadoPorTime || item.executadaPor,
    registroExecucao: registroExecucaoAtual,
    updatedAt: agoraIso,
    updatedBy: currentUser.id,
  };
  manutencoes[index] = atualizado;
  salvarManutencoes(manutencoes);
  const documentosLista = DOC_KEYS.filter(
    (key) => liberacao.documentos && liberacao.documentos[key]
  ).map((key) => DOC_LABELS[key] || key);
  logAction("release", atualizado, {
    osNumero: liberacao.osNumero,
    participantes: liberacao.participantes,
    critico: liberacao.critico,
    documentos: documentosLista,
    justificativa: overrideJustificativa || undefined,
    resumo: overrideJustificativa ? "Liberação antecipada registrada." : "Liberação registrada.",
  });
  await registrarSstDocumentacao(atualizado, liberacao);
  renderTudo();
  fecharLiberacao();
  mostrarMensagemManutencao("Liberação registrada.");
}

async function confirmarOverrideLiberacao(event) {
  event.preventDefault();
  if (!pendingLiberacaoOverride) {
    mostrarMensagemOverride("Nenhuma liberação pendente.", true);
    return;
  }
  const motivo = overrideMotivo ? overrideMotivo.value.trim() : "";
  if (!motivo) {
    mostrarMensagemOverride("Justificativa obrigatória.", true);
    return;
  }
  const index = manutencoes.findIndex(
    (registro) => registro.id === pendingLiberacaoOverride.id
  );
  if (index < 0) {
    mostrarMensagemOverride("Manutenção não encontrada.", true);
    pendingLiberacaoOverride = null;
    return;
  }
  const item = manutencoes[index];
  let liberacaoOkNoServidor = true;
  try {
    await apiMaintenanceRelease({
      id: pendingLiberacaoOverride.id,
      dataProgramada: item.data,
      justificativa: motivo,
    });
  } catch (error) {
    if (isUnauthorizedError(error)) {
      liberacaoOkNoServidor = false;
      showAuthToast("Liberação salva localmente. Sincronização pendente.");
    } else {
      mostrarMensagemOverride(error.message || "Não foi possível liberar.", true);
      return;
    }
  }
  const liberacaoBase = pendingLiberacaoOverride.liberacaoBase;
  pendingLiberacaoOverride = null;
  fecharOverrideLiberacao();
  await finalizarLiberacao(index, item, liberacaoBase, motivo);
  if (!liberacaoOkNoServidor) {
    maintenancePendingSync = true;
  }
}

async function salvarLiberacao(event) {
  event.preventDefault();
  if (!requirePermission("complete")) {
    return;
  }
  if (!manutencaoEmLiberacao) {
    mostrarMensagemLiberacao("Selecione uma manutenção.", true);
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === manutencaoEmLiberacao);
  if (index < 0) {
    mostrarMensagemLiberacao("Manutenção não encontrada.", true);
    return;
  }
  const item = manutencoes[index];
  const osNumero = liberacaoOs ? liberacaoOs.value.trim() : "";
  if (!osNumero) {
    mostrarMensagemLiberacao("Informe o Nº OS / referência.", true);
    return;
  }
  const participantes = getLiberacaoParticipantesFromForm();
  setFieldError(liberacaoParticipantesErro, "");
  if (!participantes.length) {
    setFieldError(liberacaoParticipantesErro, "Informe ao menos 1 participante.");
    mostrarMensagemLiberacao("Informe ao menos 1 participante.", true);
    return;
  }
  const equipamentoSelecionado = liberacaoEquipamento ? liberacaoEquipamento.value.trim() : "";
  const equipamentoFallback =
    item.equipamentoId || resolveEquipamentoIdFromValue(item.equipamento);
  const equipamentoId = equipamentoSelecionado || equipamentoFallback || "";
  if (liberacaoEquipamento && !equipamentoId) {
    mostrarMensagemLiberacao("Informe o equipamento da manutenção.", true);
    return;
  }
  const equipeResponsavel = liberacaoEquipeResponsavel
    ? getLiberacaoEquipeSelecionada()
    : "";
  const criticoValor = liberacaoCritico ? liberacaoCritico.value : "";
  if (!criticoValor) {
    mostrarMensagemLiberacao("Informe se o trabalho é crítico.", true);
    return;
  }
  const critico = criticoValor === "sim";
  if (critico && participantes.length < 2) {
    setFieldError(
      liberacaoParticipantesErro,
      "Para trabalho crítico, informe ao menos 2 participantes."
    );
    mostrarMensagemLiberacao(
      "Para trabalho crítico, informe ao menos 2 participantes.",
      true
    );
    return;
  }
  const documentos = { ...liberacaoDocsBase };
  for (const chave of DOC_KEYS) {
    const input = liberacaoDocInputs.find((itemInput) => itemInput.dataset.docInput === chave);
    if (input && input.files && input.files[0]) {
      try {
        documentos[chave] = await uploadLiberacaoDoc(input.files[0], chave);
      } catch (error) {
        mostrarMensagemLiberacao(
          error && error.message ? error.message : "Não foi possível enviar o documento.",
          true
        );
        return;
      }
      continue;
    }
    const docAtual = getLiberacaoDocAtual(chave);
    if (docAtual) {
      documentos[chave] = docAtual;
    }
  }
  if (!documentos.apr || !documentos.os || !documentos.pte) {
    mostrarMensagemLiberacao("Anexe APR, OS e PTE para liberar.", true);
    return;
  }
  if (critico && !documentos.pt) {
    mostrarMensagemLiberacao("PT obrigatória para trabalho crítico.", true);
    return;
  }
  const dataProgramada = parseDate(item.data);
  const hoje = startOfDay(new Date());
  const liberacaoAntecipada = dataProgramada && dataProgramada > hoje;
  if (liberacaoAntecipada && !canOverrideRelease(currentUser)) {
    mostrarMensagemLiberacao(
      `Trancada - libera em ${dataProgramada ? formatDate(dataProgramada) : "-"}.`,
      true
    );
    return;
  }
  const liberacaoBase = {
    osNumero,
    participantes,
    critico,
    documentos,
    equipamentoId,
    equipeResponsavel,
  };
  if (liberacaoAntecipada) {
    pendingLiberacaoOverride = { id: item.id, liberacaoBase };
    abrirOverrideLiberacao(dataProgramada);
    return;
  }
  let liberacaoOkNoServidor = true;
  try {
    await apiMaintenanceRelease({ id: item.id, dataProgramada: item.data });
  } catch (error) {
    if (isUnauthorizedError(error)) {
      liberacaoOkNoServidor = false;
      showAuthToast("Liberação salva localmente. Sincronização pendente.");
    } else {
      mostrarMensagemLiberacao(error.message || "Não foi possível liberar.", true);
      return;
    }
  }
  await finalizarLiberacao(index, item, liberacaoBase);
  if (!liberacaoOkNoServidor) {
    maintenancePendingSync = true;
  }
}

function handleLiberacaoDocChange(input) {
  if (!input) {
    return;
  }
  const chave = input.dataset.docInput;
  if (!chave) {
    return;
  }
  const file = input.files && input.files[0] ? input.files[0] : null;
  if (!file) {
    delete liberacaoDocsPreview[chave];
    atualizarLiberacaoDocsUI();
    atualizarLiberacaoChecklist();
    return;
  }
  lerDocumentoFile(file).then((doc) => {
    if (doc) {
      liberacaoDocsPreview[chave] = doc;
    }
    atualizarLiberacaoDocsUI();
    atualizarLiberacaoChecklist();
  });
}

function liberarManutencao(index) {
  if (!requirePermission("complete")) {
    return;
  }
  const item = manutencoes[index];
  if (item.status === "backlog") {
    mostrarMensagemManutencao("Manutenção em backlog. Não é possível liberar.", true);
    return;
  }
  const dataProgramada = parseDate(item.data);
  const hoje = startOfDay(new Date());
  const lockInfo = getReleaseLockInfo(item, dataProgramada, hoje);
  if (lockInfo && !lockInfo.canOverride) {
    mostrarMensagemManutencao(
      `Trancada - libera em ${formatDate(lockInfo.date)}.`,
      true
    );
    return;
  }
  abrirLiberacao(item);
}

function abrirCancelarInicio(item) {
  if (!modalCancelarInicio || !formCancelarInicio) {
    return;
  }
  if (!item) {
    return;
  }
  if (item.status !== "em_execucao") {
    mostrarMensagemManutencao("A manutenção precisa estar em execução.", true);
    return;
  }
  if (item.registroExecucao) {
    mostrarMensagemManutencao("Registro já iniciado. Não é possível cancelar.", true);
    return;
  }
  manutencaoEmCancelamento = item.id;
  mostrarMensagemCancelarInicio("");
  if (cancelarInicioId) {
    cancelarInicioId.value = item.id;
  }
  if (cancelarInicioMotivo) {
    cancelarInicioMotivo.value = "";
  }
  if (cancelarInicioObs) {
    cancelarInicioObs.value = "";
  }
  modalCancelarInicio.hidden = false;
}

function fecharCancelarInicio() {
  if (!modalCancelarInicio) {
    return;
  }
  modalCancelarInicio.hidden = true;
  manutencaoEmCancelamento = null;
}

function salvarCancelarInicio(event) {
  event.preventDefault();
  if (!requirePermission("complete")) {
    return;
  }
  if (!manutencaoEmCancelamento) {
    mostrarMensagemCancelarInicio("Selecione uma manutenção.", true);
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === manutencaoEmCancelamento);
  if (index < 0) {
    mostrarMensagemCancelarInicio("Manutenção não encontrada.", true);
    return;
  }
  const item = manutencoes[index];
  const motivo = cancelarInicioMotivo ? cancelarInicioMotivo.value.trim() : "";
  if (!motivo) {
    mostrarMensagemCancelarInicio("Selecione o motivo do cancelamento.", true);
    return;
  }
  const observacao = cancelarInicioObs ? cancelarInicioObs.value.trim() : "";
  if (motivo === "Outros" && !observacao) {
    mostrarMensagemCancelarInicio("Informe a observação para o motivo Outros.", true);
    return;
  }
  const inicioAnterior = item.executionStartedAt || "";
  const atualizado = {
    ...item,
    status: isLiberacaoOk(item) ? "liberada" : "agendada",
    executionStartedAt: null,
    executionStartedBy: null,
    executionFinishedAt: null,
    registroExecucao: null,
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser.id,
  };
  manutencoes[index] = atualizado;
  salvarManutencoes(manutencoes);
  const liberacao = getLiberacao(item) || {};
  const documentosLista = DOC_KEYS.filter(
    (key) => liberacao.documentos && liberacao.documentos[key]
  ).map((key) => DOC_LABELS[key] || key);
  logAction("cancel_start", atualizado, {
    motivo,
    observacao,
    osNumero: liberacao.osNumero || "",
    participantes: liberacao.participantes || [],
    critico: liberacao.critico,
    documentos: documentosLista,
    inicioExecucao: inicioAnterior,
    resumo: "Início cancelado.",
  });
  renderTudo();
  fecharCancelarInicio();
  mostrarMensagemManutencao("Início cancelado.");
}

function abrirReagendamento(item) {
  if (!modalReagendar || !formReagendar) {
    return;
  }
  mostrarMensagemReagendar("");
  if (reagendarId) {
    reagendarId.value = item.id;
  }
  if (reagendarData) {
    reagendarData.value = item.data || formatDateISO(new Date());
  }
  if (reagendarMotivo) {
    reagendarMotivo.value = "";
  }
  if (reagendarObs) {
    reagendarObs.value = "";
  }
  modalReagendar.hidden = false;
}

function fecharReagendamento() {
  if (!modalReagendar) {
    return;
  }
  modalReagendar.hidden = true;
}

function reagendarManutencao(index) {
  if (!requirePermission("reschedule")) {
    return;
  }
  const item = manutencoes[index];
  if (isDailySubstationInspection(item)) {
    mostrarMensagemManutencao(
      "Inspeção diária de subestação não pode ser reagendada.",
      true
    );
    return;
  }
  if (item.status === "em_execucao" || item.status === "encerramento") {
    mostrarMensagemManutencao("Não é possível reagendar durante a execução.", true);
    return;
  }
  if (item.status === "concluida") {
    mostrarMensagemManutencao("Manutenção concluída. Apenas leitura.", true);
    return;
  }
  abrirReagendamento(item);
}

function salvarReagendamento(event) {
  event.preventDefault();
  if (!requirePermission("reschedule")) {
    return;
  }
  if (!reagendarId || !reagendarData || !reagendarMotivo) {
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === reagendarId.value);
  if (index < 0) {
    mostrarMensagemReagendar("Manutenção não encontrada.", true);
    return;
  }
  const item = manutencoes[index];
  if (isDailySubstationInspection(item)) {
    mostrarMensagemReagendar(
      "Inspeção diária de subestação não pode ser reagendada.",
      true
    );
    return;
  }
  const motivo = reagendarMotivo.value.trim();
  if (!motivo) {
    mostrarMensagemReagendar("Selecione o motivo do reagendamento.", true);
    return;
  }
  const dataLimpa = reagendarData.value.trim();
  const novaData = parseDate(dataLimpa);
  if (!novaData) {
    mostrarMensagemReagendar("Data inválida. Use AAAA-MM-DD.", true);
    return;
  }
  if (item.status === "em_execucao" || item.status === "encerramento") {
    mostrarMensagemReagendar("Não é possível reagendar durante a execução.", true);
    return;
  }
  const dataAnterior = item.data || "";
  if (dataAnterior && dataAnterior === dataLimpa) {
    mostrarMensagemReagendar("Nova data deve ser diferente da data atual.", true);
    return;
  }
  const hoje = startOfDay(new Date());
  if (novaData < hoje) {
    const confirmar = window.confirm(
      "A nova data está no passado e a manutenção ficará em backlog. Deseja continuar?"
    );
    if (!confirmar) {
      return;
    }
  }
  const observacao = reagendarObs ? reagendarObs.value.trim() : "";
  if (motivo === "Outros" && !observacao) {
    mostrarMensagemReagendar("Informe a observação para o motivo Outros.", true);
    return;
  }

  const atualizado = {
    ...item,
    data: dataLimpa,
    status: isLiberacaoOk(item) ? "liberada" : "agendada",
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser.id,
  };

  manutencoes[index] = atualizado;
  const resultado = normalizarManutencoes(manutencoes);
  manutencoes = resultado.normalizadas;
  salvarManutencoes(manutencoes);
  logAction("reschedule", atualizado, {
    dataAnterior,
    dataNova: dataLimpa,
    motivo,
    observacao,
    templateId: item.templateId || "",
    resumo: `Reagendada de ${dataAnterior || "-"} para ${dataLimpa} (${motivo})`,
  });
  renderTudo();
  fecharReagendamento();
  mostrarMensagemManutencao("Manutenção reagendada.");
}

function formatDateTimeInput(date) {
  const offset = date.getTimezoneOffset();
  const local = new Date(date.getTime() - offset * 60000);
  return local.toISOString().slice(0, 16);
}

function parseDateTimeInput(valor) {
  if (!valor) {
    return null;
  }
  const [dataParte, horaParte] = valor.split("T");
  if (!dataParte || !horaParte) {
    return null;
  }
  const [ano, mes, dia] = dataParte.split("-").map((item) => Number.parseInt(item, 10));
  const [hora, minuto] = horaParte.split(":").map((item) => Number.parseInt(item, 10));
  if (![ano, mes, dia, hora, minuto].every(Number.isFinite)) {
    return null;
  }
  return new Date(ano, mes - 1, dia, hora, minuto);
}

function formatDuracaoMin(minutos) {
  const total = Math.max(0, Math.round(minutos));
  const horas = Math.floor(total / 60);
  const mins = total % 60;
  return `${String(horas).padStart(2, "0")}:${String(mins).padStart(2, "0")}`;
}

function formatHistoricoData(valor) {
  if (!valor && valor !== 0) {
    return "";
  }
  const parsed = parseTimestamp(valor);
  if (parsed) {
    return formatDateTime(parsed);
  }
  return String(valor);
}

function formatDataCurta(valor) {
  if (!valor) {
    return "-";
  }
  const parsed = parseDate(valor);
  return parsed ? formatDate(parsed) : String(valor);
}

function renderHistorico(item) {
  if (!listaHistorico || !historicoVazio) {
    return;
  }
  listaHistorico.innerHTML = "";
  const historico = getHistoricoManutencao(item.id);
  if (historicoResumo) {
    historicoResumo.textContent = buildManutencaoResumoTexto(item);
  }

  if (!historico.length) {
    historicoVazio.hidden = false;
    if (btnHistoricoMais) {
      btnHistoricoMais.hidden = true;
    }
    if (btnHistoricoExportar) {
      btnHistoricoExportar.hidden = true;
    }
    if (btnHistoricoExportarPdf) {
      btnHistoricoExportarPdf.hidden = true;
    }
    return;
  }
  historicoVazio.hidden = true;

  const limite = Math.min(historicoLimite, historico.length);
  historico.slice(0, limite).forEach((entry) => {
    const card = document.createElement("div");
    card.className = "history-item";

    const titulo = document.createElement("strong");
    const label = ACTION_LABELS[entry.action] || entry.action;
    titulo.textContent = label;

    const meta = document.createElement("div");
    meta.className = "history-meta";
    const dataEvento = parseTimestamp(entry.timestamp);
    meta.textContent = `${dataEvento ? formatDateTime(dataEvento) : "-"} - ${getUserLabel(
      entry.userId
    )} | ${getOrigemLabel(entry)}`;

    card.append(titulo, meta);

    const detalhes = entry.detalhes || {};
    const linhas = [];
    if (detalhes.dataAnterior || detalhes.dataNova) {
      const de = detalhes.dataAnterior ? formatDataCurta(detalhes.dataAnterior) : "-";
      const para = detalhes.dataNova ? formatDataCurta(detalhes.dataNova) : "-";
      linhas.push(`De: ${de} -> Para: ${para}`);
    }
      if (detalhes.motivo) {
        linhas.push(`Motivo: ${detalhes.motivo}`);
      }
      if (detalhes.observacao) {
        linhas.push(`Obs.: ${detalhes.observacao}`);
      }
      if (detalhes.osNumero) {
        linhas.push(`OS: ${detalhes.osNumero}`);
      }
      if (detalhes.participantes) {
        const participantesTexto = Array.isArray(detalhes.participantes)
          ? getParticipantesLabel(detalhes.participantes)
          : detalhes.participantes;
        linhas.push(`Participantes: ${participantesTexto}`);
      }
      if (detalhes.critico !== undefined) {
        linhas.push(`Crítico: ${detalhes.critico ? "Sim" : "Não"}`);
      }
      if (detalhes.documentos) {
        const docsTexto = Array.isArray(detalhes.documentos)
          ? detalhes.documentos.join(", ")
          : Object.keys(detalhes.documentos).join(", ");
        if (docsTexto) {
          linhas.push(`Documentos: ${docsTexto}`);
        }
      }
      if (detalhes.resultado) {
        linhas.push(`Resultado: ${RESULTADO_LABELS[detalhes.resultado] || detalhes.resultado}`);
      }
    if (detalhes.referencia) {
      linhas.push(`Referência: ${detalhes.referencia}`);
    }
    if (detalhes.observacaoExecucao) {
      linhas.push(`Obs. execução: ${detalhes.observacaoExecucao}`);
    }
    if (detalhes.evidenciasCount !== undefined) {
      linhas.push(`Evidências: ${detalhes.evidenciasCount}`);
    }
    if (detalhes.inicioExecucao) {
      linhas.push(`Início execução: ${formatHistoricoData(detalhes.inicioExecucao)}`);
    }
    if (detalhes.fimExecucao) {
      linhas.push(`Fim execução: ${formatHistoricoData(detalhes.fimExecucao)}`);
    }
    if (detalhes.atrasoDias !== undefined) {
      linhas.push(`Atraso (dias): ${detalhes.atrasoDias}`);
    }
    if (detalhes.resumo) {
      linhas.push(detalhes.resumo);
    }
    if (linhas.length) {
      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "btn btn--ghost btn--small history-toggle";
      toggle.textContent = "Expandir detalhes";

      const details = document.createElement("div");
      details.className = "history-details";
      details.hidden = true;

      linhas.forEach((texto) => {
        const linha = document.createElement("div");
        linha.className = "history-meta";
        linha.textContent = texto;
        details.append(linha);
      });

      toggle.addEventListener("click", () => {
        const expandir = details.hidden;
        details.hidden = !expandir;
        toggle.textContent = expandir ? "Ocultar detalhes" : "Expandir detalhes";
      });

      card.append(toggle, details);
    }

    listaHistorico.append(card);
  });

  if (btnHistoricoMais) {
    btnHistoricoMais.hidden = limite >= historico.length;
  }
  if (btnHistoricoExportar) {
    btnHistoricoExportar.hidden = false;
  }
  if (btnHistoricoExportarPdf) {
    btnHistoricoExportarPdf.hidden = false;
  }
}

function abrirHistorico(item) {
  if (!modalHistorico || !listaHistorico || !historicoVazio) {
    return;
  }
  historicoAtualId = item.id;
  historicoLimite = HISTORY_PAGE_SIZE;
  renderHistorico(item);
  modalHistorico.hidden = false;
}

function fecharHistorico() {
  if (!modalHistorico) {
    return;
  }
  modalHistorico.hidden = true;
  historicoAtualId = null;
  historicoLimite = HISTORY_PAGE_SIZE;
}

function escapeCsv(valor) {
  const texto = valor === null || valor === undefined ? "" : String(valor);
  return `"${texto.replace(/"/g, '""')}"`;
}

function exportarHistorico(item) {
  const historico = getHistoricoManutencao(item.id);
  if (!historico.length) {
    return;
  }
    const header = [
      "acao",
      "data_hora",
      "usuario",
      "origem",
      "data_anterior",
      "data_nova",
      "motivo",
      "observacao",
      "os_numero",
      "participantes",
      "critico",
      "documentos",
      "inicio_execucao",
      "fim_execucao",
      "resumo",
      "resultado",
      "referencia",
      "obs_execucao",
      "evidencias_count",
    "prev_hash",
    "hash",
  ];
  const linhas = historico.map((entry) => {
      const detalhes = entry.detalhes || {};
      const dataEvento = parseTimestamp(entry.timestamp);
      const participantesTexto = Array.isArray(detalhes.participantes)
        ? detalhes.participantes.map((id) => getUserLabel(id)).join(" | ")
        : detalhes.participantes || "";
      const documentosTexto = Array.isArray(detalhes.documentos)
        ? detalhes.documentos.join(" | ")
        : detalhes.documentos
          ? Object.keys(detalhes.documentos).join(" | ")
          : "";
      return [
        ACTION_LABELS[entry.action] || entry.action,
        dataEvento ? formatDateTime(dataEvento) : "",
        getUserLabel(entry.userId),
        getOrigemLabel(entry),
        detalhes.dataAnterior || "",
        detalhes.dataNova || "",
        detalhes.motivo || "",
        detalhes.observacao || "",
        detalhes.osNumero || "",
        participantesTexto,
        detalhes.critico === undefined ? "" : detalhes.critico ? "Sim" : "Não",
        documentosTexto,
        detalhes.inicioExecucao || "",
        detalhes.fimExecucao || "",
        detalhes.resumo || "",
        detalhes.resultado || "",
        detalhes.referencia || "",
        detalhes.observacaoExecucao || "",
        detalhes.evidenciasCount !== undefined ? detalhes.evidenciasCount : "",
      entry.prevHash || "",
      entry.hash || "",
    ]
      .map(escapeCsv)
      .join(",");
  });
  const csv = [header.map(escapeCsv).join(","), ...linhas].join("\n");
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  const dataAtual = new Date().toISOString().slice(0, 10);
  link.href = url;
  link.download = `historico-${item.id}-${dataAtual}.csv`;
  document.body.append(link);
  link.click();
  link.remove();
  URL.revokeObjectURL(url);
}

function exportarHistoricoPdf(item) {
  const historico = getHistoricoManutencao(item.id);
  if (!historico.length) {
    return;
  }
  const popup = window.open("", "_blank");
  if (!popup) {
    return;
  }
  const dataBase = item.data ? formatDate(parseDate(item.data)) : "data indefinida";
  const header = `
    <h1>Histórico da manutenção</h1>
    <p><strong>${item.titulo}</strong> | ${item.local} | ${dataBase}</p>
  `;
  const itens = historico
    .map((entry) => {
      const dataEvento = parseTimestamp(entry.timestamp);
      const linhas = [];
      if (entry.detalhes && (entry.detalhes.dataAnterior || entry.detalhes.dataNova)) {
        const de = entry.detalhes.dataAnterior
          ? formatDataCurta(entry.detalhes.dataAnterior)
          : "-";
        const para = entry.detalhes.dataNova ? formatDataCurta(entry.detalhes.dataNova) : "-";
        linhas.push(
          `De: ${de} -> Para: ${para}`
        );
      }
      if (entry.detalhes && entry.detalhes.motivo) {
        linhas.push(`Motivo: ${entry.detalhes.motivo}`);
      }
        if (entry.detalhes && entry.detalhes.observacao) {
          linhas.push(`Obs.: ${entry.detalhes.observacao}`);
        }
        if (entry.detalhes && entry.detalhes.osNumero) {
          linhas.push(`OS: ${entry.detalhes.osNumero}`);
        }
        if (entry.detalhes && entry.detalhes.participantes) {
          const participantesTexto = Array.isArray(entry.detalhes.participantes)
            ? getParticipantesLabel(entry.detalhes.participantes)
            : entry.detalhes.participantes;
          linhas.push(`Participantes: ${participantesTexto}`);
        }
        if (entry.detalhes && entry.detalhes.critico !== undefined) {
          linhas.push(`Crítico: ${entry.detalhes.critico ? "Sim" : "Não"}`);
        }
        if (entry.detalhes && entry.detalhes.documentos) {
          const docsTexto = Array.isArray(entry.detalhes.documentos)
            ? entry.detalhes.documentos.join(", ")
            : Object.keys(entry.detalhes.documentos).join(", ");
          if (docsTexto) {
            linhas.push(`Documentos: ${docsTexto}`);
          }
        }
        if (entry.detalhes && entry.detalhes.resultado) {
          linhas.push(
            `Resultado: ${
            RESULTADO_LABELS[entry.detalhes.resultado] || entry.detalhes.resultado
          }`
        );
      }
      if (entry.detalhes && entry.detalhes.referencia) {
        linhas.push(`Referência: ${entry.detalhes.referencia}`);
      }
      if (entry.detalhes && entry.detalhes.observacaoExecucao) {
        linhas.push(`Obs. execução: ${entry.detalhes.observacaoExecucao}`);
      }
      if (entry.detalhes && entry.detalhes.evidenciasCount !== undefined) {
        linhas.push(`Evidências: ${entry.detalhes.evidenciasCount}`);
      }
      if (entry.detalhes && entry.detalhes.inicioExecucao) {
        linhas.push(`Início execução: ${formatHistoricoData(entry.detalhes.inicioExecucao)}`);
      }
      if (entry.detalhes && entry.detalhes.fimExecucao) {
        linhas.push(`Fim execução: ${formatHistoricoData(entry.detalhes.fimExecucao)}`);
      }
      if (entry.detalhes && entry.detalhes.atrasoDias !== undefined) {
        linhas.push(`Atraso (dias): ${entry.detalhes.atrasoDias}`);
      }
      if (entry.detalhes && entry.detalhes.resumo) {
        linhas.push(entry.detalhes.resumo);
      }
      const detalhesHtml = linhas.length
        ? `<ul>${linhas.map((linha) => `<li>${linha}</li>`).join("")}</ul>`
        : "";
      const label = ACTION_LABELS[entry.action] || entry.action;
      return `
        <div class="item">
          <div class="item-head">
            <strong>${label}</strong>
            <span>${dataEvento ? formatDateTime(dataEvento) : "-"} | ${getUserLabel(
              entry.userId
            )} | ${getOrigemLabel(entry)}</span>
          </div>
          ${detalhesHtml}
        </div>
      `;
    })
    .join("");
  popup.document.write(`
    <!doctype html>
    <html lang="pt-BR">
      <head>
        <meta charset="utf-8" />
        <title>Histórico ${item.titulo}</title>
        <style>
          body { font-family: Arial, sans-serif; padding: 24px; color: #1c1c1c; }
          h1 { margin: 0 0 8px; font-size: 20px; }
          p { margin: 0 0 16px; color: #4a4a4a; }
          .item { border: 1px solid #d9d9d9; border-radius: 10px; padding: 12px; margin-bottom: 10px; }
          .item-head { display: flex; flex-direction: column; gap: 4px; }
          .item-head span { font-size: 12px; color: #555; }
          ul { margin: 8px 0 0 16px; padding: 0; }
          li { font-size: 13px; margin-bottom: 4px; }
        </style>
      </head>
      <body>
        ${header}
        ${itens}
      </body>
    </html>
  `);
  popup.document.close();
  popup.focus();
  popup.print();
}

function getConclusaoInicioDate() {
  if (!conclusaoInicio) {
    return null;
  }
  const valor = conclusaoInicio.value;
  const parsed = parseDateTimeInput(valor);
  if (parsed) {
    return parsed;
  }
  const inicioIso = conclusaoInicio.dataset.iso || "";
  return inicioIso ? parseTimestamp(inicioIso) : null;
}

function atualizarDuracaoConclusao() {
  if (!conclusaoInicio || !conclusaoFim || !conclusaoDuracao) {
    return;
  }
  const inicio = getConclusaoInicioDate();
  conclusaoFim.min = inicio ? formatDateTimeInput(inicio) : "";
  if (!inicio || !conclusaoFim.value) {
    conclusaoDuracao.value = "";
    return;
  }
  const fim = parseDateTimeInput(conclusaoFim.value);
  if (Number.isNaN(inicio.getTime()) || Number.isNaN(fim.getTime()) || fim < inicio) {
    conclusaoDuracao.value = "00:00";
    return;
  }
  const minutos = (fim.getTime() - inicio.getTime()) / 60000;
  conclusaoDuracao.value = formatDuracaoMin(minutos);
}

function getEvidenciaFiles() {
  if (conclusaoFotosToggle && !conclusaoFotosToggle.checked) {
    return [];
  }
  if (!evidenciaInputs.length) {
    return [];
  }
  const files = [];
  evidenciaInputs.forEach((input, index) => {
    if (!input) {
      return;
    }
    const slotValue = Number.parseInt(input.dataset.evidenciaInput, 10);
    const slotIndex = Number.isFinite(slotValue) && slotValue > 0 ? slotValue - 1 : index;
    files[slotIndex] = input.files && input.files[0] ? input.files[0] : null;
  });
  return files;
}

function atualizarSlotsFoto(arquivos) {
  if (!fotoSlots.length) {
    return;
  }
  const obrigatorio = !conclusaoFotosToggle || conclusaoFotosToggle.checked;
  fotoSlots.forEach((slot, index) => {
    const slotValue = Number.parseInt(slot.dataset.photoSlot, 10);
    const labelIndex = Number.isFinite(slotValue) && slotValue > 0 ? slotValue : index + 1;
    const fileIndex = Number.isFinite(slotValue) && slotValue > 0 ? slotValue - 1 : index;
    const baseLabel = `Foto ${labelIndex}${obrigatorio ? "*" : ""}`;
    const file = arquivos[fileIndex];
    if (file) {
      const nome = file.name ? ` - ${file.name}` : "";
      slot.textContent = `${baseLabel}${nome}`;
      slot.classList.add("is-filled");
      const invalido = !(file.type && file.type.startsWith("image/"));
      slot.classList.toggle("is-invalid", invalido);
      return;
    }
    slot.textContent = baseLabel;
    slot.classList.remove("is-filled");
    slot.classList.remove("is-invalid");
  });
}

function atualizarListaEvidencias() {
  if (conclusaoFotosToggle && !conclusaoFotosToggle.checked) {
    if (conclusaoEvidenciasLista) {
      conclusaoEvidenciasLista.innerHTML = "";
    }
    atualizarSlotsFoto([]);
    return;
  }
  const arquivos = getEvidenciaFiles();
  atualizarSlotsFoto(arquivos);
  if (!conclusaoEvidenciasLista) {
    return;
  }
  conclusaoEvidenciasLista.innerHTML = "";
  arquivos.forEach((file, index) => {
    if (!file) {
      return;
    }
    const item = document.createElement("span");
    item.className = "file-chip";
    item.textContent = `Foto ${index + 1}: ${file.name}`;
    if (!file.type || !file.type.startsWith("image/")) {
      item.classList.add("file-chip--invalid");
    }
    conclusaoEvidenciasLista.append(item);
  });
}

function lerDocumentoFile(file) {
  return new Promise((resolve) => {
    if (!file) {
      resolve(null);
      return;
    }
    const reader = new FileReader();
    reader.onload = () =>
      resolve({ nome: file.name, type: file.type || "", dataUrl: reader.result });
    reader.onerror = () => resolve(null);
    reader.readAsDataURL(file);
  });
}

function lerEvidencias(files) {
  const lista = Array.from(files || []).filter(Boolean);
  if (!lista.length) {
    return Promise.resolve([]);
  }
  return lista.reduce((promise, file) => {
    return promise.then(async (acc) => {
      const evidencia = await uploadEvidenceFile(file);
      if (evidencia) {
        acc.push(evidencia);
      }
      return acc;
    });
  }, Promise.resolve([]));
}

const DESCRICAO_BREVE_MODELOS = [
  {
    id: "coleta_oleo",
    label: "Coleta preventiva de oleo",
    text:
      "Realizada coleta preventiva de oleo em {equipamento} na {subestacao}, com drenagem/purga inicial, coleta em frascos limpos, identificacao e registro fotografico. Amostra acondicionada para analise laboratorial conforme rotina.",
  },
  {
    id: "inspecao_visual",
    label: "Inspecao visual",
    text:
      "Executada inspecao visual em {equipamento} na {subestacao}, verificando condicoes gerais, conexoes aparentes e ausencia de anomalias. Registro fotografico efetuado.",
  },
  {
    id: "termografia",
    label: "Termografia",
    text:
      "Realizado levantamento termografico em {equipamento} na {subestacao}, com varredura de pontos criticos e registros das temperaturas de referencia.",
  },
  {
    id: "aperto_torque",
    label: "Aperto / torque",
    text:
      "Executado reaperto/torqueamento em {equipamento} na {subestacao}, conforme especificacao tecnica. Verificada integridade dos terminais e conexoes.",
  },
  {
    id: "limpeza_conservacao",
    label: "Limpeza e conservacao",
    text:
      "Realizada limpeza tecnica em {equipamento} na {subestacao}, removendo poeira/contaminantes e organizando a area. Condicao final registrada.",
  },
  {
    id: "teste_funcional",
    label: "Teste funcional",
    text:
      "Efetuado teste funcional em {equipamento} na {subestacao}, validando comandos, intertravamentos e sinais. Operacao normalizada.",
  },
  {
    id: "manobra_operacional",
    label: "Manobra operacional",
    text:
      "Executada manobra operacional em {equipamento} na {subestacao} conforme procedimento e requisitos de seguranca. Sequencia registrada e equipamento estabilizado.",
  },
  {
    id: "corretiva",
    label: "Manutencao corretiva",
    text:
      "Realizada intervencao corretiva em {equipamento} na {subestacao} para restabelecimento operacional. Ajustes e testes finais executados.",
  },
  {
    id: "substituicao_componente",
    label: "Substituicao de componente",
    text:
      "Substituido componente em {equipamento} na {subestacao}, com verificacao de compatibilidade e testes pos-troca. Registro fotografico efetuado.",
  },
  {
    id: "calibracao_ajuste",
    label: "Calibracao / ajuste",
    text:
      "Calibrado/ajustado {equipamento} na {subestacao} conforme parametros de operacao. Leituras normalizadas e registro efetuado.",
  },
  {
    id: "protecao_reles",
    label: "Protecoes / reles",
    text:
      "Revisadas protecoes/reles do {equipamento} na {subestacao}, conferindo ajustes, sinais e comunicacao. Sem divergencias relevantes.",
  },
  {
    id: "baterias_ups",
    label: "Baterias / UPS",
    text:
      "Inspecionadas baterias/UPS na {subestacao}, verificando tensao, conexoes e condicoes fisicas. Registro fotografico e limpeza local realizados.",
  },
  {
    id: "aterramento_spda",
    label: "Aterramento / SPDA",
    text:
      "Verificado aterramento/SPDA na {subestacao}, conferindo conexoes aparentes e integridade. Condicoes dentro do esperado.",
  },
  {
    id: "lubrificacao",
    label: "Lubrificacao",
    text:
      "Realizada lubrificacao em {equipamento} na {subestacao}, conforme pontos previstos e especificacao do fabricante. Operacao normalizada.",
  },
];

function formatTemplateText(texto, contexto) {
  return String(texto || "").replace(/\{(\w+)\}/g, (_, key) => {
    const value = contexto && contexto[key] ? contexto[key] : "";
    return value || "nao informado";
  });
}

function getConclusaoContext(item) {
  const liberacao = getLiberacao(item) || {};
  const subestacao =
    item && (item.local || item.subestacao) ? item.local || item.subestacao : getItemSubestacao(item);
  const equipamento = getMaintenanceEquipamentoLabel(item);
  const osNumero = liberacao.osNumero || (conclusaoReferencia ? conclusaoReferencia.value : "");
  const categoria = item && item.categoria ? item.categoria : "";
  const prioridade = item && item.prioridade ? item.prioridade : "";
  const projeto = getActiveProject() ? getProjectLabel(getActiveProject()) : "";
  return {
    subestacao: subestacao && subestacao !== "-" ? subestacao : projeto || "nao informado",
    equipamento: equipamento && equipamento !== "-" ? equipamento : "nao informado",
    categoria: categoria || "nao informado",
    prioridade: prioridade || "nao informado",
    os: osNumero || "nao informado",
    projeto: projeto || "nao informado",
  };
}

function initConclusaoModelos() {
  if (!conclusaoModeloBreve) {
    return;
  }
  conclusaoModeloBreve.innerHTML = '<option value=\"\">Selecionar modelo</option>';
  DESCRICAO_BREVE_MODELOS.forEach((modelo) => {
    const opt = document.createElement("option");
    opt.value = modelo.id;
    opt.textContent = modelo.label;
    conclusaoModeloBreve.append(opt);
  });
}

function aplicarModeloBreve() {
  if (!conclusaoModeloBreve || !conclusaoDescricaoBreve) {
    return;
  }
  const selecionado = conclusaoModeloBreve.value;
  if (!selecionado) {
    return;
  }
  const modelo = DESCRICAO_BREVE_MODELOS.find((item) => item.id === selecionado);
  if (!modelo) {
    return;
  }
  const contexto = getConclusaoContext(conclusaoItemAtual || {});
  conclusaoDescricaoBreve.value = formatTemplateText(modelo.text, contexto);
}

function abrirConclusao(item) {
  if (!requirePermission("complete")) {
    return;
  }
  if (!modalConclusao || !formConclusao) {
    return;
  }
  if (!item || (item.status !== "em_execucao" && item.status !== "encerramento")) {
    mostrarMensagemManutencao("Inicie a execução antes de concluir.", true);
    return;
  }
  if (!item.executionStartedAt) {
    mostrarMensagemManutencao("Início da execução não encontrado.", true);
    return;
  }
  if (!hasExecucaoRegistradaCompleta(item)) {
    mostrarMensagemManutencao("Registre a execução antes de concluir.", true);
    abrirRegistroExecucao(item);
    return;
  }
  const registro = item.registroExecucao || {};
  const executadoPor =
    registro.executadoPor ||
    registro.executedBy ||
    item.executadaPor ||
    item.executionStartedBy ||
    item.createdBy ||
    "";
  const comentario =
    registro.comentario ||
    registro.descricao ||
    registro.resumo ||
    registro.observacaoExecucao ||
    registro.observacao ||
    "";
  manutencaoEmConclusao = item.id;
  conclusaoItemAtual = item;
  mostrarMensagemConclusao("");
  if (conclusaoResumo) {
    conclusaoResumo.textContent = buildManutencaoResumoTexto(item);
  }

  if (conclusaoId) {
    conclusaoId.value = item.id;
  }
  if (conclusaoTipo) {
    conclusaoTipo.value = item.titulo || "";
  }
  if (conclusaoSubestacao) {
    conclusaoSubestacao.value = item.local || "";
  }
  if (conclusaoCodigo) {
    conclusaoCodigo.value = item.id;
  }
  if (conclusaoAbertaPor) {
    conclusaoAbertaPor.value = getUserLabel(item.createdBy);
  }
  if (conclusaoAbertaEm) {
    const createdAt = parseTimestamp(item.createdAt);
    conclusaoAbertaEm.value = createdAt ? formatDateTime(createdAt) : "-";
  }
  if (conclusaoEncerradaPor) {
    conclusaoEncerradaPor.value = currentUser ? getUserLabel(currentUser.id) : "-";
  }

  if (conclusaoExecutadaPor) {
    conclusaoExecutadaPor.value = getUserLabel(executadoPor);
  }
  if (conclusaoComentario) {
    conclusaoComentario.value = comentario || "";
  }
  if (conclusaoResultado) {
    conclusaoResultado.value = registro.resultado || "";
  }
  if (conclusaoObsExecucao) {
    conclusaoObsExecucao.value = registro.observacaoExecucao || "";
  }
  if (conclusaoModeloBreve) {
    conclusaoModeloBreve.value = "";
  }
  if (conclusaoDescricaoBreve) {
    conclusaoDescricaoBreve.value =
      (item.conclusao && item.conclusao.descricaoBreve) || "";
  }
  const liberacao = getLiberacao(item) || {};
  if (conclusaoReferencia) {
    const osNumero = liberacao.osNumero || "";
    conclusaoReferencia.value = osNumero;
    conclusaoReferencia.readOnly = Boolean(osNumero);
  }
  evidenciaInputs.forEach((input) => {
    if (input) {
      input.value = "";
    }
  });
  if (conclusaoEvidenciasLista) {
    conclusaoEvidenciasLista.innerHTML = "";
  }
  if (conclusaoFotosToggle) {
    conclusaoFotosToggle.checked = true;
  }
  toggleConclusaoFotosUI();

  const inicio = parseTimestamp(item.executionStartedAt);
  if (conclusaoInicio) {
    conclusaoInicio.value = inicio ? formatDateTimeInput(inicio) : "";
    conclusaoInicio.dataset.iso = item.executionStartedAt || "";
  }
  if (conclusaoFim) {
    const agora = new Date();
    conclusaoFim.value = formatDateTimeInput(agora);
  }
  if (conclusaoDuracao) {
    const agora = new Date();
    const minutos =
      inicio && !Number.isNaN(agora.getTime())
        ? Math.max(0, Math.round((agora.getTime() - inicio.getTime()) / 60000))
        : 0;
    conclusaoDuracao.value = minutos ? formatDuracaoMin(minutos) : "-";
  }
  if (conclusaoParticipantes) {
    conclusaoParticipantes.value = getParticipantesLabel(liberacao.participantes);
  }
  if (conclusaoDocs) {
    const docs = liberacao.documentos || item.documentos || {};
    renderDocList(conclusaoDocs, docs, isItemCritico(item));
  }
  atualizarDuracaoConclusao();

  modalConclusao.hidden = false;
}

function fecharConclusao() {
  if (!modalConclusao) {
    return;
  }
  modalConclusao.hidden = true;
  manutencaoEmConclusao = null;
  conclusaoItemAtual = null;
}

async function salvarConclusao(event) {
  event.preventDefault();
  if (!requirePermission("complete")) {
    return;
  }
  if (!manutencaoEmConclusao) {
    mostrarMensagemConclusao("Selecione uma manutenção.", true);
    return;
  }
  const index = manutencoes.findIndex((item) => item.id === manutencaoEmConclusao);
  if (index < 0) {
    mostrarMensagemConclusao("Manutenção não encontrada.", true);
    return;
  }

  const item = manutencoes[index];
  if (item.status !== "em_execucao" && item.status !== "encerramento") {
    mostrarMensagemConclusao("Inicie a execução antes de concluir.", true);
    return;
  }
  const registro = item.registroExecucao || {};
  const executadoPor =
    registro.executadoPor ||
    registro.executedBy ||
    item.executadaPor ||
    item.executionStartedBy ||
    item.createdBy ||
    "";
  const comentario =
    registro.comentario ||
    registro.descricao ||
    registro.resumo ||
    registro.observacaoExecucao ||
    registro.observacao ||
    "";
  if (!executadoPor || !comentario) {
    mostrarMensagemConclusao("Registre a execução antes de concluir.", true);
    return;
  }
  const resultadoSelecionado = conclusaoResultado ? conclusaoResultado.value : "";
  const resultado = resultadoSelecionado || registro.resultado || "";
  if (!resultado) {
    mostrarMensagemConclusao("Informe o resultado da execução.", true);
    return;
  }
  const liberacao = getLiberacao(item);
  if (!isLiberacaoOk(item)) {
    mostrarMensagemConclusao("Documentação de liberação pendente.", true);
    return;
  }
  const comentarioMsg = getMensagemResumoRdo(comentario);
  if (comentarioMsg) {
    mostrarMensagemConclusao(comentarioMsg, true);
    return;
  }
  const descricaoBreve = conclusaoDescricaoBreve
    ? conclusaoDescricaoBreve.value.trim()
    : "";
  if (!descricaoBreve || descricaoBreve.length < MIN_DESCRICAO_BREVE) {
    mostrarMensagemConclusao(
      `Informe a descricao tecnica (minimo ${MIN_DESCRICAO_BREVE} caracteres).`,
      true
    );
    return;
  }
  const observacaoExecucao = registro.observacaoExecucao || "";
  const registroAtualizado = resultado
    ? { ...registro, resultado, comentario, executadoPor }
    : { ...registro, comentario, executadoPor };
  const referenciaInformada = conclusaoReferencia ? conclusaoReferencia.value.trim() : "";
  const referencia = referenciaInformada || (liberacao ? liberacao.osNumero || "" : "");
  if (!referencia) {
    mostrarMensagemConclusao("Informe o Nº OS / referência.", true);
    return;
  }
  const inicioValor = conclusaoInicio ? conclusaoInicio.value : "";
  const inicioDate =
    parseDateTimeInput(inicioValor) ||
    (item.executionStartedAt ? parseTimestamp(item.executionStartedAt) : null);
  if (!inicioDate) {
    mostrarMensagemConclusao("Informe o horário de início da execução.", true);
    return;
  }
  const fimValor = conclusaoFim ? conclusaoFim.value : "";
  const fimDate = parseDateTimeInput(fimValor);
  if (!fimDate) {
    mostrarMensagemConclusao("Informe o horário de fim da execução.", true);
    return;
  }
  if (fimDate < inicioDate) {
    mostrarMensagemConclusao("Fim deve ser maior ou igual ao início.", true);
    return;
  }
  const duracaoHoras = (fimDate.getTime() - inicioDate.getTime()) / 3600000;
  if (duracaoHoras > MAX_EXECUCAO_HORAS) {
    const confirmar = window.confirm(
      `Execução com ${Math.round(duracaoHoras)}h. Deseja continuar?`
    );
    if (!confirmar) {
      return;
    }
  }
  const fotosObrigatorias = !conclusaoFotosToggle || conclusaoFotosToggle.checked;
  const arquivos = fotosObrigatorias ? getEvidenciaFiles() : [];
  const arquivosValidos = arquivos.filter(Boolean);
  if (fotosObrigatorias && arquivosValidos.length < MIN_EVIDENCIAS) {
    mostrarMensagemConclusao(`Adicione as ${MIN_EVIDENCIAS} fotos obrigatórias.`, true);
    return;
  }
  if (fotosObrigatorias) {
    const arquivosInvalidos = arquivosValidos.filter(
      (file) => !file.type || !file.type.startsWith("image/")
    );
    if (arquivosInvalidos.length) {
      mostrarMensagemConclusao("Apenas fotos são permitidas.", true);
      return;
    }
  }
  if (fotosObrigatorias) {
    mostrarMensagemConclusao("Enviando evidências...");
  }
  let evidencias = [];
  if (fotosObrigatorias) {
    try {
      evidencias = await lerEvidencias(arquivosValidos);
    } catch (error) {
      mostrarMensagemConclusao(
        error && error.message ? error.message : "Falha ao enviar evidências.",
        true
      );
      return;
    }
  }
  if (fotosObrigatorias && evidencias.length < MIN_EVIDENCIAS) {
    mostrarMensagemConclusao("Não foi possível ler as evidências.", true);
    return;
  }

  const minutos = (fimDate.getTime() - inicioDate.getTime()) / 60000;
  const inicioIso = toIsoUtc(inicioDate);
  const fimIso = toIsoUtc(fimDate);
  const conclusao = {
    executadoPor,
    encerradoPor: currentUser.id,
    inicio: inicioIso,
    fim: fimIso,
    duracaoMin: Math.round(minutos),
    comentario,
    resultado,
    referencia,
    osNumero: liberacao ? liberacao.osNumero || "" : "",
    participantes: liberacao ? liberacao.participantes || [] : [],
    critico: liberacao ? liberacao.critico : undefined,
    categoria: item.categoria || "",
    prioridade: item.prioridade || "",
    equipamentoId:
      item.equipamentoId ||
      (typeof item.equipamento === "string" ? item.equipamento : "") ||
      (item.equipamento && typeof item.equipamento === "object"
        ? item.equipamento.id || item.equipamento.nome || item.equipamento.name || ""
        : ""),
    observacaoExecucao,
    descricaoBreve,
    evidencias,
  };

  const atualizado = {
    ...item,
    registroExecucao: registroAtualizado,
    executionStartedAt: inicioIso,
    executionFinishedAt: fimIso,
    status: "concluida",
    doneAt: fimIso,
    doneBy: currentUser.id,
    updatedAt: toIsoUtc(new Date()),
    updatedBy: currentUser.id,
    conclusao,
  };

  manutencoes[index] = atualizado;
  salvarManutencoes(manutencoes);
  const dataProgramada = item.data ? parseDate(item.data) : null;
  const atrasoDias =
    dataProgramada && fimDate
      ? diffInDays(startOfDay(dataProgramada), startOfDay(fimDate))
      : null;
  const documentosLista = DOC_KEYS.filter(
    (key) => liberacao && liberacao.documentos && liberacao.documentos[key]
  ).map((key) => DOC_LABELS[key] || key);
  logAction("complete", atualizado, {
    dataProgramada: item.data || "",
    dataConclusao: formatDateISO(startOfDay(fimDate)),
    atrasoDias,
    executadoPor,
    resultado,
    referencia,
    osNumero: liberacao ? liberacao.osNumero || "" : "",
    participantes: liberacao ? liberacao.participantes || [] : [],
    critico: liberacao ? liberacao.critico : undefined,
    documentos: documentosLista,
    observacaoExecucao,
    descricaoBreve: truncarTexto(descricaoBreve, 180),
    evidenciasCount: evidencias.length,
    inicioExecucao: inicioIso,
    fimExecucao: fimIso,
    resumo: `Executada por ${getUserLabel(executadoPor)} | ${formatDuracaoMin(minutos)}`,
  });
  renderTudo();
  fecharConclusao();
  mostrarMensagemManutencao("Manutenção concluída.");
}

function toggleConclusaoFotosUI() {
  const ativo = !conclusaoFotosToggle || conclusaoFotosToggle.checked;
  if (conclusaoEvidenciasField) {
    conclusaoEvidenciasField.hidden = !ativo;
  }
  evidenciaInputs.forEach((input) => {
    if (!input) {
      return;
    }
    input.disabled = !ativo;
    if (!ativo) {
      input.value = "";
    }
  });
  evidenciaButtons.forEach((button) => {
    if (button) {
      button.disabled = !ativo;
    }
  });
  atualizarListaEvidencias();
}

function abrirRelatorio(item) {
  if (!modalRelatorio) {
    return;
  }
  const conclusao = item.conclusao || {};
  const liberacao = getLiberacao(item) || {};
  const inicio = conclusao.inicio ? parseTimestamp(conclusao.inicio) : null;
  const fim = conclusao.fim ? parseTimestamp(conclusao.fim) : null;

  if (relatorioTipo) {
    relatorioTipo.textContent = item.titulo || "-";
  }
  if (relatorioSubestacao) {
    relatorioSubestacao.textContent = item.local || "-";
  }
  if (relatorioCodigo) {
    relatorioCodigo.textContent = item.id || "-";
  }
  if (relatorioAbertaEm) {
    const createdAt = parseTimestamp(item.createdAt);
    relatorioAbertaEm.textContent = createdAt ? formatDateTime(createdAt) : "-";
  }
  if (relatorioInicio) {
    relatorioInicio.textContent = inicio ? formatDateTime(inicio) : "-";
  }
  if (relatorioFim) {
    relatorioFim.textContent = fim ? formatDateTime(fim) : "-";
  }
  if (relatorioDuracao) {
    const duracaoMin = Number.isFinite(conclusao.duracaoMin) ? conclusao.duracaoMin : null;
    relatorioDuracao.textContent = duracaoMin !== null ? formatDuracaoMin(duracaoMin) : "-";
  }
  if (relatorioAbertaPor) {
    relatorioAbertaPor.textContent = getUserLabel(item.createdBy);
  }
  if (relatorioExecutadaPor) {
    relatorioExecutadaPor.textContent = getUserLabel(conclusao.executadoPor || item.doneBy);
  }
  if (relatorioEncerradaPor) {
    relatorioEncerradaPor.textContent = getUserLabel(conclusao.encerradoPor || item.doneBy);
  }
  if (relatorioResultado) {
    const label = RESULTADO_LABELS[conclusao.resultado] || "-";
    relatorioResultado.textContent = label;
  }
  if (relatorioReferencia) {
    relatorioReferencia.textContent = conclusao.referencia || liberacao.osNumero || "-";
  }
  if (relatorioEmitidoEm) {
    relatorioEmitidoEm.textContent = formatDateTime(new Date());
  }
  if (relatorioDescricao) {
    relatorioDescricao.textContent = conclusao.comentario || item.observacao || "-";
  }
  if (relatorioObsExecucao) {
    relatorioObsExecucao.textContent = conclusao.observacaoExecucao || "-";
  }

  if (relatorioEvidencias) {
    relatorioEvidencias.innerHTML = "";
    const evidencias = Array.isArray(conclusao.evidencias) ? conclusao.evidencias : [];
    if (evidencias.length === 0) {
      const vazio = document.createElement("p");
      vazio.className = "empty-state";
      vazio.textContent = "Sem evidências.";
      relatorioEvidencias.append(vazio);
    } else {
      evidencias.forEach((evidencia) => {
        const evidenceUrl = resolvePublicUrl(evidencia.dataUrl || evidencia.url || "");
        if (evidencia.type && evidencia.type.startsWith("image/")) {
          const img = document.createElement("img");
          img.src = evidenceUrl;
          img.alt = evidencia.nome || "Evidência";
          relatorioEvidencias.append(img);
          return;
        }
        const link = document.createElement("a");
        link.href = evidenceUrl || "#";
        link.target = "_blank";
        link.rel = "noopener";
        link.textContent = evidencia.nome || "Arquivo";
        relatorioEvidencias.append(link);
      });
    }
  }

  modalRelatorio.hidden = false;
}

function fecharRelatorio() {
  if (!modalRelatorio) {
    return;
  }
  modalRelatorio.hidden = true;
}

function imprimirRelatorio() {
  if (!modalRelatorio || modalRelatorio.hidden) {
    return;
  }
  window.print();
}

async function reabrirManutencao(index) {
  if (!canReopenMaintenance(currentUser)) {
    mostrarMensagemManutencao("Sem permissão para reabrir manutenções.", true);
    return;
  }
  const item = manutencoes[index];
  if (!item || item.status !== "concluida") {
    mostrarMensagemManutencao("Apenas manutenções concluídas podem ser reabertas.", true);
    return;
  }
  const confirmar = await openConfirmModal({
    title: "Reabrir manutenção",
    message:
      "Reabrir esta manutenção? Ela volta para execução e poderá ser concluída novamente.",
    confirmText: "Reabrir",
    cancelText: "Cancelar",
  });
  if (!confirmar) {
    return;
  }
  try {
    const response = await apiMaintenanceReopen({ id: item.id, projectId: activeProjectId });
    const atualizado = response && response.item ? response.item : { ...item, status: "em_execucao" };
    manutencoes[index] = atualizado;
    salvarManutencoes(manutencoes);
    logAction("reopen", atualizado, { resumo: "Reaberta" });
    renderTudo();
    mostrarMensagemManutencao("Manutenção reaberta.");
  } catch (error) {
    const message = error && error.message ? error.message : "Falha ao reabrir manutenção.";
    mostrarMensagemManutencao(message, true);
  }
}

async function removerManutencao(index) {
  if (!canDeleteMaintenance(currentUser)) {
    mostrarMensagemManutencao("Sem permiss\u00e3o para excluir manutencoes.", true);
    return;
  }
  const item = manutencoes[index];
  const isConcluida = item && item.status === "concluida";
  const confirmar = await openConfirmModal({
    title: isConcluida ? "Excluir manutenção concluída" : "Excluir manutenção",
    message: isConcluida
      ? "Excluir esta manutenção concluída? Esta ação remove histórico e evidências."
      : "Excluir esta manutenção?",
    confirmText: "Excluir",
    cancelText: "Cancelar",
  });
  if (!confirmar) {
    return;
  }
  try {
    await apiMaintenanceDelete(item.id, activeProjectId);
    markMaintenanceDeletedIds(item.id);
    clearMaintenanceDirtyIds(item.id);
    const serverIds = maintenanceServerIdsByProject.get(activeProjectId || "");
    if (serverIds) {
      serverIds.delete(String(item.id));
    }
    if (item && item.templateId && item.data) {
      addRecurrenceSuppression(item.templateId, item.data);
    }
    manutencoes = manutencoes.filter(
      (entry) => entry && String(entry.id) !== String(item.id)
    );
    salvarManutencoes(manutencoes);
    logAction("remove", item, { resumo: "Excluida" });
    renderTudo();
    mostrarMensagemManutencao("Manutencao excluida.");
  } catch (error) {
    const message = error && error.message ? error.message : "Falha ao excluir manutencao.";
    mostrarMensagemManutencao(message, true);
  }
}

function agirNaManutencao(event) {
  const botao = event.target.closest("button[data-action]");
  if (!botao) {
    return;
  }

  const card = botao.closest("[data-id]");
  if (!card) {
    return;
  }

  const id = card.dataset.id;
  const index = manutencoes.findIndex((item) => item.id === id);
  if (index < 0) {
    return;
  }

  const acao = botao.dataset.action;
  if (acao === "edit") {
    editarManutencao(index);
  }
  if (acao === "note") {
    registrarObservacao(index);
  }
  if (acao === "backlog_reason") {
    registrarMotivoBacklog(index);
  }
  if (acao === "reschedule") {
    reagendarManutencao(index);
  }
  if (acao === "release") {
    liberarManutencao(index);
  }
  if (acao === "execute") {
    executarManutencao(index);
  }
  if (acao === "register") {
    abrirRegistroExecucao(manutencoes[index]);
  }
  if (acao === "cancel_start") {
    abrirCancelarInicio(manutencoes[index]);
  }
  if (acao === "finish") {
    abrirConclusao(manutencoes[index]);
  }
  if (acao === "reopen") {
    reabrirManutencao(index);
  }
  if (acao === "history") {
    abrirHistorico(manutencoes[index]);
  }
  if (acao === "remove") {
    removerManutencao(index);
  }
}

function ativarTab(nome) {
  tabButtons.forEach((botao) => {
    const ativo = botao.dataset.tab === nome;
    botao.classList.toggle("is-active", ativo);
    botao.classList.toggle("active", ativo);
  });
  panels.forEach((panel) => {
    panel.classList.toggle("is-active", panel.dataset.panel === nome);
  });
  if (crumbs) {
    renderBreadcrumb();
  }
  atualizarTituloPagina(nome);
  if (currentUser && nome && nome.startsWith("sst")) {
    carregarSst(true);
  }
  if (currentUser && nome === "feedbacks") {
    carregarFeedbacks(true);
  }
}

async function authLoginLocal(login, senha) {
  const matricula = String(login || "").trim();
  const password = String(senha || "");
  if (!matricula || !password) {
    throw new Error("Informe usuario e senha.");
  }
  await dataProvider.roles.seedDefaultRolesIfEmpty();
  try {
    await ensureBootstrapAccessAccount();
  } catch (error) {
    // noop
  }
  const account = await getUserByMatriculaNormalized(normalizeMatricula(matricula));
  if (!account) {
    throw new Error("Usuario ou senha invalidos.");
  }
  if (normalizeAccessUserStatus(account.status, account.active) === "INATIVO") {
    throw new Error("Conta inativa.");
  }
  const ok = await verifyPasswordHash(password, account.passwordHash);
  if (!ok) {
    throw new Error("Usuario ou senha invalidos.");
  }
  const role = await resolveRoleFromDb(account);
  const user = buildSessionUser(account, role);
  salvarSessao({ userId: user.id, createdAt: toIsoUtc(new Date()) });
  return { user };
}

async function authLogoutLocal() {
  salvarSessao(null);
  currentUser = null;
  users = [];
  accessUsers = [];
  renderAuthUI();
}

async function apiLogin(login, senha) {
  if (USE_AUTH_API) {
    return apiRequest("/api/auth/login", {
      method: "POST",
      body: JSON.stringify({ login, senha }),
    });
  }
  return authLoginLocal(login, senha);
}

async function apiLogout() {
  if (USE_AUTH_API) {
    return apiRequest("/api/auth/logout", { method: "POST", body: "{}" });
  }
  return authLogoutLocal();
}

async function apiRegister(payload) {
  return apiRequest("/api/auth/register", {
    method: "POST",
    body: JSON.stringify(payload),
  });
}

async function apiVerifyEmail(token) {
  const safeToken = encodeURIComponent(String(token || ""));
  return apiRequest(`/api/auth/verify?token=${safeToken}`, { method: "GET" });
}

async function apiVerifyEmailCode(email, code) {
  return apiRequest("/api/auth/verify-code", {
    method: "POST",
    body: JSON.stringify({ email, code }),
  });
}

async function apiResendVerificationCode(email) {
  return apiRequest("/api/auth/verify/resend", {
    method: "POST",
    body: JSON.stringify({ email }),
  });
}

async function apiPasswordResetRequest(email) {
  return apiRequest("/api/auth/password-reset/request", {
    method: "POST",
    body: JSON.stringify({ email }),
  });
}

async function apiPasswordResetConfirm(payload) {
  return apiRequest("/api/auth/password-reset/confirm", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiPasswordResetValidate(email, code) {
  return apiRequest("/api/auth/password-reset/validate", {
    method: "POST",
    body: JSON.stringify({ email, code }),
  });
}

async function apiInvite(role) {
  return apiRequest("/api/auth/invite", {
    method: "POST",
    body: JSON.stringify({ role }),
  });
}

async function apiAdminUsers() {
  return apiRequest("/api/admin/users");
}

async function apiAdminAutomations() {
  if (!USE_AUTH_API) {
    return { automations: readGerencialAutomationsStorage() };
  }
  try {
    return await apiRequest("/api/admin/automations");
  } catch (error) {
    if (shouldFallbackAdminRequest(error)) {
      return { automations: readGerencialAutomationsStorage() };
    }
    throw error;
  }
}

async function apiUpdateAutomation(automationId, payload) {
  const updateLocal = () => {
    const id = String(automationId || "").trim();
    if (!id) {
      throw new Error("Automacao invalida.");
    }
    const list = readGerencialAutomationsStorage();
    const index = list.findIndex((item) => String(item.id) === id);
    if (index < 0) {
      throw new Error("Automacao nao encontrada.");
    }
    const updated = {
      ...list[index],
      ...(payload || {}),
      id,
      updatedAt: new Date().toISOString(),
    };
    list[index] = updated;
    writeGerencialAutomationsStorage(list);
    return { automations: list };
  };
  if (!USE_AUTH_API) {
    return updateLocal();
  }
  const safeId = encodeURIComponent(String(automationId || ""));
  try {
    return await apiRequest(`/api/admin/automations/${safeId}`, {
      method: "PATCH",
      body: JSON.stringify(payload || {}),
    });
  } catch (error) {
    if (shouldFallbackAdminRequest(error)) {
      return updateLocal();
    }
    throw error;
  }
}

async function apiAdminFiles(params = {}) {
  const readLocal = () => {
    const typeFilter = String(params.type || "").trim();
    const search = normalizeSearchValue(String(params.search || "").trim());
    const list = readGerencialFilesStorage();
    const filtered = list.filter((file) => {
      if (typeFilter && String(file.type || "") !== typeFilter) {
        return false;
      }
      if (!search) {
        return true;
      }
      const haystack = normalizeSearchValue(
        `${file.originalName || ""} ${file.name || ""} ${file.type || ""}`
      );
      return haystack.includes(search);
    });
    return { files: filtered, total: filtered.length };
  };
  if (!USE_AUTH_API) {
    return readLocal();
  }
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  try {
    return await apiRequest(`/api/admin/files${suffix ? `?${suffix}` : ""}`);
  } catch (error) {
    if (shouldFallbackAdminRequest(error)) {
      return readLocal();
    }
    throw error;
  }
}

async function apiUploadFile(formData) {
  const uploadLocal = async () => {
    const type = String(formData.get("type") || "").trim();
    const file = formData.get("file");
    if (!type) {
      throw new Error("Tipo do arquivo invalido.");
    }
    if (!file) {
      throw new Error("Arquivo invalido.");
    }
    const doc = await lerDocumentoFile(file);
    if (!doc || !doc.dataUrl) {
      throw new Error("Falha ao ler arquivo.");
    }
    const now = new Date().toISOString();
    const entry = {
      id: criarId(),
      type,
      name: file.name || doc.nome || "arquivo",
      originalName: file.name || doc.nome || "arquivo",
      mime: file.type || doc.type || "",
      size: file.size || 0,
      url: doc.dataUrl,
      createdAt: now,
      createdBy: currentUser ? currentUser.id : "",
    };
    const list = readGerencialFilesStorage();
    list.unshift(entry);
    writeGerencialFilesStorage(list);
    return { file: entry, files: list };
  };
  if (!USE_AUTH_API) {
    return uploadLocal();
  }
  const response = await fetch(`${API_BASE}/api/admin/files`, {
    method: "POST",
    credentials: "include",
    body: formData,
  });
  const data = await response.json().catch(() => ({}));
  if (!response.ok) {
    const message = data && data.message ? data.message : "Falha no upload.";
    const error = new Error(message);
    error.status = response.status;
    error.data = data;
    if (shouldFallbackAdminRequest(error)) {
      return uploadLocal();
    }
    throw error;
  }
  return data;
}

async function apiUploadLiberacaoDoc(formData) {
  const response = await fetch(`${API_BASE}/api/maintenance/liberacao-doc`, {
    method: "POST",
    credentials: "include",
    body: formData,
  });
  const data = await response.json().catch(() => ({}));
  if (!response.ok) {
    const message = data && data.message ? data.message : "Falha no envio do documento.";
    const error = new Error(message);
    error.status = response.status;
    error.data = data;
    throw error;
  }
  return data;
}

async function apiUploadEvidence(formData) {
  const response = await fetch(`${API_BASE}/api/maintenance/evidence`, {
    method: "POST",
    credentials: "include",
    body: formData,
  });
  const data = await response.json().catch(() => ({}));
  if (!response.ok) {
    const message = data && data.message ? data.message : "Falha ao enviar evidência.";
    const error = new Error(message);
    error.status = response.status;
    error.data = data;
    throw error;
  }
  return data;
}

async function apiDeleteFile(fileId) {
  const deleteLocal = () => {
    const id = String(fileId || "").trim();
    if (!id) {
      return { ok: true };
    }
    const list = readGerencialFilesStorage().filter((file) => String(file.id) !== id);
    writeGerencialFilesStorage(list);
    return { ok: true };
  };
  if (!USE_AUTH_API) {
    return deleteLocal();
  }
  const safeId = encodeURIComponent(String(fileId || ""));
  try {
    return await apiRequest(`/api/admin/files/${safeId}`, {
      method: "DELETE",
      body: "{}",
    });
  } catch (error) {
    if (shouldFallbackAdminRequest(error)) {
      return deleteLocal();
    }
    throw error;
  }
}

async function apiAdminHealth() {
  if (!USE_AUTH_API) {
    return buildLocalHealthSnapshot();
  }
  try {
    return await apiRequest("/api/admin/health");
  } catch (error) {
    if (shouldFallbackAdminRequest(error)) {
      return buildLocalHealthSnapshot();
    }
    throw error;
  }
}

async function apiAdminLogs(params = {}) {
  if (!USE_AUTH_API) {
    return { logs: [], total: 0, filteredTotal: 0 };
  }
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  try {
    return await apiRequest(`/api/admin/logs${suffix ? `?${suffix}` : ""}`);
  } catch (error) {
    if (shouldFallbackAdminRequest(error)) {
      return { logs: [], total: 0, filteredTotal: 0 };
    }
    throw error;
  }
}

async function apiRunHealthTask(taskId) {
  if (!USE_AUTH_API) {
    return { ok: true, snapshot: buildLocalHealthSnapshot() };
  }
  const safeId = encodeURIComponent(String(taskId || ""));
  try {
    return await apiRequest(`/api/admin/health/tasks/${safeId}/run`, {
      method: "POST",
      body: "{}",
    });
  } catch (error) {
    if (shouldFallbackAdminRequest(error)) {
      return { ok: true, snapshot: buildLocalHealthSnapshot() };
    }
    throw error;
  }
}

async function apiAdminPermissions() {
  return apiRequest("/api/admin/permissions");
}

async function apiAdminPermissoes() {
  if (!USE_AUTH_API) {
    return { values: readGerencialPermissoesStorage(), profiles: [], permissions: [] };
  }
  try {
    return await apiRequest("/api/admin/permissoes");
  } catch (error) {
    if (shouldFallbackAdminRequest(error)) {
      return { values: readGerencialPermissoesStorage(), profiles: [], permissions: [] };
    }
    throw error;
  }
}

async function apiSalvarPermissoes(payload) {
  const saveLocal = () => {
    const values = payload && payload.values ? payload.values : {};
    writeGerencialPermissoesStorage(values);
    return { values, profiles: [], permissions: [] };
  };
  if (!USE_AUTH_API) {
    return saveLocal();
  }
  try {
    return await apiRequest("/api/admin/permissoes", {
      method: "PUT",
      body: JSON.stringify(payload),
    });
  } catch (error) {
    if (shouldFallbackAdminRequest(error)) {
      return saveLocal();
    }
    throw error;
  }
}

async function apiAdminUpdateUser(userId, payload) {
  return apiRequest(`/api/admin/users/${userId}`, {
    method: "PATCH",
    body: JSON.stringify(payload),
  });
}

async function apiUpdateProfile(payload) {
  if (!USE_AUTH_API) {
    if (!currentUser) {
      throw new Error("Nao autorizado.");
    }
    const updated = await updateUserToDb({ id: currentUser.id, ...(payload || {}) });
    const user = buildSessionUser(updated, resolveRoleFromAccessMap(updated));
    return { user };
  }
  return apiRequest("/api/profile", {
    method: "PATCH",
    body: JSON.stringify(payload),
  });
}

async function updateProfileForUser(userId, payload) {
  const targetId = String(userId || "").trim();
  if (!targetId) {
    throw new Error("Usuario invalido.");
  }
  if (!USE_AUTH_API) {
    const updated = await updateUserToDb({ id: targetId, ...(payload || {}) });
    const user = buildSessionUser(updated, resolveRoleFromAccessMap(updated));
    return { user };
  }
  if (currentUser && String(currentUser.id) === targetId) {
    return apiUpdateProfile(payload);
  }
  const data = await apiAdminUpdateUser(targetId, payload);
  const updated = data && (data.user || data);
  if (updated) {
    return { user: buildSessionUser(updated, resolveRoleFromAccessMap(updated)) };
  }
  return { user: null };
}

async function apiUploadAvatar(dataUrl) {
  return apiRequest("/api/profile/avatar", {
    method: "POST",
    body: JSON.stringify({ dataUrl }),
  });
}

async function apiDeleteAvatar() {
  return apiRequest("/api/profile/avatar", {
    method: "DELETE",
    body: "{}",
  });
}

async function apiMaintenanceSync(items) {
  return apiRequest("/api/maintenance/sync", {
    method: "POST",
    body: JSON.stringify({ items }),
  });
}

async function apiTemplatesList(projectId) {
  const query = projectId ? `?projectId=${encodeURIComponent(projectId)}` : "";
  return apiRequest(`/api/maintenance/templates${query}`);
}

async function apiTemplatesSync(items, projectId) {
  return apiRequest("/api/maintenance/templates/sync", {
    method: "POST",
    body: JSON.stringify({
      projectId: projectId || "",
      items: Array.isArray(items) ? items : [],
    }),
  });
}

async function apiMaintenanceList(projectId) {
  const query = projectId ? `?projectId=${encodeURIComponent(projectId)}` : "";
  return apiRequest(`/api/maintenance${query}`);
}

async function apiMaintenanceDelete(maintenanceId, projectId) {
  if (!USE_AUTH_API) {
    return { ok: true };
  }
  const query = projectId ? `?projectId=${encodeURIComponent(projectId)}` : "";
  return apiRequest(`/api/maintenance/${encodeURIComponent(maintenanceId)}${query}`, {
    method: "DELETE",
  });
}

async function apiMaintenanceRelease(payload) {
  return apiRequest("/api/maintenance/release", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiRdoGenerateText(payload) {
  return apiRequest("/api/rdo/generate-text", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiMaintenanceReopen(payload) {
  return apiRequest("/api/maintenance/reopen", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

function normalizeMaintenanceStatus(raw) {
  const value = String(raw || "").trim().toLowerCase();
  if (!value) {
    return "agendada";
  }
  const normalized = value
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");
  if (
    [
      "concluida",
      "concluido",
      "executada",
      "executadas",
      "executado",
      "executados",
      "done",
      "completed",
      "finalizada",
      "finalizado",
    ].includes(
      normalized
    )
  ) {
    return "concluida";
  }
  if (["cancelada", "cancelado", "canceled", "cancelled"].includes(normalized)) {
    return "cancelada";
  }
  if (["em_execucao", "execucao", "executando", "em_exec"].includes(normalized)) {
    return "em_execucao";
  }
  if (
    [
      "encerramento",
      "encerrando",
      "encerrado",
      "encerrada",
      "encerradas",
      "finalizacao",
    ].includes(normalized)
  ) {
    return "encerramento";
  }
  if (["backlog", "atrasada", "atrasado", "overdue"].includes(normalized)) {
    return "backlog";
  }
  if (
    [
      "liberada",
      "liberado",
      "liberacao",
      "liberado_para_execucao",
      "liberada_para_execucao",
      "released",
    ].includes(normalized)
  ) {
    return "liberada";
  }
  if (
    ["agendada", "agendado", "programada", "programado", "pendente", "scheduled"].includes(
      normalized
    )
  ) {
    return "agendada";
  }
  return "agendada";
}

function getMaintenanceDueDate(item) {
  if (!item) {
    return null;
  }
  return parseDateOnly(item.prazo || item.data || item.dueDate || item.prazoManutencao);
}

function getMaintenanceCompletedAt(item) {
  if (!item) {
    return null;
  }
  return parseDateTime(
    item.dataConclusao || item.doneAt || item.concluidaEm || item.concluidoEm || item.completedAt
  );
}

function isMaintenanceCritical(item) {
  if (!item) {
    return false;
  }
  const crit = String(item.criticidade || "").trim().toLowerCase();
  return Boolean(
    item.safetyCritical ||
      item.critico ||
      crit === "alta" ||
      crit === "critica" ||
      crit === "critico" ||
      crit === "sim"
  );
}

function getMaintenanceTitle(item) {
  return (
    String(item.atividade || item.titulo || item.nome || item.task || "Atividade").trim() ||
    "Atividade"
  );
}

function getMaintenanceOwner(item) {
  const raw = String(
    item.responsavel ||
      item.executadaPor ||
      item.owner ||
      item.responsavelManutencao ||
      "Equipe"
  ).trim();
  if (!raw) {
    return "Equipe";
  }
  if (raw.toLowerCase().startsWith("team:")) {
    const cleaned = raw.slice(5).trim();
    return cleaned || "Equipe";
  }
  return raw;
}

function buildLocalDashboardSummary(items, projectId) {
  const list = Array.isArray(items) ? items : [];
  const today = startOfDay(new Date());
  const pendingItems = [];
  const completedItems = [];
  let missingCompletionDates = 0;

  list.forEach((item) => {
    const status = normalizeMaintenanceStatus(item && item.status);
    if (status === "cancelada") {
      return;
    }
    if (status === "concluida") {
      completedItems.push(item);
      return;
    }
    pendingItems.push(item);
  });

  const venceHoje = pendingItems.filter((item) => {
    if (hasExecucaoRegistradaCompleta(item)) {
      return false;
    }
    const due = getMaintenanceDueDate(item);
    return due && isSameDay(due, today);
  }).length;

  const atrasadas = pendingItems.filter((item) => {
    if (hasExecucaoRegistradaCompleta(item)) {
      return false;
    }
    const status = normalizeMaintenanceStatus(item && item.status);
    if (status !== "backlog") {
      return false;
    }
    const due = getMaintenanceDueDate(item);
    return Boolean(due && due < today);
  }).length;

  const criticas = pendingItems.filter((item) => isMaintenanceCritical(item)).length;
  const aguardandoConclusao = pendingItems.filter((item) => {
    if (hasExecucaoRegistradaCompleta(item)) {
      return true;
    }
    const status = normalizeMaintenanceStatus(item && item.status);
    return status === "encerramento";
  }).length;

  const score = atrasadas * 2 + criticas * 3 + venceHoje;
  let riscoImediato = "Baixo";
  if (score > 12) {
    riscoImediato = "Crítico";
  } else if (score >= 7) {
    riscoImediato = "Alto";
  } else if (score >= 3) {
    riscoImediato = "Moderado";
  }

  const alertasOperacionais = [];
  pendingItems
    .filter((item) => isMaintenanceCritical(item))
    .slice(0, 3)
    .forEach((item) => {
      const due = getMaintenanceDueDate(item);
      const dueLabel = due ? formatDateISO(due) : "--";
      alertasOperacionais.push({
        tipo: "critico",
        msg: `${getMaintenanceTitle(item)} - prazo ${dueLabel}`,
      });
    });

  if (alertasOperacionais.length < 3) {
    pendingItems
      .filter((item) => {
        if (isMaintenanceCritical(item)) {
          return false;
        }
        const due = getMaintenanceDueDate(item);
        return due && (due < today || isSameDay(due, today));
      })
      .slice(0, 3 - alertasOperacionais.length)
      .forEach((item) => {
        const due = getMaintenanceDueDate(item);
        const dueLabel = due ? formatDateISO(due) : "--";
        alertasOperacionais.push({
          tipo: "aviso",
          msg: `${getMaintenanceTitle(item)} - prazo ${dueLabel}`,
        });
      });
  }

  const backlogTotal = pendingItems.filter((item) => {
    if (hasExecucaoRegistradaCompleta(item)) {
      return false;
    }
    const status = normalizeMaintenanceStatus(item && item.status);
    if (status === "backlog") {
      return true;
    }
    if (status === "em_execucao" || status === "encerramento") {
      return false;
    }
    const due = getMaintenanceDueDate(item);
    return due && due < today;
  }).length;

  let concluidasTotal = 0;
  let concluidasNoPrazo = 0;
  let concluidasPeriodo = 0;

  completedItems.forEach((item) => {
    let completedAt = getMaintenanceCompletedAt(item);
    if (!completedAt) {
      completedAt = today;
      missingCompletionDates += 1;
    }
    const completedDay = startOfDay(completedAt);
    concluidasTotal += 1;
    const due = getMaintenanceDueDate(item);
    if (!due || completedDay <= due) {
      concluidasNoPrazo += 1;
    }
    concluidasPeriodo += 1;
  });

  const pontualidadePct = concluidasTotal
    ? Math.round((concluidasNoPrazo / concluidasTotal) * 100)
    : 0;

  const atrasos = pendingItems
    .map((item) => {
      const status = normalizeMaintenanceStatus(item && item.status);
      if (status === "em_execucao" || status === "encerramento") {
        return null;
      }
      const due = getMaintenanceDueDate(item);
      if (!due || due >= today) {
        return null;
      }
      return diffInDays(due, today);
    })
    .filter((value) => typeof value === "number");
  const atrasoMedioDias = atrasos.length
    ? Number((atrasos.reduce((acc, value) => acc + value, 0) / atrasos.length).toFixed(1))
    : 0;

  const proximasAtividades = pendingItems
    .filter((item) => {
      const status = normalizeMaintenanceStatus(item && item.status);
      return status === "agendada" || status === "liberada";
    })
    .map((item) => {
      const due = getMaintenanceDueDate(item);
      return due ? { item, due } : null;
    })
    .filter(Boolean)
    .sort((a, b) => a.due - b.due)
    .slice(0, 5)
    .map(({ item, due }) => {
      let status = "Em dia";
      if (isSameDay(due, today)) {
        status = "Hoje";
      } else if (due < today) {
        status = "Atrasada";
      }
      return {
        atividade: getMaintenanceTitle(item),
        responsavel: getMaintenanceOwner(item),
        prazo: formatDateISO(due),
        status,
      };
    });

  const labels = [];
  const serie = [];
  const recentDays = [];
  for (let i = 0; i < 7; i += 1) {
    const day = startOfDay(addDays(today, -6 + i));
    labels.push(formatShortLabel(day));
    recentDays.push(day);
    const programadas = list.filter((item) => {
      const due = getMaintenanceDueDate(item);
      if (!due || !isSameDay(due, day)) {
        return false;
      }
      return normalizeMaintenanceStatus(item && item.status) !== "cancelada";
    });
    if (!programadas.length) {
      serie.push(null);
      continue;
    }
    const concluidasNoPrazoDia = programadas.filter((item) => {
      if (normalizeMaintenanceStatus(item && item.status) !== "concluida") {
        return false;
      }
      let completedAt = getMaintenanceCompletedAt(item);
      if (!completedAt) {
        completedAt = day;
        missingCompletionDates += 1;
      }
      const due = getMaintenanceDueDate(item);
      return !due || completedAt <= due;
    });
    const eficiencia = Math.round((concluidasNoPrazoDia.length / programadas.length) * 100);
    serie.push(eficiencia);
  }

  const miniSeries = {
    backlog: recentDays.map((day) => {
      return pendingItems.filter((item) => {
        if (hasExecucaoRegistradaCompleta(item)) {
          return false;
        }
        const status = normalizeMaintenanceStatus(item && item.status);
        if (status === "backlog") {
          return true;
        }
        if (status === "em_execucao" || status === "encerramento") {
          return false;
        }
        const due = getMaintenanceDueDate(item);
        return due && due < day;
      }).length;
    }),
    concluidas: recentDays.map((day) => {
      return completedItems.filter((item) => {
        const completedAt = getMaintenanceCompletedAt(item);
        if (!completedAt) {
          return false;
        }
        return isSameDay(completedAt, day);
      }).length;
    }),
  };

  const generatedAt = new Date().toISOString();

  return {
    kpis: {
      venceHoje,
      atrasadas,
      criticas,
      riscoImediato,
      aguardandoConclusao,
    },
    alertasOperacionais,
    saudeOperacional: {
      pontualidadePct,
      backlogTotal,
      concluidasPeriodo,
      atrasoMedioDias,
    },
    proximasAtividades,
    miniSeries,
    graficoEficiencia: {
      labels,
      serie,
    },
    meta: {
      generatedAt,
      project: projectId || "",
    },
    generatedAt,
  };
}

async function apiDashboardSummary() {
  if (!USE_AUTH_API) {
    const scoped = Array.isArray(manutencoes)
      ? manutencoes.filter(
          (item) =>
            item && (!activeProjectId || !item.projectId || item.projectId === activeProjectId)
        )
      : [];
    return buildLocalDashboardSummary(scoped, activeProjectId);
  }
  return apiRequest("/api/dashboard/summary");
}

async function apiProjetosList() {
  if (!USE_AUTH_API) {
    seedDefaultProjectsIfEmpty();
    return { projects: readProjectsStorage() };
  }
  return apiRequest("/api/projetos");
}

async function apiProjetosCreate(payload) {
  if (!USE_AUTH_API) {
    const now = toIsoUtc(new Date());
    const record = normalizeProjectRecord({
      ...(payload || {}),
      id: criarId(),
      createdAt: now,
      updatedAt: now,
    });
    if (!record) {
      throw new Error("Informe codigo e nome do projeto.");
    }
    const list = readProjectsStorage();
    const codigo = String(record.codigo || "").trim();
    if (codigo && list.some((item) => String(item.codigo || "").trim() === codigo)) {
      throw new Error("Codigo ja cadastrado.");
    }
    list.push(record);
    writeProjectsStorage(list);
    return { project: record, projects: list };
  }
  return apiRequest("/api/projetos", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiProjetosUpdate(projectId, payload) {
  if (!USE_AUTH_API) {
    const id = String(projectId || "").trim();
    if (!id) {
      throw new Error("Projeto invalido.");
    }
    const list = readProjectsStorage();
    const index = list.findIndex((item) => String(item.id) === id);
    if (index < 0) {
      throw new Error("Projeto nao encontrado.");
    }
    const existing = list[index];
    const now = toIsoUtc(new Date());
    const updated = normalizeProjectRecord({
      ...existing,
      ...(payload || {}),
      id: existing.id,
      createdAt: existing.createdAt || now,
      updatedAt: now,
    });
    if (!updated) {
      throw new Error("Dados do projeto invalidos.");
    }
    const codigo = String(updated.codigo || "").trim();
    if (
      codigo &&
      list.some((item, idx) => idx !== index && String(item.codigo || "").trim() === codigo)
    ) {
      throw new Error("Codigo ja cadastrado.");
    }
    list[index] = updated;
    writeProjectsStorage(list);
    return { project: updated, projects: list };
  }
  return apiRequest(`/api/projetos/${encodeURIComponent(projectId)}`, {
    method: "PUT",
    body: JSON.stringify(payload || {}),
  });
}

async function apiProjetosDelete(projectId) {
  if (!USE_AUTH_API) {
    const id = String(projectId || "").trim();
    if (!id) {
      return { ok: true };
    }
    const list = readProjectsStorage().filter((item) => String(item.id) !== id);
    writeProjectsStorage(list);
    return { ok: true };
  }
  return apiRequest(`/api/projetos/${encodeURIComponent(projectId)}`, {
    method: "DELETE",
  });
}

async function apiProjetosEquipeList(projectId) {
  return apiRequest(`/api/projetos/${encodeURIComponent(projectId)}/equipe`);
}

async function apiProjetosEquipeAdd(projectId, payload) {
  return apiRequest(`/api/projetos/${encodeURIComponent(projectId)}/equipe`, {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiProjetosEquipeRemove(projectId, userId) {
  return apiRequest(
    `/api/projetos/${encodeURIComponent(projectId)}/equipe/${encodeURIComponent(userId)}`,
    { method: "DELETE" }
  );
}

async function apiProjetosEquipamentosList(projectId) {
  return apiRequest(`/api/projetos/${encodeURIComponent(projectId)}/equipamentos`);
}

async function apiProjetosEquipamentosCreate(projectId, payload) {
  return apiRequest(`/api/projetos/${encodeURIComponent(projectId)}/equipamentos`, {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiEquipamentosUpdate(equipamentoId, payload) {
  return apiRequest(`/api/equipamentos/${encodeURIComponent(equipamentoId)}`, {
    method: "PUT",
    body: JSON.stringify(payload || {}),
  });
}

async function apiEquipamentosDelete(equipamentoId) {
  return apiRequest(`/api/equipamentos/${encodeURIComponent(equipamentoId)}`, {
    method: "DELETE",
  });
}

async function apiProjetosGetActive() {
  if (!USE_AUTH_API) {
    const projectId = localStorage.getItem(ACTIVE_PROJECT_KEY) || "";
    return { projectId };
  }
  return apiRequest("/api/projetos/active");
}

async function apiProjetosSetActive(projectId) {
  if (!USE_AUTH_API) {
    return { projectId: String(projectId || "").trim() };
  }
  return apiRequest("/api/projetos/active", {
    method: "POST",
    body: JSON.stringify({ projectId }),
  });
}

async function apiPmpActivitiesList(params = {}) {
  const search = new URLSearchParams();
  if (params.projectId) {
    search.set("projectId", params.projectId);
  }
  if (params.year) {
    search.set("year", params.year);
  }
  const suffix = search.toString();
  return apiRequest(`/api/pmp/activities${suffix ? `?${suffix}` : ""}`);
}

async function apiPmpActivitiesCreate(payload) {
  return apiRequest("/api/pmp/activities", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiPmpActivitiesUpdate(activityId, payload) {
  return apiRequest(`/api/pmp/activities/${encodeURIComponent(activityId)}`, {
    method: "PUT",
    body: JSON.stringify(payload || {}),
  });
}

async function apiPmpActivitiesDelete(activityId) {
  return apiRequest(`/api/pmp/activities/${encodeURIComponent(activityId)}`, {
    method: "DELETE",
  });
}

async function apiPmpExecutionsList(params = {}) {
  const search = new URLSearchParams();
  if (params.projectId) {
    search.set("projectId", params.projectId);
  }
  if (params.year) {
    search.set("year", params.year);
  }
  const suffix = search.toString();
  return apiRequest(`/api/pmp/executions${suffix ? `?${suffix}` : ""}`);
}

async function apiPmpExecutionSave(payload) {
  return apiRequest("/api/pmp/executions", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiPmpExecutionDelete(executionId) {
  return apiRequest(`/api/pmp/executions/${encodeURIComponent(executionId)}`, {
    method: "DELETE",
  });
}

async function apiPmpDuplicate(payload) {
  return apiRequest("/api/pmp/duplicate", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiAlmoxItemsList(params = {}) {
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  return apiRequest(`/api/almox/items${suffix ? `?${suffix}` : ""}`);
}

async function apiAlmoxItemCreate(payload) {
  return apiRequest("/api/almox/items", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiAlmoxMovementsList(params = {}) {
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  return apiRequest(`/api/almox/movements${suffix ? `?${suffix}` : ""}`);
}

async function apiAlmoxMovementCreate(payload) {
  return apiRequest("/api/almox/movements", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiAlmoxStockList(params = {}) {
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  return apiRequest(`/api/almox/stock${suffix ? `?${suffix}` : ""}`);
}

async function apiAlmoxStockUpdate(stockId, payload) {
  const safeId = encodeURIComponent(String(stockId || ""));
  return apiRequest(`/api/almox/stock/${safeId}`, {
    method: "PUT",
    body: JSON.stringify(payload || {}),
  });
}

async function apiAlmoxEpiByUser(params = {}) {
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  return apiRequest(`/api/almox/epi-by-user${suffix ? `?${suffix}` : ""}`);
}

async function apiSstTrainingsList() {
  return apiRequest("/api/sst/trainings");
}

async function apiSstTrainingRecordsList() {
  return apiRequest("/api/sst/training-records");
}

async function apiSstTrainingCreate(payload) {
  return apiRequest("/api/sst/trainings", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiSstInspectionsList(params = {}) {
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  return apiRequest(`/api/sst/inspections${suffix ? `?${suffix}` : ""}`);
}

async function apiSstInspectionCreate(payload) {
  return apiRequest("/api/sst/inspections", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiSstNonconformitiesList(params = {}) {
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  return apiRequest(`/api/sst/nonconformities${suffix ? `?${suffix}` : ""}`);
}

async function apiSstNonconformityCreate(payload) {
  return apiRequest("/api/sst/nonconformities", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiSstIncidentsList(params = {}) {
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  return apiRequest(`/api/sst/incidents${suffix ? `?${suffix}` : ""}`);
}

async function apiSstIncidentCreate(payload) {
  return apiRequest("/api/sst/incidents", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiSstAprsList(params = {}) {
  const query = new URLSearchParams(params);
  const suffix = query.toString();
  return apiRequest(`/api/sst/aprs${suffix ? `?${suffix}` : ""}`);
}

async function apiSstAprCreate(payload) {
  return apiRequest("/api/sst/aprs", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function apiSstPermitsList() {
  return apiRequest("/api/sst/permits");
}

async function apiSstPermitCreate(payload) {
  return apiRequest("/api/sst/permits", {
    method: "POST",
    body: JSON.stringify(payload || {}),
  });
}

async function syncMaintenanceNow(items, force) {
  if (!USE_AUTH_API) {
    return { ok: true, skipped: true };
  }
  if (!currentUser) {
    return { ok: false, skipped: true };
  }
  if (!activeProjectId) {
    return { ok: false, skipped: true };
  }
  if (maintenanceSyncPromise) {
    return maintenanceSyncPromise;
  }
  if (!force && Date.now() - maintenanceLastSync < 10 * 1000) {
    return { ok: true, skipped: true };
  }
  maintenancePendingSync = true;
  const dirtyMap = readMaintenanceDirtyMap();
  const serverIds = maintenanceServerIdsByProject.get(activeProjectId) || null;
  const payloadItems = dedupeMaintenanceList(items).filter((item) => {
    if (!item || !item.id) {
      return false;
    }
    if (!serverIds) {
      return true;
    }
    if (serverIds.size === 0) {
      return Boolean(dirtyMap[String(item.id)]);
    }
    const id = String(item.id);
    return serverIds.has(id) || Boolean(dirtyMap[id]);
  });
  if (!payloadItems.length) {
    maintenancePendingSync = false;
    return { ok: true, skipped: true };
  }
  maintenanceSyncPromise = apiMaintenanceSync(payloadItems);
  try {
    await maintenanceSyncPromise;
    maintenanceLastSync = Date.now();
    maintenanceLastUserId = currentUser.id;
    maintenanceSyncFailed = false;
    maintenancePendingSync = false;
    clearMaintenanceDirtyIds();
    return { ok: true };
  } catch (error) {
    maintenanceSyncFailed = true;
    throw error;
  } finally {
    maintenanceSyncPromise = null;
  }
}

function scheduleMaintenanceSync(items, force) {
  if (!USE_AUTH_API) {
    return;
  }
  if (!currentUser) {
    return;
  }
  if (!activeProjectId) {
    return;
  }
  maintenancePendingSync = true;
  if (STRICT_SERVER_SYNC) {
    syncMaintenanceNow(items, true)
      .then(async () => {
        await carregarManutencoesServidor(true);
        loadDashboardSummary(true, { skipSync: true });
      })
      .catch((error) => {
        if (error && error.status === 403) {
          showAuthToast(
            "Sem permissão para sincronizar alterações. Verifique 'Manutenção - executar'."
          );
        } else {
          showAuthToast("Falha ao sincronizar. Alterações não aplicadas para todos.");
        }
        // Mantém estado local; nova tentativa ocorrerá via sincronização automática/manual.
      });
    return;
  }
  if (!maintenanceLoadedProjects.has(activeProjectId) && !force) {
    return;
  }
  if (force) {
    if (maintenanceSyncTimer) {
      clearTimeout(maintenanceSyncTimer);
      maintenanceSyncTimer = null;
    }
    syncMaintenanceNow(items, true).then(() => {
      loadDashboardSummary(true, { skipSync: true });
    });
    return;
  }
  if (maintenanceSyncTimer) {
    return;
  }
  maintenanceSyncTimer = setTimeout(() => {
    maintenanceSyncTimer = null;
    syncMaintenanceNow(items, false).then(() => {
      loadDashboardSummary(true, { skipSync: true });
    });
  }, 600);
}

async function loadDashboardSummary(force, options = {}) {
  if (!currentUser) {
    return;
  }
  if (!activeProjectId) {
    return;
  }
  const agora = Date.now();
  if (!force && dashboardRequest) {
    return;
  }
  const dashboardTtl = STRICT_SERVER_SYNC ? 0 : DASHBOARD_CLIENT_TTL_MS;
  if (!force && dashboardSummary && agora - dashboardLastFetch < dashboardTtl) {
    return;
  }
  dashboardError = "";
  dashboardRequest = (async () => {
    if (USE_AUTH_API && !options.skipSync) {
      try {
        await syncMaintenanceNow(manutencoes, force || !dashboardSummary);
      } catch (error) {
        if (STRICT_SERVER_SYNC) {
          showAuthToast("Falha de sincronização. Alterações locais preservadas.");
        }
      }
    }
    return apiDashboardSummary();
  })();
  try {
    const data = await dashboardRequest;
    dashboardSummary = data;
    dashboardLastFetch = Date.now();
  } catch (error) {
    dashboardSummary = null;
    dashboardError = "Falha ao carregar indicadores. Recarregue.";
  } finally {
    dashboardRequest = null;
    renderDashboardHome();
  }
}

function aprovarSolicitacao(item) {
  if (!currentUser || !canInviteUsuarios(currentUser)) {
    mostrarMensagemGerencial("Sem permissão para aprovar solicitações.", true);
    return;
  }
  const requestId = item.dataset.requestId;
  const solicitacao = requests.find((req) => req.id === requestId);
  if (!solicitacao) {
    return;
  }

  const permissions = {};
  Object.keys(PERMISSIONS).forEach((key) => {
    const checkbox = item.querySelector(`input[data-permission="${key}"]`);
    permissions[key] = checkbox ? checkbox.checked : false;
  });

  const sections = {};
  Object.keys(SECTION_LABELS).forEach((key) => {
    const checkbox = item.querySelector(`input[data-section="${key}"]`);
    sections[key] = checkbox ? checkbox.checked : true;
  });

  const roleCheckbox = item.querySelector("input[data-role='admin']");
  const isAdminChecked = Boolean(roleCheckbox && roleCheckbox.checked);

  const novoUsuario = {
    id: criarId(),
    username: solicitacao.matricula,
    matricula: solicitacao.matricula,
    name: solicitacao.nome,
    role: isAdminChecked ? "admin" : "colaborador",
    password: solicitacao.senha,
    permissions: isAdminChecked ? getDefaultPermissions() : permissions,
    sections: isAdminChecked ? { ...DEFAULT_SECTIONS } : sections,
    createdAt: toIsoUtc(new Date()),
  };

  users = [...users, novoUsuario];
  requests = requests.filter((req) => req.id !== requestId);
  salvarUsuarios(users);
  salvarSolicitacoes(requests);
  renderSolicitacoes();
  renderUsuarios();
}

function recusarSolicitacao(item) {
  if (!currentUser || !canInviteUsuarios(currentUser)) {
    mostrarMensagemGerencial("Sem permissão para recusar solicitações.", true);
    return;
  }
  const requestId = item.dataset.requestId;
  requests = requests.filter((req) => req.id !== requestId);
  salvarSolicitacoes(requests);
  renderSolicitacoes();
}

function atualizarPermissoesUsuario(checkbox) {
  const userId = checkbox.dataset.userId;
  const permission = checkbox.dataset.permission;
  const user = users.find((usuario) => usuario.id === userId);
  if (!user || user.role === "admin") {
    return;
  }
  user.permissions = user.permissions || {};
  user.permissions[permission] = checkbox.checked;
  salvarUsuarios(users);
  if (currentUser && currentUser.id === userId) {
    currentUser = user;
    renderAuthUI();
  }
}

function contarAdmins() {
  return users.filter((user) => user.role === "admin").length;
}

function atualizarSecoesUsuario(checkbox) {
  const userId = checkbox.dataset.userId;
  const section = checkbox.dataset.section;
  const user = users.find((usuario) => usuario.id === userId);
  if (!user || user.role === "admin") {
    return;
  }
  user.sections = user.sections || { ...DEFAULT_SECTIONS };
  user.sections[section] = checkbox.checked;
  salvarUsuarios(users);
  if (currentUser && currentUser.id === userId) {
    currentUser = user;
  }
  renderAuthUI();
}

function atualizarRoleUsuario(checkbox) {
  if (!isAdmin()) {
    return;
  }
  const userId = checkbox.dataset.userId;
  const user = users.find((usuario) => usuario.id === userId);
  if (!user) {
    return;
  }
  if (currentUser && user.id === currentUser.id) {
    checkbox.checked = true;
    mostrarMensagemGerencial("Não é possível alterar o próprio cargo.", true);
    return;
  }
  if (!checkbox.checked && user.role === "admin" && contarAdmins() <= 1) {
    checkbox.checked = true;
    mostrarMensagemGerencial("Deve existir pelo menos um administrador.", true);
    return;
  }
  user.role = checkbox.checked ? "admin" : "colaborador";
  if (user.role === "admin") {
    user.permissions = getDefaultPermissions();
    user.sections = { ...DEFAULT_SECTIONS };
  } else {
    user.permissions = user.permissions || getDefaultPermissions();
    user.sections = user.sections || { ...DEFAULT_SECTIONS };
  }
  salvarUsuarios(users);
  renderTudo();
}

function salvarDadosUsuario(item) {
  const userId = item.dataset.userId;
  const user = users.find((usuario) => usuario.id === userId);
  if (!user) {
    return;
  }
  if (!currentUser || !canEditProfile(currentUser, user)) {
    mostrarMensagemGerencial("Sem permissão para editar este perfil.", true);
    return;
  }
  const cargoInput = item.querySelector("[data-user-field='cargo']");
  const projetoInput = item.querySelector("[data-user-field='projeto']");
  const atribuicoesInput = item.querySelector("[data-user-field='atribuicoes']");
  user.cargo = cargoInput ? cargoInput.value.trim() : "";
  user.projeto = projetoInput ? projetoInput.value.trim() : "";
  user.atribuicoes = atribuicoesInput ? atribuicoesInput.value.trim() : "";
  salvarUsuarios(users);
  renderUsuarios();
  if (currentUser && currentUser.id === userId) {
    currentUser = user;
    renderAuthUI();
  }
  mostrarMensagemGerencial("Dados da conta atualizados.");
}

function removerUsuario(item) {
  if (!currentUser || !canDesativarUsuarios(currentUser)) {
    mostrarMensagemGerencial("Sem permissão para remover usuários.", true);
    return;
  }
  const userId = item.dataset.userId;
  const user = users.find((usuario) => usuario.id === userId);
  if (!user) {
    return;
  }
  if (currentUser && user.id === currentUser.id) {
    mostrarMensagemGerencial("Não é possível remover a conta logada.", true);
    return;
  }
  if (user.role === "admin" && contarAdmins() <= 1) {
    mostrarMensagemGerencial("Deve existir pelo menos um administrador.", true);
    return;
  }
  const confirmar = window.confirm(`Remover a conta de ${user.name}?`);
  if (!confirmar) {
    return;
  }
  users = users.filter((usuario) => usuario.id !== userId);
  salvarUsuarios(users);
  renderUsuarios();
  mostrarMensagemGerencial("Conta removida.");
}

tabButtons.forEach((botao) => {
  botao.addEventListener("click", () => {
    const tab = botao.dataset.tab;
    const scrollTarget = botao.dataset.scrollTarget;
    abrirPainelComCarregamento(tab, scrollTarget);
    if (tab === "acessos") {
      refreshAccessData({ force: true });
    }
  });
});

document.querySelectorAll("[data-open-tab]").forEach((link) => {
  link.addEventListener("click", (event) => {
    event.preventDefault();
    const tab = link.dataset.openTab;
    if (tab) {
      const href = link.getAttribute("href");
      const scrollTarget = href && href.startsWith("#") ? href.slice(1) : null;
      abrirPainelComCarregamento(tab, scrollTarget);
    }
  });
});

if (btnRefreshHealth) {
  btnRefreshHealth.addEventListener("click", () => {
    carregarHealth(true);
  });
}

if (btnHealthRunAll) {
  btnHealthRunAll.addEventListener("click", async () => {
    btnHealthRunAll.disabled = true;
    try {
      await runAllHealthTasks();
    } finally {
      btnHealthRunAll.disabled = false;
    }
  });
}

if (healthTasks) {
  healthTasks.addEventListener("click", async (event) => {
    const btn = event.target.closest("[data-action=\"run-task\"]");
    if (!btn || !currentUser || !hasGranularPermission(currentUser, "reexecutarTarefas")) {
      return;
    }
    const taskId = btn.dataset.taskId;
    if (!taskId) {
      return;
    }
    btn.disabled = true;
    mostrarMensagemHealth("Reexecutando tarefa...");
    try {
      const data = await apiRunHealthTask(taskId);
      if (data && data.snapshot) {
        healthSnapshot = data.snapshot;
        renderHealthSummary(healthSnapshot);
        renderHealthTasks(healthSnapshot);
        renderHealthIntegrity(healthSnapshot);
      }
      mostrarMensagemHealth("Tarefa reexecutada.");
    } catch (error) {
      mostrarMensagemHealth(error.message || "Falha ao reexecutar tarefa.", true);
    } finally {
      btn.disabled = false;
    }
  });
}

if (btnLogsApply) {
  btnLogsApply.addEventListener("click", () => {
    carregarApiLogs(true);
  });
}

if (btnLogsExport) {
  btnLogsExport.addEventListener("click", () => {
    exportarApiLogs();
  });
}

if (btnLogsClear) {
  btnLogsClear.addEventListener("click", () => {
    if (logsFilterEndpoint) {
      logsFilterEndpoint.value = "";
    }
    if (logsFilterUser) {
      logsFilterUser.value = "";
    }
    if (logsFilterStatus) {
      logsFilterStatus.value = "";
    }
    if (logsFilterFrom) {
      logsFilterFrom.value = "";
    }
    if (logsFilterTo) {
      logsFilterTo.value = "";
    }
    carregarApiLogs(true);
  });
}

if (btnLogsRefresh) {
  btnLogsRefresh.addEventListener("click", () => {
    carregarApiLogs(true);
  });
}

if (btnLogsLoadMore) {
  btnLogsLoadMore.addEventListener("click", () => {
    carregarApiLogs(false);
  });
}

if (apiLogsTable) {
  apiLogsTable.addEventListener("click", (event) => {
    const btn = event.target.closest("[data-action=\"toggle-log\"]");
    if (!btn) {
      return;
    }
    const logId = btn.dataset.logId;
    if (!logId) {
      return;
    }
    const detailRow = apiLogsTable.querySelector(
      `tr[data-log-details=\"${logId}\"]`
    );
    if (!detailRow) {
      return;
    }
    detailRow.hidden = !detailRow.hidden;
    btn.textContent = detailRow.hidden ? "Ver JSON" : "Ocultar";
  });
}

if (btnAutomationRefresh) {
  btnAutomationRefresh.addEventListener("click", () => {
    carregarAutomacoes(true);
  });
}

if (automationList) {
  automationList.addEventListener("change", async (event) => {
    const toggle = event.target.closest("[data-action=\"toggle-automation\"]");
    if (!toggle || !currentUser || !hasGranularPermission(currentUser, "gerenciarAutomacoes")) {
      return;
    }
    const automationId = toggle.dataset.automationId;
    if (!automationId) {
      return;
    }
    const enabled = toggle.checked;
    toggle.disabled = true;
    mostrarMensagemAutomacoes("Salvando automação...");
    try {
      const data = await apiUpdateAutomation(automationId, { enabled });
      automationsState.items = Array.isArray(data.automations) ? data.automations : [];
      renderAutomacoes();
      mostrarMensagemAutomacoes("Automação atualizada.");
    } catch (error) {
      toggle.checked = !enabled;
      mostrarMensagemAutomacoes(error.message || "Falha ao atualizar automação.", true);
    } finally {
      toggle.disabled = false;
    }
  });
}

if (btnFilesRefresh) {
  btnFilesRefresh.addEventListener("click", () => {
    carregarArquivos(true);
  });
}

if (filesFilterType) {
  filesFilterType.addEventListener("change", () => {
    carregarArquivos(true);
  });
}

if (filesSearch) {
  filesSearch.addEventListener("input", () => {
    if (filesSearchTimer) {
      clearTimeout(filesSearchTimer);
    }
    filesSearchTimer = setTimeout(() => {
      carregarArquivos(true);
    }, 300);
  });
}

if (btnFilesUpload) {
  btnFilesUpload.addEventListener("click", async () => {
    if (!filesUploadInput || !filesUploadType) {
      return;
    }
    if (!currentUser || !canUploadFilesClient(currentUser)) {
      mostrarMensagemArquivos("Sem permissão para enviar arquivos.", true);
      return;
    }
    const type = filesUploadType.value;
    const file = filesUploadInput.files && filesUploadInput.files[0];
    if (!type) {
      mostrarMensagemArquivos("Selecione o tipo do arquivo.", true);
      return;
    }
    if (!file) {
      mostrarMensagemArquivos("Selecione um arquivo.", true);
      return;
    }
    if (!FILE_ALLOWED_TYPES.includes(file.type)) {
      mostrarMensagemArquivos("Tipo de arquivo não suportado.", true);
      return;
    }
    if (file.size > FILE_MAX_BYTES) {
      mostrarMensagemArquivos("Arquivo acima de 10 MB.", true);
      return;
    }
    btnFilesUpload.disabled = true;
    mostrarMensagemArquivos("Enviando arquivo...");
    try {
      const formData = new FormData();
      formData.append("type", type);
      formData.append("file", file);
      await apiUploadFile(formData);
      filesUploadInput.value = "";
      carregarArquivos(true);
      mostrarMensagemArquivos("Arquivo enviado com sucesso.");
    } catch (error) {
      mostrarMensagemArquivos(error.message || "Falha ao enviar arquivo.", true);
    } finally {
      btnFilesUpload.disabled = false;
    }
  });
}

if (filesList) {
  filesList.addEventListener("click", async (event) => {
    const removeBtn = event.target.closest("[data-action=\"delete-file\"]");
    if (!removeBtn) {
      return;
    }
    if (!currentUser || !canDeleteFilesClient(currentUser)) {
      mostrarMensagemArquivos("Sem permissão para remover arquivos.", true);
      return;
    }
    const fileId = removeBtn.dataset.fileId;
    if (!fileId) {
      return;
    }
    const confirmar = window.confirm("Excluir este arquivo?");
    if (!confirmar) {
      return;
    }
    removeBtn.disabled = true;
    mostrarMensagemArquivos("Removendo arquivo...");
    try {
      await apiDeleteFile(fileId);
      carregarArquivos(true);
      mostrarMensagemArquivos("Arquivo removido.");
    } catch (error) {
      mostrarMensagemArquivos(error.message || "Falha ao remover arquivo.", true);
    } finally {
      removeBtn.disabled = false;
    }
  });
}

if (btnPermissoesSalvar) {
  btnPermissoesSalvar.addEventListener("click", async () => {
    if (!currentUser || !isAdmin() || !canViewGerencial(currentUser)) {
      mostrarMensagemPermissoes("Sem permissão para editar permissões.", true);
      return;
    }
    const payload = { values: coletarPermissoesGerenciais() };
    btnPermissoesSalvar.disabled = true;
    mostrarMensagemPermissoes("Salvando permissões...");
    try {
      const data = await apiSalvarPermissoes(payload);
      permissoesState.values = data.values || payload.values;
      permissoesState.profiles = Array.isArray(data.profiles) ? data.profiles : permissoesState.profiles;
      permissoesState.permissions = Array.isArray(data.permissions)
        ? data.permissions
        : permissoesState.permissions;
      permissoesState.loaded = true;
      if (currentUser) {
        const profileKey = getProfileKeyForUser(currentUser);
        if (permissoesState.values && permissoesState.values[profileKey]) {
          currentUser.granularPermissions = permissoesState.values[profileKey];
        }
      }
      renderPermissoesGerenciais();
      renderAuthUI();
      renderPerfil();
      mostrarMensagemPermissoes("Permissões atualizadas.");
    } catch (error) {
      mostrarMensagemPermissoes(error.message || "Falha ao salvar permissões.", true);
    } finally {
      btnPermissoesSalvar.disabled = false;
    }
  });
}

if (permissoesSearch) {
  permissoesSearch.addEventListener("input", () => {
    renderPermissoesGerenciais();
  });
}


if (btnLembretes) {
  btnLembretes.addEventListener("click", (event) => {
    event.stopPropagation();
    alternarPainelLembretes();
  });
}

if (btnDashboard) {
  btnDashboard.addEventListener("click", () => {
    abrirPainelComCarregamento("inicio");
  });
}

if (btnHelp) {
  btnHelp.addEventListener("click", (event) => {
    event.stopPropagation();
    if (!currentUser) {
      return;
    }
    openHelpModal();
  });
}

if (btnSyncSite) {
  btnSyncSite.addEventListener("click", (event) => {
    event.stopPropagation();
    syncSiteNow();
  });
}

if (btnHelpClose) {
  btnHelpClose.addEventListener("click", () => {
    closeHelpModal();
  });
}

if (modalHelp) {
  modalHelp.addEventListener("click", (event) => {
    if (event.target === modalHelp) {
      closeHelpModal();
    }
  });
}

if (btnUserMenu) {
  btnUserMenu.addEventListener("click", (event) => {
    event.stopPropagation();
    if (!currentUser) {
      return;
    }
    alternarUserMenu();
  });
}

if (userMenuPanel) {
  userMenuPanel.addEventListener("click", (event) => {
    const item = event.target.closest(".user-menu__item");
    if (!item) {
      return;
    }
    const action = item.dataset.action;
    fecharUserMenu();
    if (!action) {
      return;
    }
    if (action === "view-profile") {
      openProfileForUser(currentUser.id, { edit: false });
      cancelarModoEdicaoPerfil();
      return;
    }
    if (action === "edit-profile") {
      openProfileForUser(currentUser.id, { edit: true });
    }
  });
}

if (listaLembretes) {
  listaLembretes.addEventListener("click", (event) => {
    const item = event.target.closest(".lembrete-item");
    if (!item) {
      return;
    }
    const id = item.dataset.maintenanceId;
    if (!id) {
      return;
    }
    markNotificationRead(id);
    renderLembretes();
    fecharPainelLembretes();
    openMaintenanceFromNotification(id);
  });
}

if (listaAnuncios) {
  listaAnuncios.addEventListener("click", (event) => {
    const item = event.target.closest("[data-announcement-id]");
    if (!item) {
      return;
    }
    const id = item.dataset.announcementId;
    if (!id) {
      return;
    }
    const anuncio = announcements.find((entry) => String(entry.id) === String(id));
    if (anuncio) {
      openAnnouncementView(anuncio);
    }
  });
}
if (listaAnunciosLidos) {
  listaAnunciosLidos.addEventListener("click", (event) => {
    const item = event.target.closest("[data-announcement-id]");
    if (!item) {
      return;
    }
    const id = item.dataset.announcementId;
    if (!id) {
      return;
    }
    const anuncio = announcements.find((entry) => String(entry.id) === String(id));
    if (anuncio) {
      openAnnouncementView(anuncio);
    }
  });
}

document.addEventListener("click", (event) => {
  if (painelLembretes && !painelLembretes.hidden && btnLembretes) {
    const dentro =
      painelLembretes.contains(event.target) || btnLembretes.contains(event.target);
    if (!dentro) {
      fecharPainelLembretes();
    }
  }
  if (feedbackInboxPanel && !feedbackInboxPanel.hidden && btnFeedbackInbox) {
    const dentro =
      feedbackInboxPanel.contains(event.target) || btnFeedbackInbox.contains(event.target);
    if (!dentro) {
      feedbackInboxPanel.hidden = true;
      btnFeedbackInbox.setAttribute("aria-expanded", "false");
    }
  }
  if (userMenuPanel && !userMenuPanel.hidden && btnUserMenu) {
    const dentro =
      userMenuPanel.contains(event.target) || btnUserMenu.contains(event.target);
    if (!dentro) {
      fecharUserMenu();
    }
  }
});

document.addEventListener("keydown", (event) => {
  if (event.key === "Escape") {
    if (modalConfirm && !modalConfirm.hidden) {
      closeConfirmModal(false);
      return;
    }
    if (modalAccessHelp && !modalAccessHelp.hidden) {
      closeAccessHelpModal();
      return;
    }
    if (modalPasswordReset && !modalPasswordReset.hidden) {
      closePasswordResetModal();
      return;
    }
    if (modalAnuncioView && !modalAnuncioView.hidden) {
      closeAnnouncementView();
      return;
    }
    if (modalAnunciosLidos && !modalAnunciosLidos.hidden) {
      closeAnnouncementsReadModal();
      return;
    }
    fecharPainelLembretes();
    fecharUserMenu();
    closeHelpModal();
  }
});

if (btnFecharPerfil) {
  btnFecharPerfil.addEventListener("click", () => {
    fecharPainelPerfil();
  });
}

if (btnTabLogin) {
  btnTabLogin.addEventListener("click", () => {
    if (authPanels && !authPanels.hidden && authPanelLogin && !authPanelLogin.hidden) {
      esconderAuthPanels();
      return;
    }
    mostrarAuthPanel("login");
    if (loginUsuario) {
      loginUsuario.focus();
    }
  });
}

if (btnTabRegistro) {
  btnTabRegistro.addEventListener("click", () => {
    if (authPanels && !authPanels.hidden && authPanelRegistro && !authPanelRegistro.hidden) {
      esconderAuthPanels();
      return;
    }
    mostrarAuthPanel("registro");
  });
}

if (btnSair) {
  btnSair.addEventListener("click", async () => {
    try {
      await apiLogout();
    } catch (error) {
      // noop
    }
    currentUser = null;
    renderTudo();
    pendingVerificationEmail = "";
    mostrarAuthPanel("login");
  });
}

document.addEventListener("click", (event) => {
  const cancelarEdicao = event.target.closest("#btnCancelarEdicaoManutencao");
  if (cancelarEdicao) {
    limparEdicaoManutencao();
    mostrarMensagemManutencao("Edição cancelada.");
    return;
  }
  const editar = event.target.closest("#btnPerfilEditar");
  if (editar) {
    ativarModoEdicaoPerfil();
    return;
  }

  const cancelar = event.target.closest("#btnPerfilCancelar");
  if (cancelar) {
    cancelarModoEdicaoPerfil();
    return;
  }

  const salvar = event.target.closest("#btnPerfilSalvar");
  if (!salvar) {
    return;
  }
  const perfilUsuario = getProfileTargetUser();
  if (!currentUser || !perfilUsuario) {
    return;
  }
  if (!canEditProfile(currentUser, perfilUsuario)) {
    setPerfilSaveMessage("Sem permiss\u00e3o para editar este perfil.", true);
    return;
  }
  const uenInput = document.getElementById("perfilUenInput");
  const projetoInput = document.getElementById("perfilProjetoInput");
  const atribuicoesInput = document.getElementById("perfilAtribuicoesInput");
  const payload = {};
  const uenValue = uenInput ? uenInput.value.trim() : "";
  const projetoValue = projetoInput ? projetoInput.value.trim() : "";
  const atribuicoesValue = atribuicoesInput ? atribuicoesInput.value.trim() : "";
  if (uenInput && uenValue !== (perfilUsuario.uen || "")) {
    payload.uen = uenValue;
  }
  if (projetoInput && projetoValue !== (perfilUsuario.projectId || "")) {
    payload.projectId = projetoValue;
  }
  if (atribuicoesInput && atribuicoesValue !== (perfilUsuario.atribuicoes || "")) {
    payload.atribuicoes = atribuicoesValue;
  }
  if (!Object.keys(payload).length) {
    setPerfilSaveMessage("Nenhuma altera\u00e7\u00e3o para salvar.");
    return;
  }
  salvar.disabled = true;
  setPerfilSaveMessage("");
  updateProfileForUser(perfilUsuario.id, payload)
    .then(() => {
      setProfileEditParam(false);
      return refreshAccessUsers();
    })
    .then(() => {
      renderPerfil();
      renderUsuarios();
      setPerfilSaveMessage("Perfil atualizado.");
    })
    .catch((error) => {
      const message = error && error.message ? error.message : "N\u00e3o foi poss\u00edvel salvar.";
      setPerfilSaveMessage(message, true);
    })
    .finally(() => {
      salvar.disabled = false;
    });
});

document.addEventListener("click", (event) => {
  const actionButton = event.target.closest("[data-profile-action]");
  if (actionButton) {
    handleProfileAction(actionButton.dataset.profileAction);
    return;
  }
  const openPermissoes = event.target.closest("#btnPerfilPermissoesDetalhes");
  if (openPermissoes) {
    openProfilePermissionsModal();
    return;
  }
  const closePermissoes = event.target.closest(
    "#btnCloseProfilePermissions, #btnCloseProfilePermissionsFooter"
  );
  if (closePermissoes) {
    closeProfilePermissionsModal();
  }
});

if (btnSalvarConfig) {
  btnSalvarConfig.addEventListener("click", salvarConfiguracoes);
}

if (btnExportarDados) {
  btnExportarDados.addEventListener("click", exportarDados);
}

if (btnImportarDados) {
  btnImportarDados.addEventListener("click", importarDados);
}

if (btnLimparConcluidas) {
  btnLimparConcluidas.addEventListener("click", limparConcluidas);
}

if (btnLimparAuditoria) {
  btnLimparAuditoria.addEventListener("click", limparAuditoria);
}

if (btnRecalcularBacklog) {
  btnRecalcularBacklog.addEventListener("click", recalcularBacklog);
}

if (btnGerarRelatorio) {
  btnGerarRelatorio.addEventListener("click", gerarRelatorio);
}
// Convites removidos: gestao de acessos e feita via administracao.

if (btnPasswordResetSendCode) {
  btnPasswordResetSendCode.addEventListener("click", async () => {
    const email = normalizeVerificationEmail(
      (passwordResetEmail && passwordResetEmail.value) || ""
    );
    if (!email || !isValidEmail(email)) {
      setPasswordResetMessage("Informe um email valido.", true);
      if (passwordResetEmail) {
        passwordResetEmail.focus();
      }
      return;
    }
    setPasswordResetMessage("");
    btnPasswordResetSendCode.disabled = true;
    btnPasswordResetSendCode.textContent = "Enviando...";
    try {
      await apiPasswordResetRequest(email);
      setPasswordResetMessage(
        "Codigo enviado. Verifique seu email e cole o codigo abaixo.",
        false
      );
      if (passwordResetCode) {
        passwordResetCode.value = "";
      }
      setPasswordResetCodeValidated(false);
      setPasswordResetCodeSent(true);
      startPasswordResetCooldown(PASSWORD_RESET_RESEND_SECONDS);
      if (passwordResetCode) {
        passwordResetCode.focus();
      }
    } catch (error) {
      const message =
        error && error.message ? error.message : "Nao foi possivel enviar o codigo.";
      setPasswordResetMessage(message, true);
      if (error && error.data && error.data.retryAfter) {
        startPasswordResetCooldown(error.data.retryAfter);
      }
    } finally {
      updatePasswordResetCooldown();
    }
  });
}

if (btnPasswordResetValidate) {
  btnPasswordResetValidate.addEventListener("click", async () => {
    const email = normalizeVerificationEmail(
      (passwordResetEmail && passwordResetEmail.value) || ""
    );
    const code = String((passwordResetCode && passwordResetCode.value) || "").replace(
      /\D/g,
      ""
    );
    if (!email || !isValidEmail(email)) {
      setPasswordResetMessage("Informe um email valido.", true);
      if (passwordResetEmail) {
        passwordResetEmail.focus();
      }
      return;
    }
    if (!code) {
      setPasswordResetMessage("Informe o codigo.", true);
      if (passwordResetCode) {
        passwordResetCode.focus();
      }
      return;
    }
    setPasswordResetMessage("");
    btnPasswordResetValidate.disabled = true;
    btnPasswordResetValidate.textContent = "Validando...";
    try {
      await apiPasswordResetValidate(email, code);
      setPasswordResetCodeValidated(true);
      setPasswordResetMessage("Codigo confirmado. Agora defina a nova senha.", false);
      if (passwordResetNew) {
        passwordResetNew.focus();
      }
    } catch (error) {
      const message =
        error && error.message ? error.message : "Nao foi possivel validar o codigo.";
      setPasswordResetCodeValidated(false);
      setPasswordResetMessage(message, true);
      if (passwordResetCode) {
        passwordResetCode.focus();
      }
    } finally {
      btnPasswordResetValidate.textContent = "Pronto";
      const codeValue = passwordResetCode ? passwordResetCode.value.trim() : "";
      btnPasswordResetValidate.disabled = !passwordResetCodeSent || !codeValue;
    }
  });
}

if (passwordResetForm) {
  passwordResetForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    setPasswordResetMessage("");
    if (!passwordResetCodeSent) {
      setPasswordResetMessage("Envie o codigo primeiro.", true);
      return;
    }
    if (!passwordResetCodeValidated) {
      setPasswordResetMessage("Clique em Pronto para validar o codigo.", true);
      return;
    }
    const email = normalizeVerificationEmail(
      (passwordResetEmail && passwordResetEmail.value) || ""
    );
    const code = String((passwordResetCode && passwordResetCode.value) || "").replace(
      /\D/g,
      ""
    );
    const password = String((passwordResetNew && passwordResetNew.value) || "").trim();
    const passwordConfirm = String(
      (passwordResetConfirm && passwordResetConfirm.value) || ""
    ).trim();
    if (!email || !isValidEmail(email)) {
      setPasswordResetMessage("Informe um email valido.", true);
      if (passwordResetEmail) {
        passwordResetEmail.focus();
      }
      return;
    }
    if (!code) {
      setPasswordResetMessage("Informe o codigo.", true);
      if (passwordResetCode) {
        passwordResetCode.focus();
      }
      return;
    }
    if (!password || !passwordConfirm) {
      setPasswordResetMessage("Informe e confirme a nova senha.", true);
      if (passwordResetNew) {
        passwordResetNew.focus();
      }
      return;
    }
    if (password !== passwordConfirm) {
      setPasswordResetMessage("As senhas nao conferem.", true);
      if (passwordResetConfirm) {
        passwordResetConfirm.focus();
      }
      return;
    }
    const rules = checkPasswordPolicy(password);
    const ok = Object.values(rules).every(Boolean);
    if (!ok) {
      setPasswordResetMessage("Senha fora da politica.", true);
      if (passwordResetNew) {
        passwordResetNew.focus();
      }
      return;
    }
    if (btnPasswordResetSubmit) {
      btnPasswordResetSubmit.disabled = true;
      btnPasswordResetSubmit.textContent = "Salvando...";
    }
    try {
      await apiPasswordResetConfirm({
        email,
        code,
        password,
        passwordConfirm,
      });
      closePasswordResetModal();
      if (loginUsuario) {
        loginUsuario.value = email;
      }
      if (loginSenha) {
        loginSenha.focus();
      }
      mostrarMensagemConta("Senha atualizada. Faca login.", false);
    } catch (error) {
      const message =
        error && error.message ? error.message : "Nao foi possivel atualizar a senha.";
      setPasswordResetMessage(message, true);
    } finally {
      if (btnPasswordResetSubmit) {
        btnPasswordResetSubmit.disabled = false;
        btnPasswordResetSubmit.textContent = "Salvar nova senha";
      }
    }
  });
}

loginForm.addEventListener("submit", async (event) => {
  event.preventDefault();
  const login = loginUsuario.value.trim();
  const senha = loginSenha.value.trim();
  if (!login || !senha) {
    mostrarMensagemConta("Informe usuário e senha.", true);
    return;
  }
  if (btnLoginSubmit) {
    btnLoginSubmit.disabled = true;
    btnLoginSubmit.textContent = "Entrando...";
  }
  try {
    const data = await apiLogin(login, senha);
    currentUser = data.user;
    mostrarMensagemConta(`Bem-vindo, ${currentUser.name}.`);
    loginSenha.value = "";
    await carregarSessaoServidor();
  } catch (error) {
    const message = error && error.message ? error.message : "Usuário ou senha inválidos.";
    mostrarMensagemConta(message, true);
    if (error && error.data && error.data.requiresEmailVerification) {
      const pendingEmail = normalizeVerificationEmail(error.data.email || login);
      mostrarFormularioVerificacao(pendingEmail);
    }
  } finally {
    if (btnLoginSubmit) {
      btnLoginSubmit.disabled = false;
      btnLoginSubmit.textContent = "Entrar";
    }
  }
});

if (reqForm) {
  reqForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    mostrarMensagemConta("Cadastro desativado. Procure o PCM/Admin.", true);
  });
}

if (verifyForm) {
  verifyForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    setFieldError(verifyCodeError, "");
    const email = normalizeVerificationEmail(
      (verifyEmail && verifyEmail.value) || pendingVerificationEmail
    );
    const code = String((verifyCode && verifyCode.value) || "").replace(/\D/g, "");
    if (!email || !code) {
      setFieldError(verifyCodeError, "Informe o e-mail e o codigo.");
      return;
    }
    if (btnVerifySubmit) {
      btnVerifySubmit.disabled = true;
      btnVerifySubmit.textContent = "Confirmando...";
    }
    try {
      await apiVerifyEmailCode(email, code);
      pendingVerificationEmail = "";
      mostrarFormularioRegistro();
      if (verifyEmail) {
        verifyEmail.value = "";
      }
      if (verifyCode) {
        verifyCode.value = "";
      }
      if (loginUsuario) {
        loginUsuario.value = email;
      }
      mostrarMensagemConta("Email confirmado. Faça login.", false);
      mostrarAuthPanel("login");
      if (loginSenha) {
        loginSenha.focus();
      }
    } catch (error) {
      const message = error && error.message ? error.message : "Nao foi possivel validar o codigo.";
      setFieldError(verifyCodeError, message);
      mostrarMensagemConta(message, true);
    } finally {
      if (btnVerifySubmit) {
        btnVerifySubmit.disabled = false;
        btnVerifySubmit.textContent = "Confirmar código";
      }
    }
  });
}

if (btnVerifyResend) {
  btnVerifyResend.addEventListener("click", async () => {
    const email = normalizeVerificationEmail(
      (verifyEmail && verifyEmail.value) || pendingVerificationEmail
    );
    if (!email) {
      setFieldError(verifyCodeError, "Informe o e-mail para reenviar.");
      return;
    }
    setFieldError(verifyCodeError, "");
    btnVerifyResend.disabled = true;
    btnVerifyResend.textContent = "Reenviando...";
    try {
      const data = await apiResendVerificationCode(email);
      const nextEmail = normalizeVerificationEmail((data && data.pendingEmail) || email);
      pendingVerificationEmail = nextEmail;
      if (verifyEmail) {
        verifyEmail.value = nextEmail;
      }
      if (verifyHintEmail) {
        verifyHintEmail.textContent = nextEmail || "seu e-mail";
      }
      mostrarMensagemConta("Codigo reenviado. Verifique sua caixa de entrada.", false);
      if (verifyCode) {
        verifyCode.focus();
      }
    } catch (error) {
      const message = error && error.message ? error.message : "Nao foi possivel reenviar o codigo.";
      setFieldError(verifyCodeError, message);
      mostrarMensagemConta(message, true);
    } finally {
      btnVerifyResend.disabled = false;
      btnVerifyResend.textContent = "Reenviar código";
    }
  });
}

if (btnVerifyBack) {
  btnVerifyBack.addEventListener("click", () => {
    mostrarFormularioRegistro();
    if (reqMatricula && pendingVerificationEmail && !reqMatricula.value.trim()) {
      reqMatricula.value = pendingVerificationEmail;
    }
    if (reqMatricula) {
      reqMatricula.focus();
    }
  });
}

if (tipoManutencao) {
  tipoManutencao.addEventListener("change", atualizarTipoSelecionado);
}

if (templateForm) {
  templateForm.addEventListener("submit", salvarModelo);
  templateForm.addEventListener("input", handleTemplateFormChange);
  templateForm.addEventListener("change", handleTemplateFormChange);
}

document.querySelectorAll(".toggle-password").forEach((button) => {
  button.addEventListener("click", () => togglePassword(button));
});
bindCapsLockIndicator(loginSenha, capsLockLogin);
bindCapsLockIndicator(reqSenha, capsLockRegistro);

if (reqSenha) {
  reqSenha.addEventListener("input", atualizarSenhaRules);
}
if (reqSenhaRules) {
  atualizarSenhaRules();
}
mostrarFormularioRegistro();

if (btnPresetDiasUteis) {
  btnPresetDiasUteis.addEventListener("click", aplicarPresetDiasUteis);
}

if (templatePresets) {
  templatePresets.addEventListener("click", (event) => {
    const botao = event.target.closest("[data-template-preset]");
    if (!botao) {
      return;
    }
    aplicarPresetModelo(botao.dataset.templatePreset);
  });
}

if (btnCancelarModelo) {
  btnCancelarModelo.addEventListener("click", () => {
    limparTemplateForm();
  });
}

if (templateFrequencia) {
  templateFrequencia.addEventListener("change", () => atualizarTemplateFrequenciaUI(true));
}
if (templateMonthlyFixed) {
  templateMonthlyFixed.addEventListener("change", () => atualizarTemplateMonthlyUI(true));
}
if (templateMonthlyMulti) {
  templateMonthlyMulti.addEventListener("change", () => atualizarTemplateMonthlyUI(true));
}
if (templateSearch) {
  templateSearch.addEventListener("input", renderModelos);
}
if (templateFilterSubestacao) {
  templateFilterSubestacao.addEventListener("change", renderModelos);
}
if (templateSort) {
  templateSort.addEventListener("change", renderModelos);
}
if (filtroProgramacaoSubestacao) {
  filtroProgramacaoSubestacao.addEventListener("change", renderProgramacao);
}
if (filtroProgramacaoStatus) {
  filtroProgramacaoStatus.addEventListener("change", renderProgramacao);
}
if (filtroProgramacaoPeriodo) {
  filtroProgramacaoPeriodo.addEventListener("change", renderProgramacao);
}
if (kpiPeriodo) {
  kpiPeriodo.addEventListener("change", () => {
    kpiDrilldown = null;
    renderGrafico();
  });
}
if (kpiSubestacao) {
  kpiSubestacao.addEventListener("change", () => {
    kpiDrilldown = null;
    renderGrafico();
  });
}
if (kpiCategoria) {
  kpiCategoria.addEventListener("change", () => {
    kpiDrilldown = null;
    renderGrafico();
  });
}
if (kpiPrioridade) {
  kpiPrioridade.addEventListener("change", () => {
    kpiDrilldown = null;
    renderGrafico();
  });
}
if (kpiUsuarioFiltro) {
  kpiUsuarioFiltro.addEventListener("change", () => {
    kpiDrilldown = null;
    renderGrafico();
  });
}
if (kpiDrilldownLimite) {
  kpiDrilldownLimite.addEventListener("change", renderKpiDrilldown);
}
if (kpiCards) {
  kpiCards.addEventListener("click", handleKpiDrilldownClick);
}
if (kpiTrendChart) {
  kpiTrendChart.addEventListener("click", handleKpiDrilldownClick);
}
if (kpiAgingChart) {
  kpiAgingChart.addEventListener("click", handleKpiDrilldownClick);
}
if (kpiSlaChart) {
  kpiSlaChart.addEventListener("click", handleKpiDrilldownClick);
}
if (kpiRanking) {
  kpiRanking.addEventListener("click", handleKpiDrilldownClick);
  kpiRanking.addEventListener("click", handleKpiRankingSort);
}

if (btnAdicionarManutencao) {
  btnAdicionarManutencao.addEventListener("click", adicionarManutencao);
}
if (btnCancelarEdicaoManutencao) {
  btnCancelarEdicaoManutencao.addEventListener("click", () => {
    limparEdicaoManutencao();
    mostrarMensagemManutencao("Edição cancelada.");
  });
}
if (novaManutencaoCard) {
  const marcarEdicao = () => {
    if (manutencaoEmEdicao) {
      manutencaoEditDirty = true;
    }
  };
  novaManutencaoCard.addEventListener("input", marcarEdicao);
  novaManutencaoCard.addEventListener("change", marcarEdicao);
}
if (listaAgendadas) {
  listaAgendadas.addEventListener("click", agirNaManutencao);
}
if (listaBacklog) {
  listaBacklog.addEventListener("click", agirNaManutencao);
}
if (listaConcluidas) {
  listaConcluidas.addEventListener("click", agirNaManutencao);
}
if (listaExecucaoHoje) {
  listaExecucaoHoje.addEventListener("click", agirNaManutencao);
}
if (listaExecucaoVencidas) {
  listaExecucaoVencidas.addEventListener("click", agirNaManutencao);
}
if (listaExecucaoCriticas) {
  listaExecucaoCriticas.addEventListener("click", agirNaManutencao);
}
if (listaRelatorios) {
  listaRelatorios.addEventListener("click", (event) => {
    const botao = event.target.closest("button[data-action='open-report']");
    if (!botao) {
      return;
    }
    const card = botao.closest("[data-id]");
    if (!card) {
      return;
    }
    const item = manutencoes.find((registro) => registro.id === card.dataset.id);
    if (item) {
      abrirRelatorio(item);
    }
  });
}
if (perfProjetoPeriodo) {
  perfProjetoPeriodo.addEventListener("change", renderPerformanceProjetos);
}
if (perfProjetoFiltro) {
  perfProjetoFiltro.addEventListener("change", renderPerformanceProjetos);
}
if (perfPessoaPeriodo) {
  perfPessoaPeriodo.addEventListener("change", renderPerformancePessoas);
}
if (perfPessoaFiltro) {
  perfPessoaFiltro.addEventListener("change", renderPerformancePessoas);
}

if (projectSelect) {
  projectSelect.addEventListener("change", (event) => {
    const nextId = event.target.value;
    if (!nextId) {
      return;
    }
    setActiveProjectId(nextId);
  });
}

if (projectFormSelect) {
  projectFormSelect.addEventListener("change", () => {
    const projectId = projectFormSelect.value;
    if (!projectId) {
      resetProjectForm();
      return;
    }
    const project = availableProjects.find((item) => item.id === projectId);
    if (project) {
      setProjectFormValues(project);
    }
  });
}

if (manutencaoProjeto) {
  manutencaoProjeto.addEventListener("change", (event) => {
    const nextId = event.target.value;
    if (!nextId) {
      return;
    }
    setActiveProjectId(nextId);
  });
}

if (templateProjeto) {
  templateProjeto.addEventListener("change", (event) => {
    const nextId = event.target.value;
    if (!nextId) {
      return;
    }
    setActiveProjectId(nextId);
  });
}

if (equipamentoFormProject) {
  equipamentoFormProject.addEventListener("change", (event) => {
    const nextId = event.target.value;
    if (!nextId) {
      return;
    }
    setActiveProjectId(nextId);
  });
}

if (projectManageBtn && !projectManageBtn.dataset.tab) {
  projectManageBtn.addEventListener("click", () => {
    abrirPainelComCarregamento("projetos");
  });
}
if (projectTabs.length) {
  projectTabs.forEach((button) => {
    button.addEventListener("click", () => {
      setProjectTab(button.dataset.projectTab);
    });
  });
}

  if (projectForm) {
    projectForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      if (!currentUser || !canManageProjetos(currentUser)) {
        return;
      }
      const payload = {
        codigo: projectFormCodigo ? projectFormCodigo.value.trim() : "",
        nome: projectFormNome ? projectFormNome.value.trim() : "",
        cliente: projectFormCliente ? projectFormCliente.value.trim() : "",
        nomeTime: projectFormTime ? projectFormTime.value.trim() : "",
        descricao: projectFormDescricao ? projectFormDescricao.value.trim() : "",
        locais: parseProjectLocaisInput(projectFormLocais ? projectFormLocais.value : ""),
      };
    const projectId = projectFormId ? projectFormId.value.trim() : "";
    try {
      if (projectId) {
        await apiProjetosUpdate(projectId, payload);
      } else {
        await apiProjetosCreate(payload);
      }
      resetProjectForm();
      await refreshProjects();
    } catch (error) {
      alert(error && error.message ? error.message : "Falha ao salvar projeto.");
    }
  });
}

if (projectFormCancel) {
  projectFormCancel.addEventListener("click", () => {
    resetProjectForm();
  });
}

if (projectTable) {
  projectTable.addEventListener("click", async (event) => {
    const action = event.target.closest("[data-action]");
    if (!action) {
      return;
    }
    const row = event.target.closest("tr");
    if (!row) {
      return;
    }
    const projectId = row.dataset.projectId;
    if (!projectId) {
      return;
    }
    if (action.dataset.action === "set-active") {
      await setActiveProjectId(projectId);
      return;
    }
    if (!currentUser || !canManageProjetos(currentUser)) {
      return;
    }
    if (action.dataset.action === "edit-project") {
      const project = availableProjects.find((item) => item.id === projectId);
      if (!project) {
        return;
      }
      setProjectFormValues(project);
      return;
    }
    if (action.dataset.action === "delete-project") {
      const ok = confirm("Excluir projeto? Essa ação não pode ser desfeita.");
      if (!ok) {
        return;
      }
      try {
        await apiProjetosDelete(projectId);
        await refreshProjects();
      } catch (error) {
        alert(error && error.message ? error.message : "Falha ao excluir projeto.");
      }
    }
  });
}

if (equipamentoForm) {
  equipamentoForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!currentUser || !canManageEquipamentos(currentUser)) {
      return;
    }
    const payload = {
      tag: equipamentoFormTag ? equipamentoFormTag.value.trim() : "",
      nome: equipamentoFormNome ? equipamentoFormNome.value.trim() : "",
      categoria: equipamentoFormCategoria ? equipamentoFormCategoria.value.trim() : "",
      descricao: equipamentoFormDescricao ? equipamentoFormDescricao.value.trim() : "",
    };
    const targetProjectId = equipamentoFormProject
      ? equipamentoFormProject.value.trim()
      : activeProjectId;
    const equipamentoId = equipamentoFormId ? equipamentoFormId.value.trim() : "";
    try {
      if (equipamentoId) {
        if (targetProjectId && targetProjectId !== activeProjectId) {
          await setActiveProjectId(targetProjectId);
        }
        await apiEquipamentosUpdate(equipamentoId, payload);
      } else if (targetProjectId) {
        await apiProjetosEquipamentosCreate(targetProjectId, payload);
        if (targetProjectId !== activeProjectId) {
          await setActiveProjectId(targetProjectId);
        }
      } else {
        alert("Selecione um projeto para o equipamento.");
        return;
      }
      resetEquipamentoForm();
      await carregarEquipamentosProjeto();
    } catch (error) {
      alert(error && error.message ? error.message : "Falha ao salvar equipamento.");
    }
  });
}

if (equipamentoFormCancel) {
  equipamentoFormCancel.addEventListener("click", () => {
    resetEquipamentoForm();
  });
}

if (equipamentoTable) {
  equipamentoTable.addEventListener("click", async (event) => {
    const action = event.target.closest("[data-action]");
    if (!action) {
      return;
    }
    const row = event.target.closest("tr");
    if (!row) {
      return;
    }
    const equipamentoId = row.dataset.equipmentId;
    if (!equipamentoId) {
      return;
    }
    if (!currentUser || !canManageEquipamentos(currentUser)) {
      return;
    }
    const equipamento = projectEquipamentos.find((item) => item.id === equipamentoId);
    if (!equipamento) {
      return;
    }
    if (action.dataset.action === "edit-equipment") {
      if (equipamentoFormId) equipamentoFormId.value = equipamento.id;
      if (equipamentoFormProject) {
        equipamentoFormProject.value = equipamento.projectId || activeProjectId || "";
      }
      if (equipamentoFormTag) equipamentoFormTag.value = equipamento.tag || "";
      if (equipamentoFormNome) equipamentoFormNome.value = equipamento.nome || "";
      if (equipamentoFormCategoria) equipamentoFormCategoria.value = equipamento.categoria || "";
      if (equipamentoFormDescricao) equipamentoFormDescricao.value = equipamento.descricao || "";
      return;
    }
    if (action.dataset.action === "delete-equipment") {
      const ok = confirm("Excluir equipamento?");
      if (!ok) {
        return;
      }
      try {
        await apiEquipamentosDelete(equipamentoId);
        await carregarEquipamentosProjeto();
      } catch (error) {
        alert(error && error.message ? error.message : "Falha ao excluir equipamento.");
      }
    }
  });
}

if (equipeForm) {
  equipeForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!currentUser || !canManageEquipeProjeto(currentUser)) {
      return;
    }
    const selected = equipeFormUser
      ? Array.from(equipeFormUser.selectedOptions)
          .map((option) => option.value)
          .filter(Boolean)
      : [];
    if (!selected.length || !activeProjectId) {
      return;
    }
    try {
      await apiProjetosEquipeAdd(activeProjectId, { userIds: selected });
      if (equipeForm) {
        equipeForm.reset();
      }
      if (equipeSearch) {
        equipeSearch.value = "";
      }
      await carregarEquipeProjeto();
    } catch (error) {
      alert(error && error.message ? error.message : "Falha ao adicionar equipe.");
    }
  });
}

if (equipeSearch) {
  equipeSearch.addEventListener("input", () => {
    renderEquipeSelectOptions();
  });
}

if (equipeTable) {
  equipeTable.addEventListener("click", async (event) => {
    const action = event.target.closest("[data-action]");
    if (!action) {
      return;
    }
    const row = event.target.closest("tr");
    if (!row) {
      return;
    }
    const userId = row.dataset.userId;
    if (!userId) {
      return;
    }
    if (!currentUser || !canManageEquipeProjeto(currentUser)) {
      return;
    }
    if (action.dataset.action === "remove-team") {
      const ok = confirm("Remover usuário do projeto?");
      if (!ok || !activeProjectId) {
        return;
      }
      try {
        await apiProjetosEquipeRemove(activeProjectId, userId);
        await carregarEquipeProjeto();
      } catch (error) {
        alert(error && error.message ? error.message : "Falha ao remover usuário.");
      }
    }
  });
}
if (btnEnviarFeedback) {
  btnEnviarFeedback.addEventListener("click", enviarFeedback);
}
if (feedbackTemplateButtons.length && feedbackMessage) {
  const templates = {
    bom: "Excelente atuação no atendimento e registro das atividades. Sua organização ajudou a equipe a manter o ritmo.",
    melhora:
      "Observei pontos que podem melhorar: alinhar o status no OPSCOPE logo após a execução e detalhar melhor o impacto.",
    apoio:
      "Obrigado pelo apoio em campo. Sua prontidão e comunicação clara facilitaram o fechamento das tarefas.",
  };
  feedbackTemplateButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      const key = btn.dataset.feedbackTemplate || "";
      if (templates[key]) {
        feedbackMessage.value = templates[key];
        feedbackMessage.focus();
      }
    });
  });
}
if (feedbackTabButtons.length) {
  feedbackTabButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      feedbackTabButtons.forEach((other) => other.classList.remove("is-active"));
      btn.classList.add("is-active");
      renderFeedbackList();
    });
  });
}
if (feedbackSearch) {
  feedbackSearch.addEventListener("input", renderFeedbackList);
}
if (feedbackSort) {
  feedbackSort.addEventListener("change", renderFeedbackList);
}
if (btnFeedbackInbox) {
  btnFeedbackInbox.addEventListener("click", (event) => {
    event.stopPropagation();
    if (!feedbackInboxPanel) {
      return;
    }
    const isOpen = !feedbackInboxPanel.hidden;
    feedbackInboxPanel.hidden = isOpen;
    btnFeedbackInbox.setAttribute("aria-expanded", String(!isOpen));
  });
}
if (feedbackInboxLink) {
  feedbackInboxLink.addEventListener("click", () => {
    ativarTab("feedbacks");
    if (feedbackInboxPanel) {
      feedbackInboxPanel.hidden = true;
    }
  });
}
if (btnNovoAnuncio) {
  btnNovoAnuncio.addEventListener("click", (event) => {
    event.stopPropagation();
    openAnnouncementModal();
  });
}
if (btnAnunciosLidos) {
  btnAnunciosLidos.addEventListener("click", (event) => {
    event.stopPropagation();
    openAnnouncementsReadModal();
  });
}
if (btnCancelarAnuncio) {
  btnCancelarAnuncio.addEventListener("click", () => {
    closeAnnouncementModal();
  });
}
if (btnFecharAnuncio) {
  btnFecharAnuncio.addEventListener("click", () => {
    closeAnnouncementModal();
  });
}
if (modalAnuncio) {
  modalAnuncio.addEventListener("click", (event) => {
    if (event.target === modalAnuncio) {
      closeAnnouncementModal();
    }
  });
}
if (anuncioImagens) {
  anuncioImagens.addEventListener("change", handleAnnouncementImageInput);
}
if (btnAnuncioViewClose) {
  btnAnuncioViewClose.addEventListener("click", () => {
    closeAnnouncementView();
  });
}
if (btnAnuncioViewCloseFooter) {
  btnAnuncioViewCloseFooter.addEventListener("click", () => {
    closeAnnouncementView();
  });
}
if (modalAnuncioView) {
  modalAnuncioView.addEventListener("click", (event) => {
    if (event.target === modalAnuncioView) {
      closeAnnouncementView();
    }
  });
}
if (btnAnunciosLidosClose) {
  btnAnunciosLidosClose.addEventListener("click", () => {
    closeAnnouncementsReadModal();
  });
}
if (btnAnunciosLidosCloseFooter) {
  btnAnunciosLidosCloseFooter.addEventListener("click", () => {
    closeAnnouncementsReadModal();
  });
}
if (modalAnunciosLidos) {
  modalAnunciosLidos.addEventListener("click", (event) => {
    if (event.target === modalAnunciosLidos) {
      closeAnnouncementsReadModal();
    }
  });
}
if (btnAnuncioViewMarkRead) {
  btnAnuncioViewMarkRead.addEventListener("click", () => {
    if (!activeAnnouncementView || !currentUser) {
      return;
    }
    markAnnouncementRead(activeAnnouncementView.id, currentUser);
    renderAnuncios();
    renderAnunciosLidos();
    renderAnnouncementView(activeAnnouncementView);
  });
}
if (anuncioEscopo) {
  anuncioEscopo.addEventListener("change", updateAnnouncementScopeField);
}
if (formAnuncio) {
  formAnuncio.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!currentUser || !canCreateAnnouncements(currentUser)) {
      if (mensagemAnuncio) {
        mensagemAnuncio.textContent = "Sem permissão para criar anúncios.";
        mensagemAnuncio.classList.add("mensagem--erro");
      }
      return;
    }
    const titulo = anuncioTitulo ? anuncioTitulo.value.trim() : "";
    const mensagem = anuncioMensagem ? anuncioMensagem.value.trim() : "";
    const tipo = normalizeAnnouncementType(anuncioTipo ? anuncioTipo.value : "info");
    const criticidade = normalizeAnnouncementSeverity(
      anuncioCriticidade ? anuncioCriticidade.value : "baixa"
    );
    const escopo = anuncioEscopo ? anuncioEscopo.value : "all";
    const projectId = escopo === "project" && anuncioProjeto ? anuncioProjeto.value.trim() : "";
    if (!titulo || !mensagem) {
      if (mensagemAnuncio) {
        mensagemAnuncio.textContent = "Informe título e mensagem do anúncio.";
        mensagemAnuncio.classList.add("mensagem--erro");
      }
      return;
    }
    if (escopo === "project" && !projectId) {
      if (mensagemAnuncio) {
        mensagemAnuncio.textContent = "Selecione o projeto do anúncio.";
        mensagemAnuncio.classList.add("mensagem--erro");
      }
      return;
    }
    if (mensagemAnuncio) {
      mensagemAnuncio.textContent = "Enviando anúncio...";
      mensagemAnuncio.classList.remove("mensagem--erro");
    }
    const nowIso = toIsoUtc(new Date());
    const senderRank = getUserHierarchyRank(currentUser);
    const payload = {
      id: criarId(),
      title: titulo,
      message: mensagem,
      type: tipo,
      severity: criticidade,
      scope: escopo,
      projectId,
      projectLabel: escopo === "project" ? getAnnouncementProjectLabel(projectId) : "",
      images: announcementDraftImages,
      createdAt: nowIso,
      createdBy: currentUser.id,
      createdByName: getDisplayName(currentUser),
      senderRank,
      senderRoleLabel: getRoleLabel(currentUser),
    };
    try {
      const data = await apiAnnouncementsCreate(payload);
      const item = normalizeAnnouncementRecord(
        data && (data.item || data.announcement || data.annuncio || payload)
      );
      const fallback = Boolean(data && data.fallback);
      if (item) {
        announcements = normalizeAnnouncements([item].concat(announcements || []));
        announcementsLastFetch = Date.now();
      }
      renderAnuncios();
      if (mensagemAnuncio) {
        mensagemAnuncio.textContent = fallback
          ? "Anúncio salvo localmente (API indisponível)."
          : "Anúncio enviado.";
        mensagemAnuncio.classList.remove("mensagem--erro");
      }
      showAuthToast(
        fallback ? "API de anúncios indisponível. Salvo localmente." : "Anúncio enviado."
      );
      closeAnnouncementModal();
    } catch (error) {
      if (mensagemAnuncio) {
        mensagemAnuncio.textContent = error && error.message ? error.message : "Falha ao enviar anúncio.";
        mensagemAnuncio.classList.add("mensagem--erro");
      }
    }
  });
}
if (relatorioPeriodoFiltro) {
  relatorioPeriodoFiltro.addEventListener("change", renderRelatorios);
}
if (relatorioStatusFiltro) {
  relatorioStatusFiltro.addEventListener("change", renderRelatorios);
}
if (relatorioResponsavelFiltro) {
  relatorioResponsavelFiltro.addEventListener("change", renderRelatorios);
}
if (relatorioTipoFiltro) {
  relatorioTipoFiltro.addEventListener("change", renderRelatorios);
}
if (btnRelatoriosExportar) {
  btnRelatoriosExportar.addEventListener("click", () => {
    const ok = exportarRelatoriosPdf();
    if (!ok) {
      alert("Popup bloqueado. Permita a abertura para exportar o PDF.");
    }
  });
}
if (btnRelatoriosResumo) {
  btnRelatoriosResumo.addEventListener("click", () => {
    const ok = gerarResumoMensal();
    if (!ok) {
      alert("Popup bloqueado. Permita a abertura para visualizar o resumo.");
    }
  });
}
if (relatorioMes) {
  if (!relatorioMes.value) {
    relatorioMes.value = formatDateISO(new Date()).slice(0, 7);
  }
  updateMonthlyRangeFromMonth();
  relatorioMes.addEventListener("change", () => {
    updateMonthlyRangeFromMonth();
  });
}
if (btnRelatorioMensalPreview) {
  btnRelatorioMensalPreview.addEventListener("click", () => {
    const ok = abrirRdoMensalPreview();
    if (!ok) {
      alert("Não foi possível abrir o preview do RDO mensal.");
    }
  });
}
if (btnRelatorioMensalExportar) {
  btnRelatorioMensalExportar.addEventListener("click", () => {
    const ok = gerarRdoMensal(true);
    if (!ok) {
      alert("Popup bloqueado. Permita a abertura para exportar o PDF.");
    }
  });
}
if (btnRelatorioMensalRdo) {
  btnRelatorioMensalRdo.addEventListener("click", () => {
    const ok = abrirRdoMensalPreview();
    if (!ok) {
      alert("Não foi possível abrir o preview do RDO mensal.");
    }
  });
}
if (rdoMensalPreviewClose) {
  rdoMensalPreviewClose.addEventListener("click", fecharRdoMensalPreview);
}
if (rdoMensalPreviewModal) {
  rdoMensalPreviewModal.addEventListener("click", (event) => {
    if (event.target === rdoMensalPreviewModal) {
      fecharRdoMensalPreview();
    }
  });
}
if (formConclusao) {
  formConclusao.addEventListener("submit", salvarConclusao);
}
if (btnAplicarModeloBreve) {
  btnAplicarModeloBreve.addEventListener("click", aplicarModeloBreve);
}
if (conclusaoInicio) {
  conclusaoInicio.addEventListener("input", atualizarDuracaoConclusao);
}
if (conclusaoFim) {
  conclusaoFim.addEventListener("input", atualizarDuracaoConclusao);
}
if (formRegistroExecucao) {
  formRegistroExecucao.addEventListener("submit", salvarRegistroExecucao);
}
if (formCancelarExecucao) {
  formCancelarExecucao.addEventListener("submit", salvarCancelamentoExecucao);
}
if (formLiberacao) {
  formLiberacao.addEventListener("submit", salvarLiberacao);
}
if (formOverride) {
  formOverride.addEventListener("submit", confirmarOverrideLiberacao);
}
if (btnFecharConclusao) {
  btnFecharConclusao.addEventListener("click", fecharConclusao);
}
if (btnCancelarConclusao) {
  btnCancelarConclusao.addEventListener("click", fecharConclusao);
}
if (btnFecharLiberacao) {
  btnFecharLiberacao.addEventListener("click", fecharLiberacao);
}
if (btnCancelarLiberacao) {
  btnCancelarLiberacao.addEventListener("click", fecharLiberacao);
}
if (btnFecharOverride) {
  btnFecharOverride.addEventListener("click", fecharOverrideLiberacao);
}
if (btnCancelarOverride) {
  btnCancelarOverride.addEventListener("click", fecharOverrideLiberacao);
}
if (btnFecharRegistroExecucao) {
  btnFecharRegistroExecucao.addEventListener("click", fecharRegistroExecucao);
}
if (btnCancelarRegistroExecucao) {
  btnCancelarRegistroExecucao.addEventListener("click", fecharRegistroExecucao);
}
if (btnCancelarExecucao) {
  btnCancelarExecucao.addEventListener("click", abrirCancelarExecucao);
}
if (btnVoltarCancelarExecucao) {
  btnVoltarCancelarExecucao.addEventListener("click", fecharCancelarExecucao);
}
if (formCancelarInicio) {
  formCancelarInicio.addEventListener("submit", salvarCancelarInicio);
}
if (btnFecharCancelarInicio) {
  btnFecharCancelarInicio.addEventListener("click", fecharCancelarInicio);
}
if (btnCancelarCancelarInicio) {
  btnCancelarCancelarInicio.addEventListener("click", fecharCancelarInicio);
}
if (formReagendar) {
  formReagendar.addEventListener("submit", salvarReagendamento);
}
if (btnFecharReagendar) {
  btnFecharReagendar.addEventListener("click", fecharReagendamento);
}
if (btnCancelarReagendar) {
  btnCancelarReagendar.addEventListener("click", fecharReagendamento);
}
if (reagendarMotivo) {
  reagendarMotivo.addEventListener("change", () => {
    mostrarMensagemReagendar("");
  });
}
if (formBacklogMotivo) {
  formBacklogMotivo.addEventListener("submit", salvarBacklogMotivo);
}
if (btnFecharBacklogMotivo) {
  btnFecharBacklogMotivo.addEventListener("click", fecharBacklogMotivo);
}
if (btnCancelarBacklogMotivo) {
  btnCancelarBacklogMotivo.addEventListener("click", fecharBacklogMotivo);
}
if (backlogMotivoSelect) {
  backlogMotivoSelect.addEventListener("change", () => {
    mostrarMensagemBacklogMotivo("");
  });
}
if (cancelarInicioMotivo) {
  cancelarInicioMotivo.addEventListener("change", () => {
    mostrarMensagemCancelarInicio("");
  });
}
if (liberacaoOs) {
  liberacaoOs.addEventListener("input", atualizarLiberacaoChecklist);
}
if (liberacaoParticipantes) {
  liberacaoParticipantes.addEventListener("change", atualizarLiberacaoChecklist);
}
if (liberacaoParticipantesList) {
  liberacaoParticipantesList.addEventListener("click", (event) => {
    const button = event.target.closest("button[data-participant-name]");
    if (!button) {
      return;
    }
    toggleLiberacaoParticipante(button.dataset.participantName);
  });
}
if (liberacaoParticipantesSelected) {
  liberacaoParticipantesSelected.addEventListener("click", (event) => {
    const button = event.target.closest("button[data-participant-remove]");
    if (!button) {
      return;
    }
    const name = button.dataset.participantRemove;
    liberacaoParticipantesSelecionados = liberacaoParticipantesSelecionados.filter(
      (item) => item !== name
    );
    syncLiberacaoParticipantesInput();
    renderLiberacaoParticipantesOptions();
    renderLiberacaoParticipantesSelected();
    setFieldError(liberacaoParticipantesErro, "");
    atualizarLiberacaoChecklist();
  });
}
if (btnAddParticipanteExternoLiberacao) {
  btnAddParticipanteExternoLiberacao.addEventListener("click", () => {
    addLiberacaoParticipantesExternos(
      liberacaoParticipanteExterno ? liberacaoParticipanteExterno.value : ""
    );
    if (liberacaoParticipanteExterno) {
      liberacaoParticipanteExterno.value = "";
      liberacaoParticipanteExterno.focus();
    }
  });
}
if (liberacaoParticipanteExterno) {
  liberacaoParticipanteExterno.addEventListener("keydown", (event) => {
    if (event.key === "Enter") {
      event.preventDefault();
      addLiberacaoParticipantesExternos(liberacaoParticipanteExterno.value);
      liberacaoParticipanteExterno.value = "";
    }
  });
}
if (liberacaoCritico) {
  liberacaoCritico.addEventListener("change", atualizarLiberacaoCriticoUI);
}
if (overrideMotivo) {
  overrideMotivo.addEventListener("input", () => {
    mostrarMensagemOverride("");
  });
}
if (criticoManutencao) {
  criticoManutencao.addEventListener("change", atualizarNovaCriticoUI);
  atualizarNovaCriticoUI();
}
if (futuraManutencao) {
  futuraManutencao.addEventListener("change", atualizarDataManutencaoState);
  atualizarDataManutencaoState();
}
if (participantesManutencao) {
  participantesManutencao.addEventListener("input", () => {
    setFieldError(participantesManutencaoErro, "");
  });
}
if (participantesManutencaoList) {
  participantesManutencaoList.addEventListener("click", (event) => {
    const button = event.target.closest("button[data-participant-name]");
    if (!button) {
      return;
    }
    toggleManutencaoParticipante(button.dataset.participantName);
  });
}
if (participantesManutencaoSelected) {
  participantesManutencaoSelected.addEventListener("click", (event) => {
    const button = event.target.closest("button[data-participant-remove]");
    if (!button) {
      return;
    }
    const name = button.dataset.participantRemove;
    manutencaoParticipantesSelecionados = manutencaoParticipantesSelecionados.filter(
      (item) => item !== name
    );
    syncManutencaoParticipantesInput();
    renderManutencaoParticipantesOptions();
    renderManutencaoParticipantesSelected();
    setFieldError(participantesManutencaoErro, "");
  });
}
if (btnAddParticipanteExterno) {
  btnAddParticipanteExterno.addEventListener("click", () => {
    addManutencaoParticipantesExternos(
      participanteExternoManutencao ? participanteExternoManutencao.value : ""
    );
    if (participanteExternoManutencao) {
      participanteExternoManutencao.value = "";
      participanteExternoManutencao.focus();
    }
  });
}
if (participanteExternoManutencao) {
  participanteExternoManutencao.addEventListener("keydown", (event) => {
    if (event.key === "Enter") {
      event.preventDefault();
      addManutencaoParticipantesExternos(participanteExternoManutencao.value);
      participanteExternoManutencao.value = "";
    }
  });
}
if (templateParticipantesList) {
  templateParticipantesList.addEventListener("click", (event) => {
    const button = event.target.closest("button[data-participant-name]");
    if (!button) {
      return;
    }
    toggleTemplateParticipante(button.dataset.participantName);
  });
}
if (templateParticipantesSelected) {
  templateParticipantesSelected.addEventListener("click", (event) => {
    const button = event.target.closest("button[data-participant-remove]");
    if (!button) {
      return;
    }
    const name = button.dataset.participantRemove;
    templateParticipantesSelecionados = templateParticipantesSelecionados.filter(
      (item) => item !== name
    );
    syncTemplateParticipantesInput();
    renderTemplateParticipantesOptions();
    renderTemplateParticipantesSelected();
    setFieldError(templateParticipantesErro, "");
  });
}
if (btnAddTemplateParticipanteExterno) {
  btnAddTemplateParticipanteExterno.addEventListener("click", () => {
    addTemplateParticipantesExternos(
      templateParticipanteExterno ? templateParticipanteExterno.value : ""
    );
    if (templateParticipanteExterno) {
      templateParticipanteExterno.value = "";
      templateParticipanteExterno.focus();
    }
  });
}
if (templateParticipanteExterno) {
  templateParticipanteExterno.addEventListener("keydown", (event) => {
    if (event.key === "Enter") {
      event.preventDefault();
      addTemplateParticipantesExternos(templateParticipanteExterno.value);
      templateParticipanteExterno.value = "";
    }
  });
}
if (btnFecharHistorico) {
  btnFecharHistorico.addEventListener("click", fecharHistorico);
}
if (btnFecharPreview) {
  btnFecharPreview.addEventListener("click", fecharPreview);
}
if (btnAbrirPreview) {
  btnAbrirPreview.addEventListener("click", () => {
    if (!previewCurrentUrl) {
      return;
    }
    openInNewTab(previewCurrentUrl);
  });
  btnAbrirPreview.disabled = true;
}
if (btnConfirmarInicioExecucao) {
  btnConfirmarInicioExecucao.addEventListener("click", confirmarInicioExecucao);
}
if (btnCancelarInicioExecucao) {
  btnCancelarInicioExecucao.addEventListener("click", fecharInicioExecucao);
}
if (btnFecharInicioExecucao) {
  btnFecharInicioExecucao.addEventListener("click", fecharInicioExecucao);
}
if (btnHistoricoMais) {
  btnHistoricoMais.addEventListener("click", () => {
    if (!historicoAtualId) {
      return;
    }
    const item = manutencoes.find((registro) => registro.id === historicoAtualId);
    if (!item) {
      return;
    }
    historicoLimite += HISTORY_PAGE_SIZE;
    renderHistorico(item);
  });
}
if (btnHistoricoExportar) {
  btnHistoricoExportar.addEventListener("click", () => {
    if (!historicoAtualId) {
      return;
    }
    const item = manutencoes.find((registro) => registro.id === historicoAtualId);
    if (!item) {
      return;
    }
    exportarHistorico(item);
  });
}
if (btnHistoricoExportarPdf) {
  btnHistoricoExportarPdf.addEventListener("click", () => {
    if (!historicoAtualId) {
      return;
    }
    const item = manutencoes.find((registro) => registro.id === historicoAtualId);
    if (!item) {
      return;
    }
    exportarHistoricoPdf(item);
  });
}
if (evidenciaButtons.length) {
  evidenciaButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const alvo = button.dataset.evidenciaBtn;
      const input = evidenciaInputs.find(
        (item) => item.dataset.evidenciaInput === alvo
      );
      if (input) {
        input.click();
      }
    });
  });
}
if (evidenciaInputs.length) {
  evidenciaInputs.forEach((input) => {
    input.addEventListener("change", atualizarListaEvidencias);
  });
}
if (conclusaoFotosToggle) {
  conclusaoFotosToggle.addEventListener("change", toggleConclusaoFotosUI);
  toggleConclusaoFotosUI();
}
if (novaDocButtons.length) {
  novaDocButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const alvo = button.dataset.novaDocBtn;
      const input = novaDocInputs.find((item) => item.dataset.novaDocInput === alvo);
      if (input) {
        input.click();
      }
    });
  });
}
if (novaDocInputs.length) {
  novaDocInputs.forEach((input) => {
    input.addEventListener("change", atualizarNovaDocsUI);
  });
  atualizarNovaDocsUI();
}
if (novaDocViews.length) {
  novaDocViews.forEach((button) => {
    button.addEventListener("click", () => {
      const alvo = button.dataset.novaDocView;
      const input = novaDocInputs.find((item) => item.dataset.novaDocInput === alvo);
      const file = input && input.files && input.files[0] ? input.files[0] : null;
      if (file) {
        const blobUrl = URL.createObjectURL(file);
        abrirPreview(blobUrl, blobUrl);
        return;
      }
      const existente = novaDocExisting && alvo ? novaDocExisting[alvo] : null;
      if (existente) {
        abrirDocumento(existente);
      }
    });
  });
}
if (liberacaoDocButtons.length) {
  liberacaoDocButtons.forEach((button) => {
    button.addEventListener("click", () => {
      const alvo = button.dataset.docBtn;
      const input = liberacaoDocInputs.find((item) => item.dataset.docInput === alvo);
      if (input) {
        input.click();
      }
    });
  });
}
if (liberacaoDocInputs.length) {
  liberacaoDocInputs.forEach((input) => {
    input.addEventListener("change", () => handleLiberacaoDocChange(input));
  });
}
if (liberacaoDocViews.length) {
  liberacaoDocViews.forEach((button) => {
    button.addEventListener("click", () => {
      const alvo = button.dataset.docView;
      const doc = getLiberacaoDocAtual(alvo);
      if (doc) {
        abrirDocumento(doc);
      }
    });
  });
}
if (btnImprimirRelatorio) {
  btnImprimirRelatorio.addEventListener("click", imprimirRelatorio);
}
if (btnExportarPDF) {
  btnExportarPDF.addEventListener("click", imprimirRelatorio);
}
if (btnFecharRelatorio) {
  btnFecharRelatorio.addEventListener("click", fecharRelatorio);
}

if (gerencialTabs.length) {
  gerencialTabs.forEach((tab) => {
    tab.addEventListener("click", () => {
      if (tab.hidden) {
        return;
      }
      const tabId = tab.dataset.tabTarget;
      if (canAccessGerencialTab(tabId, currentUser)) {
        setGerencialTabActive(tabId);
      }
    });
  });
}

if (gerencialIndicatorsWrap) {
  gerencialIndicatorsWrap.addEventListener("click", (event) => {
    const actionBtn = event.target.closest(".indicator-card__action");
    if (actionBtn) {
      const action = actionBtn.dataset.action;
      if (action === "open-diagnostico") {
        setGerencialTabActive("diagnostico");
        carregarHealth(true);
      }
      if (action === "open-logs") {
        setGerencialTabActive("logs");
        carregarApiLogs(true);
      }
      if (action === "open-arquivos") {
        setGerencialTabActive("arquivos");
        carregarArquivos(true);
      }
      if (action === "open-automacoes") {
        setGerencialTabActive("automacoes");
        carregarAutomacoes(true);
      }
      return;
    }
    const card = event.target.closest(".indicator-card[data-tab-target]");
    if (!card || card.hidden) {
      return;
    }
    const tabId = card.dataset.tabTarget;
    if (canAccessGerencialTab(tabId, currentUser)) {
      setGerencialTabActive(tabId);
    }
  });
  gerencialIndicatorsWrap.addEventListener("keydown", (event) => {
    if (event.key !== "Enter" && event.key !== " ") {
      return;
    }
    const card = event.target.closest(".indicator-card[data-tab-target]");
    if (!card || card.hidden) {
      return;
    }
    event.preventDefault();
    const tabId = card.dataset.tabTarget;
    if (canAccessGerencialTab(tabId, currentUser)) {
      setGerencialTabActive(tabId);
    }
  });
}

if (btnGerencialPalette) {
  btnGerencialPalette.addEventListener("click", openGerencialPalette);
}

if (gerencialPaletteTrigger) {
  gerencialPaletteTrigger.addEventListener("focus", openGerencialPalette);
  gerencialPaletteTrigger.addEventListener("click", openGerencialPalette);
}

if (gerencialPaletteInput) {
  gerencialPaletteInput.addEventListener("input", (event) => {
    renderGerencialPalette(event.target.value);
  });
  gerencialPaletteInput.addEventListener("keydown", (event) => {
    if (event.key !== "Enter") {
      return;
    }
    const first = gerencialPaletteList
      ? gerencialPaletteList.querySelector(".command-palette__item")
      : null;
    if (first) {
      first.click();
    }
  });
}

if (gerencialPalette) {
  gerencialPalette.addEventListener("click", (event) => {
    const close = event.target.closest("[data-palette-close]");
    if (close || event.target.classList.contains("command-palette__overlay")) {
      closeGerencialPalette();
      return;
    }
    const item = event.target.closest(".command-palette__item");
    if (!item) {
      return;
    }
    const tabId = item.dataset.paletteTab;
    if (tabId && canAccessGerencialTab(tabId, currentUser)) {
      setGerencialTabActive(tabId);
    }
    const selector = item.dataset.paletteSelector;
    if (selector) {
      const target = document.querySelector(selector);
      if (target && typeof target.click === "function" && !target.disabled) {
        target.click();
      }
    }
    const scrollTarget = item.dataset.paletteScroll;
    if (scrollTarget) {
      const target = document.getElementById(scrollTarget);
      if (target) {
        target.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }
    closeGerencialPalette();
  });
}

document.addEventListener("keydown", (event) => {
  if (event.key === "Escape") {
    if (gerencialPalette && !gerencialPalette.hidden) {
      closeGerencialPalette();
      return;
    }
  }
  if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === "k") {
    const opened = openGerencialPalette();
    if (opened) {
      event.preventDefault();
    }
  }
});

if (btnGerencialRefreshAll) {
  btnGerencialRefreshAll.addEventListener("click", () => {
    refreshGerencialAll();
  });
}

if (btnGerencialGoLogs) {
  btnGerencialGoLogs.addEventListener("click", () => {
    if (canAccessGerencialTab("logs", currentUser)) {
      setGerencialTabActive("logs");
    }
  });
}

if (btnGerencialGoPermissoes) {
  btnGerencialGoPermissoes.addEventListener("click", () => {
    if (canAccessGerencialTab("permissoes", currentUser)) {
      setGerencialTabActive("permissoes");
    }
  });
}

if (listaSolicitacoes) {
  listaSolicitacoes.addEventListener("click", (event) => {
    const botao = event.target.closest("button[data-action]");
    if (!botao) {
      return;
    }
    const item = botao.closest("[data-request-id]");
    if (!item) {
      return;
    }
    if (botao.dataset.action === "approve") {
      aprovarSolicitacao(item);
    }
    if (botao.dataset.action === "reject") {
      recusarSolicitacao(item);
    }
  });
}

if (listaUsuarios) {
  listaUsuarios.addEventListener("click", (event) => {
    const item = event.target.closest(".account-item");
    if (!item || !item.dataset.userId) {
      return;
    }
    abrirUserDrawer(item.dataset.userId);
  });

  listaUsuarios.addEventListener("keydown", (event) => {
    if (event.key !== "Enter" && event.key !== " ") {
      return;
    }
    const item = event.target.closest(".account-item");
    if (!item || !item.dataset.userId) {
      return;
    }
    event.preventDefault();
    abrirUserDrawer(item.dataset.userId);
  });
}

if (userFiltroNome) {
  userFiltroNome.addEventListener("input", renderUsuarios);
}
if (userFiltroCargo) {
  userFiltroCargo.addEventListener("input", renderUsuarios);
}
if (userFiltroProjeto) {
  userFiltroProjeto.addEventListener("input", renderUsuarios);
}
if (userFiltroStatus) {
  userFiltroStatus.addEventListener("change", renderUsuarios);
}
if (btnLimparFiltroUsuarios) {
  btnLimparFiltroUsuarios.addEventListener("click", () => {
    if (userFiltroNome) {
      userFiltroNome.value = "";
    }
    if (userFiltroCargo) {
      userFiltroCargo.value = "";
    }
    if (userFiltroProjeto) {
      userFiltroProjeto.value = "";
    }
    if (userFiltroStatus) {
      userFiltroStatus.value = "";
    }
    renderUsuarios();
  });
}

if (userDrawer) {
  userDrawer.addEventListener("click", (event) => {
    const alvo = event.target.closest("[data-drawer-close]");
    if (alvo) {
      fecharUserDrawer();
    }
  });
}
if (btnFecharUserDrawer) {
  btnFecharUserDrawer.addEventListener("click", fecharUserDrawer);
}
if (btnCancelarUserDrawer) {
  btnCancelarUserDrawer.addEventListener("click", fecharUserDrawer);
}
if (userDrawerForm) {
  userDrawerForm.addEventListener("submit", salvarUserDrawer);
}
if (drawerRole) {
  drawerRole.addEventListener("change", () => {
    const userId = drawerUserId ? drawerUserId.value : "";
    const user = users.find((item) => item.id === userId);
    renderDrawerPermissions(user || {}, collectDrawerPermissions());
  });
}

if (btnLogoHome) {
  btnLogoHome.addEventListener("click", () => {
    abrirPainelComCarregamento("inicio");
  });
}

if (btnIrAcessos) {
  btnIrAcessos.addEventListener("click", () => {
    abrirPainelComCarregamento("acessos");
    setAccessTab("contas");
    refreshAccessData({ force: true });
  });
}

if (accessTabs.length) {
  accessTabs.forEach((button) => {
    button.addEventListener("click", () => {
      setAccessTab(button.dataset.accessTab || "contas");
    });
  });
}

if (btnAccessNewUser) {
  btnAccessNewUser.addEventListener("click", () => {
    if (!currentUser || !canManageAccess(currentUser)) {
      setAccessMessage("Sem permiss\u00e3o para criar contas.", true);
      return;
    }
    if (!accessWriteEnabled) {
      setAccessMessage(ACCESS_STORAGE_READONLY_MESSAGE, true);
      return;
    }
    openAccessUserModal();
  });
}

if (btnAccessNewRole) {
  btnAccessNewRole.addEventListener("click", () => {
    if (!currentUser || !canManageAccess(currentUser)) {
      setAccessMessage("Sem permiss\u00e3o para criar cargos.", true);
      return;
    }
    if (!accessWriteEnabled) {
      setAccessMessage(ACCESS_STORAGE_READONLY_MESSAGE, true);
      return;
    }
    openAccessRoleModal();
  });
}

if (btnAccessExport) {
  btnAccessExport.addEventListener("click", exportAccessPackage);
}

if (btnAccessImport) {
  btnAccessImport.addEventListener("click", () => {
    if (currentUser && !canManageAccess(currentUser)) {
      setAccessMessage("Sem permiss\u00e3o para importar acessos.", true);
      return;
    }
    if (!accessWriteEnabled) {
      setAccessMessage(ACCESS_STORAGE_READONLY_MESSAGE, true);
      return;
    }
    openAccessImportDialog();
  });
}

if (accessImportInput) {
  accessImportInput.addEventListener("change", () => {
    const file = accessImportInput.files && accessImportInput.files[0];
    if (!file) {
      return;
    }
    if (currentUser && !canManageAccess(currentUser)) {
      showAccessImportMessage("Sem permiss\u00e3o para importar acessos.", true);
      return;
    }
    if (!accessWriteEnabled) {
      showAccessImportMessage(ACCESS_STORAGE_READONLY_MESSAGE, true);
      return;
    }
    importAccessPackageFromFile(file);
  });
}

if (btnAccessClearFilters) {
  btnAccessClearFilters.addEventListener("click", () => {
    if (accessUserSearch) {
      accessUserSearch.value = "";
    }
    if (accessUserStatusFilter) {
      accessUserStatusFilter.value = "";
    }
    if (accessUserRoleFilter) {
      accessUserRoleFilter.value = "";
    }
    if (accessUserProjectFilter) {
      accessUserProjectFilter.value = "";
    }
    renderAccessUsers();
  });
}

if (accessUserSearch) {
  accessUserSearch.addEventListener("input", renderAccessUsers);
}
if (accessUserStatusFilter) {
  accessUserStatusFilter.addEventListener("change", renderAccessUsers);
}
if (accessUserRoleFilter) {
  accessUserRoleFilter.addEventListener("change", renderAccessUsers);
}
if (accessUserProjectFilter) {
  accessUserProjectFilter.addEventListener("change", renderAccessUsers);
}
if (accessRoleSearch) {
  accessRoleSearch.addEventListener("input", renderAccessRoles);
}
if (accessRoleSelect) {
  accessRoleSelect.addEventListener("change", () => {
    if (accessRoleSelectLocked) {
      return;
    }
    const selectedId = accessRoleSelect.value;
    if (!selectedId || selectedId === "__new__") {
      resetAccessRoleToNew();
      return;
    }
    const role = accessRoles.find((item) => String(item.id) === String(selectedId));
    if (role) {
      if (accessRoleModalTitle) {
        accessRoleModalTitle.textContent = "Editar cargo";
      }
      if (accessRoleModalSubtitle) {
        accessRoleModalSubtitle.textContent = "Atualize as permiss\u00f5es do cargo.";
      }
      selectAccessRole(role);
    }
  });
}
if (btnAccessRoleRename) {
  btnAccessRoleRename.addEventListener("click", () => {
    const enabled = !accessRoleEditorState.renameMode;
    setAccessRoleNameMode(enabled);
  });
}
if (accessRolePermissionSearch) {
  accessRolePermissionSearch.addEventListener("input", () => {
    accessRoleEditorState.query = accessRolePermissionSearch.value || "";
    renderAccessRolePermissions();
  });
}
if (accessRoleFilterConfigured) {
  accessRoleFilterConfigured.addEventListener("click", () => {
    accessRoleEditorState.onlyConfigured = !accessRoleEditorState.onlyConfigured;
    renderAccessRolePermissions();
  });
}
if (accessRoleFilterCritical) {
  accessRoleFilterCritical.addEventListener("click", () => {
    accessRoleEditorState.onlyCritical = !accessRoleEditorState.onlyCritical;
    renderAccessRolePermissions();
  });
}
if (accessRoleAllNone) {
  accessRoleAllNone.addEventListener("click", () => {
    applyAccessRoleGlobalLevel("NONE");
  });
}
if (accessRoleAllView) {
  accessRoleAllView.addEventListener("click", () => {
    applyAccessRoleGlobalLevel("VIEW");
  });
}
if (accessRoleAllEdit) {
  accessRoleAllEdit.addEventListener("click", () => {
    applyAccessRoleGlobalLevel("EDIT");
  });
}
if (accessRoleChangesDetails) {
  accessRoleChangesDetails.addEventListener("click", () => {
    accessRoleEditorState.showChanges = !accessRoleEditorState.showChanges;
    renderAccessRolePermissions();
  });
}
if (accessRoleAdminToggle) {
  accessRoleAdminToggle.addEventListener("change", () => {
    toggleAccessRoleAdmin(accessRoleAdminToggle.checked);
  });
}
if (accessRoleEditor) {
  accessRoleEditor.addEventListener("click", (event) => {
    const moduleButton = event.target.closest("button[data-role-module]");
    if (moduleButton) {
      setAccessRoleActiveModule(moduleButton.dataset.roleModule);
      return;
    }
    const levelButton = event.target.closest("button[data-level]");
    if (levelButton) {
      const level = levelButton.dataset.level;
      const itemKey = levelButton.dataset.itemKey;
      if (itemKey) {
        applyAccessRoleItemLevel(itemKey, level);
        return;
      }
      if (accessRoleModuleLevel && accessRoleModuleLevel.contains(levelButton)) {
        applyAccessRoleModuleLevel(accessRoleEditorState.activeModule, level);
        return;
      }
    }
  });
}

if (accessUsersTableBody) {
  accessUsersTableBody.addEventListener("click", async (event) => {
    const button = event.target.closest("button[data-action]");
    if (!button) {
      return;
    }
    const userId = button.dataset.userId;
    const user = accessUsers.find((item) => String(item.id) === String(userId));
    if (!user) {
      return;
    }
    if (!currentUser || !canManageAccess(currentUser)) {
      setAccessMessage("Sem permiss\u00e3o para esta acao.", true);
      return;
    }
    if (!accessWriteEnabled && button.dataset.action !== "view-profile") {
      setAccessMessage(ACCESS_STORAGE_READONLY_MESSAGE, true);
      return;
    }
    if (button.dataset.action === "view-profile") {
      openProfileForUser(user.id, { edit: false });
      return;
    }
    if (button.dataset.action === "edit-user") {
      openAccessUserModal(user);
      return;
    }
    if (button.dataset.action === "reset-password") {
      openResetPasswordModal(user);
      return;
    }
    if (button.dataset.action === "toggle-status") {
      const currentStatus = normalizeAccessUserStatus(user.status, user.active);
      const nextStatus = currentStatus === "INATIVO" ? "ATIVO" : "INATIVO";
      const confirmar =
        nextStatus === "INATIVO"
          ? window.confirm("Inativar esta conta?")
          : window.confirm("Ativar esta conta?");
      if (!confirmar) {
        return;
      }
      setAccessMessage("Atualizando status...");
      try {
        if (nextStatus === "INATIVO") {
          await dataProvider.authAdmin.deactivateUser(user.id);
          if (accessUserStatusFilter && accessUserStatusFilter.value === "ATIVO") {
            accessUserStatusFilter.value = "";
          }
        } else {
          await dataProvider.authAdmin.activateUser(user.id);
        }
        await refreshAccessUsers();
        setAccessMessage("Status atualizado.");
      } catch (error) {
        setAccessMessage(error.message || "Falha ao atualizar status.", true);
      }
    }
    if (button.dataset.action === "delete-user") {
      if (normalizeAccessUserStatus(user.status, user.active) !== "INATIVO") {
        setAccessMessage("Apenas contas inativas podem ser excluidas.", true);
        return;
      }
      const confirmar = window.confirm(
        "Excluir esta conta definitivamente? Esta acao nao pode ser desfeita."
      );
      if (!confirmar) {
        return;
      }
      setAccessMessage("Excluindo conta...");
      try {
        await dataProvider.authAdmin.deleteUser(user.id);
        await refreshAccessUsers();
        setAccessMessage("Conta excluida.");
      } catch (error) {
        setAccessMessage(error.message || "Falha ao excluir conta.", true);
      }
    }
  });
}

if (accessRolesTableBody) {
  accessRolesTableBody.addEventListener("click", async (event) => {
    const button = event.target.closest("button[data-action]");
    if (!button) {
      return;
    }
    const roleId = button.dataset.roleId;
    const role = accessRoles.find((item) => String(item.id) === String(roleId));
    if (!role) {
      return;
    }
    if (!currentUser || !canManageAccess(currentUser)) {
      setAccessMessage("Sem permiss\u00e3o para esta acao.", true);
      return;
    }
    if (!accessWriteEnabled) {
      setAccessMessage(ACCESS_STORAGE_READONLY_MESSAGE, true);
      return;
    }
    if (button.dataset.action === "move-role-up") {
      await moveAccessRole(role.id, "up");
      return;
    }
    if (button.dataset.action === "move-role-down") {
      await moveAccessRole(role.id, "down");
      return;
    }
    if (button.dataset.action === "edit-role") {
      openAccessRoleModal(role);
      return;
    }
    if (button.dataset.action === "delete-role") {
      const confirmar = window.confirm("Excluir este cargo?");
      if (!confirmar) {
        return;
      }
      setAccessMessage("Removendo cargo...");
      try {
        await dataProvider.roles.deleteRole(role.id);
        setStoredAccessRoleLevelMarkers(role.id, []);
        await refreshAccessRoles();
        await refreshAccessUsers();
        setAccessMessage("Cargo removido.");
      } catch (error) {
        setAccessMessage(error.message || "Falha ao remover cargo.", true);
      }
    }
  });
}

if (btnCloseAccessUserModal) {
  btnCloseAccessUserModal.addEventListener("click", closeAccessUserModal);
}
if (btnAccessUserCancel) {
  btnAccessUserCancel.addEventListener("click", closeAccessUserModal);
}
if (modalAccessUser) {
  modalAccessUser.addEventListener("click", (event) => {
    if (event.target === modalAccessUser) {
      closeAccessUserModal();
    }
  });
}

if (btnCloseProfilePermissions) {
  btnCloseProfilePermissions.addEventListener("click", closeProfilePermissionsModal);
}
if (btnCloseProfilePermissionsFooter) {
  btnCloseProfilePermissionsFooter.addEventListener("click", closeProfilePermissionsModal);
}
if (modalProfilePermissions) {
  modalProfilePermissions.addEventListener("click", (event) => {
    if (event.target === modalProfilePermissions) {
      closeProfilePermissionsModal();
    }
  });
}

document.querySelectorAll('input[name="accessUserPasswordMode"]').forEach((input) => {
  input.addEventListener("change", updateAccessUserPasswordMode);
});

if (btnAccessGeneratePassword) {
  btnAccessGeneratePassword.addEventListener("click", () => {
    const password = generatePassword(12);
    const manualRadio = document.querySelector('input[name="accessUserPasswordMode"][value="MANUAL"]');
    if (manualRadio) {
      manualRadio.checked = true;
    }
    if (accessUserPassword) {
      accessUserPassword.value = password;
      accessUserPassword.focus();
    }
    if (accessUserPasswordHint) {
      accessUserPasswordHint.textContent = "Senha gerada automaticamente. Copie antes de salvar.";
    }
    updateAccessUserPasswordMode();
  });
}

if (accessUserForm) {
  accessUserForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!currentUser || !canManageAccess(currentUser)) {
      setAccessUserFormMessage("Sem permiss\u00e3o para salvar.", true);
      return;
    }
    if (!accessWriteEnabled) {
      setAccessUserFormMessage(ACCESS_STORAGE_READONLY_MESSAGE, true);
      return;
    }
    const id = accessUserId ? accessUserId.value.trim() : "";
    const payload = {
      name: accessUserName ? accessUserName.value.trim() : "",
      matricula: accessUserMatricula ? accessUserMatricula.value.trim() : "",
      email: accessUserEmail ? accessUserEmail.value.trim().toLowerCase() : "",
      roleId: accessUserRole ? accessUserRole.value : "",
      projectId: accessUserProject ? accessUserProject.value : null,
      status: accessUserStatus ? accessUserStatus.value : "ATIVO",
    };
    setAccessUserFormMessage("");
    if (!payload.email) {
      setAccessUserFormMessage("Informe o email do usuario.", true);
      if (accessUserEmail) {
        accessUserEmail.focus();
      }
      return;
    }
    if (!isValidEmail(payload.email)) {
      setAccessUserFormMessage("Informe um email valido.", true);
      if (accessUserEmail) {
        accessUserEmail.focus();
      }
      return;
    }
    try {
      if (id) {
        await dataProvider.authAdmin.updateUser({ ...payload, id });
        closeAccessUserModal();
        await refreshAccessUsers();
        setAccessMessage("Conta atualizada.");
      } else {
        const mode = getSelectedAccessUserPasswordMode();
        const password = accessUserPassword ? accessUserPassword.value.trim() : "";
        const result = await dataProvider.authAdmin.createUser({
          ...payload,
          passwordMode: mode,
          password,
        });
        closeAccessUserModal();
        await refreshAccessUsers();
        setAccessMessage("Conta criada.");
        if (result && result.generatedPassword) {
          showGeneratedPassword(result.generatedPassword);
        }
      }
    } catch (error) {
      setAccessUserFormMessage(error.message || "Falha ao salvar conta.", true);
    }
  });
}

if (btnCloseResetPassword) {
  btnCloseResetPassword.addEventListener("click", closeResetPasswordModal);
}
if (btnResetPasswordCancel) {
  btnResetPasswordCancel.addEventListener("click", closeResetPasswordModal);
}
if (modalResetPassword) {
  modalResetPassword.addEventListener("click", (event) => {
    if (event.target === modalResetPassword) {
      closeResetPasswordModal();
    }
  });
}

document.querySelectorAll('input[name="resetPasswordMode"]').forEach((input) => {
  input.addEventListener("change", updateResetPasswordMode);
});

if (btnResetGeneratePassword) {
  btnResetGeneratePassword.addEventListener("click", () => {
    const password = generatePassword(12);
    const manualRadio = document.querySelector('input[name="resetPasswordMode"][value="MANUAL"]');
    if (manualRadio) {
      manualRadio.checked = true;
    }
    if (resetPasswordValue) {
      resetPasswordValue.value = password;
      resetPasswordValue.focus();
    }
    updateResetPasswordMode();
  });
}

if (resetPasswordForm) {
  resetPasswordForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!currentUser || !canManageAccess(currentUser)) {
      setResetPasswordMessage("Sem permiss\u00e3o para salvar.", true);
      return;
    }
    if (!accessWriteEnabled) {
      setResetPasswordMessage(ACCESS_STORAGE_READONLY_MESSAGE, true);
      return;
    }
    const id = resetPasswordUserId ? resetPasswordUserId.value.trim() : "";
    const mode = getSelectedResetPasswordMode();
    const password = resetPasswordValue ? resetPasswordValue.value.trim() : "";
    setResetPasswordMessage("");
    try {
      const result = await dataProvider.authAdmin.resetPassword({ id, mode, password });
      closeResetPasswordModal();
      await refreshAccessUsers();
      setAccessMessage("Senha atualizada.");
      if (result && result.generatedPassword) {
        showGeneratedPassword(result.generatedPassword);
      }
    } catch (error) {
      setResetPasswordMessage(error.message || "Falha ao atualizar senha.", true);
    }
  });
}

if (btnCloseGeneratedPassword) {
  btnCloseGeneratedPassword.addEventListener("click", closeGeneratedPasswordModal);
}
if (btnGeneratedPasswordDone) {
  btnGeneratedPasswordDone.addEventListener("click", closeGeneratedPasswordModal);
}
if (btnCopyGeneratedPassword) {
  btnCopyGeneratedPassword.addEventListener("click", async () => {
    const text = generatedPasswordValue ? generatedPasswordValue.textContent : "";
    if (!text) {
      return;
    }
    try {
      await navigator.clipboard.writeText(text);
      btnCopyGeneratedPassword.textContent = "Copiado!";
      setTimeout(() => {
        btnCopyGeneratedPassword.textContent = "Copiar";
      }, 2000);
    } catch (error) {
      // noop
    }
  });
}

if (modalGeneratedPassword) {
  modalGeneratedPassword.addEventListener("click", (event) => {
    if (event.target === modalGeneratedPassword) {
      closeGeneratedPasswordModal();
    }
  });
}

if (btnCloseAccessRoleModal) {
  btnCloseAccessRoleModal.addEventListener("click", closeAccessRoleModal);
}
if (btnAccessRoleCancel) {
  btnAccessRoleCancel.addEventListener("click", closeAccessRoleModal);
}
if (modalAccessRole) {
  modalAccessRole.addEventListener("click", (event) => {
    if (event.target === modalAccessRole) {
      closeAccessRoleModal();
    }
  });
}

if (btnConfirmOk) {
  btnConfirmOk.addEventListener("click", () => closeConfirmModal(true));
}
if (btnConfirmCancel) {
  btnConfirmCancel.addEventListener("click", () => closeConfirmModal(false));
}
if (btnConfirmClose) {
  btnConfirmClose.addEventListener("click", () => closeConfirmModal(false));
}
if (modalConfirm) {
  modalConfirm.addEventListener("click", (event) => {
    if (event.target === modalConfirm) {
      closeConfirmModal(false);
    }
  });
}
if (btnAuthHelp) {
  btnAuthHelp.addEventListener("click", openAccessHelpModal);
}
if (btnForgotPassword) {
  btnForgotPassword.addEventListener("click", (event) => {
    event.preventDefault();
    openPasswordResetModal(loginUsuario ? loginUsuario.value : "");
  });
}
if (btnAccessHelpClose) {
  btnAccessHelpClose.addEventListener("click", closeAccessHelpModal);
}
if (modalAccessHelp) {
  modalAccessHelp.addEventListener("click", (event) => {
    if (event.target === modalAccessHelp) {
      closeAccessHelpModal();
    }
  });
}
if (btnAccessHelpRequest) {
  btnAccessHelpRequest.addEventListener("click", () => {
    handleAccessHelpCopy("request");
  });
}
if (btnAccessHelpReset) {
  btnAccessHelpReset.addEventListener("click", () => {
    openPasswordResetModal(loginUsuario ? loginUsuario.value : "");
  });
}
if (btnAccessHelpImport) {
  btnAccessHelpImport.addEventListener("click", () => {
    openAccessImportDialog();
  });
}
if (btnPasswordResetClose) {
  btnPasswordResetClose.addEventListener("click", closePasswordResetModal);
}
if (btnPasswordResetCancel) {
  btnPasswordResetCancel.addEventListener("click", closePasswordResetModal);
}
if (modalPasswordReset) {
  modalPasswordReset.addEventListener("click", (event) => {
    if (event.target === modalPasswordReset) {
      closePasswordResetModal();
    }
  });
}
if (passwordResetEmail) {
  passwordResetEmail.addEventListener("input", () => {
    if (passwordResetCodeSent) {
      if (passwordResetCode) {
        passwordResetCode.value = "";
      }
      if (passwordResetNew) {
        passwordResetNew.value = "";
      }
      if (passwordResetConfirm) {
        passwordResetConfirm.value = "";
      }
      setPasswordResetCodeSent(false);
    }
    setPasswordResetMessage("");
  });
}
if (passwordResetCode) {
  passwordResetCode.addEventListener("input", () => {
    if (passwordResetCodeValidated) {
      setPasswordResetCodeValidated(false);
    }
    if (btnPasswordResetValidate) {
      const codeValue = passwordResetCode.value.trim();
      btnPasswordResetValidate.disabled = !passwordResetCodeSent || !codeValue;
    }
    setPasswordResetMessage("");
  });
}

if (accessRoleForm) {
  accessRoleForm.addEventListener("submit", async (event) => {
    event.preventDefault();
    if (!currentUser || !canManageAccess(currentUser)) {
      setAccessRoleFormMessage("Sem permiss\u00e3o para salvar.", true);
      return;
    }
    if (!accessWriteEnabled) {
      setAccessRoleFormMessage(ACCESS_STORAGE_READONLY_MESSAGE, true);
      return;
    }
    const id = accessRoleId ? accessRoleId.value.trim() : "";
    const name = accessRoleName ? accessRoleName.value.trim() : "";
    if (!id && !name) {
      setAccessRoleFormMessage("Selecione ou informe o nome do cargo.", true);
      return;
    }
    const permissions = collectAccessRolePermissions();
    const baselineExpanded = expandAccessPermissions(accessRoleEditorState.baseline || []);
    const currentExpanded = expandAccessPermissions(permissions);
    const diff = diffAccessRoleKeys(accessRoleEditorState.baseline || [], permissions);
    const changedCount = diff.changedItems.length;
    const newlyDangerous = Array.from(currentExpanded).filter(
      (key) => ACCESS_PERMISSION_DANGEROUS.has(key) && !baselineExpanded.has(key)
    );
    if (newlyDangerous.length) {
      const labels = newlyDangerous
        .map((key) =>
          formatAccessText((ACCESS_PERMISSION_INDEX.get(key) || {}).label || key)
        )
        .join(", ");
      const quantidade = newlyDangerous.length;
      const permLabel = quantidade === 1 ? "permiss\u00e3o cr\u00edtica" : "permiss\u00f5es cr\u00edticas";
      const confirm = await openConfirmModal({
        title: "Permiss\u00f5es cr\u00edticas habilitadas",
        message: `Voc\u00ea habilitou ${quantidade} ${permLabel}: ${labels}. Deseja continuar?`,
        confirmText: "Confirmar e salvar",
        cancelText: "Cancelar",
      });
      if (!confirm) {
        return;
      }
    }
    setAccessRoleFormMessage("");
    try {
      const savedRole = await dataProvider.roles.upsertRole({ id: id || undefined, name, permissions });
      if (savedRole && savedRole.id) {
        setStoredAccessRoleLevelMarkers(savedRole.id, permissions);
      }
      closeAccessRoleModal();
      await refreshAccessRoles();
      await refreshAccessUsers();
      setAccessMessage(
        `Cargo salvo. Voc\u00ea alterou ${changedCount} item${changedCount === 1 ? "" : "s"}.`
      );
    } catch (error) {
      setAccessRoleFormMessage(error.message || "Falha ao salvar cargo.", true);
    }
  });
}

if (listaModelos) {
  listaModelos.addEventListener("click", (event) => {
    const botao = event.target.closest("button[data-action]");
    if (!botao) {
      return;
    }
    const item = botao.closest("[data-template-id]");
    if (!item) {
      return;
    }
    if (botao.dataset.action === "edit-template") {
      const template = templates.find((registro) => registro.id === item.dataset.templateId);
      if (template) {
        preencherTemplateForm(template);
      }
    }
    if (botao.dataset.action === "toggle-template") {
      alternarModelo(item);
    }
    if (botao.dataset.action === "delete-template") {
      removerModelo(item);
    }
  });
}

if (pmpForm) {
  pmpForm.addEventListener("submit", salvarPmpActivity);
}
if (pmpFormCancel) {
  pmpFormCancel.addEventListener("click", resetPmpForm);
}
if (pmpAno) {
  pmpAno.addEventListener("change", renderPmpModule);
}
if (pmpView) {
  pmpView.addEventListener("change", renderPmpModule);
}
if (pmpMes) {
  pmpMes.addEventListener("change", renderPmpModule);
}
if (pmpFiltroProjeto) {
  pmpFiltroProjeto.addEventListener("change", () => {
    renderPmpEquipamentoOptions(pmpFiltroProjeto.value);
    renderPmpResponsavelOptions(pmpFiltroProjeto.value);
    syncPmpHorasDisponiveisInput(pmpFiltroProjeto.value);
    updatePmpImportButton();
    renderPmpModule();
  });
}
if (pmpFiltroFrequencia) {
  pmpFiltroFrequencia.addEventListener("change", renderPmpModule);
}
if (pmpFiltroEquipamento) {
  pmpFiltroEquipamento.addEventListener("change", renderPmpModule);
}
if (pmpFiltroResponsavel) {
  pmpFiltroResponsavel.addEventListener("change", renderPmpModule);
}
if (pmpFiltroOrigem) {
  pmpFiltroOrigem.addEventListener("change", renderPmpModule);
}
if (pmpFiltroStatus) {
  pmpFiltroStatus.addEventListener("change", renderPmpModule);
}
if (pmpHorasDisponiveis) {
  pmpHorasDisponiveis.addEventListener("input", () => {
    renderPmpModule();
    schedulePmpHorasDisponiveisSave();
  });
}
if (pmpBusca) {
  pmpBusca.addEventListener("input", renderPmpModule);
}
if (pmpProjeto) {
  pmpProjeto.addEventListener("change", () => {
    renderPmpEquipamentoOptions(pmpProjeto.value);
    renderPmpResponsavelOptions(pmpProjeto.value);
  });
}
if (pmpProcedimentoUpload && pmpProcedimentoFile) {
  pmpProcedimentoUpload.addEventListener("click", () => {
    if (!currentUser || !canUploadPmpProcedimento(currentUser)) {
      if (pmpFormMensagem) {
        pmpFormMensagem.textContent = "Somente PCM pode anexar procedimentos.";
      }
      return;
    }
    pmpProcedimentoFile.click();
  });
}
if (pmpProcedimentoFile) {
  pmpProcedimentoFile.addEventListener("change", () => {
    const file = pmpProcedimentoFile.files && pmpProcedimentoFile.files[0];
    uploadPmpProcedimento(file);
  });
}
if (pmpProcedimentoView) {
  pmpProcedimentoView.addEventListener("click", () => {
    openPmpProcedimento(pmpProcedimentoDoc);
  });
}
if (pmpProcedimentoRemove) {
  pmpProcedimentoRemove.addEventListener("click", () => {
    if (!currentUser || !canUploadPmpProcedimento(currentUser)) {
      if (pmpFormMensagem) {
        pmpFormMensagem.textContent = "Somente PCM pode remover procedimentos.";
      }
      return;
    }
    if (!pmpProcedimentoDoc) {
      return;
    }
    const confirmar = window.confirm("Remover o procedimento anexado?");
    if (!confirmar) {
      return;
    }
    setPmpProcedimentoDoc(null);
    if (pmpFormMensagem) {
      pmpFormMensagem.textContent = "Procedimento removido. Salve a atividade para aplicar.";
    }
  });
}
if (pmpGridBody) {
  pmpGridBody.addEventListener("click", (event) => {
    const botao = event.target.closest("[data-pmp-action]");
    if (botao) {
      const activityId = botao.dataset.pmpId;
      if (!activityId) {
        return;
      }
      if (botao.dataset.pmpAction === "edit") {
        const activity = pmpActivities.find((item) => item.id === activityId);
        if (activity) {
          preencherPmpForm(activity);
        }
      }
      if (botao.dataset.pmpAction === "delete") {
        removerPmpActivity(activityId);
      }
      if (botao.dataset.pmpAction === "view-procedure") {
        const activity = pmpActivities.find((item) => item.id === activityId);
        if (activity) {
          openPmpProcedimento(activity.procedimentoDoc || null);
        }
      }
      return;
    }
    const cell = event.target.closest("td[data-pmp-cell]");
    if (cell && cell.dataset.activityId && cell.dataset.periodKey) {
      openPmpCellModal(cell.dataset.activityId, cell.dataset.periodKey);
    }
  });
}
if (pmpChecklistAdd) {
  pmpChecklistAdd.addEventListener("click", addPmpChecklistItem);
}
if (pmpChecklistList) {
  pmpChecklistList.addEventListener("click", (event) => {
    const botao = event.target.closest("[data-pmp-checklist-remove]");
    if (!botao) {
      return;
    }
    const index = Number(botao.dataset.pmpChecklistRemove);
    if (!Number.isFinite(index)) {
      return;
    }
    pmpChecklistItems = pmpChecklistItems.filter((_, idx) => idx !== index);
    renderPmpChecklist();
  });
}
if (pmpImportBtn) {
  pmpImportBtn.addEventListener("click", openPmpImportModal);
}
if (pmpImportCancel) {
  pmpImportCancel.addEventListener("click", closePmpImportModal);
}
if (pmpImportClose) {
  pmpImportClose.addEventListener("click", closePmpImportModal);
}
if (pmpImportSearch) {
  pmpImportSearch.addEventListener("input", renderPmpImportList);
}
if (pmpImportConfirm) {
  pmpImportConfirm.addEventListener("click", confirmPmpImport);
}
if (pmpCellClose) {
  pmpCellClose.addEventListener("click", closePmpCellModal);
}
if (pmpCellCloseBtn) {
  pmpCellCloseBtn.addEventListener("click", closePmpCellModal);
}
if (pmpCellSave) {
  pmpCellSave.addEventListener("click", salvarPmpExecucaoManual);
}
if (pmpCellRemove) {
  pmpCellRemove.addEventListener("click", removerPmpExecucaoManual);
}
if (pmpCellUnset) {
  pmpCellUnset.addEventListener("click", marcarPmpNaoPrevista);
}
if (pmpCellMarkCancel) {
  pmpCellMarkCancel.addEventListener("click", marcarPmpCancelada);
}
if (pmpDuplicarPlano) {
  pmpDuplicarPlano.addEventListener("click", duplicarPmpPlano);
}
if (pmpExportPdf) {
  pmpExportPdf.addEventListener("click", exportarPmpPdf);
}
if (pmpExportExcel) {
  pmpExportExcel.addEventListener("click", exportarPmpExcel);
}
if (almoxMovType) {
  almoxMovType.addEventListener("change", updateAlmoxTransferFields);
  updateAlmoxTransferFields();
}
if (almoxItemForm) {
  almoxItemForm.addEventListener("submit", handleAlmoxItemSubmit);
}
if (almoxMovForm) {
  almoxMovForm.addEventListener("submit", handleAlmoxMovSubmit);
}
if (sstTrainingForm) {
  sstTrainingForm.addEventListener("submit", handleSstTrainingSubmit);
}
if (sstInspectionForm) {
  sstInspectionForm.addEventListener("submit", (event) => event.preventDefault());
}
if (sstTemplateSeedBtn) {
  sstTemplateSeedBtn.addEventListener("click", handleSstTemplateSeed);
}
if (sstTemplateNewBtn) {
  sstTemplateNewBtn.addEventListener("click", () => openSstTemplateModal());
}
if (formSstTemplate) {
  formSstTemplate.addEventListener("submit", handleSstTemplateSubmit);
}
if (sstTemplateAddQuestion) {
  sstTemplateAddQuestion.addEventListener("click", () => addSstTemplateQuestionRow());
}
if (sstTemplateQuestions) {
  sstTemplateQuestions.addEventListener("click", handleSstTemplateQuestionsClick);
}
if (sstTemplateTableBody) {
  sstTemplateTableBody.addEventListener("click", handleSstTemplateTableClick);
}
if (sstInspectionStartBtn) {
  sstInspectionStartBtn.addEventListener("click", handleSstInspectionStart);
}
if (sstInspectionTableBody) {
  sstInspectionTableBody.addEventListener("click", handleSstInspectionHistoryClick);
}
if (sstInspectionFilterProject) {
  sstInspectionFilterProject.addEventListener("change", renderSstInspecoes);
}
if (sstInspectionFilterTemplate) {
  sstInspectionFilterTemplate.addEventListener("change", renderSstInspecoes);
}
if (sstInspectionFilterStatus) {
  sstInspectionFilterStatus.addEventListener("change", renderSstInspecoes);
}
if (sstInspectionFilterFrom) {
  sstInspectionFilterFrom.addEventListener("change", renderSstInspecoes);
}
if (sstInspectionFilterTo) {
  sstInspectionFilterTo.addEventListener("change", renderSstInspecoes);
}
if (sstInspectionFilterSearch) {
  sstInspectionFilterSearch.addEventListener("input", renderSstInspecoes);
}
if (sstInspectionProject) {
  sstInspectionProject.addEventListener("change", () => {
    renderSstInspectionLocalOptions();
    renderSstInspectionTemplateOptions();
    renderSstVehicleOptions();
    updateSstInspectionVehicleVisibility();
  });
}
if (sstInspectionVehicle) {
  sstInspectionVehicle.addEventListener("change", () => {
    const vehicle = sstVehicles.find(
      (item) => String(item.id) === String(sstInspectionVehicle.value)
    );
    updateSstInspectionVehicleInfo(vehicle || null);
  });
}
if (sstInspectionVehicleStatusFilter) {
  sstInspectionVehicleStatusFilter.addEventListener("change", renderSstVehicleOptions);
}
if (sstInspectionVehicleCta) {
  sstInspectionVehicleCta.addEventListener("click", (event) => {
    event.preventDefault();
    const projectId = sstInspectionProject ? sstInspectionProject.value : activeProjectId;
    openProjectVehiclesTab(projectId || "");
  });
}
if (sstInspectionTemplate) {
  sstInspectionTemplate.addEventListener("change", () => {
    updateSstInspectionVehicleVisibility();
    renderSstVehicleOptions();
  });
}
if (sstVehicleForm) {
  sstVehicleForm.addEventListener("submit", handleSstVehicleSubmit);
}
if (sstVehicleTableBody) {
  sstVehicleTableBody.addEventListener("click", handleSstVehicleTableClick);
}
if (sstVehicleFilterProject) {
  sstVehicleFilterProject.addEventListener("change", renderSstVehicles);
}
if (sstVehicleFilterStatus) {
  sstVehicleFilterStatus.addEventListener("change", renderSstVehicles);
}
if (sstVehicleFilterSearch) {
  sstVehicleFilterSearch.addEventListener("input", renderSstVehicles);
}
if (sstVehicleCancel) {
  sstVehicleCancel.addEventListener("click", resetSstVehicleForm);
}
if (btnFecharSstTemplate) {
  btnFecharSstTemplate.addEventListener("click", closeSstTemplateModal);
}
if (btnCancelarSstTemplate) {
  btnCancelarSstTemplate.addEventListener("click", closeSstTemplateModal);
}
if (btnFecharSstWizard) {
  btnFecharSstWizard.addEventListener("click", closeSstInspectionWizard);
}
if (sstWizardPrev) {
  sstWizardPrev.addEventListener("click", handleSstWizardPrev);
}
if (sstWizardNext) {
  sstWizardNext.addEventListener("click", handleSstWizardNext);
}
if (sstWizardBody) {
  sstWizardBody.addEventListener("click", handleSstWizardBodyClick);
}
if (btnFecharSstDetails) {
  btnFecharSstDetails.addEventListener("click", closeSstInspectionDetails);
}
if (btnCancelarSstDetails) {
  btnCancelarSstDetails.addEventListener("click", closeSstInspectionDetails);
}
if (sstInspectionGenerateNc) {
  sstInspectionGenerateNc.addEventListener("click", handleSstInspectionGenerateNc);
}
if (sstInspectionDetailsBody) {
  sstInspectionDetailsBody.addEventListener("click", handleSstInspectionDetailsClick);
}
if (sstNcForm) {
  sstNcForm.addEventListener("submit", handleSstNcSubmit);
}
if (sstNcAttachments) {
  sstNcAttachments.addEventListener("change", handleSstNcAttachmentsChange);
}
if (sstNcSourceInspection) {
  sstNcSourceInspection.addEventListener("change", handleSstNcSourceChange);
}
if (sstNcTableBody) {
  sstNcTableBody.addEventListener("click", handleSstNcTableClick);
}
if (sstNcFilterProject) {
  sstNcFilterProject.addEventListener("change", renderSstNcs);
}
if (sstNcFilterStatus) {
  sstNcFilterStatus.addEventListener("change", renderSstNcs);
}
if (sstNcFilterSeverity) {
  sstNcFilterSeverity.addEventListener("change", renderSstNcs);
}
if (sstNcFilterResponsible) {
  sstNcFilterResponsible.addEventListener("change", renderSstNcs);
}
if (sstNcFilterFrom) {
  sstNcFilterFrom.addEventListener("change", renderSstNcs);
}
if (sstNcFilterTo) {
  sstNcFilterTo.addEventListener("change", renderSstNcs);
}
if (sstNcFilterSearch) {
  sstNcFilterSearch.addEventListener("input", renderSstNcs);
}
if (sstNcDetailsSave) {
  sstNcDetailsSave.addEventListener("click", handleSstNcDetailsSave);
}
if (sstNcDetailsClose) {
  sstNcDetailsClose.addEventListener("click", closeSstNcDetails);
}
if (btnFecharSstNcDetails) {
  btnFecharSstNcDetails.addEventListener("click", closeSstNcDetails);
}
if (sstNcActionAdd) {
  sstNcActionAdd.addEventListener("click", handleSstNcActionAdd);
}
if (sstNcActionsList) {
  sstNcActionsList.addEventListener("click", handleSstNcActionsClick);
}
if (sstNcDetailsAttachments) {
  sstNcDetailsAttachments.addEventListener("change", handleSstNcDetailsAttachmentsChange);
}
if (sstNcDetailsEvidenceList) {
  sstNcDetailsEvidenceList.addEventListener("click", handleSstNcEvidenceOpen);
}
if (sstNcNotifyBtn) {
  sstNcNotifyBtn.addEventListener("click", handleSstNcNotify);
}
if (sstIncidentForm) {
  sstIncidentForm.addEventListener("submit", handleSstIncidentSubmit);
}
if (sstDocNewBtn) {
  sstDocNewBtn.addEventListener("click", abrirSstDocForm);
}
if (btnFecharSstDocForm) {
  btnFecharSstDocForm.addEventListener("click", fecharSstDocForm);
}
if (btnCancelarSstDocForm) {
  btnCancelarSstDocForm.addEventListener("click", fecharSstDocForm);
}
if (formSstDoc) {
  formSstDoc.addEventListener("submit", handleSstDocSubmit);
}
if (sstDocAprBtn && sstDocAprInput) {
  sstDocAprBtn.addEventListener("click", () => sstDocAprInput.click());
}
if (sstDocAprInput) {
  sstDocAprInput.addEventListener("change", handleSstDocAprChange);
}
if (sstDocAprView) {
  sstDocAprView.addEventListener("click", handleSstDocAprView);
}
if (sstDocStatusFilter) {
  sstDocStatusFilter.addEventListener("change", renderSstAprPt);
}
if (sstDocProjectFilter) {
  sstDocProjectFilter.addEventListener("change", renderSstAprPt);
}
if (sstDocSearch) {
  sstDocSearch.addEventListener("input", renderSstAprPt);
}
if (sstDocTableBody) {
  sstDocTableBody.addEventListener("click", handleSstDocContainerClick);
}
if (sstDocQueue) {
  sstDocQueue.addEventListener("click", handleSstDocContainerClick);
}
if (sstDocApproveBtn) {
  sstDocApproveBtn.addEventListener("click", () => atualizarSstDocStatus("APROVADO"));
}
if (sstDocRejectBtn) {
  sstDocRejectBtn.addEventListener("click", () => atualizarSstDocStatus("REPROVADO"));
}
if (btnFecharSstDocReview) {
  btnFecharSstDocReview.addEventListener("click", fecharSstDocReview);
}
if (btnCancelarSstDocReview) {
  btnCancelarSstDocReview.addEventListener("click", fecharSstDocReview);
}

users = [];
templates = carregarTemplates();
garantirTemplatesPadrao();
const resultadoTemplates = normalizarTemplates(templates);
templates = resultadoTemplates.normalizadas;
if (resultadoTemplates.mudou) {
  salvarTemplates(templates, { skipSync: true });
}
requests = carregarSolicitacoes();
auditLog = carregarAuditoria();
iniciarAuditChain();
currentUser = null;
carregarConfiguracoes();

renderSubestacoes();
renderTipoOptions();
limparTemplateForm();
initSidebarToggle();
initAvatarUpload();
initRichEditors();
initConclusaoModelos();
initFontGroups();
initSyncDebug();
carregarSessaoServidor();
preencherInicioExecucaoNova();

function applyProjectVehiclesQuery() {
  const params = new URLSearchParams(window.location.search);
  const tab = params.get("tab");
  const projectTab = params.get("projectTab");
  if (tab === "projetos" && projectTab === "veiculos") {
    openProjectVehiclesTab(params.get("projectId") || "");
  }
}

applyProjectVehiclesQuery();

window.addEventListener("focus", atualizarSeNecessario);
window.addEventListener("storage", (event) => {
  if (
    event.key === ANNOUNCEMENTS_KEY ||
    event.key === ANNOUNCEMENTS_READ_KEY ||
    event.key === ANNOUNCEMENTS_READERS_KEY
  ) {
    carregarAnuncios(true);
    return;
  }
  const keysBase = [
    STORAGE_KEY,
    REQUEST_KEY,
    AUDIT_KEY,
    RDO_KEY,
    FEEDBACK_KEY,
    SST_DOCS_KEY,
    SST_VEHICLES_KEY,
    REMINDER_KEY,
    TEMPLATE_KEY,
  ];
  const accessKeys = [ACCESS_SYNC_KEY, ACCESS_USERS_KEY, ACCESS_ROLES_KEY];
  const projectKeys = [PROJECTS_SYNC_KEY, PROJECTS_KEY];
  const isAccessUpdate = accessKeys.includes(event.key);
  const isProjectListUpdate = projectKeys.includes(event.key);
  const isProjectStorageUpdate = keysBase.some((base) => isProjectStorageKey(event.key, base));
  if (isAccessUpdate) {
    if (currentUser) {
      refreshAccessData({ reason: "storage" });
    }
    return;
  }
  if (isProjectListUpdate) {
    if (currentUser) {
      refreshProjects();
    }
    return;
  }
  if (isProjectStorageUpdate) {
    templates = carregarTemplates();
    garantirTemplatesPadrao();
    const normalizados = normalizarTemplates(templates);
    templates = normalizados.normalizadas;
    if (normalizados.mudou) {
      salvarTemplates(templates, { skipSync: true });
    }
    requests = carregarSolicitacoes();
    auditLog = carregarAuditoria();
    iniciarAuditChain();
    carregarConfiguracoes();
    manutencoes = carregarManutencoes();
    const resultado = normalizarManutencoes(manutencoes);
    manutencoes = resultado.normalizadas;
    salvarManutencoes(manutencoes);
    rdoSnapshots = carregarRdoSnapshots();
    carregarFeedbacks();
    montarRdoUI();
    carregarSessaoServidor();
  }
});




